import { Box3 } from 'three';
import { Components } from '@thatopen/components';
import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';
import { CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer.js';
import { DataMap } from '@thatopen/fragments';
import { DataSet } from '@thatopen/fragments';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import * as FRAGS from '@thatopen/fragments';
import { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';
import { GTAOPass } from 'three/examples/jsm/postprocessing/GTAOPass.js';
import { LineMaterial } from 'three/examples/jsm/lines/LineMaterial.js';
import * as OBC from '@thatopen/components';
import { Pass } from 'three/examples/jsm/postprocessing/Pass.js';
import { SimpleRenderer } from '@thatopen/components';
import * as THREE from 'three';
import { Vector3 } from 'three';

export declare class Area {
    id: string;
    readonly points: DataSet<THREE.Vector3>;
    tolerance: number;
    private _plane;
    get plane(): THREE.Plane | null;
    private get _coordinateSystem();
    get points2D(): THREE.Vector2[] | null;
    get center(): THREE.Vector3 | null;
    get value(): number;
    get rawValue(): number;
    get boundingBox(): THREE.Box3 | null;
    get perimeter(): number;
    private _rounding;
    set rounding(value: number);
    get rounding(): number;
    private _units;
    set units(value: "m2" | "cm2" | "mm2" | "km2");
    get units(): "m2" | "cm2" | "mm2" | "km2";
    constructor(points?: THREE.Vector3[]);
    isPointInPlane(point: THREE.Vector3): boolean;
    clone(): Area;
    computePlane(): THREE.Plane | null;
    convertPointTo2D(point: THREE.Vector3): THREE.Vector2 | null;
    convertPointTo3D(point2D: THREE.Vector2): THREE.Vector3 | null;
}

/**
 * AreaMeasurement allows users to measure and interact with areas in a 3D environment. This class provides functionality for creating, updating, and deleting area measurements, as well as managing their visual representation. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/AreaMeasurement). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/AreaMeasurement).
 */
export declare class AreaMeasurement extends Measurement<Area, "area"> {
    static uuid: "09b78c1f-0ff1-4630-a818-ceda3d878c75";
    /**
     * The tolerance value used for picking operations in area measurement.
     * This value determines the precision or sensitivity when selecting or interacting
     * with measurement areas. A smaller value increases precision, while a larger value
     * allows for more leniency in selection.
     *
     * @default 0.1
     */
    pickTolerance: number;
    /**
     * Represents the tolerance value used for area measurement calculations.
     * This value defines the acceptable margin of error for a point in the shape to be added to the area element.
     *
     * @default 0.005
     */
    tolerance: number;
    /**
     * The possible modes in which a measurement of this type may be created.
     */
    modes: AreaMeasurerModes[number][];
    private _mode;
    get mode(): AreaMeasurerModes[number];
    /**
     * Represents the current measurement mode being used.
     */
    set mode(value: AreaMeasurerModes[number]);
    private _temp;
    private _lineToAreaMap;
    constructor(components: OBC.Components);
    private initHandlers;
    private computeLineElements;
    private updatePreview;
    create: () => Promise<void>;
    endCreation: () => void;
    cancelCreation: () => void;
    private addLineElementsFromPointsForArea;
    delete: () => void;
}

/**
 * Represents the modes available for measuring areas. `free`: Allows freeform area measurement without constraints. `square`: Restricts area measurement to square shapes.
 */
declare type AreaMeasurerModes = ["free", "square", "face"];

declare class BasePass extends Pass {
    scene: THREE.Scene;
    camera: THREE.Camera;
    overrideMaterial: THREE.Material | null;
    clearColor: THREE.Color | null;
    clearAlpha: number | null;
    clearDepth: boolean;
    needsSwap: boolean;
    isolatedMaterials: THREE.Material[];
    private _oldClearColor;
    constructor(scene: THREE.Scene, camera: THREE.Camera, overrideMaterial?: null, clearColor?: null, clearAlpha?: null);
    render(renderer: THREE.WebGLRenderer, writeBuffer: THREE.WebGLRenderTarget, readBuffer: THREE.WebGLRenderTarget): void;
}

/**
 * This component is used to navigate and visualize cross sections of a 3D model. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/CivilNavigators). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/CivilCrossSectionNavigator).
 */
export declare class CivilCrossSectionNavigator extends OBC.Component implements OBC.Disposable {
    /**
     * A unique identifier for the component. This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "96b2c87e-d90b-4639-8257-8f01136fe324";
    /** {@link OBC.Component.enabled} */
    enabled: boolean;
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    private _world;
    private _flip;
    private _plane?;
    private _point;
    private _edgeMeshes;
    private _sectionVisible;
    private _sectionOffset;
    edgeMaterial: LineMaterial;
    /**
     * A property representing the plane used for cross section visualization.
     */
    get plane(): OBC.SimplePlane;
    /**
     * A property representing the plane used for cross section visualization.
     */
    set plane(plane: OBC.SimplePlane);
    get sectionVisible(): boolean;
    set sectionVisible(visible: boolean);
    /**
     * A getter for the 3D world.
     * @returns The 3D world.
     */
    get world(): OBC.World | null;
    /**
     * A setter for the 3D world.
     * @param world - The new 3D world.
     */
    set world(world: OBC.World | null);
    constructor(components: OBC.Components);
    get flip(): boolean;
    set flip(flip: boolean);
    dispose(): void;
    /**
     * Sets the cross section plane based on the given curve mesh and point.
     *
     * @param point - The point on the curve mesh where the cross section should be created.
     * @param normal - The normal of the plane.
     *
     * @throws Will throw an error if the world or plane is not set before calling this method.
     * @throws Will throw an error if the geometry is not indexed.
     *
     * @returns {Promise<void>}
     */
    set(point: THREE.Vector3, normal: THREE.Vector3): Promise<void>;
    update(): Promise<void>;
    private generateModelSection;
    private clearMeshes;
}

export declare enum CivilMarkerType {
    SELECT = "select",
    HOVER = "hover"
}

declare class CivilNavigator implements OBC.Disposable {
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    alignments: THREE.Group[];
    components: OBC.Components;
    /**
     * Event triggered when a marker (point) on a curve changes.
     * Provides information about the alignment, percentage, type of marker, and the curve.
     */
    readonly onMarkerChange: OBC.Event<{
        alignment: THREE.Group;
        curve: THREE.Line;
        point: THREE.Vector3;
        normal: THREE.Vector3;
    }>;
    /** {@link OBC.Component.enabled} */
    enabled: boolean;
    highlightMaterial: LineMaterial;
    increments: number;
    screenDistanceLimit: number;
    fadeInTime: number;
    private _mouseMarkers?;
    private _highlighted;
    private _stationPoints;
    private readonly _originalHighlightMaterialId;
    private _world;
    private _raycaster;
    private _stationLabelColor;
    private _stationLabelBackgroundColor;
    private _stationPointerColor;
    private _stationPointerBackgroundColor;
    /**
     * Getter for the world property.
     * Returns the current world instance.
     * @returns {OBC.World | null} The current world instance or null if not set.
     */
    get world(): OBC.World | null;
    /**
     * Setter for the world property.
     * Sets the world instance and initializes the component.
     * @param {OBC.World | null} world - The new world instance or null to clear the current world.
     */
    set world(world: OBC.World | null);
    get stationLabelColor(): THREE.Color;
    set stationLabelColor(color: THREE.Color);
    get stationLabelBackgroundColor(): THREE.Color;
    set stationLabelBackgroundColor(color: THREE.Color);
    get stationPointerColor(): THREE.Color;
    set stationPointerColor(color: THREE.Color);
    get stationPointerBackgroundColor(): THREE.Color;
    set stationPointerBackgroundColor(color: THREE.Color);
    constructor(components: OBC.Components, highlightMaterial: LineMaterial);
    dispose(): void;
    updateAlignments(): void;
    setMarkerAtPoint(point: CivilPoint, type: "select" | "hover"): void;
    highlight(alignment: THREE.Group, removePrevious?: boolean): void;
    clearHighlight(alignments?: Iterable<THREE.Group<THREE.Object3DEventMap>>): void;
    createStations(alignment: THREE.Group): void;
    clearStations(ids?: Iterable<string>): void;
    updateStations(): void;
    getCursorValue(): string;
    setCursorValue(value: string, type: "select" | "hover"): void;
    private isLabelClipped;
    private clearLabels;
    private newCivilLabel;
    private setupEvents;
    private _pointerDown;
    private _pointerDownTime;
    private onPointerDown;
    private onPointerUp;
    private onMouseMove;
    private setMarkerToMouse;
    private updateMarkerValue;
    private getFormattedStation;
    private getLabel;
    private getPoint;
}

/**
 * This component provides functionality for navigating and interacting with civil engineering data in a 3D environment. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/CivilNavigators). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/CivilNavigators).
 *
 */
export declare class CivilNavigators extends OBC.Component implements OBC.Disposable {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "0a59c09e-2b49-474a-9320-99f51f40f182";
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    list: Map<string, CivilNavigator>;
    /** {@link OBC.Component.enabled} */
    enabled: boolean;
    highlightMaterial: LineMaterial;
    private _increments;
    private _screenDistanceLimit;
    private _fadeInTime;
    private _stationLabelColor;
    private _stationLabelBackgroundColor;
    private _stationPointerColor;
    private _stationPointerBackgroundColor;
    get increments(): number;
    set increments(value: number);
    get screenDistanceLimit(): number;
    set screenDistanceLimit(value: number);
    get fadeInTime(): number;
    set fadeInTime(value: number);
    get stationLabelColor(): THREE.Color;
    set stationLabelColor(color: THREE.Color);
    get stationLabelBackgroundColor(): THREE.Color;
    set stationLabelBackgroundColor(color: THREE.Color);
    get stationPointerColor(): THREE.Color;
    set stationPointerColor(color: THREE.Color);
    get stationPointerBackgroundColor(): THREE.Color;
    set stationPointerBackgroundColor(color: THREE.Color);
    constructor(components: OBC.Components);
    create(id: string): CivilNavigator;
    delete(id: string): void;
    dispose(): void;
    updateAlignments(): void;
}

export declare interface CivilPoint {
    point: THREE.Vector3;
    normal: THREE.Vector3;
    curve: THREE.Line;
    alignment: THREE.Group;
}

/**
 * This component provides functionality for navigating and interacting with civil engineering data in a 3D environment. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/CivilNavigators). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/CivilRaycaster).
 *
 */
export declare class CivilRaycaster {
    alignments: THREE.Group[];
    /** {@link OBC.Component.enabled} */
    enabled: boolean;
    world: OBC.World | null;
    private _raycastable;
    private _components;
    constructor(components: OBC.Components);
    update(): void;
    dispose(): void;
    castRay(): CivilPoint | null;
}

export declare class CivilUtils {
    static alignmentPercentageToPoint(alignment: THREE.Group, percentage: number): CivilPoint | null;
    static curvePercentageToPoint(alignment: THREE.Group, curve: THREE.Object3D, percentage: number): CivilPoint | null;
    static alignmentLength(alignment: THREE.Group): any;
    static curveLength(curve: THREE.Object3D): any;
    static curvePointToAlignmentPercentage(alignment: THREE.Group, point: THREE.Vector3, targetCurve: THREE.Object3D): number | null;
    static isPointbetweenTwoOthers(pA: THREE.Vector3, pB: THREE.Vector3, pToCheck: THREE.Vector3): boolean;
}

/**
 * The `ClipEdges` class is responsible for managing and rendering clipped edges and fills in a ThreeJS scene based on specified styles and models. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/ClipStyler). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/ClipEdges).
 */
export declare class ClipEdges implements OBC.Disposable {
    private _components;
    private _modelStyleGeometries;
    readonly onDisposed: OBC.Event<undefined>;
    /**
     * The ThreeJS group that holds all the edges and fills together
     */
    readonly three: THREE.Group<THREE.Object3DEventMap>;
    /**
     * A readonly property representing the ThreeJS plane used to created the edges and fills.
     */
    readonly plane: THREE.Plane;
    readonly items: DataMap<string, ClipEdgesItemStyle>;
    /**
     * The world in which the edges and fills will be placed.
     */
    world: OBC.World | null;
    private _visible;
    /**
     * Sets the visibility of the object in the scene.
     * When set to `true`, the object is added to the scene if the `world` property is defined.
     * When set to `false`, the object is removed from its parent.
     */
    set visible(value: boolean);
    get visible(): boolean;
    constructor(components: OBC.Components, plane: THREE.Plane);
    private setupEvents;
    private getStyleMeshes;
    private updateMeshes;
    private create;
    /**
     * Updates the clip edges based on the provided groups and their associated styles and data.
     * If no groups are specified, all items will be updated.
     *
     * @param groups - An optional array of group names to filter which items should be updated.
     * @returns A promise that resolves when the update process is complete.
     */
    update(groups?: string[]): Promise<void>;
    /** {@link OBC.Disposable.dispose} */
    dispose(): void;
}

/**
 * Configuration for creating ClipEdges.
 */
export declare interface ClipEdgesCreationConfig {
    /**
     * If true, updates the ClipEdges based on the plane update.
     */
    link?: boolean;
    /**
     * The unique name of the ClipEdges.
     */
    id?: string;
    /**
     * The world in which the ClipEdges are going to be added.
     */
    world?: OBC.World;
    /**
     * A record of groups from the classifier to style based on the style name set.
     */
    items?: Record<string, ClipEdgesItemStyle>;
}

/**
 * Represents the style configuration for clip edges items.
 */
export declare interface ClipEdgesItemStyle {
    /**
     * The name of the style from the ClipStyler to apply.
     */
    style: string;
    /**
     * Optional classifier intersection input. If not set, all items cut will be styled.
     */
    data?: OBC.ClassifierIntersectionInput;
}

/**
 * Represents the style configuration for clipping edges, including materials for lines and fills.
 */
export declare interface ClipStyle {
    linesMaterial?: LineMaterial;
    fillsMaterial?: THREE.Material;
}

/**
 * A component that can style Clipping Planes by adding edges and fills. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/ClipStyler). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/ClipStyler).
 */
export declare class ClipStyler extends OBC.Component implements OBC.Disposable {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "24dfc306-a3c4-410f-8071-babc4afa5e4d";
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    /** {@link OBC.Component.enabled} */
    enabled: boolean;
    /**
     * Represents the current world instance used by the ClipStyler.
     * This can be an instance of `OBC.World` or `null` if no world is set.
     * You can still specify other world during the ClipEdges creation.
     */
    world: OBC.World | null;
    readonly styles: FRAGS.DataMap<string, ClipStyle>;
    readonly list: FRAGS.DataMap<string, ClipEdges>;
    private _visible;
    /**
     * Gets the visibility state of the edges.
     */
    get visible(): boolean;
    /**
     * Sets the visibility state of the edges.
     * @param {boolean} active - The new visibility state.
     */
    set visible(active: boolean);
    constructor(components: OBC.Components);
    private setEvents;
    private setEdgesConfig;
    /**
     * Creates a new instance of `ClipEdges` using the specified plane and optional configuration.
     *
     * @param plane - The `THREE.Plane` object used to define the clipping plane.
     * @param config - Optional configuration for the edges creation.
     * @returns A new instance of `ClipEdges` initialized with the specified plane and configuration.
     * @remarks The given plane won't be copied during the ClipEdges creation.
     */
    create(plane: THREE.Plane, config?: ClipEdgesCreationConfig): ClipEdges;
    /**
     * Creates and configures clip edges from a given view.
     *
     * This method generates clip edges based on the provided view's plane and optional configuration.
     * If the `link` option in the configuration is enabled (default is `true`), the clip edges are
     * dynamically linked to the view's lifecycle events, ensuring proper disposal, updates, and visibility
     * synchronization with the view's state.
     *
     * @param view - The view object from which the clip edges are created.
     * @param config - Optional configuration for clip edge creation.
     * @returns The created clip edges object, configured and optionally linked to the view's lifecycle.
     */
    createFromView(view: OBC.View, config?: ClipEdgesCreationConfig): ClipEdges;
    /**
     * Creates and returns styled edges from a clipping plane identified by its ID.
     * Optionally, a configuration object can be provided to customize the creation process.
     *
     * @param id - The unique identifier of the clipping plane to create edges from.
     * @param config - Optional configuration for edge creation, including visibility and linking behavior.
     *
     * @returns The created edges styled from the clipping plane.
     *
     * @remarks
     * - If `config.link` is `true` (default), the edges will automatically update when the clipping plane's dragging ends
     *   and will be disposed of when the clipping plane is disposed.
     */
    createFromClipping(id: string, config?: ClipEdgesCreationConfig): ClipEdges;
    /** {@link OBC.Disposable.dispose} */
    dispose(): void;
}

/**
 * Interface representing the data required to create a dimension line.
 */
export declare interface DimensionData {
    /**
     * The 3D line representing the dimension.
     */
    line: Line;
    startNormal?: THREE.Vector3;
    endNormal?: THREE.Vector3;
    /**
     * The material to be used for the line of the dimension.
     */
    lineMaterial: THREE.LineBasicMaterial;
    /**
     * The HTML element to be used as the endpoint marker for the dimension line.
     */
    endpointElement: HTMLElement;
}

/**
 * A class representing a simple dimension line in a 3D space.
 */
export declare class DimensionLine {
    /**
     * The label for the dimension line.
     */
    label: Mark;
    /**
     * The bounding box for the dimension line.
     */
    boundingBox: THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[], THREE.Object3DEventMap>;
    /**
     * The world in which the dimension line exists.
     */
    world: OBC.World;
    private _components;
    private _units;
    /**
     * The units used for the dimension line.
     */
    set units(value: "mm" | "cm" | "m" | "km");
    get units(): "mm" | "cm" | "m" | "km";
    /**
     * The number of decimals to show in the label.
     */
    private _rounding;
    set rounding(value: number);
    get rounding(): number;
    startNormal: THREE.Vector3 | null;
    readonly line: Line;
    readonly rectangleComponentLines: Line[];
    readonly projectionComponentLines: Line[];
    private _visible;
    private readonly _root;
    private _endpoints;
    readonly lineElement: THREE.Line;
    readonly rectangleDimensions: DataSet<DimensionLine>;
    readonly projectionDimensions: DataSet<DimensionLine>;
    /**
     * Updates the dimension line's appearance based on its state.
     * @param {boolean} isSelected - Whether the dimension line is selected.
     */
    isSelected: boolean;
    /**
     * Getter for the visibility of the dimension line.
     */
    get visible(): boolean;
    /**
     * Setter for the visibility of the dimension line.
     * @param {boolean} value - The new visibility state.
     */
    set visible(value: boolean);
    /**
     * Setter for the end point of the dimension line.
     * Updates the line geometry and position of the end point marker.
     * @param {THREE.Vector3} point - The new end point.
     */
    set end(point: THREE.Vector3);
    /**
     * Setter for the start point of the dimension line.
     * Updates the line geometry and position of the start point marker.
     * @param {THREE.Vector3} point - The new start point.
     */
    set start(point: THREE.Vector3);
    constructor(components: OBC.Components, world: OBC.World, data: DimensionData, rounding?: number, // Default rounding precision
    units?: "mm" | "cm" | "m" | "km");
    applyPlanesVisibility(planes: THREE.Plane[]): void;
    private setupEvents;
    /**
     * Disposes of the dimension line and its associated resources.
     * This method should be called when the dimension line is no longer needed.
     * It removes the dimension line from the world, destroys its components, and frees up memory.
     */
    dispose(): void;
    /**
     * Creates a bounding box for the dimension line.
     * The bounding box is a 3D box that encloses the dimension line.
     * It is used for collision detection and visibility culling.
     * The bounding box is initially invisible and can be toggled using the `toggleBoundingBox` method.
     */
    createBoundingBox(): void;
    private _latestRectangularInversion;
    invertRectangularDimensions(): void;
    displayRectangularDimensions(): void;
    displayProjectionDimensions(): void;
    private _endpointElement;
    set endpointElement(value: HTMLElement);
    get endpointElement(): HTMLElement;
    private createEndpoints;
    private updateProjectionComponents;
    private updateRectangleComponents;
    updateLabel(): void;
    private updateGeometry;
    update(): void;
    private _material;
    set material(value: THREE.LineBasicMaterial);
    get material(): THREE.LineBasicMaterial;
    private _componentsMaterial;
    private createLine;
    private newText;
    valueFormatter: ((value: number) => string) | null;
    private getTextContent;
    set color(color: THREE.Color);
}

declare class EdgeDetectionPass extends Pass {
    private _edgeMaterial;
    private _combineMaterial;
    private _fsQuad;
    private _edgeRenderTarget;
    private _vertexColorRenderTarget;
    private _fragments;
    private _renderer;
    private _overrideMaterial;
    private _depthBiasStrength;
    private _mode;
    get mode(): EdgeDetectionPassMode;
    set mode(value: EdgeDetectionPassMode);
    get width(): number;
    set width(value: number);
    get color(): THREE.Color;
    set color(value: THREE.Color);
    get depthBiasStrength(): number;
    set depthBiasStrength(value: number);
    constructor(renderer: OBC.BaseRenderer, fragments: OBC.FragmentsManager, width?: number);
    setSize(width: number, height: number): void;
    setWidth(width: number): void;
    render(renderer: THREE.WebGLRenderer, writeBuffer: THREE.WebGLRenderTarget, readBuffer: THREE.WebGLRenderTarget): void;
    dispose(): void;
    private setMaterialToMesh;
}

/**
 * The mode of the edge detection pass.
 */
export declare enum EdgeDetectionPassMode {
    /**
     * Looks good, including LODs, but less performant.
     */
    DEFAULT = 0,
    /**
     * Doesn't include LODs, but much more performant.
     */
    GLOBAL = 1
}

declare class ExcludedObjectsPass extends Pass {
    materialToExclude: THREE.MeshBasicMaterial;
    private _excludedMaterials;
    private _originalMaterials;
    private _renderer;
    private _world;
    private _fsQuad;
    private _combineMaterial;
    private _excludedRenderTarget;
    constructor(renderer: OBC.BaseRenderer, world: OBC.World);
    /**
     * Add materials to be excluded from postproduction
     */
    addExcludedMaterial(material: THREE.Material): void;
    /**
     * Remove materials from the excluded list
     */
    removeExcludedMaterial(material: THREE.Material): void;
    /**
     * Clear all excluded materials
     */
    clearExcludedMaterials(): void;
    /**
     * Get the list of excluded materials
     */
    get excludedMaterials(): THREE.Material[];
    setSize(width: number, height: number): void;
    render(renderer: THREE.WebGLRenderer, writeBuffer: THREE.WebGLRenderTarget, readBuffer: THREE.WebGLRenderTarget): void;
    private _substituteMaterials;
    private _restoreMaterials;
    dispose(): void;
}

/**
 * A postprocessing pass that applies a gloss effect to the rendered scene.
 * The gloss effect makes surfaces appear more reflective based on their
 * angle relative to the camera view.
 */
export declare class GlossPass extends Pass {
    resolution: THREE.Vector2;
    renderScene: THREE.Scene;
    renderCamera: THREE.Camera;
    fsQuad: FullScreenQuad;
    glossOverrideMaterial: THREE.ShaderMaterial;
    glossBuffer: THREE.WebGLRenderTarget;
    private _glossEnabled;
    get glossEnabled(): boolean;
    set glossEnabled(active: boolean);
    get minGloss(): number;
    set minGloss(value: number);
    get maxGloss(): number;
    set maxGloss(value: number);
    get glossExponent(): number;
    set glossExponent(value: number);
    get fresnelExponent(): number;
    set fresnelExponent(value: number);
    get glossFactor(): number;
    set glossFactor(value: number);
    get fresnelFactor(): number;
    set fresnelFactor(value: number);
    constructor(resolution: THREE.Vector2, world: OBC.World);
    dispose(): void;
    setSize(width: number, height: number): void;
    render(renderer: THREE.WebGLRenderer, writeBuffer: any, readBuffer: any): void;
    get vertexShader(): string;
    get fragmentShader(): string;
    createGlossMaterial(): THREE.ShaderMaterial;
    private newRenderTarget;
}

/**
 * A class to provide a graphical marker for picking vertices in a 3D scene.
 */
export declare class GraphicVertexPicker implements OBC.Disposable {
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    /** The marker used to indicate the picked vertex. */
    marker: Mark | null;
    world: OBC.World | null;
    mode: GraphicVertexPickerMode;
    maxDistance: number;
    private _enabled;
    set enabled(value: boolean);
    get enabled(): boolean;
    private _components;
    private _preview;
    private _pointerVisible;
    private _intersectionFound;
    static baseSnappingStyle: Partial<CSSStyleDeclaration>;
    static snappingStyles: Record<FRAGS.SnappingClass, Partial<CSSStyleDeclaration>>;
    constructor(components: OBC.Components);
    /** {@link OBC.Disposable.onDisposed} */
    dispose(): void;
    /**
     * Retrieves the picked vertex from the world and updates the marker's position.
     * If no vertex is picked, the marker is hidden.
     *
     * @param world - The world in which to pick the vertex.
     * @returns The picked vertex, or null if no vertex was picked.
     */
    get(config?: {
        world?: OBC.World;
        snappingClasses?: FRAGS.SnappingClass[];
    }): Promise<any>;
    private getSynchronous;
    private getDefault;
    updatePointer(): void;
    private showPointer;
    private hidePointer;
    private applySnapping;
}

export declare enum GraphicVertexPickerMode {
    DEFAULT = 0,
    SYNCHRONOUS = 1
}

/**
 * This component allows highlighting and selecting fragments in a 3D scene. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/Highlighter). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/Highlighter).
 */
export declare class Highlighter extends OBC.Component implements OBC.Disposable, OBC.Eventable {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "cb8a76f2-654a-4b50-80c6-66fd83cafd77";
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    /** {@link OBC.Updateable.onBeforeUpdate} */
    readonly onBeforeUpdate: OBC.Event<Highlighter>;
    /** {@link OBC.Updateable.onAfterUpdate} */
    readonly onAfterUpdate: OBC.Event<Highlighter>;
    /** Event triggered when the Highlighter is setup. */
    readonly onSetup: OBC.Event<Highlighter>;
    /** Indicates whether the Highlighter is setup. */
    isSetup: boolean;
    /** {@link OBC.Component.enabled} */
    enabled: boolean;
    /** Stores the events triggered by the Highlighter. */
    events: HighlightEvents;
    /** Determines the multiple selection behavior. */
    multiple: "none" | "shiftKey" | "ctrlKey";
    /** Zoom factor applied when zooming to selection. */
    zoomFactor: number;
    /** Indicates whether to zoom to the selection when highlighting. */
    zoomToSelection: boolean;
    /** Stores the backup color before selection. */
    backupColor: THREE.Color | null;
    /** Stores the current selection. */
    selection: {
        [selectionID: string]: OBC.ModelIdMap;
    };
    /** Stores the configuration options for the Highlighter. */
    config: Required<HighlighterConfig>;
    /** Stores the styles used for highlighting selections. If null, the highlighter won't color geometries (useful for selection without coloring). */
    readonly styles: DataMap<string, Omit<FRAGS.MaterialDefinition, "customId"> | null>;
    /** Styles with auto toggle will be unselected when selected twice. */
    autoToggle: Set<string>;
    /** Position of the mouse on mouseDown. */
    private mouseDownPosition;
    /** Threshhold on how much the mouse have to move until its considered movement */
    mouseMoveThreshold: number;
    /** If defined, only the specified elements will be selected by the specified style. */
    selectable: {
        [name: string]: OBC.ModelIdMap;
    };
    /** Manager to easily toggle and reset all events. */
    eventManager: OBC.EventManager;
    private _mouseState;
    constructor(components: OBC.Components);
    private setStyleEvents;
    /** {@link Disposable.dispose} */
    dispose(): Promise<void>;
    /**
     * Adds a new selection with the given name and color.
     * Throws an error if a selection with the same name already exists.
     *
     * @param name - The name of the new selection.
     * @param color - The color to be used for highlighting the selection.
     *
     * @throws Will throw an error if a selection with the same name already exists.
     * @deprecated Use highlighter.styles.set() instead
     */
    add(style: FRAGS.MaterialDefinition & {
        customId: string;
    }): void;
    add(customId: string): void;
    /**
     * Removes the specified selection.
     *
     * @param name - The name of the new selection.
     * @deprecated use highlighter.styles.delete
     */
    remove(name: string): Promise<void>;
    /**
     * Highlights a fragment based on a raycast from the mouse position.
     *
     * @param name - The name of the selection.
     * @param removePrevious - Whether to remove previous highlights.
     * @param zoomToSelection - Whether to zoom to the highlighted selection.
     * @param exclude - Fragments to exclude from the highlight.
     *
     * @returns The highlighted fragment and its ID, or null if no fragment was highlighted.
     *
     * @throws Will throw an error if the world or a required component is not found.
     * @throws Will throw an error if the selection does not exist.
     * @throws Will throw an error if the fragment or its geometry is not found.
     * @throws Will throw an error if the item ID is not found.
     * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
     */
    highlight(name: string, removePrevious?: boolean, zoomToSelection?: boolean, exclude?: OBC.ModelIdMap | null): Promise<void>;
    private _fromHighlight;
    /**
     * Highlights a fragment based on a given fragment ID map.
     *
     * @param name - The name of the selection.
     * @param modelIdMap - The fragment ID map to highlight.
     * @param removePrevious - Whether to remove previous highlights.
     * @param zoomToSelection - Whether to zoom to the highlighted selection.
     * @param exclude - Fragments to exclude from the highlight.
     * @param fillMesh - The fill mesh to also highlight, if any.
     * @param isPicking - Whether this function is called when picking with the mouse.
     *
     * @returns Promise that resolves when the highlighting is complete.
     *
     * @throws Will throw an error if the selection does not exist.
     * @throws Will throw an error if the fragment or its geometry is not found.
     * @throws Will throw an error if the item ID is not found.
     * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
     */
    highlightByID(name: string, modelIdMap: OBC.ModelIdMap, removePrevious?: boolean, zoomToSelection?: boolean, exclude?: OBC.ModelIdMap | null, isPicking?: boolean): Promise<void>;
    /**
     * Updates the colors of highlighted fragments based on the current selection and styles.
     * @returns Resolves when all highlight updates and core state updates are completed.
     */
    updateColors(): Promise<void>;
    private updateStyleMap;
    /**
     * Retrieves a map of model IDs to element IDs, excluding elements that are also present in the selection map
     * specified by `this.config.selectName`. Optionally filters the results based on a provided filter map.
     *
     * @param style - The style name to retrieve the selection from.
     * @param filter - An optional map of model IDs to element IDs used to further filter the results. If provided,
     *                 only elements present in this filter will be included in the result.
     * @returns A map of model IDs to element IDs, excluding selected elements and optionally filtered elements.
     *          Returns `null` if the resulting map is empty.
     * @throws Error - If the specified style does not exist in the selection.
     */
    private getMapWithoutSelection;
    /**
     * Clears the selection for the given name or all selections if no name is provided.
     *
     * @param name - The name of the selection to clear. If not provided, clears all selections.
     * @param filter - The only items to unselect. If not provided, all items will be unselected.
     *
     */
    clear(name?: string, _filter?: OBC.ModelIdMap): Promise<void>;
    /**
     * Sets up the Highlighter with the provided configuration.
     *
     * @param config - Optional configuration for the Highlighter.
     * If not provided, the Highlighter will use the default configuration.
     *
     * @throws Will throw an error if the world or a required component is not found.
     * @throws Will throw an error if the selection already exists.
     * @throws Will throw an error if the fragment or its geometry is not found.
     * @throws Will throw an error if the item ID is not found.
     * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
     */
    setup(config?: Partial<HighlighterConfig>): void;
    private zoomSelection;
    private restorePreviousColors;
    private setupEvents;
    private onMouseDown;
    private debounceTimeout;
    private onMouseUp;
    private onMouseMove;
}

/**
 * Interface defining the configuration options for the Highlighter class.
 */
export declare interface HighlighterConfig {
    /** Name of the selection event. */
    selectName: string;
    /** Toggles the select functionality. */
    selectEnabled: boolean;
    /**
     * Color used for selection.
     * @deprecated use selectMaterialDefinition instead
     * */
    selectionColor: THREE.Color | null;
    /** Whether to automatically highlight fragments on click. */
    autoHighlightOnClick: boolean;
    /** The world in which the highlighter operates. */
    world: OBC.World | null;
    selectMaterialDefinition: Omit<FRAGS.MaterialDefinition, "customId"> | null;
    /** Whether to automatically update fragments when highlighting. */
    autoUpdateFragments: boolean;
}

/**
 * Interface defining the events that the Highlighter class can trigger. Each highlighter has its own set of events, identified by the highlighter name.
 */
export declare interface HighlightEvents {
    [highlighterName: string]: {
        /** Event triggered before a fragment is highlighted, giving the last selection. */
        onBeforeHighlight: OBC.Event<OBC.ModelIdMap>;
        /** Event triggered when a fragment is highlighted. */
        onHighlight: OBC.Event<OBC.ModelIdMap>;
        /** Event triggered when a fragment is cleared. */
        onClear: OBC.Event<OBC.ModelIdMap>;
    };
}

/**
 * The `Hoverer` class is responsible for managing hover effects on 3D objects within a scene. It supports animations for fading in and out hover effects and manages the lifecycle of associated 3D meshes. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/Hoverer). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/Hoverer).
 */
export declare class Hoverer extends OBC.Component implements OBC.Disposable {
    static uuid: "26fbd870-b1b2-4b71-b747-4063d484de1b";
    readonly onHoverStarted: OBC.Event<Hoverer>;
    readonly onHoverEnded: OBC.Event<Hoverer>;
    private HOVERER_OPACITY_KEY;
    private _hoverTimeout;
    private _meshes;
    private _localId;
    private _fadeAnimation;
    private _world;
    set world(value: OBC.World | null);
    get world(): OBC.World | null;
    private _enabled;
    set enabled(value: boolean);
    get enabled(): boolean;
    private _material;
    set material(value: THREE.Material);
    get material(): THREE.Material;
    readonly onDisposed: OBC.Event<unknown>;
    duration: number;
    animation: boolean;
    constructor(components: OBC.Components);
    private setupEvents;
    private mouseStopTimeout;
    private onMouseMove;
    private onMouseLeave;
    private animate;
    hover(): Promise<void>;
    clear(): void;
    dispose(): void;
}

/**
 * Interface representing a group of markers.
 */
export declare interface IGroupedMarkers {
    /**
     * Unique identifier for the group of markers.
     */
    key: string;
    /**
     * Array of keys of markers that belong to this group.
     */
    markerKeys: string[];
    /**
     * Label of the group of markers.
     */
    label: Mark;
}

/**
 * Interface representing a marker object.
 */
export declare interface IMarker {
    /**
     * Unique identifier for the marker.
     */
    key: string;
    /**
     * Label of the marker.
     */
    label: Mark;
    /**
     * Optional type of the marker.
     */
    type?: string;
    /**
     * Indicates whether the marker is merged with other markers.
     */
    merged: boolean;
    /**
     * Indicates whether the marker is static and should not be clustered.
     */
    static: boolean;
}

/**
 * A basic dimension tool to measure distances between 2 points in 3D and display a 3D symbol displaying the numeric value. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/LengthMeasurement). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/LengthMeasurement).
 */
export declare class LengthMeasurement extends Measurement<Line, "length"> {
    static uuid: "2f9bcacf-18a9-4be6-a293-e898eae64ea1";
    private _temp;
    /**
     * The possible modes in which a measurement of this type may be created.
     */
    modes: LengthMeasurerModes[number][];
    private _mode;
    get mode(): LengthMeasurerModes[number];
    /**
     * Represents the current measurement mode being used.
     */
    set mode(value: LengthMeasurerModes[number]);
    get isDragging(): boolean;
    constructor(components: OBC.Components);
    private initHandlers;
    private initPreview;
    private updatePreviewLine;
    create: () => Promise<void>;
    endCreation: () => void;
    cancelCreation: () => void;
    delete: () => void;
}

/**
 * Represents the modes available for the length measurement tool. `free`: Allows free-form measurement without constraints. `edge`: Enables measurement constrained to item edges.
 */
declare type LengthMeasurerModes = ["free", "edge"];

export declare class Line extends THREE.Line3 {
    id: string;
    private _units;
    set units(value: "m" | "cm" | "mm" | "km");
    get units(): "m" | "cm" | "mm" | "km";
    private _rounding;
    set rounding(value: number);
    get rounding(): number;
    get value(): number;
}

/**
 * Represents a marker in the 3D world.
 */
export declare class Mark implements OBC.Hideable, OBC.Disposable {
    /**
     * The CSS object representing the marker.
     */
    three: CSS2DObject;
    /**
     * The world in which the marker exists.
     */
    world: OBC.World;
    /**
     * The visibility state of the marker, used for culling (e.g. clipping planes).
     */
    wasVisible: boolean;
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    /** {@link OBC.Hideable.visible} */
    set visible(value: boolean);
    /** {@link OBC.Hideable.visible} */
    get visible(): boolean;
    constructor(world: OBC.World, element?: HTMLElement, parent?: THREE.Object3D);
    /**
     * Toggles the visibility of the marker.
     *
     * This method changes the `visible` property of the marker to its opposite value.
     * If the marker is currently visible, it will be hidden, and vice versa.
     */
    toggleVisibility(): void;
    /**
     * Never Display marker.
     *
     * This method changes the `visible` property of the marker to its false value.
     * Marker will never displayed.
     */
    notDisplay(): void;
    /** {@link OBC.Disposable.dispose} */
    dispose(): void;
}

/**
 * Component for Managing Markers along with creating different types of markers. Every marker is a Simple2DMarker. For every marker that needs to be added, you can use the Manager to add the marker and change its look and feel. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/Marker). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/Marker).
 */
export declare class Marker extends OBC.Component implements OBC.Disposable {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "4079eb91-79b0-4ede-bcf2-15b837129236";
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    /** {@link OBC.Component.enabled} */
    enabled: boolean;
    /**
     * The distance threshold for clustering markers.
     * Markers within this distance will be considered for clustering.
     * Default value is 50.
     */
    threshold: number;
    /**
     * Indicates whether markers should be automatically clustered.
     * If true, markers will be clustered based on the threshold value.
     * Default value is true.
     */
    autoCluster: boolean;
    private static readonly DEFAULT_CLUSTER_STYLES;
    clusterElementStyles: Partial<{
        [key: string]: string | undefined;
    }>;
    /**
     * A Map containing the markers grouped by world UUID.
     * Each world can have its own set of markers.
     */
    list: Map<string, Map<string, IMarker>>;
    protected clusterLabels: Set<IGroupedMarkers>;
    protected currentKeys: Set<string>;
    protected _color: string;
    protected _markerKey: number;
    protected _clusterKey: number;
    private _worldEvents;
    private _setupWorlds;
    /**
     * Getter for the color property.
     * Returns the current color of the markers.
     *
     * @returns {string} The current color of the markers.
     */
    get color(): string;
    /**
     * Setter for the color property.
     * Updates the color of all the markers to the new value.
     *
     * @param {string} value - The new color value for the markers.
     */
    set color(value: string);
    constructor(components: OBC.Components);
    /**
     * Creates a new marker at the specified point in the world.
     *
     * @param world - The world where the marker will be created.
     * @param text - The text content of the marker.
     * @param point - The 3D position where the marker will be placed.
     * @param isStatic - Indicates whether the marker should be static and not clustered.
     * @returns The unique key of the created marker.
     */
    create(world: OBC.World, element: HTMLElement, point: THREE.Vector3, isStatic?: boolean): string | null;
    /**
     * Deletes a marker with the specified ID from all worlds.
     *
     * @param id - The unique identifier of the marker to be deleted.
     *
     * @remarks
     * This method iterates through all the worlds and their respective markers.
     * If a marker with the specified ID is found, it disposes of the marker's label
     * and removes the marker from the world's marker list.
     *
     */
    delete(id: string): void;
    /**
     * Retrieves the list of markers associated with a specific world.
     * If the list does not exist for the given world, it creates a new one.
     *
     * @param world - The world for which the marker list is to be retrieved.
     * @returns A Map containing the markers associated with the given world.
     *
     * @remarks
     * This method is used to manage markers per world. It ensures that each world has its own set of markers.
     * If a marker list for the given world does not exist, it creates a new one and associates it with the world.
     */
    getWorldMarkerList(world: OBC.World): Map<string, IMarker>;
    /** {@link OBC.Disposable.dispose} */
    dispose(type?: string): void;
    /**
     * Sets up event listeners for clustering markers in the given world.
     *
     * @param world - The world where the event listeners will be set up.
     * @param enabled - Indicates whether the event listeners should be enabled or disabled.
     *
     * @remarks
     * This method checks if the event listeners are already set up for the given world.
     * If the event listeners are already set up and the `enabled` parameter is true, the method returns without doing anything.
     * If the world does not have camera controls, the method returns without doing anything.
     *
     * The method then retrieves the event listener for the given world using the `getWorldEvent` method.
     * It removes the existing event listeners for the "sleep" and "rest" events from the world's camera controls.
     *
     * If the `enabled` parameter is true, the method adds the event listener for the "sleep" and "rest" events to the world's camera controls.
     */
    setupEvents(world: OBC.World, enabled: boolean): void;
    /**
     * Performs clustering of markers in the given world.
     *
     * @param world - The world where clustering will be performed.
     *
     */
    cluster(world: OBC.World): void;
    private getWorldEvent;
    private resetMarkers;
    private removeMergeMarkers;
    private getAveragePositionFromLabels;
    clusterElementFactory: () => HTMLElement;
    private createClusterElement;
    private getScreenPosition;
    private distance;
    private navigateToCluster;
}

export declare class MeasureFill {
    private readonly _root;
    private _components;
    private _material;
    set material(value: THREE.MeshLambertMaterial);
    get material(): THREE.MeshLambertMaterial;
    private _visible;
    set visible(value: boolean);
    get visible(): boolean;
    set rounding(value: number);
    get rounding(): number;
    set units(value: "m2" | "cm2" | "mm2" | "km2");
    get units(): "m2" | "cm2" | "mm2" | "km2";
    private _color;
    set color(color: THREE.Color);
    get color(): THREE.Color;
    readonly label: MeasureMark;
    readonly three: THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[], THREE.Object3DEventMap>;
    world: OBC.World;
    area: Area;
    constructor(components: OBC.Components, world: OBC.World, area?: Area);
    applyPlanesVisibility(planes: THREE.Plane[]): void;
    private _triggerUpdate;
    private updateMesh;
    update(): void;
    dispose(): void;
}

export declare class MeasureMark extends Mark {
    private _value;
    set value(value: number);
    get value(): number;
    private _units;
    set units(value: string);
    get units(): string;
    private _worldUnits;
    set worldUnits(value: string);
    get worldUnits(): string;
    private _color;
    set color(color: THREE.Color);
    get color(): THREE.Color;
    private _textColor;
    set textColor(color: THREE.Color);
    get textColor(): THREE.Color;
    private _rounding;
    set rounding(value: number);
    get rounding(): number;
    get formattedValue(): string;
    constructor(world: OBC.World);
}

/**
 * Abstract class that gives the core elements to create any measurement component. ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/Measurement).
 */
export declare abstract class Measurement<T extends Record<string, any> = Record<string, any>, U extends keyof MeasureToUnitMap = keyof MeasureToUnitMap> extends OBC.Component implements OBC.Createable, OBC.Hideable, OBC.Disposable {
    list: FRAGS.DataSet<T>;
    onDisposed: OBC.Event<unknown>;
    snappings?: FRAGS.SnappingClass[];
    lines: FRAGS.DataSet<DimensionLine>;
    fills: FRAGS.DataSet<MeasureFill>;
    labels: FRAGS.DataSet<Mark>;
    volumes: FRAGS.DataSet<MeasureVolume>;
    delay: number;
    abstract modes: string[];
    abstract mode: string;
    protected _world: OBC.World | null;
    set world(value: OBC.World | null);
    get world(): OBC.World | null;
    readonly measureType: U;
    get unitsList(): string[];
    readonly onPointerStop: OBC.Event<unknown>;
    readonly onPointerMove: OBC.Event<unknown>;
    readonly onStateChanged: OBC.Event<MeasurementStateChange[]>;
    private pointerStopTimeout;
    private onMove;
    private onKeydown;
    private setEvents;
    readonly onEnabledChange: OBC.Event<Boolean>;
    private _enabled;
    set enabled(value: boolean);
    get enabled(): boolean;
    static valueFormatter: ((value: number) => string) | null;
    readonly onVisibilityChange: OBC.Event<Boolean>;
    private _visible;
    set visible(value: boolean);
    get visible(): boolean;
    private _units;
    set units(value: MeasureToUnitMap[U]);
    get units(): MeasureToUnitMap[U];
    private _rounding;
    set rounding(value: number);
    get rounding(): number;
    private _linesEndpointElement;
    set linesEndpointElement(value: HTMLElement);
    get linesEndpointElement(): HTMLElement;
    private _linesMaterial;
    set linesMaterial(value: THREE.LineBasicMaterial);
    get linesMaterial(): THREE.LineBasicMaterial;
    private _fillsMaterial;
    set fillsMaterial(value: THREE.MeshLambertMaterial);
    get fillsMaterial(): THREE.MeshLambertMaterial;
    private _volumesMaterial;
    set volumesMaterial(value: THREE.MeshLambertMaterial);
    get volumesMaterial(): THREE.MeshLambertMaterial;
    private _color;
    set color(value: THREE.Color);
    get color(): THREE.Color;
    get pickerMode(): GraphicVertexPickerMode;
    set pickerMode(value: GraphicVertexPickerMode);
    get snapDistance(): number;
    set snapDistance(value: number);
    protected _vertexPicker: GraphicVertexPicker;
    constructor(components: OBC.Components, measureType: U);
    create: (_input?: any) => void;
    endCreation: (_data?: T) => void;
    cancelCreation: () => void;
    delete: (_data?: any) => void;
    dispose(): void;
    applyPlanesVisibility(planes: THREE.Plane[]): void;
    protected createLineElement(line: Line, startNormal?: THREE.Vector3 | null): DimensionLine;
    protected createFillElement(area: Area): MeasureFill;
    protected createVolumeElement(volume: Volume): MeasureVolume;
    protected addLineElementsFromPoints(points: THREE.Vector3[]): void;
    protected getLineBoxes(): THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[], THREE.Object3DEventMap>[];
    protected getFillBoxes(): THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[], THREE.Object3DEventMap>[];
    protected getVolumeBoxes(): Promise<THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[], THREE.Object3DEventMap>[][]>;
}

declare type MeasurementStateChange = "mode" | "color" | "units" | "rounding" | "visibility" | "enabled";

declare type MeasureToUnitMap = {
    length: "mm" | "cm" | "m" | "km";
    area: "mm2" | "cm2" | "m2" | "km2";
    volume: "mm3" | "cm3" | "m3" | "km3";
};

declare class MeasureVolume {
    private readonly _root;
    private _components;
    private _material;
    set material(value: THREE.MeshLambertMaterial);
    get material(): THREE.MeshLambertMaterial;
    private _visible;
    set visible(value: boolean);
    get visible(): boolean;
    set rounding(value: number);
    get rounding(): number;
    set units(value: "m3" | "cm3" | "mm3" | "km3");
    get units(): "m3" | "cm3" | "mm3" | "km3";
    private _color;
    set color(color: THREE.Color);
    get color(): THREE.Color;
    readonly label: MeasureMark;
    world: OBC.World;
    volume: Volume;
    meshes: THREE.Mesh[];
    constructor(components: OBC.Components, world: OBC.World, volume?: Volume);
    applyPlanesVisibility(planes: THREE.Plane[]): void;
    private updateMesh;
    update(): Promise<void>;
    private cleanMeshes;
    dispose(): void;
}

/**
 * Mesher is a class that manages the creation and removal of THREE.Mesh objects from fragment data. It allows to efficiently retrieve and remove meshes for specific model items. ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/Mesher).
 */
export declare class Mesher extends OBC.Component implements OBC.Disposable {
    static uuid: "ab45d0a7-feea-4afc-927c-80832dae76dd";
    enabled: boolean;
    /**
     * A map of model IDs to arrays of THREE.BufferGeometry objects.
     * This is used to store and reuse the geometries generated by the mesher.
     */
    readonly geometries: OBC.ModelIdDataMap<{
        geometry: THREE.BufferGeometry;
        transform: THREE.Matrix4;
    }[]>;
    /**
     * Retrieves meshes for specified model items, optionally applying a material and coordinate system transformation.
     *
     * @param modelIdMap - A map of model IDs to an array of local IDs, specifying which items to retrieve meshes for.
     * @param _config - Optional configuration object.
     * @param _config.material - Optional material to apply to the meshes. If not provided, the default material is used.
     * @param _config.applyTransformation - Whether to bring the mesh to its original position or leave it at 0,0,0. Defaults to `true`.
     * @returns A map of model IDs to a map of local IDs to an array of THREE.Mesh objects.
     */
    get(modelIdMap: OBC.ModelIdMap, _config?: {
        material?: THREE.Material;
        coordinate?: boolean;
        applyTransformation?: boolean;
    }): Promise<OBC.ModelIdDataMap<THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[], THREE.Object3DEventMap>[]>>;
    private getModelMeshes;
    /**
     * Removes the cached geometries by disposing the resources.
     * This makes the meshes created by the component unusable as the geometry will no longer be present.
     *
     * @param modelIds - An optional array of model IDs to remove. If not provided, all meshes will be removed.
     */
    remove(modelIds?: string[]): void;
    readonly onDisposed: OBC.Event<unknown>;
    dispose(full?: boolean): void;
    getMeshesFromResult(result: OBC.ModelIdDataMap<THREE.Mesh[]>): THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[], THREE.Object3DEventMap>[];
    private createGeometry;
    private createMesh;
}

/**
 * This component allows adding a colored outline with thickness to fragments in a 3D scene. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/Outliner). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/Outliner).
 */
export declare class Outliner extends OBC.Component implements OBC.Disposable {
    private _world?;
    /**
     * The world where the outliner operates.
     */
    set world(value: OBC.World | undefined);
    get world(): OBC.World | undefined;
    /**
     * A set of Highlighter styles to be linked with the outliner.
     * @remarks Use this or addItems directly but avoid using both at the same time to prevent unwanted results
     */
    styles: DataSet<string>;
    outlinePositions: boolean;
    private _mesh;
    private get _points();
    /** {@link OBC.Component.enabled} */
    get enabled(): boolean;
    /** {@link OBC.Component.enabled} */
    set enabled(value: boolean);
    get color(): THREE.Color;
    /**
     * Sets the color for the outline.
     */
    set color(value: THREE.Color);
    get thickness(): number;
    /**
     * Sets the thickness of the outline effect in the post-production renderer.
     */
    set thickness(value: number);
    get fillColor(): THREE.Color;
    /**
     * Sets the fill color for the outline effect in the postproduction pipeline.
     */
    set fillColor(value: THREE.Color);
    get fillOpacity(): number;
    /**
     * Sets the fill opacity for the outline pass in the postproduction renderer.
     */
    set fillOpacity(value: number);
    readonly onDisposed: OBC.Event<unknown>;
    /**
     * A unique identifier for the component.

     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "2fd3bcc5-b3b6-4ded-9f64-f47a02854a10";
    private _meshes;
    private _map;
    private _activeStyles;
    private _styleCallbacks;
    constructor(components: OBC.Components);
    private setupEvents;
    private updateFromStyles;
    /**
     * Updates the outline effect with the current meshes from the mesher component.
     */
    update(modelIdMap?: OBC.ModelIdMap): Promise<void>;
    /**
     * Adds items to be outlined.
     *
     * @param modelIdMap - An object representing the model ID map to be added.
     * @returns A promise that resolves once the outliner has been updated with the new model ID map.
     */
    addItems(modelIdMap: OBC.ModelIdMap): Promise<void>;
    /**
     * Removes items from the current outlines.
     *
     * @param modelIdMap - An object representing the mapping of model IDs to be removed.
     * @returns A promise that resolves once the update operation is complete.
     */
    removeItems(modelIdMap: OBC.ModelIdMap): Promise<void>;
    /**
     * Cleans up the outlines.
     */
    clean(): void;
    /** {@link Disposable.dispose} */
    dispose(): void;
    private cleanMeshes;
    private updatePoints;
    private getRenderer;
}

export declare class PlatformComponents extends OBC.Component {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "74c0c370-1af8-4ca9-900a-4a4196c0f2f5";
    enabled: boolean;
    inputs: string[];
    private readonly _requestEventID;
    private readonly _createEventID;
    constructor(components: OBC.Components);
    import<T extends OBC.Component = OBC.Component>(componentSource: string): Promise<T | null>;
}

declare class Postproduction {
    invisibleMaterials: Set<THREE.Material>;
    composer?: EffectComposer;
    readonly onStyleChanged: OBC.Event<PostproductionAspect>;
    private _enabled;
    private _initialized;
    private _basePass?;
    private _aoPass?;
    private _outputPass?;
    private _edgeDetectionPass?;
    private _smaaPass?;
    private _simpleOutlinePass?;
    private _excludedObjectsPass?;
    private _glossPass?;
    private _style;
    private _outlinesEnabled;
    private _glossEnabled;
    private _smaaEnabled;
    private _excludedObjectsEnabled;
    private _components;
    private _renderer;
    defaultAoParameters: {
        radius: number;
        distanceExponent: number;
        thickness: number;
        scale: number;
        samples: number;
        distanceFallOff: number;
        screenSpaceRadius: boolean;
    };
    get basePass(): BasePass;
    get enabled(): boolean;
    set enabled(value: boolean);
    get aoPass(): GTAOPass;
    get outlinePass(): SimpleOutlinePass;
    get edgesPass(): EdgeDetectionPass;
    get excludedObjectsPass(): ExcludedObjectsPass;
    get glossPass(): GlossPass;
    get outlinesEnabled(): boolean;
    set outlinesEnabled(value: boolean);
    get excludedObjectsEnabled(): boolean;
    set excludedObjectsEnabled(value: boolean);
    get glossEnabled(): boolean;
    set glossEnabled(value: boolean);
    get smaaEnabled(): boolean;
    set smaaEnabled(value: boolean);
    get style(): PostproductionAspect;
    set style(value: PostproductionAspect);
    constructor(components: OBC.Components, renderer: PostproductionRenderer);
    update(): void;
    dispose(): void;
    setSize(width: number, height: number): void;
    updateCamera(): void;
    clear(): void;
    private initialize;
}

export declare enum PostproductionAspect {
    COLOR = 0,
    PEN = 1,
    PEN_SHADOWS = 2,
    COLOR_PEN = 3,
    COLOR_SHADOWS = 4,
    COLOR_PEN_SHADOWS = 5
}

/**
 * A class that extends RendererWith2D and adds post-processing capabilities. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/PostproductionRenderer). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/PostproductionRenderer).
 */
export declare class PostproductionRenderer extends RendererWith2D {
    /**
     * The default style to use when the mode is MANUAL.
     */
    manualDefaultStyle: PostproductionAspect;
    /**
     * Whether the postproduction will temporarily be turned off when the mode is MANUAL to get a more fluid navigation experience.
     */
    turnOffOnManualMode: boolean;
    /**
     * The delay in milliseconds to wait before turning the postproduction back on when the mode is MANUAL.
     */
    manualModeDelay: number;
    private _postproduction?;
    private _timeout;
    private _previousStyle;
    private _previousEnabled;
    /**
     * Getter for the postproduction instance.
     * Throws an error if the postproduction instance is not yet initialized.
     *
     * @returns The initialized Postproduction instance.
     */
    get postproduction(): Postproduction;
    constructor(components: OBC.Components, container: HTMLElement, parameters?: Partial<THREE.WebGLRendererParameters>);
    /** {@link Updateable.update} */
    update(): void;
    /** {@link OBC.Disposable.dispose}. */
    dispose(): void;
    private setStyleWithoutEvent;
    private setPostproductionSize;
}

/**
 * A basic renderer capable of rendering 3D and 2D objects ([Objec3Ds](https://threejs.org/docs/#api/en/core/Object3D) and [CSS2DObjects](https://threejs.org/docs/#examples/en/renderers/CSS2DRenderer) respectively).
 */
export declare class RendererWith2D extends SimpleRenderer {
    /**
     * This renderer is used to render 2D objects (CSS2DObjects) in a 3D scene.
     */
    three2D: CSS2DRenderer;
    constructor(components: Components, container: HTMLElement, parameters?: Partial<THREE.WebGLRendererParameters>);
    private setupHtmlRenderer;
}

declare class SimpleOutlinePass extends Pass {
    outlineColor: THREE.Color;
    thickness: number;
    fillColor: THREE.Color;
    fillOpacity: number;
    debugShowMask: boolean;
    scene: THREE.Scene;
    private _maskTarget;
    private _fsQuad;
    private _world;
    private _debugQuad;
    constructor(width: number, height: number, world: OBC.World);
    setSize(width: number, height: number): void;
    render(renderer: THREE.WebGLRenderer, writeBuffer: THREE.WebGLRenderTarget, readBuffer: THREE.WebGLRenderTarget): void;
    dispose(): void;
}

export declare class Volume {
    private _components;
    id: string;
    readonly onItemsChanged: OBC.Event<undefined>;
    private _items;
    set items(value: OBC.ModelIdMap);
    get items(): OBC.ModelIdMap;
    private _units;
    set units(value: "m3" | "cm3" | "mm3" | "km3");
    get units(): "m3" | "cm3" | "mm3" | "km3";
    private _rounding;
    set rounding(value: number);
    get rounding(): number;
    getRawValue(): Promise<number>;
    getValue(): Promise<number>;
    getCenter(): Promise<Vector3>;
    constructor(components: OBC.Components);
    getBox(): Promise<Box3>;
    clone(): Volume;
}

/**
 * A basic dimension tool to measure volumes and display a 3D symbol with the numeric value. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/VolumeMeasurement). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/VolumeMeasurement).
 */
export declare class VolumeMeasurement extends Measurement<Volume, "volume"> {
    static uuid: "01f885ab-ec4e-4e6c-a853-9dfc0d6766ed";
    private _temp;
    readonly onPreviewInitialized: OBC.Event<MeasureVolume>;
    /**
     * The possible modes in which a measurement of this type may be created.
     */
    modes: VolumeMeasurerModes[number][];
    private _mode;
    get mode(): VolumeMeasurerModes[number];
    /**
     * Represents the current measurement mode being used.
     */
    set mode(value: VolumeMeasurerModes[number]);
    constructor(components: OBC.Components);
    private initHandlers;
    private _previousHovererState;
    private initPreview;
    create: () => Promise<void>;
    endCreation: () => void;
    cancelCreation: () => void;
    delete: () => Promise<void>;
}

/**
 * Represents the modes available for the volume measurement tool.
 */
declare type VolumeMeasurerModes = ["free"];

export { }
