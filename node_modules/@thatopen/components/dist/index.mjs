var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as FRAGS from "@thatopen/fragments";
import { DataMap as DataMap$1, FragmentsModels, DataSet as DataSet$1 } from "@thatopen/fragments";
import * as THREE$1 from "three";
import { BufferAttribute, Vector3, Plane, Line3, Vector2, Triangle, Sphere, Matrix4, Box3, BackSide, DoubleSide, FrontSide, Ray, Mesh, Controls, Quaternion, Raycaster, Object3D, MeshBasicMaterial, LineBasicMaterial, CylinderGeometry, BoxGeometry, BufferGeometry, Float32BufferAttribute, OctahedronGeometry, Line, TorusGeometry, SphereGeometry, Euler, PlaneGeometry } from "three";
import * as WEBIFC from "web-ifc";
class Event {
  constructor() {
    /**
     * Whether this event is active or not. If not, it won't trigger.
     */
    __publicField(this, "enabled", true);
    /** Triggers all the callbacks assigned to this event. */
    __publicField(this, "trigger", (data) => {
      if (!this.enabled) {
        return;
      }
      const handlers = this.handlers.slice(0);
      for (const handler of handlers) {
        handler(data);
      }
    });
    __publicField(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(handler) {
    this.handlers.push(handler);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(handler) {
    this.handlers = this.handlers.filter((h) => h !== handler);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
}
class AsyncEvent {
  constructor() {
    /**
     * Whether this event is active or not. If not, it won't trigger.
     */
    __publicField(this, "enabled", true);
    /** Triggers all the callbacks assigned to this event. */
    __publicField(this, "trigger", async (data) => {
      if (!this.enabled) {
        return;
      }
      const handlers = this.handlers.slice(0);
      for (const handler of handlers) {
        await handler(data);
      }
    });
    __publicField(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(handler) {
    this.handlers.push(handler);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(handler) {
    this.handlers = this.handlers.filter((h) => h !== handler);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
}
class Base {
  constructor(components) {
    /** Whether is component is {@link Disposable}. */
    __publicField(this, "isDisposeable", () => {
      return "dispose" in this && "onDisposed" in this;
    });
    /** Whether is component is {@link Resizeable}. */
    __publicField(this, "isResizeable", () => {
      return "resize" in this && "getSize" in this;
    });
    /** Whether is component is {@link Updateable}. */
    __publicField(this, "isUpdateable", () => {
      return "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this;
    });
    /** Whether is component is {@link Hideable}. */
    __publicField(this, "isHideable", () => {
      return "visible" in this;
    });
    /** Whether is component is {@link Configurable}. */
    __publicField(this, "isConfigurable", () => {
      return "setup" in this && "config" in this && "onSetup" in this;
    });
    /** Whether is component is {@link Serializable}. */
    __publicField(this, "isSerializable", () => {
      return "import" in this && "export" in this;
    });
    this.components = components;
  }
}
class Component extends Base {
}
class BaseWorldItem extends Base {
  constructor(components) {
    super(components);
    __publicField(this, "worlds", new DataMap$1());
    /**
     * Event that is triggered when a world is added or removed from the `worlds` map.
     * The event payload contains the world instance and the action ("added" or "removed").
     */
    __publicField(this, "onWorldChanged", new Event());
    __publicField(this, "_currentWorld", null);
    this.onWorldChanged.add(({ world, action }) => {
      if (action === "removed") {
        this.worlds.delete(world.uuid);
      }
    });
  }
  /**
   * The current world this item is associated with. It can be null if no world is currently active.
   */
  set currentWorld(value) {
    this._currentWorld = value;
  }
  get currentWorld() {
    return this._currentWorld;
  }
}
class BaseCamera extends BaseWorldItem {
  constructor() {
    super(...arguments);
    /**
     * Checks whether the instance is {@link CameraControllable}.
     *
     * @returns True if the instance is controllable, false otherwise.
     */
    __publicField(this, "hasCameraControls", () => {
      return "controls" in this;
    });
  }
}
class BaseRenderer extends BaseWorldItem {
  constructor() {
    super(...arguments);
    /** {@link Updateable.onBeforeUpdate} */
    __publicField(this, "onAfterUpdate", new Event());
    /** {@link Updateable.onAfterUpdate} */
    __publicField(this, "onBeforeUpdate", new Event());
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /** {@link Resizeable.onResize} */
    __publicField(this, "onResize", new Event());
    /**
     * Event that fires when there has been a change to the list of clipping
     * planes used by the active renderer.
     */
    __publicField(this, "onClippingPlanesUpdated", new Event());
    /**
     * The list of [clipping planes](https://threejs.org/docs/#api/en/renderers/WebGLRenderer.clippingPlanes) used by this instance of the renderer.
     */
    __publicField(this, "clippingPlanes", []);
  }
  /**
   * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
   *
   * @remarks
   * This method is typically called when there is a change to the list of clipping planes
   * used by the active renderer.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Sets or removes a clipping plane from the renderer.
   *
   * @param active - A boolean indicating whether the clipping plane should be active or not.
   * @param plane - The clipping plane to be added or removed.
   * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
   *
   * @remarks
   * This method adds or removes a clipping plane from the `clippingPlanes` array.
   * If `active` is `true` and the plane is not already in the array, it is added.
   * If `active` is `false` and the plane is in the array, it is removed.
   * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
   * excluding any planes marked as local.
   */
  setPlane(active, plane, isLocal) {
    plane.isLocal = isLocal;
    const index = this.clippingPlanes.indexOf(plane);
    if (active && index === -1) {
      this.clippingPlanes.push(plane);
    } else if (!active && index > -1) {
      this.clippingPlanes.splice(index, 1);
    }
    this.three.clippingPlanes = this.clippingPlanes.filter(
      (plane2) => !plane2.isLocal
    );
  }
}
const _Disposer = class _Disposer extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "_disposedComponents", /* @__PURE__ */ new Set());
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    components.add(_Disposer.uuid, this);
  }
  // TODO: Remove this?
  /**
   * Return the UUIDs of all disposed components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(object, materials = true, recursive = true) {
    object.removeFromParent();
    const item = object;
    if (item.dispose) {
      item.dispose();
    }
    this.disposeGeometryAndMaterials(object, materials);
    if (recursive && item.children && item.children.length) {
      this.disposeChildren(item);
    }
    object.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(geometry) {
    if (geometry.boundsTree && geometry.disposeBoundsTree) {
      geometry.disposeBoundsTree();
    }
    geometry.dispose();
  }
  disposeGeometryAndMaterials(mesh, materials) {
    const item = mesh;
    if (item.geometry) {
      this.disposeGeometry(item.geometry);
    }
    if (materials && item.material) {
      _Disposer.disposeMaterial(item);
    }
    item.material = [];
    item.geometry = null;
  }
  disposeChildren(mesh) {
    for (const child of mesh.children) {
      this.destroy(child);
    }
  }
  static disposeMaterial(mesh) {
    if (mesh.material) {
      if (Array.isArray(mesh.material)) {
        for (const mat of mesh.material) {
          mat.dispose();
        }
      } else {
        mesh.material.dispose();
      }
    }
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_Disposer, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
let Disposer = _Disposer;
class BaseScene extends BaseWorldItem {
  constructor(components) {
    super(components);
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /** The set of directional lights managed by this scene component. */
    __publicField(this, "directionalLights", /* @__PURE__ */ new Map());
    /** The set of ambient lights managed by this scene component. */
    __publicField(this, "ambientLights", /* @__PURE__ */ new Map());
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const disposer = this.components.get(Disposer);
    for (const child of this.three.children) {
      const mesh = child;
      if (mesh.geometry) {
        disposer.destroy(mesh);
      }
    }
    this.deleteAllLights();
    this.three.children = [];
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  deleteAllLights() {
    for (const [, light] of this.directionalLights) {
      light.removeFromParent();
      light.target.removeFromParent();
      light.dispose();
    }
    this.directionalLights.clear();
    for (const [, light] of this.ambientLights) {
      light.removeFromParent();
      light.dispose();
    }
    this.ambientLights.clear();
  }
}
class DataSet extends Set {
  /**
   * Constructs a new instance of the DataSet class.
   *
   * @param iterable - An optional iterable object to initialize the set with.
   */
  constructor(iterable) {
    super(iterable);
    /**
     * An event that is triggered when a new item is added to the set.
     */
    __publicField(this, "onItemAdded", new Event());
    /**
     * An event that is triggered when an item is deleted from the set.
     */
    __publicField(this, "onItemDeleted", new Event());
    /**
     * An event that is triggered when the set is cleared.
     */
    __publicField(this, "onCleared", new Event());
    /**
     * A function that acts as a guard for adding items to the set.
     * It determines whether a given value should be allowed to be added to the set.
     *
     * @param value - The value to be checked against the guard.
     * @returns A boolean indicating whether the value should be allowed to be added to the set.
     *          By default, this function always returns true, allowing all values to be added.
     *          You can override this behavior by providing a custom implementation.
     */
    __publicField(this, "guard", () => true);
  }
  /**
   * Clears the set and triggers the onCleared event.
   */
  clear() {
    super.clear();
    this.onCleared.trigger();
  }
  /**
   * Adds one or multiple values to the set and triggers the onItemAdded event per each.
   *
   * @param value - The value to add to the set.
   * @returns - The set instance.
   */
  add(...value) {
    for (const item of value) {
      const existing = this.has(item);
      if (existing)
        continue;
      const isValid = this.guard(item);
      if (!isValid)
        continue;
      super.add(item);
      if (!this.onItemAdded)
        this.onItemAdded = new Event();
      this.onItemAdded.trigger(item);
    }
    return this;
  }
  /**
   * Deletes a value from the set and triggers the onItemDeleted event.
   *
   * @param value - The value to delete from the set.
   * @returns - True if the value was successfully deleted, false otherwise.
   */
  delete(value) {
    const deleted = super.delete(value);
    if (deleted)
      this.onItemDeleted.trigger();
    return deleted;
  }
  /**
   * Clears the set and resets the onItemAdded, onItemDeleted, and onCleared events.
   */
  dispose() {
    this.clear();
    this.onItemAdded.reset();
    this.onItemDeleted.reset();
    this.onCleared.reset();
  }
}
const _UUID = class _UUID {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = `${_UUID._lut[d0 & 255] + _UUID._lut[d0 >> 8 & 255] + _UUID._lut[d0 >> 16 & 255] + _UUID._lut[d0 >> 24 & 255]}-${_UUID._lut[d1 & 255]}${_UUID._lut[d1 >> 8 & 255]}-${_UUID._lut[d1 >> 16 & 15 | 64]}${_UUID._lut[d1 >> 24 & 255]}-${_UUID._lut[d2 & 63 | 128]}${_UUID._lut[d2 >> 8 & 255]}-${_UUID._lut[d2 >> 16 & 255]}${_UUID._lut[d2 >> 24 & 255]}${_UUID._lut[d3 & 255]}${_UUID._lut[d3 >> 8 & 255]}${_UUID._lut[d3 >> 16 & 255]}${_UUID._lut[d3 >> 24 & 255]}`;
    return uuid.toLowerCase();
  }
  static validate(uuid) {
    if (!_UUID._pattern.test(uuid))
      throw new Error(
        `${uuid} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
__publicField(_UUID, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/);
// prettier-ignore
__publicField(_UUID, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
let UUID = _UUID;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var validator$2 = {};
var util$3 = {};
(function(exports) {
  const nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  const nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  const nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
  const regexName = new RegExp("^" + nameRegexp + "$");
  const getAllMatches = function(string, regex) {
    const matches = [];
    let match = regex.exec(string);
    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      const len = match.length;
      for (let index = 0; index < len; index++) {
        allmatches.push(match[index]);
      }
      matches.push(allmatches);
      match = regex.exec(string);
    }
    return matches;
  };
  const isName = function(string) {
    const match = regexName.exec(string);
    return !(match === null || typeof match === "undefined");
  };
  exports.isExist = function(v) {
    return typeof v !== "undefined";
  };
  exports.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };
  exports.merge = function(target, a, arrayMode) {
    if (a) {
      const keys = Object.keys(a);
      const len = keys.length;
      for (let i = 0; i < len; i++) {
        if (arrayMode === "strict") {
          target[keys[i]] = [a[keys[i]]];
        } else {
          target[keys[i]] = a[keys[i]];
        }
      }
    }
  };
  exports.getValue = function(v) {
    if (exports.isExist(v)) {
      return v;
    } else {
      return "";
    }
  };
  exports.isName = isName;
  exports.getAllMatches = getAllMatches;
  exports.nameRegexp = nameRegexp;
})(util$3);
const util$2 = util$3;
const defaultOptions$2 = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
validator$2.validate = function(xmlData, options) {
  options = Object.assign({}, defaultOptions$2, options);
  const tags = [];
  let tagFound = false;
  let reachedRoot = false;
  if (xmlData[0] === "\uFEFF") {
    xmlData = xmlData.substr(1);
  }
  for (let i = 0; i < xmlData.length; i++) {
    if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
      i += 2;
      i = readPI(xmlData, i);
      if (i.err)
        return i;
    } else if (xmlData[i] === "<") {
      let tagStartPos = i;
      i++;
      if (xmlData[i] === "!") {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === "/") {
          closingTag = true;
          i++;
        }
        let tagName = "";
        for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        if (tagName[tagName.length - 1] === "/") {
          tagName = tagName.substring(0, tagName.length - 1);
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '" + tagName + "' is an invalid name.";
          }
          return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
        }
        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;
        if (attrStr[attrStr.length - 1] === "/") {
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
          } else {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject(
                "InvalidTag",
                "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                getLineNumberForPosition(xmlData, tagStartPos)
              );
            }
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }
          if (reachedRoot === true) {
            return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
          } else if (options.unpairedTags.indexOf(tagName) !== -1)
            ;
          else {
            tags.push({ tagName, tagStartPos });
          }
          tagFound = true;
        }
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "!") {
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i + 1] === "?") {
              i = readPI(xmlData, ++i);
              if (i.err)
                return i;
            } else {
              break;
            }
          } else if (xmlData[i] === "&") {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          } else {
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        }
        if (xmlData[i] === "<") {
          i--;
        }
      }
    } else {
      if (isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }
  if (!tagFound) {
    return getErrorObject("InvalidXml", "Start tag expected.", 1);
  } else if (tags.length == 1) {
    return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  } else if (tags.length > 0) {
    return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  }
  return true;
};
function isWhiteSpace(char) {
  return char === " " || char === "	" || char === "\n" || char === "\r";
}
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == "?" || xmlData[i] == " ") {
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === "xml") {
        return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}
function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "<") {
        angleBracketsCount++;
      } else if (xmlData[i] === ">") {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  }
  return i;
}
const doubleQuote = '"';
const singleQuote = "'";
function readAttributeStr(xmlData, i) {
  let attrStr = "";
  let startChar = "";
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === "") {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i])
        ;
      else {
        startChar = "";
      }
    } else if (xmlData[i] === ">") {
      if (startChar === "") {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== "") {
    return false;
  }
  return {
    value: attrStr,
    index: i,
    tagClosed
  };
}
const validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function validateAttributeString(attrStr, options) {
  const matches = util$2.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};
  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
      return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
    }
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      attrNames[attrName] = 1;
    } else {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
    }
  }
  return true;
}
function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === "x") {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ";")
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}
function validateAmpersand(xmlData, i) {
  i++;
  if (xmlData[i] === ";")
    return -1;
  if (xmlData[i] === "#") {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ";")
      break;
    return -1;
  }
  return i;
}
function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col
    }
  };
}
function validateAttrName(attrName) {
  return util$2.isName(attrName);
}
function validateTagName(tagname) {
  return util$2.isName(tagname);
}
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}
var OptionsBuilder = {};
const defaultOptions$1 = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(tagName, val2) {
    return val2;
  },
  attributeValueProcessor: function(attrName, val2) {
    return val2;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(tagName, jPath, attrs) {
    return tagName;
  }
  // skipEmptyListItem: false
};
const buildOptions$1 = function(options) {
  return Object.assign({}, defaultOptions$1, options);
};
OptionsBuilder.buildOptions = buildOptions$1;
OptionsBuilder.defaultOptions = defaultOptions$1;
class XmlNode {
  constructor(tagname) {
    this.tagname = tagname;
    this.child = [];
    this[":@"] = {};
  }
  add(key, val2) {
    if (key === "__proto__")
      key = "#__proto__";
    this.child.push({ [key]: val2 });
  }
  addChild(node) {
    if (node.tagname === "__proto__")
      node.tagname = "#__proto__";
    if (node[":@"] && Object.keys(node[":@"]).length > 0) {
      this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
    } else {
      this.child.push({ [node.tagname]: node.child });
    }
  }
}
var xmlNode$1 = XmlNode;
const util$1 = util$3;
function readDocType$1(xmlData, i) {
  const entities = {};
  if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
    i = i + 9;
    let angleBracketsCount = 1;
    let hasBody = false, comment = false;
    let exp = "";
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === "<" && !comment) {
        if (hasBody && isEntity(xmlData, i)) {
          i += 7;
          [entityName, val, i] = readEntityExp(xmlData, i + 1);
          if (val.indexOf("&") === -1)
            entities[validateEntityName(entityName)] = {
              regx: RegExp(`&${entityName};`, "g"),
              val
            };
        } else if (hasBody && isElement(xmlData, i))
          i += 8;
        else if (hasBody && isAttlist(xmlData, i))
          i += 8;
        else if (hasBody && isNotation(xmlData, i))
          i += 9;
        else if (isComment)
          comment = true;
        else
          throw new Error("Invalid DOCTYPE");
        angleBracketsCount++;
        exp = "";
      } else if (xmlData[i] === ">") {
        if (comment) {
          if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
            comment = false;
            angleBracketsCount--;
          }
        } else {
          angleBracketsCount--;
        }
        if (angleBracketsCount === 0) {
          break;
        }
      } else if (xmlData[i] === "[") {
        hasBody = true;
      } else {
        exp += xmlData[i];
      }
    }
    if (angleBracketsCount !== 0) {
      throw new Error(`Unclosed DOCTYPE`);
    }
  } else {
    throw new Error(`Invalid Tag instead of DOCTYPE`);
  }
  return { entities, i };
}
function readEntityExp(xmlData, i) {
  let entityName2 = "";
  for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"'); i++) {
    entityName2 += xmlData[i];
  }
  entityName2 = entityName2.trim();
  if (entityName2.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const startChar = xmlData[i++];
  let val2 = "";
  for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
    val2 += xmlData[i];
  }
  return [entityName2, val2, i];
}
function isComment(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "-" && xmlData[i + 3] === "-")
    return true;
  return false;
}
function isEntity(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y")
    return true;
  return false;
}
function isElement(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T")
    return true;
  return false;
}
function isAttlist(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T")
    return true;
  return false;
}
function isNotation(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N")
    return true;
  return false;
}
function validateEntityName(name) {
  if (util$1.isName(name))
    return name;
  else
    throw new Error(`Invalid entity name ${name}`);
}
var DocTypeReader = readDocType$1;
const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
const consider = {
  hex: true,
  // oct: false,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function toNumber$1(str, options = {}) {
  options = Object.assign({}, consider, options);
  if (!str || typeof str !== "string")
    return str;
  let trimmedStr = str.trim();
  if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
    return str;
  else if (str === "0")
    return 0;
  else if (options.hex && hexRegex.test(trimmedStr)) {
    return parse_int(trimmedStr, 16);
  } else if (trimmedStr.search(/[eE]/) !== -1) {
    const notation = trimmedStr.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
    if (notation) {
      if (options.leadingZeros) {
        trimmedStr = (notation[1] || "") + notation[3];
      } else {
        if (notation[2] === "0" && notation[3][0] === ".")
          ;
        else {
          return str;
        }
      }
      return options.eNotation ? Number(trimmedStr) : str;
    } else {
      return str;
    }
  } else {
    const match = numRegex.exec(trimmedStr);
    if (match) {
      const sign = match[1];
      const leadingZeros = match[2];
      let numTrimmedByZeros = trimZeros(match[3]);
      if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
        return str;
      else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
        return str;
      else if (options.leadingZeros && leadingZeros === str)
        return 0;
      else {
        const num = Number(trimmedStr);
        const numStr = "" + num;
        if (numStr.search(/[eE]/) !== -1) {
          if (options.eNotation)
            return num;
          else
            return str;
        } else if (trimmedStr.indexOf(".") !== -1) {
          if (numStr === "0" && numTrimmedByZeros === "")
            return num;
          else if (numStr === numTrimmedByZeros)
            return num;
          else if (sign && numStr === "-" + numTrimmedByZeros)
            return num;
          else
            return str;
        }
        if (leadingZeros) {
          return numTrimmedByZeros === numStr || sign + numTrimmedByZeros === numStr ? num : str;
        } else {
          return trimmedStr === numStr || trimmedStr === sign + numStr ? num : str;
        }
      }
    } else {
      return str;
    }
  }
}
function trimZeros(numStr) {
  if (numStr && numStr.indexOf(".") !== -1) {
    numStr = numStr.replace(/0+$/, "");
    if (numStr === ".")
      numStr = "0";
    else if (numStr[0] === ".")
      numStr = "0" + numStr;
    else if (numStr[numStr.length - 1] === ".")
      numStr = numStr.substr(0, numStr.length - 1);
    return numStr;
  }
  return numStr;
}
function parse_int(numStr, base) {
  if (parseInt)
    return parseInt(numStr, base);
  else if (Number.parseInt)
    return Number.parseInt(numStr, base);
  else if (window && window.parseInt)
    return window.parseInt(numStr, base);
  else
    throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}
var strnum = toNumber$1;
const util = util$3;
const xmlNode = xmlNode$1;
const readDocType = DocTypeReader;
const toNumber = strnum;
let OrderedObjParser$1 = class OrderedObjParser {
  constructor(options) {
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
      "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
      "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
      "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent": { regex: /&(cent|#162);/g, val: "¢" },
      "pound": { regex: /&(pound|#163);/g, val: "£" },
      "yen": { regex: /&(yen|#165);/g, val: "¥" },
      "euro": { regex: /&(euro|#8364);/g, val: "€" },
      "copyright": { regex: /&(copy|#169);/g, val: "©" },
      "reg": { regex: /&(reg|#174);/g, val: "®" },
      "inr": { regex: /&(inr|#8377);/g, val: "₹" },
      "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 16)) }
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue$1;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
  }
};
function addExternalEntities(externalEntities) {
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
      regex: new RegExp("&" + ent + ";", "g"),
      val: externalEntities[ent]
    };
  }
}
function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val2 !== void 0) {
    if (this.options.trimValues && !dontTrim) {
      val2 = val2.trim();
    }
    if (val2.length > 0) {
      if (!escapeEntities)
        val2 = this.replaceEntitiesValue(val2);
      const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
      if (newval === null || newval === void 0) {
        return val2;
      } else if (typeof newval !== typeof val2 || newval !== val2) {
        return newval;
      } else if (this.options.trimValues) {
        return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
      } else {
        const trimmedVal = val2.trim();
        if (trimmedVal === val2) {
          return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          return val2;
        }
      }
    }
  }
}
function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(":");
    const prefix = tagname.charAt(0) === "/" ? "/" : "";
    if (tags[0] === "xmlns") {
      return "";
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}
const attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function buildAttributesMap(attrStr, jPath, tagName) {
  if (!this.options.ignoreAttributes && typeof attrStr === "string") {
    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length;
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if (aName === "__proto__")
          aName = "#__proto__";
        if (oldVal !== void 0) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if (newVal === null || newVal === void 0) {
            attrs[aName] = oldVal;
          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
            attrs[aName] = newVal;
          } else {
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}
const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n");
  const xmlObj = new xmlNode("!xml");
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for (let i = 0; i < xmlData.length; i++) {
    const ch = xmlData[i];
    if (ch === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
        let tagName = xmlData.substring(i + 2, closeIndex).trim();
        if (this.options.removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
          }
        }
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode) {
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }
        const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
        if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0;
        if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
          propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
          this.tagsNodeStack.pop();
        } else {
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);
        currentNode = this.tagsNodeStack.pop();
        textData = "";
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        let tagData = readTagExp(xmlData, i, false, "?>");
        if (!tagData)
          throw new Error("Pi Tag is not closed.");
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags)
          ;
        else {
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath);
        }
        i = tagData.closeIndex + 1;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const comment = xmlData.substring(i + 4, endIndex - 2);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
        }
        i = endIndex;
      } else if (xmlData.substr(i + 1, 2) === "!D") {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9, closeIndex);
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if (val2 == void 0)
          val2 = "";
        if (this.options.cdataPropName) {
          currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
        } else {
          currentNode.add(this.options.textNodeName, val2);
        }
        i = closeIndex + 2;
      } else {
        let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
        let tagName = result.tagName;
        const rawTagName = result.rawTagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode && textData) {
          if (currentNode.tagname !== "!xml") {
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }
        const lastTag = currentNode;
        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if (tagName !== xmlObj.tagname) {
          jPath += jPath ? "." + tagName : tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
          let tagContent = "";
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            i = result.closeIndex;
          } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
            i = result.closeIndex;
          } else {
            const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
            if (!result2)
              throw new Error(`Unexpected end of ${rawTagName}`);
            i = result2.i;
            tagContent = result2.tagContent;
          }
          const childNode = new xmlNode(tagName);
          if (tagName !== tagExp && attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if (tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          this.addChild(currentNode, childNode, jPath);
        } else {
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            const childNode = new xmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath);
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          } else {
            const childNode = new xmlNode(tagName);
            this.tagsNodeStack.push(currentNode);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath);
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    } else {
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
};
function addChild(currentNode, childNode, jPath) {
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
  if (result === false)
    ;
  else if (typeof result === "string") {
    childNode.tagname = result;
    currentNode.addChild(childNode);
  } else {
    currentNode.addChild(childNode);
  }
}
const replaceEntitiesValue$1 = function(val2) {
  if (this.options.processEntities) {
    for (let entityName2 in this.docTypeEntities) {
      const entity = this.docTypeEntities[entityName2];
      val2 = val2.replace(entity.regx, entity.val);
    }
    for (let entityName2 in this.lastEntities) {
      const entity = this.lastEntities[entityName2];
      val2 = val2.replace(entity.regex, entity.val);
    }
    if (this.options.htmlEntities) {
      for (let entityName2 in this.htmlEntities) {
        const entity = this.htmlEntities[entityName2];
        val2 = val2.replace(entity.regex, entity.val);
      }
    }
    val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return val2;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) {
    if (isLeafNode === void 0)
      isLeafNode = Object.keys(currentNode.child).length === 0;
    textData = this.parseTextData(
      textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode
    );
    if (textData !== void 0 && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}
function isItStopNode(stopNodes, jPath, currentTagName) {
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
      return true;
  }
  return false;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
      if (ch === attrBoundary)
        attrBoundary = "";
    } else if (ch === '"' || ch === "'") {
      attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if (closingChar[1]) {
        if (xmlData[index + 1] === closingChar[1]) {
          return {
            data: tagExp,
            index
          };
        }
      } else {
        return {
          data: tagExp,
          index
        };
      }
    } else if (ch === "	") {
      ch = " ";
    }
    tagExp += ch;
  }
}
function findClosingIndex(xmlData, str, i, errMsg) {
  const closingIndex = xmlData.indexOf(str, i);
  if (closingIndex === -1) {
    throw new Error(errMsg);
  } else {
    return closingIndex + str.length - 1;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result)
    return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if (separatorIndex !== -1) {
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    if (colonIndex !== -1) {
      tagName = tagName.substr(colonIndex + 1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
function readStopNodeData(xmlData, tagName, i) {
  const startIndex = i;
  let openTagCount = 1;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
        if (closeTagName === tagName) {
          openTagCount--;
          if (openTagCount === 0) {
            return {
              tagContent: xmlData.substring(startIndex, i),
              i: closeIndex
            };
          }
        }
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
        i = closeIndex;
      } else {
        const tagData = readTagExp(xmlData, i, ">");
        if (tagData) {
          const openTagName = tagData && tagData.tagName;
          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
            openTagCount++;
          }
          i = tagData.closeIndex;
        }
      }
    }
  }
}
function parseValue(val2, shouldParse, options) {
  if (shouldParse && typeof val2 === "string") {
    const newval = val2.trim();
    if (newval === "true")
      return true;
    else if (newval === "false")
      return false;
    else
      return toNumber(val2, options);
  } else {
    if (util.isExist(val2)) {
      return val2;
    } else {
      return "";
    }
  }
}
var OrderedObjParser_1 = OrderedObjParser$1;
var node2json = {};
function prettify$1(node, options) {
  return compress(node, options);
}
function compress(arr, options, jPath) {
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName$1(tagObj);
    let newJpath = "";
    if (jPath === void 0)
      newJpath = property;
    else
      newJpath = jPath + "." + property;
    if (property === options.textNodeName) {
      if (text === void 0)
        text = tagObj[property];
      else
        text += "" + tagObj[property];
    } else if (property === void 0) {
      continue;
    } else if (tagObj[property]) {
      let val2 = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val2, options);
      if (tagObj[":@"]) {
        assignAttributes(val2, tagObj[":@"], newJpath, options);
      } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
        val2 = val2[options.textNodeName];
      } else if (Object.keys(val2).length === 0) {
        if (options.alwaysCreateTextNode)
          val2[options.textNodeName] = "";
        else
          val2 = "";
      }
      if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
        if (!Array.isArray(compressedObj[property])) {
          compressedObj[property] = [compressedObj[property]];
        }
        compressedObj[property].push(val2);
      } else {
        if (options.isArray(property, newJpath, isLeaf)) {
          compressedObj[property] = [val2];
        } else {
          compressedObj[property] = val2;
        }
      }
    }
  }
  if (typeof text === "string") {
    if (text.length > 0)
      compressedObj[options.textNodeName] = text;
  } else if (text !== void 0)
    compressedObj[options.textNodeName] = text;
  return compressedObj;
}
function propName$1(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (key !== ":@")
      return key;
  }
}
function assignAttributes(obj, attrMap, jpath, options) {
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [attrMap[atrrName]];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}
function isLeafTag(obj, options) {
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  if (propCount === 0) {
    return true;
  }
  if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
    return true;
  }
  return false;
}
node2json.prettify = prettify$1;
const { buildOptions } = OptionsBuilder;
const OrderedObjParser2 = OrderedObjParser_1;
const { prettify } = node2json;
const validator$1 = validator$2;
let XMLParser$1 = class XMLParser {
  constructor(options) {
    this.externalEntities = {};
    this.options = buildOptions(options);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(xmlData, validationOption) {
    if (typeof xmlData === "string")
      ;
    else if (xmlData.toString) {
      xmlData = xmlData.toString();
    } else {
      throw new Error("XML data is accepted in String or Bytes[] form.");
    }
    if (validationOption) {
      if (validationOption === true)
        validationOption = {};
      const result = validator$1.validate(xmlData, validationOption);
      if (result !== true) {
        throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
      }
    }
    const orderedObjParser = new OrderedObjParser2(this.options);
    orderedObjParser.addExternalEntities(this.externalEntities);
    const orderedResult = orderedObjParser.parseXml(xmlData);
    if (this.options.preserveOrder || orderedResult === void 0)
      return orderedResult;
    else
      return prettify(orderedResult, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(key, value) {
    if (value.indexOf("&") !== -1) {
      throw new Error("Entity value can't have '&'");
    } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    } else if (value === "&") {
      throw new Error("An entity with value '&' is not permitted");
    } else {
      this.externalEntities[key] = value;
    }
  }
};
var XMLParser_1 = XMLParser$1;
const EOL = "\n";
function toXml(jArray, options) {
  let indentation = "";
  if (options.format && options.indentBy.length > 0) {
    indentation = EOL;
  }
  return arrToStr(jArray, options, "", indentation);
}
function arrToStr(arr, options, jPath, indentation) {
  let xmlStr = "";
  let isPreviousElementTag = false;
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const tagName = propName(tagObj);
    if (tagName === void 0)
      continue;
    let newJPath = "";
    if (jPath.length === 0)
      newJPath = tagName;
    else
      newJPath = `${jPath}.${tagName}`;
    if (tagName === options.textNodeName) {
      let tagText = tagObj[tagName];
      if (!isStopNode(newJPath, options)) {
        tagText = options.tagValueProcessor(tagName, tagText);
        tagText = replaceEntitiesValue(tagText, options);
      }
      if (isPreviousElementTag) {
        xmlStr += indentation;
      }
      xmlStr += tagText;
      isPreviousElementTag = false;
      continue;
    } else if (tagName === options.cdataPropName) {
      if (isPreviousElementTag) {
        xmlStr += indentation;
      }
      xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
      isPreviousElementTag = false;
      continue;
    } else if (tagName === options.commentPropName) {
      xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
      isPreviousElementTag = true;
      continue;
    } else if (tagName[0] === "?") {
      const attStr2 = attr_to_str(tagObj[":@"], options);
      const tempInd = tagName === "?xml" ? "" : indentation;
      let piTextNodeName = tagObj[tagName][0][options.textNodeName];
      piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
      xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
      isPreviousElementTag = true;
      continue;
    }
    let newIdentation = indentation;
    if (newIdentation !== "") {
      newIdentation += options.indentBy;
    }
    const attStr = attr_to_str(tagObj[":@"], options);
    const tagStart = indentation + `<${tagName}${attStr}`;
    const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
    if (options.unpairedTags.indexOf(tagName) !== -1) {
      if (options.suppressUnpairedNode)
        xmlStr += tagStart + ">";
      else
        xmlStr += tagStart + "/>";
    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
      xmlStr += tagStart + "/>";
    } else if (tagValue && tagValue.endsWith(">")) {
      xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
    } else {
      xmlStr += tagStart + ">";
      if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
        xmlStr += indentation + options.indentBy + tagValue + indentation;
      } else {
        xmlStr += tagValue;
      }
      xmlStr += `</${tagName}>`;
    }
    isPreviousElementTag = true;
  }
  return xmlStr;
}
function propName(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (!obj.hasOwnProperty(key))
      continue;
    if (key !== ":@")
      return key;
  }
}
function attr_to_str(attrMap, options) {
  let attrStr = "";
  if (attrMap && !options.ignoreAttributes) {
    for (let attr in attrMap) {
      if (!attrMap.hasOwnProperty(attr))
        continue;
      let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
      attrVal = replaceEntitiesValue(attrVal, options);
      if (attrVal === true && options.suppressBooleanAttributes) {
        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
      } else {
        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
      }
    }
  }
  return attrStr;
}
function isStopNode(jPath, options) {
  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
  let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
  for (let index in options.stopNodes) {
    if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
      return true;
  }
  return false;
}
function replaceEntitiesValue(textValue, options) {
  if (textValue && textValue.length > 0 && options.processEntities) {
    for (let i = 0; i < options.entities.length; i++) {
      const entity = options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}
var orderedJs2Xml = toXml;
const buildFromOrderedJs = orderedJs2Xml;
const defaultOptions = {
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: "  ",
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};
function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    this.isAttribute = function() {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }
  this.processTextOrObjNode = processTextOrObjNode;
  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = ">\n";
    this.newLine = "\n";
  } else {
    this.indentate = function() {
      return "";
    };
    this.tagEndChar = ">";
    this.newLine = "";
  }
}
Builder.prototype.build = function(jObj) {
  if (this.options.preserveOrder) {
    return buildFromOrderedJs(jObj, this.options);
  } else {
    if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
      jObj = {
        [this.options.arrayNodeName]: jObj
      };
    }
    return this.j2x(jObj, 0).val;
  }
};
Builder.prototype.j2x = function(jObj, level) {
  let attrStr = "";
  let val2 = "";
  for (let key in jObj) {
    if (!Object.prototype.hasOwnProperty.call(jObj, key))
      continue;
    if (typeof jObj[key] === "undefined") {
      if (this.isAttribute(key)) {
        val2 += "";
      }
    } else if (jObj[key] === null) {
      if (this.isAttribute(key)) {
        val2 += "";
      } else if (key[0] === "?") {
        val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
      } else {
        val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
      }
    } else if (jObj[key] instanceof Date) {
      val2 += this.buildTextValNode(jObj[key], key, "", level);
    } else if (typeof jObj[key] !== "object") {
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
      } else {
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
          val2 += this.replaceEntitiesValue(newval);
        } else {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      const arrLen = jObj[key].length;
      let listTagVal = "";
      let listTagAttr = "";
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === "undefined")
          ;
        else if (item === null) {
          if (key[0] === "?")
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (typeof item === "object") {
          if (this.options.oneListGroup) {
            const result = this.j2x(item, level + 1);
            listTagVal += result.val;
            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
              listTagAttr += result.attrStr;
            }
          } else {
            listTagVal += this.processTextOrObjNode(item, key, level);
          }
        } else {
          if (this.options.oneListGroup) {
            let textValue = this.options.tagValueProcessor(key, item);
            textValue = this.replaceEntitiesValue(textValue);
            listTagVal += textValue;
          } else {
            listTagVal += this.buildTextValNode(item, key, "", level);
          }
        }
      }
      if (this.options.oneListGroup) {
        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
      }
      val2 += listTagVal;
    } else {
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
        }
      } else {
        val2 += this.processTextOrObjNode(jObj[key], key, level);
      }
    }
  }
  return { attrStr, val: val2 };
};
Builder.prototype.buildAttrPairStr = function(attrName, val2) {
  val2 = this.options.attributeValueProcessor(attrName, "" + val2);
  val2 = this.replaceEntitiesValue(val2);
  if (this.options.suppressBooleanAttributes && val2 === "true") {
    return " " + attrName;
  } else
    return " " + attrName + '="' + val2 + '"';
};
function processTextOrObjNode(object, key, level) {
  const result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}
Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
  if (val2 === "") {
    if (key[0] === "?")
      return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    else {
      return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  } else {
    let tagEndExp = "</" + key + this.tagEndChar;
    let piClosingChar = "";
    if (key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
    if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
      return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val2}-->` + this.newLine;
    } else {
      return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
    }
  }
};
Builder.prototype.closeTag = function(key) {
  let closeTag = "";
  if (this.options.unpairedTags.indexOf(key) !== -1) {
    if (!this.options.suppressUnpairedNode)
      closeTag = "/";
  } else if (this.options.suppressEmptyNode) {
    closeTag = "/";
  } else {
    closeTag = `></${key}`;
  }
  return closeTag;
};
Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
  } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val2}-->` + this.newLine;
  } else if (key[0] === "?") {
    return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
  } else {
    let textValue = this.options.tagValueProcessor(key, val2);
    textValue = this.replaceEntitiesValue(textValue);
    if (textValue === "") {
      return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
    } else {
      return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
    }
  }
};
Builder.prototype.replaceEntitiesValue = function(textValue) {
  if (textValue && textValue.length > 0 && this.options.processEntities) {
    for (let i = 0; i < this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
};
function indentate(level) {
  return this.options.indentBy.repeat(level);
}
function isAttribute(name) {
  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}
var json2xml = Builder;
const validator = validator$2;
const XMLParser2 = XMLParser_1;
const XMLBuilder = json2xml;
var fxp = {
  XMLParser: XMLParser2,
  XMLValidator: validator,
  XMLBuilder
};
class XML {
}
__publicField(XML, "parser", new fxp.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
__publicField(XML, "builder", new fxp.XMLBuilder({
  attributeNamePrefix: "$",
  ignoreAttributes: false,
  suppressBooleanAttributes: false
}));
class VertexPicker extends Component {
  constructor(components, config) {
    super(components);
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /**
     * An event that is triggered when a vertex is found.
     * The event passes a THREE.Vector3 representing the position of the found vertex.
     */
    __publicField(this, "onVertexFound", new Event());
    /**
     * An event that is triggered when a vertex is lost.
     * The event passes a THREE.Vector3 representing the position of the lost vertex.
     */
    __publicField(this, "onVertexLost", new Event());
    /**
     * An event that is triggered when the picker is enabled or disabled
     */
    __publicField(this, "onEnabled", new Event());
    /**
     * A reference to the Components instance associated with this VertexPicker.
     */
    __publicField(this, "components");
    /**
     * A reference to the working plane used for vertex picking.
     * This plane is used to determine which vertices are considered valid for picking.
     * If this value is null, all vertices are considered valid.
     */
    __publicField(this, "workingPlane", null);
    __publicField(this, "_pickedPoint", null);
    __publicField(this, "_config");
    __publicField(this, "_enabled", false);
    this.components = components;
    this.config = {
      snapDistance: 0.25,
      showOnlyVertex: false,
      ...config
    };
    this.enabled = false;
  }
  /**
   * Sets the enabled state of the VertexPicker.
   * When enabled, the VertexPicker will actively search for vertices in the 3D scene.
   * When disabled, the VertexPicker will stop searching for vertices and reset the picked point.
   *
   * @param value - The new enabled state.
   */
  set enabled(value) {
    this._enabled = value;
    if (!value) {
      this._pickedPoint = null;
    }
    this.onEnabled.trigger(value);
  }
  /**
   * Gets the current enabled state of the VertexPicker.
   *
   * @returns The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the configuration for the VertexPicker component.
   *
   * @param value - A Partial object containing the configuration properties to update.
   * The properties not provided in the value object will retain their current values.
   *
   * @example
   * ```typescript
   * vertexPicker.config = {
   *   snapDistance: 0.5,
   *   showOnlyVertex: true,
   * };
   * ```
   */
  set config(value) {
    this._config = { ...this._config, ...value };
  }
  /**
   * Gets the current configuration for the VertexPicker component.
   *
   * @returns A copy of the current VertexPickerConfig object.
   *
   * @example
   * ```typescript
   * const currentConfig = vertexPicker.config;
   * console.log(currentConfig.snapDistance); // Output: 0.25
   * ```
   */
  get config() {
    return this._config;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onVertexFound.reset();
    this.onVertexLost.reset();
    this.components = null;
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Performs the vertex picking operation based on the current state of the VertexPicker.
   *
   * @param world - The World instance to use for raycasting.
   *
   * @returns The current picked point, or null if no point is picked.
   *
   * @remarks
   * This method checks if the VertexPicker is enabled. If not, it returns the current picked point.
   * If enabled, it performs raycasting to find the closest intersecting object.
   * It then determines the closest vertex or point on the face, based on the configuration settings.
   * If the picked point is on the working plane (if defined), it triggers the `onVertexFound` event and updates the `pickedPoint`.
   * If the picked point is not on the working plane, it resets the `pickedPoint`.
   * If no intersecting object is found, it triggers the `onVertexLost` event and resets the `pickedPoint`.
   */
  async get(world) {
    if (!this.enabled)
      return this._pickedPoint;
    const casters = this.components.get(Raycasters);
    const caster = casters.get(world);
    const intersects = await caster.castRay();
    if (!intersects) {
      if (this._pickedPoint !== null) {
        this.onVertexLost.trigger();
        this._pickedPoint = null;
      }
      return this._pickedPoint;
    }
    const point = intersects.point;
    if (this._pickedPoint === null || !this._pickedPoint.equals(point)) {
      this._pickedPoint = point.clone();
      this.onVertexFound.trigger(this._pickedPoint);
    }
    return this._pickedPoint;
  }
  // private getClosestVertex(intersects: THREE.Intersection) {
  //   let closestVertex = new THREE.Vector3();
  //   let vertexFound = false;
  //   let closestDistance = Number.MAX_SAFE_INTEGER;
  //   const vertices = this.getVertices(intersects);
  //   if (vertices === null) {
  //     return null;
  //   }
  //   for (const vertex of vertices) {
  //     if (!vertex) {
  //       continue;
  //     }
  //     const distance = intersects.point.distanceTo(vertex);
  //     if (distance > closestDistance || distance > this._config.snapDistance) {
  //       continue;
  //     }
  //     vertexFound = true;
  //     closestVertex = vertex;
  //     closestDistance = intersects.point.distanceTo(vertex);
  //   }
  //   if (vertexFound) {
  //     return closestVertex;
  //   }
  //   return this.config.showOnlyVertex ? null : intersects.point;
  // }
  // private getVertices(intersects: THREE.Intersection) {
  //   const mesh = intersects.object as THREE.Mesh | THREE.InstancedMesh;
  //   if (!intersects.face || !mesh) return null;
  //   const geom = mesh.geometry;
  //   const instanceTransform = new THREE.Matrix4();
  //   const { instanceId } = intersects;
  //   const instanceFound = instanceId !== undefined;
  //   const isInstance = mesh instanceof THREE.InstancedMesh;
  //   if (isInstance && instanceFound) {
  //     mesh.getMatrixAt(instanceId, instanceTransform);
  //   }
  //   return [
  //     this.getVertex(intersects.face.a, geom),
  //     this.getVertex(intersects.face.b, geom),
  //     this.getVertex(intersects.face.c, geom),
  //   ].map((vertex) => {
  //     if (vertex) {
  //       if (isInstance && instanceFound) {
  //         vertex.applyMatrix4(instanceTransform);
  //       }
  //       vertex.applyMatrix4(mesh.matrixWorld);
  //     }
  //     return vertex;
  //   });
  // }
  // private getVertex(index: number, geom: THREE.BufferGeometry) {
  //   if (index === undefined) return null;
  //   const vertices = geom.attributes.position as THREE.BufferAttribute;
  //   return new THREE.Vector3(
  //     vertices.getX(index),
  //     vertices.getY(index),
  //     vertices.getZ(index),
  //   );
  // }
}
class ModelIdMapUtils {
  /**
   * Creates a new ModelIdMap from the union of multiple ModelIdMaps.
   * @param maps - An array of ModelIdMaps to join.
   * @returns A new ModelIdMap containing all model identifiers and localIds from all input maps.
   */
  static join(maps) {
    const result = {};
    for (const map of maps) {
      for (const modelID in map) {
        if (!result[modelID]) {
          result[modelID] = new Set(map[modelID]);
        } else {
          for (const id of map[modelID]) {
            result[modelID].add(id);
          }
        }
      }
    }
    return result;
  }
  /**
   * Creates a new ModelIdMap from the intersection of multiple ModelIdMaps.
   * @param maps - An array of ModelIdMaps.
   * @returns A new ModelIdMap containing only model identifiers and localIds present in all input maps.
   */
  static intersect(maps) {
    if (maps.length === 0) {
      return {};
    }
    let result = ModelIdMapUtils.clone(maps[0]);
    for (let i = 1; i < maps.length; i++) {
      const currentMap = maps[i];
      const newResult = {};
      for (const modelID in result) {
        if (currentMap[modelID]) {
          const intersection = /* @__PURE__ */ new Set();
          for (const id of result[modelID]) {
            if (currentMap[modelID].has(id)) {
              intersection.add(id);
            }
          }
          if (intersection.size > 0) {
            newResult[modelID] = intersection;
          }
        }
      }
      result = newResult;
    }
    return result;
  }
  /**
   * Creates a deep clone of a ModelIdMap.
   * @param source - The ModelIdMap to clone.
   * @returns A new ModelIdMap with the same model identifiers and localIds as the original.
   */
  static clone(source) {
    const clone = {};
    for (const modelID in source) {
      clone[modelID] = new Set(source[modelID]);
    }
    return clone;
  }
  /**
   * Remove all entries from one ModelIdMap to another.
   * @param target - The ModelIdMap to subtract from.
   * @param source - The ModelIdMap to subtract.
   */
  static remove(target, source, clone = false) {
    if (clone)
      target = ModelIdMapUtils.clone(target);
    for (const modelID in source) {
      if (target[modelID]) {
        for (const id of source[modelID]) {
          target[modelID].delete(id);
        }
        if (target[modelID].size === 0) {
          delete target[modelID];
        }
      }
    }
  }
  /**
   * Adds all entries from one ModelIdMap to another.
   * @param target - The ModelIdMap to add to.
   * @param source - The ModelIdMap to add from.
   */
  static add(target, source, clone = false) {
    if (clone)
      target = ModelIdMapUtils.clone(target);
    for (const modelID in source) {
      if (!target[modelID]) {
        target[modelID] = new Set(source[modelID]);
      } else {
        for (const id of source[modelID]) {
          target[modelID].add(id);
        }
      }
    }
  }
  static append(target, modelId, ...localIds) {
    let values = target[modelId];
    if (!values) {
      values = /* @__PURE__ */ new Set();
      target[modelId] = values;
    }
    for (const localId of localIds) {
      values.add(localId);
    }
  }
  /**
   * Checks if two ModelIdMaps are equal.
   * @param a - The first ModelIdMap.
   * @param b - The second ModelIdMap.
   * @returns True if the ModelIdMaps are equal, false otherwise.
   */
  static isEqual(a, b) {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const modelID of aKeys) {
      if (!b[modelID]) {
        return false;
      }
      if (a[modelID].size !== b[modelID].size) {
        return false;
      }
      for (const id of a[modelID]) {
        if (!b[modelID].has(id)) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Checks if a ModelIdMap is empty.
   * @param map - The ModelIdMap to check.
   * @returns True if the ModelIdMap is empty, false otherwise.
   */
  static isEmpty(map) {
    const totalItems = Object.values(map).reduce(
      (sum, set) => sum + set.size,
      0
    );
    return totalItems === 0;
  }
  /**
   * Converts a ModelIdMap into a plain JavaScript object with array values.
   * @param map - The ModelIdMap to convert.
   * @returns A plain JavaScript object where each key (model ID) maps to an array of local IDs.
   */
  static toRaw(map) {
    const result = {};
    for (const modelID in map) {
      result[modelID] = Array.from(map[modelID]);
    }
    return result;
  }
  /**
   * Creates a ModelIdMap from a plain JavaScript object with array values.
   * @param raw - A plain JavaScript object where each key (model ID) maps to an array of local IDs.
   * @returns A ModelIdMap.
   */
  static fromRaw(raw) {
    const result = {};
    for (const modelID in raw) {
      result[modelID] = new Set(raw[modelID]);
    }
    return result;
  }
}
class DataMap extends Map {
  /**
   * Constructs a new DataMap instance.
   *
   * @param iterable - An iterable object containing key-value pairs to populate the map.
   */
  constructor(iterable) {
    super(iterable);
    /**
     * An event triggered when a new item is set in the map.
     */
    __publicField(this, "onItemSet", new Event());
    /**
     * An event triggered when an existing item in the map is updated.
     */
    __publicField(this, "onItemUpdated", new Event());
    /**
     * An event triggered when an item is deleted from the map.
     */
    __publicField(this, "onItemDeleted", new Event());
    /**
     * An event triggered when the map is cleared.
     */
    __publicField(this, "onCleared", new Event());
    /**
     * A function that acts as a guard for adding items to the set.
     * It determines whether a given value should be allowed to be added to the set.
     *
     * @param key - The key of the entry to be checked against the guard.
     * @param value - The value of the entry to be checked against the guard.
     * @returns A boolean indicating whether the value should be allowed to be added to the set.
     *          By default, this function always returns true, allowing all values to be added.
     *          You can override this behavior by providing a custom implementation.
     */
    __publicField(this, "guard", () => true);
  }
  /**
   * Clears the map and triggers the onCleared event.
   */
  clear() {
    super.clear();
    this.onCleared.trigger();
  }
  /**
   * Sets the value for the specified key in the map.
   * If the item is new, then onItemSet is triggered.
   * If the item is already in the map, then onItemUpdated is triggered.
   *
   * @param key - The key of the item to set.
   * @param value - The value of the item to set.
   * @returns The DataMap instance.
   */
  set(key, value) {
    const triggerUpdate = this.has(key);
    const guard = this.guard ?? (() => true);
    const isValid = guard(key, value);
    if (!isValid)
      return this;
    const result = super.set(key, value);
    if (triggerUpdate) {
      if (!this.onItemUpdated) {
        this.onItemUpdated = new Event();
      }
      this.onItemUpdated.trigger({ key, value });
    } else {
      if (!this.onItemSet) {
        this.onItemSet = new Event();
      }
      this.onItemSet.trigger({ key, value });
    }
    return result;
  }
  /**
   * Sets the value in the map with a randomly generated uuidv4 key.
   * Only use this if your keys are strings
   *
   * @param value - The value of the item to set.
   * @returns The key used.
   */
  add(value) {
    const key = UUID.create();
    this.set(key, value);
    return key;
  }
  /**
   * Deletes the specified key from the map and triggers the onItemDeleted event if the key was found.
   *
   * @param key - The key of the item to delete.
   * @returns True if the key was found and deleted; otherwise, false.
   */
  delete(key) {
    const deleted = super.delete(key);
    if (deleted)
      this.onItemDeleted.trigger(key);
    return deleted;
  }
  /**
   * Clears the map and resets the events.
   */
  dispose() {
    this.clear();
    this.onItemSet.reset();
    this.onItemDeleted.reset();
    this.onCleared.reset();
  }
}
class ControlsUtils {
  static isEntry(item) {
    const types = /* @__PURE__ */ new Set([
      "Boolean",
      "Color",
      "Text",
      "Number",
      "Select",
      "Vector3",
      "TextSet",
      "None"
    ]);
    return types.has(item.type);
  }
  static copySchema(schema, copy = {}) {
    for (const name in schema) {
      const entry = schema[name];
      if (this.isEntry(entry)) {
        copy[name] = this.copyEntry(entry);
      } else {
        copy[name] = {};
        this.copySchema(entry, copy[name]);
      }
    }
    return copy;
  }
  static copyEntry(controlEntry) {
    if (controlEntry.type === "Boolean") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value
      };
    }
    if (controlEntry.type === "Color") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value.clone()
      };
    }
    if (controlEntry.type === "Text") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value
      };
    }
    if (controlEntry.type === "Number") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value,
        min: entry.min,
        max: entry.max,
        interpolable: entry.interpolable
      };
    }
    if (controlEntry.type === "Select") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value,
        multiple: entry.multiple,
        options: new Set(entry.options)
      };
    }
    if (controlEntry.type === "Vector3") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value.clone()
      };
    }
    if (controlEntry.type === "TextSet") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: new Set(entry.value)
      };
    }
    if (controlEntry.type === "None") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value
      };
    }
    throw new Error("Invalid entry!");
  }
}
class EventManager {
  constructor() {
    /**
     * The list of events managed by this instance.
     */
    __publicField(this, "list", /* @__PURE__ */ new Set());
  }
  /**
   * Adds events to this manager.
   * @param events the events to add.
   */
  add(events) {
    for (const event of events) {
      this.list.add(event);
    }
  }
  /**
   * Removes events from this manager.
   * @param events the events to remove.
   */
  remove(events) {
    for (const event of events) {
      this.list.delete(event);
    }
  }
  /**
   * Sets all the events managed by this instance as enabled or disabled.
   * @param active whether to turn on or off the events.
   */
  set(active) {
    for (const event of this.list) {
      event.enabled = active;
    }
  }
  /**
   * Resets all the events managed by this instance.
   */
  reset() {
    for (const event of this.list) {
      event.reset();
    }
  }
}
class Configurator {
  constructor(component, components, name, uuid) {
    __publicField(this, "_component");
    __publicField(this, "name");
    __publicField(this, "uuid");
    this._component = component;
    this.name = name;
    this.uuid = uuid ?? UUID.create();
    const configManager = components.get(ConfigManager);
    configManager.list.set(this.uuid, this);
  }
  get controls() {
    return ControlsUtils.copySchema(this._config);
  }
  set(data) {
    for (const name in data) {
      if (name in this) {
        const key = name;
        this[key] = data[name].value;
      }
    }
  }
  export(controls = this._config, exported = {}) {
    for (const id in controls) {
      const control = controls[id];
      const isControl = ControlsUtils.isEntry(control);
      if (isControl) {
        if (control.type === "Color") {
          const { r, g, b } = control.value;
          exported[id] = { ...control, value: { r, g, b } };
        } else if (control.type === "Vector3") {
          const { x, y, z } = control.value;
          exported[id] = { ...control, value: { x, y, z } };
        } else if (control.type === "TextSet") {
          const value = Array.from(control.value);
          exported[id] = { ...control, value };
        } else if (control.type === "Select") {
          const options = Array.from(control.options);
          exported[id] = { ...control, options };
        } else {
          exported[id] = { ...control };
        }
      } else {
        exported[id] = {};
        this.export(control, exported[id]);
      }
    }
    return exported;
  }
  import(exported, imported = {}, first = true) {
    for (const id in exported) {
      const control = exported[id];
      const isControl = ControlsUtils.isEntry(control);
      if (isControl) {
        if (control.type === "Color") {
          const { r, g, b } = control.value;
          imported[id] = { ...control, value: new THREE$1.Color(r, g, b) };
        } else if (control.type === "Vector3") {
          const { x, y, z } = control.value;
          imported[id] = { ...control, value: new THREE$1.Vector3(x, y, z) };
        } else if (control.type === "TextSet") {
          imported[id] = { ...control, value: new Set(control.value) };
        } else if (control.type === "Select") {
          imported[id] = { ...control, options: new Set(control.options) };
        } else {
          imported[id] = { ...control };
        }
      } else {
        imported[id] = {};
        this.import(control, imported[id], false);
      }
    }
    if (first) {
      this.set(imported);
    }
  }
}
const _ConfigManager = class _ConfigManager extends Component {
  constructor(components) {
    super(components);
    /**
     * The list of all configurations of this app.
     */
    __publicField(this, "list", new DataMap$1());
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    components.add(_ConfigManager.uuid, this);
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_ConfigManager, "uuid", "b8c764e0-6b24-4e77-9a32-35fa728ee5b4");
let ConfigManager = _ConfigManager;
class Mouse {
  constructor(dom) {
    __publicField(this, "_event");
    __publicField(this, "_position", new THREE$1.Vector2());
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "updateMouseInfo", (event) => {
      this._event = event;
    });
    this.dom = dom;
    this.setupEvents(true);
  }
  /**
   * The real position of the mouse or touch of the Three.js canvas.
   */
  get position() {
    this.updatePosition(false);
    return this._position.clone();
  }
  /**
   * The raw position of the mouse or touch of the Three.js canvas.
   */
  get rawPosition() {
    this.updatePosition(true);
    return this._position.clone();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false);
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  updatePosition(raw) {
    if (this._event) {
      const bounds = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(bounds, this._event, raw);
      this._position.y = this.getPositionY(bounds, this._event, raw);
    }
  }
  getPositionY(bound, event, raw) {
    const data = this.getDataObject(event);
    if (raw) {
      return data.clientY;
    }
    return -((data.clientY - bound.top) / (bound.bottom - bound.top)) * 2 + 1;
  }
  getPositionX(bound, event, raw) {
    const data = this.getDataObject(event);
    if (raw) {
      return data.clientX;
    }
    return (data.clientX - bound.left) / (bound.right - bound.left) * 2 - 1;
  }
  getDataObject(event) {
    return event instanceof MouseEvent ? event : event.touches[0];
  }
  setupEvents(active) {
    if (active) {
      this.dom.addEventListener("pointermove", this.updateMouseInfo);
      this.dom.addEventListener("touchstart", this.updateMouseInfo);
    } else {
      this.dom.removeEventListener("pointermove", this.updateMouseInfo);
      this.dom.removeEventListener("touchstart", this.updateMouseInfo);
    }
  }
}
const _FragmentsManager = class _FragmentsManager extends Component {
  constructor(components) {
    super(components);
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "onBeforeDispose", new Event());
    /**
     * Event triggered when fragments are loaded.
     */
    __publicField(this, "onFragmentsLoaded", new Event());
    __publicField(this, "baseCoordinationModel", "");
    __publicField(this, "baseCoordinationMatrix", new THREE$1.Matrix4());
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    __publicField(this, "_core");
    this.components.add(_FragmentsManager.uuid, this);
  }
  get initialized() {
    return !!this._core;
  }
  /**
   * Map containing all loaded fragment models.
   * The key is the group's unique identifier, and the value is the model itself.
   */
  get list() {
    return this.core.models.list;
  }
  get core() {
    if (!this._core) {
      throw new Error("FragmentsManager not initialized. Call init() first.");
    }
    return this._core;
  }
  get _hasCoordinationModel() {
    return this.baseCoordinationModel !== "";
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onBeforeDispose.trigger();
    if (this._core) {
      this.core.dispose();
      this._core = void 0;
    }
    this.baseCoordinationModel = "";
    this.onFragmentsLoaded.reset();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  init(workerURL) {
    this._core = new FragmentsModels(workerURL);
    this.core.onModelLoaded.add(async () => {
      if (this._hasCoordinationModel)
        return;
      const firstModel = [...this.list.values()][0];
      if (!firstModel)
        return;
      this.baseCoordinationModel = firstModel.modelId;
      this.baseCoordinationMatrix = await firstModel.getCoordinationMatrix();
    });
    this.list.onItemDeleted.add(() => {
      if (this.list.size > 0)
        return;
      this.baseCoordinationModel = "";
      this.baseCoordinationMatrix = new THREE$1.Matrix4();
    });
  }
  async raycast(data) {
    const results = [];
    for (const model of this.core.models.list.values()) {
      if (data.snappingClasses && data.snappingClasses.length > 0) {
        const snappingRaycast = await model.raycastWithSnapping(
          data
        );
        if (snappingRaycast && snappingRaycast.length > 0) {
          results.push(snappingRaycast[0]);
        } else {
          const simpleRaycast = await model.raycast(data);
          if (simpleRaycast)
            results.push(simpleRaycast);
        }
      } else {
        const simpleRaycast = await model.raycast(data);
        if (simpleRaycast)
          results.push(simpleRaycast);
      }
    }
    await Promise.all(results);
    if (results.length === 0)
      return void 0;
    let closestResult = results[0];
    let minDistance = closestResult.distance;
    for (let i = 1; i < results.length; i++) {
      if (results[i].distance < minDistance) {
        minDistance = results[i].distance;
        closestResult = results[i];
      }
    }
    return closestResult;
  }
  async getPositions(items) {
    const results = [];
    const getModelPositions = async (model, localIds) => {
      const positions = await model.getPositions(localIds);
      for (const position of positions) {
        results.push(position);
      }
    };
    const promises = [];
    for (const modelId in items) {
      const model = this.core.models.list.get(modelId);
      if (model) {
        promises.push(getModelPositions(model, Array.from(items[modelId])));
      }
    }
    await Promise.all(promises);
    return results;
  }
  async getBBoxes(items) {
    const results = [];
    const getBoxes = async (model, localIds) => {
      const boxes = await model.getBoxes(localIds);
      if (boxes) {
        for (const box of boxes) {
          results.push(box);
        }
      }
    };
    const promises = [];
    for (const itemID in items) {
      const model = this.core.models.list.get(itemID);
      if (model) {
        promises.push(getBoxes(model, Array.from(items[itemID])));
      }
    }
    await Promise.all(promises);
    return results;
  }
  async highlight(style, items) {
    await this.forEachModel(items, "highlight", style);
  }
  /**
   * Retrieves data for specified items from multiple models.
   *
   * @param items A map of model IDs to an array of local IDs, specifying which items to retrieve data for.
   * @param config Optional configuration for data retrieval.
   * @returns A record mapping model IDs to an array of item data.
   */
  async getData(items, config) {
    const result = {};
    for (const [modelId, localIds] of Object.entries(items)) {
      const model = this.list.get(modelId);
      if (!model)
        continue;
      if (localIds.size === 0) {
        result[modelId] = [];
        continue;
      }
      const data = await model.getItemsData([...localIds], config);
      result[modelId] = data;
    }
    return result;
  }
  async resetHighlight(items) {
    await this.forEachModel(items, "resetHighlight");
  }
  async forEachModel(items, method, ...args) {
    const _items = {};
    if (items) {
      for (const modelId in items) {
        const ids = items[modelId];
        _items[modelId] = Array.from(ids);
      }
    } else {
      for (const name of this.core.models.list.keys()) {
        _items[name] = void 0;
      }
    }
    const promises = [];
    for (const modelId in _items) {
      const model = this.core.models.list.get(modelId);
      if (model) {
        const ids = _items[modelId];
        const promise = model[method](ids, ...args);
        promises.push(promise);
      }
    }
    await Promise.all(promises);
  }
  /**
   * Converts a collection of IFC GUIDs to a fragmentIdMap.
   *
   * @param guids - An iterable collection of global IDs to be converted to a fragment ID map.
   *
   * @returns A fragment ID map, where the keys are fragment IDs and the values are the corresponding express IDs.
   */
  async guidsToModelIdMap(guids) {
    const modelIdMap = {};
    for (const [id, model] of this.list) {
      const localIds = (await model.getLocalIdsByGuids([...guids])).filter(
        (localId) => localId !== null
      );
      modelIdMap[id] = new Set(localIds);
    }
    return modelIdMap;
  }
  /**
   * Converts a fragment ID map to a collection of GUIDs.
   *
   * @param modelIdMap - A ModelIdMap to be converted to a collection of GUIDs.
   *
   * @returns An array of GUIDs.
   */
  async modelIdMapToGuids(modelIdMap) {
    const guids = [];
    for (const [modelId, localIds] of Object.entries(modelIdMap)) {
      const model = this.list.get(modelId);
      if (!model)
        continue;
      const modelGuids = (await model.getGuidsByLocalIds([...localIds])).filter(
        (guid) => guid !== null
      );
      guids.push(...modelGuids);
    }
    return guids;
  }
  // /**
  //  * Applies coordinate transformation to the provided models.
  //  * If no models are provided, all groups are used.
  //  * The first model in the list becomes the base model for coordinate transformation.
  //  * All other models are then transformed to match the base model's coordinate system.
  //  *
  //  * @param models - The models to apply coordinate transformation to.
  //  * If not provided, all models are used.
  //  */
  // coordinate(models = Array.from(this.groups.values())) {
  //   const isFirstModel = this.baseCoordinationModel.length === 0;
  //   if (isFirstModel) {
  //     const first = models.pop();
  //     if (!first) {
  //       return;
  //     }
  //     this.baseCoordinationModel = first.uuid;
  //     this.baseCoordinationMatrix = first.coordinationMatrix.clone();
  //   }
  //   if (!models.length) {
  //     return;
  //   }
  //   for (const model of models) {
  //     if (model.coordinationMatrix.equals(this.baseCoordinationMatrix)) {
  //       continue;
  //     }
  //     model.position.set(0, 0, 0);
  //     model.rotation.set(0, 0, 0);
  //     model.scale.set(1, 1, 1);
  //     model.updateMatrix();
  //     this.applyBaseCoordinateSystem(model, model.coordinationMatrix);
  //   }
  // }
  /**
   * Applies the base coordinate system to the provided object.
   *
   * This function takes an object and its original coordinate system as input.
   * It then inverts the original coordinate system and applies the base coordinate system
   * to the object. This ensures that the object's position, rotation, and scale are
   * transformed to match the base coordinate system (which is taken from the first model loaded).
   *
   * @param object - The object to which the base coordinate system will be applied.
   * This should be an instance of THREE.Object3D.
   *
   * @param originalCoordinateSystem - The original coordinate system of the object.
   * This should be a THREE.Matrix4 representing the object's transformation matrix.
   */
  applyBaseCoordinateSystem(object, originalCoordinateSystem) {
    const transformMatrix = new THREE$1.Matrix4();
    if (originalCoordinateSystem) {
      transformMatrix.copy(originalCoordinateSystem.clone()).invert();
    }
    transformMatrix.multiply(this.baseCoordinationMatrix);
    object.applyMatrix4(transformMatrix);
    return transformMatrix;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_FragmentsManager, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
let FragmentsManager = _FragmentsManager;
class IfcFragmentSettings {
  constructor() {
    /** Path of the WASM for [web-ifc](https://github.com/ThatOpen/engine_web-ifc). */
    __publicField(this, "wasm", {
      path: "",
      absolute: false,
      logLevel: WEBIFC.LogLevel.LOG_LEVEL_OFF
    });
    /** Loader settings for [web-ifc](https://github.com/ThatOpen/engine_web-ifc). */
    __publicField(this, "webIfc", {
      COORDINATE_TO_ORIGIN: true
      // OPTIMIZE_PROFILES: true,
    });
    /**
     * Whether to automatically set the path to the WASM file for [web-ifc](https://github.com/ThatOpen/engine_web-ifc).
     * If set to true, the path will be set to the default path of the WASM file.
     * If set to false, the path must be provided manually in the `wasm.path` property.
     * Default value is true.
     */
    __publicField(this, "autoSetWasm", true);
    /**
     * Custom function to handle the file location for [web-ifc](https://github.com/ThatOpen/engine_web-ifc).
     * This function will be called when [web-ifc](https://github.com/ThatOpen/engine_web-ifc) needs to locate a file.
     * If set to null, the default file location handler will be used.
     *
     * @param url - The URL of the file to locate.
     * @returns The absolute path of the file.
     */
    __publicField(this, "customLocateFileHandler", null);
  }
}
const _IfcLoader = class _IfcLoader extends Component {
  constructor(components) {
    super(components);
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /**
     * An event triggered when the IFC file starts loading.
     */
    __publicField(this, "onIfcStartedLoading", new Event());
    /**
     * An event triggered when the IFC importer is initialized.
     */
    __publicField(this, "onIfcImporterInitialized", new Event());
    /**
     * An event triggered when the setup process is completed.
     */
    __publicField(this, "onSetup", new Event());
    /**
     * The settings for the IfcLoader.
     * It includes options for excluding categories, setting WASM paths, and more.
     */
    __publicField(this, "settings", new IfcFragmentSettings());
    /**
     * The instance of the Web-IFC library used for handling IFC data.
     */
    __publicField(this, "webIfc", new WEBIFC.IfcAPI());
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    this.components.add(_IfcLoader.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.webIfc = null;
    this.onDisposed.trigger(_IfcLoader.uuid);
    this.onDisposed.reset();
  }
  /**
   * Sets up the IfcLoader component with the provided configuration.
   *
   * @param config - Optional configuration settings for the IfcLoader.
   * If not provided, the existing settings will be used.
   *
   * @returns A Promise that resolves when the setup process is completed.
   *
   * @remarks
   * If the `autoSetWasm` option is enabled in the configuration,
   * the method will automatically set the WASM paths for the Web-IFC library.
   *
   * @example
   * ```typescript
   * const ifcLoader = new IfcLoader(components);
   * await ifcLoader.setup({ autoSetWasm: true });
   * ```
   */
  async setup(config) {
    this.settings = { ...this.settings, ...config };
    if (this.settings.autoSetWasm) {
      await this.autoSetWasm();
    }
    this.onSetup.trigger();
  }
  /**
   * Loads an IFC file and processes it for 3D visualization.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @param coordinate - Boolean indicating whether to coordinate the loaded IFC data. Default is true.
   * @param name - Name for the fragments model.
   * @param config - Optional extra data for loading the IFC.
   *
   * @returns A Promise that resolves to the FragmentsModel containing the loaded and processed IFC data.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * const model = await ifcLoader.load(ifcData);
   * ```
   */
  async load(data, coordinate, name, config) {
    const fragments = this.components.get(FragmentsManager);
    if (!fragments.initialized) {
      throw new Error("You need to initialize fragments first.");
    }
    if (this.settings.autoSetWasm) {
      await this.autoSetWasm();
    }
    fragments.core.settings.autoCoordinate = coordinate;
    const serializer = new FRAGS.IfcImporter();
    serializer.wasm.path = this.settings.wasm.path;
    serializer.wasm.absolute = this.settings.wasm.absolute;
    serializer.webIfcSettings = this.settings.webIfc;
    this.onIfcImporterInitialized.trigger(serializer);
    if (config == null ? void 0 : config.instanceCallback)
      config.instanceCallback(serializer);
    const bytes = await serializer.process({
      ...config == null ? void 0 : config.processData,
      bytes: data
    });
    const model = await fragments.core.load(bytes, {
      modelId: name,
      userData: config == null ? void 0 : config.userData
    });
    return model;
  }
  /**
   * Reads an IFC file and initializes the Web-IFC library.
   *
   * @param data - The Uint8Array containing the IFC file data.
   *
   * @returns A Promise that resolves when the IFC file is opened and initialized.
   *
   * @remarks
   * This method sets the WASM path and initializes the Web-IFC library based on the provided settings.
   * It also opens the IFC model using the provided data and settings.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * await ifcLoader.readIfcFile(ifcData);
   * ```
   */
  async readIfcFile(data) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init(this.settings.customLocateFileHandler || void 0);
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    return this.webIfc.OpenModel(data, this.settings.webIfc);
  }
  /**
   * Cleans up the IfcLoader component by resetting the Web-IFC library,
   * clearing the visited fragments and fragment instances maps, and creating a new instance of the Web-IFC library.
   *
   * @remarks
   * This method is called automatically after using the .load() method, so usually you don't need to use it manually.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * ifcLoader.cleanUp();
   * ```
   */
  cleanUp() {
    try {
      this.webIfc.Dispose();
    } catch (e) {
      console.log("Web-ifc wasn't disposed.");
    }
    this.webIfc = null;
    this.webIfc = new WEBIFC.IfcAPI();
  }
  async autoSetWasm() {
    const componentsPackage = await fetch(
      `https://unpkg.com/@thatopen/components@${Components.release}/package.json`
    );
    if (!componentsPackage.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const componentsPackageJSON = await componentsPackage.json();
    if (!("web-ifc" in componentsPackageJSON.peerDependencies)) {
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    } else {
      const webIfcVer = componentsPackageJSON.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${webIfcVer}/`;
      this.settings.wasm.absolute = true;
    }
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_IfcLoader, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
let IfcLoader = _IfcLoader;
const _Hider = class _Hider extends Component {
  constructor(components) {
    super(components);
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    this.components.add(_Hider.uuid, this);
  }
  /**
   * Sets the visibility of fragment items within the 3D scene.
   * If no `modelIdMap` parameter is provided, all fragments will be set to the specified visibility.
   * If it is provided, only the specified fragment items will be affected.
   *
   * @param visible - The visibility state to set for the items.
   * @param modelIdMap - An optional map of modelIds and their corresponding itemIds to be affected.
   * If not provided, all fragment items will be affected.
   */
  async set(visible, modelIdMap) {
    const fragments = this.components.get(FragmentsManager);
    const promises = [];
    if (modelIdMap) {
      for (const [modelId, localIds] of Object.entries(modelIdMap)) {
        const model = fragments.list.get(modelId);
        if (!model)
          continue;
        promises.push(model.setVisible([...localIds], visible));
      }
    } else {
      for (const model of fragments.list.values()) {
        promises.push(model.setVisible(void 0, visible));
      }
    }
    await Promise.all(promises);
    await fragments.core.update(true);
  }
  /**
   * Isolates fragments within the 3D scene by hiding all other fragments and showing only the specified ones.
   * It calls the `set` method twice: first to hide all fragments, and then to show only the specified ones.
   *
   * @param modelIdMap - A map of model IDs and their corresponding itemIds to be isolated.
   */
  async isolate(modelIdMap) {
    await Promise.all([
      this.set(false),
      // Hides all fragments
      this.set(true, modelIdMap)
      // Shows only the specified fragments
    ]);
  }
  /**
   * Toggles the visibility of specified items in the fragments.
   *
   * @param modelIdMap - An object where the keys are model IDs and the values are arrays of local IDs representing the fragments to be toggled.
   * @returns A promise that resolves when all visibility toggles and the core update are complete.
   */
  async toggle(modelIdMap) {
    const promises = [];
    const fragments = this.components.get(FragmentsManager);
    for (const [modelId, localIds] of Object.entries(modelIdMap)) {
      const model = fragments.list.get(modelId);
      if (!model)
        continue;
      promises.push(model.toggleVisible([...localIds]));
    }
    await Promise.all(promises);
    await fragments.core.update(true);
  }
  /**
   * Asynchronously retrieves a map of model IDs to their corresponding item IDs based on visibility state.
   *
   * @param state - The visibility state to filter items by.
   * @param modelIds - Optional array of model IDs to filter the items. If not provided, all models will be considered.
   * @returns A promise that resolves to a ModelIdMap record where the keys are model IDs and the values are arrays of item IDs that match the visibility state.
   */
  async getVisibilityMap(state, modelIds) {
    const models = [];
    const promises = [];
    const fragments = this.components.get(FragmentsManager);
    if (modelIds) {
      for (const modelId of modelIds) {
        const model = fragments.list.get(modelId);
        if (!model)
          continue;
        models.push(model.modelId);
        promises.push(model.getItemsByVisibility(state));
      }
    } else {
      for (const model of fragments.list.values()) {
        models.push(model.modelId);
        promises.push(model.getItemsByVisibility(state));
      }
    }
    const localIds = await Promise.all(promises);
    const modelIdMap = {};
    for (const [index, modelId] of models.entries()) {
      modelIdMap[modelId] = localIds[index];
    }
    return modelIdMap;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_Hider, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
let Hider = _Hider;
const _BoundingBoxer = class _BoundingBoxer extends Component {
  constructor(components) {
    super(components);
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /**
     * A readonly dataset containing instances of THREE.Box3.
     */
    __publicField(this, "list", new FRAGS.DataSet());
    this.components.add(_BoundingBoxer.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose(full = true) {
    this.list.clear();
    this.onDisposed.trigger(_BoundingBoxer.uuid);
    if (full) {
      this.onDisposed.reset();
      this.list.eventsEnabled = false;
      this.list.dispose();
    }
  }
  /**
   * Combines all bounding boxes in the `list` property into a single bounding box.
   *
   * @returns A `THREE.Box3` instance representing the union of all bounding boxes in the `list`.
   */
  get() {
    const fullBox = new THREE$1.Box3();
    for (const box of this.list) {
      fullBox.union(box);
    }
    return fullBox;
  }
  /**
   * Asynchronously adds bounding boxes to the list by merging boxes from models
   * specified in the provided `ModelIdMap`.
   *
   * @param items - A map where keys are model IDs and values are arrays of local IDs
   *                representing specific parts of the models to include in the bounding box.
   */
  async addFromModelIdMap(items) {
    const fragments = this.components.get(FragmentsManager);
    const box = new THREE$1.Box3();
    for (const [modelId, localIds] of Object.entries(items)) {
      const model = fragments.list.get(modelId);
      if (!model)
        continue;
      const itemsBox = await model.getMergedBox([...localIds]);
      box.union(itemsBox);
    }
    this.list.add(box);
  }
  /**
   * Adds bounding boxes from models to the current list based on optional filtering criteria.
   *
   * @param modelIds - An optional array of regular expressions used to filter models by their IDs.
   *                   If provided, only models whose IDs match at least one of the regular expressions
   *                   will have their bounding boxes added to the list. If not, all models will be used.
   */
  addFromModels(modelIds) {
    const fragments = this.components.get(FragmentsManager);
    for (const [modelId, model] of fragments.list) {
      if (modelIds && !modelIds.some((regex) => regex.test(modelId)))
        continue;
      this.list.add(model.box);
    }
  }
  /**
   * Calculates and returns the center point of the bounding box derived from the provided model ID map.
   *
   * @param modelIdMap - A mapping of model IDs and localIds used to generate the bounding box.
   * @returns A `THREE.Vector3` object representing the center point of the bounding box.
   */
  async getCenter(modelIdMap) {
    this.list.clear();
    await this.addFromModelIdMap(modelIdMap);
    const box = this.get();
    this.list.clear();
    const center = new THREE$1.Vector3();
    box.getCenter(center);
    return center;
  }
  /**
   * Calculates the camera orientation and position based on the specified orientation
   * and an optional offset factor.
   *
   * @param orientation - Specifies the direction of the camera relative to the bounding box.
   * @param offsetFactor - A multiplier applied to the distance between the camera and the bounding box.
   *                       Defaults to `1`.
   * @returns An object containing:
   *          - `position`: A `THREE.Vector3` representing the calculated camera position.
   *          - `target`: A `THREE.Vector3` representing the center of the bounding box, which the camera should target.
   */
  async getCameraOrientation(orientation, offsetFactor = 1) {
    const fragments = this.components.get(FragmentsManager);
    this.list.clear();
    for (const [_, model] of fragments.list) {
      this.list.add(model.box);
    }
    const box = this.get();
    this.list.clear();
    const center = new THREE$1.Vector3();
    box.getCenter(center);
    const size = new THREE$1.Vector3();
    box.getSize(size);
    const cameraDistance = Math.max(size.x, size.y, size.z) * offsetFactor;
    const position = new THREE$1.Vector3();
    switch (orientation) {
      case "front":
        position.set(center.x, center.y, center.z + cameraDistance);
        break;
      case "back":
        position.set(center.x, center.y, center.z - cameraDistance);
        break;
      case "left":
        position.set(center.x - cameraDistance, center.y, center.z);
        break;
      case "right":
        position.set(center.x + cameraDistance, center.y, center.z);
        break;
      case "top":
        position.set(center.x, center.y + cameraDistance, center.z);
        break;
      case "bottom":
        position.set(center.x, center.y - cameraDistance, center.z);
        break;
      default:
        position.set(center.x, center.y, center.z + cameraDistance);
    }
    return { position, target: center };
  }
};
__publicField(_BoundingBoxer, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
let BoundingBoxer = _BoundingBoxer;
class FinderQuery {
  constructor(components, queries) {
    __publicField(this, "name", "Query");
    __publicField(this, "customData", {});
    __publicField(this, "_components");
    __publicField(this, "_queries", []);
    __publicField(this, "_aggregation", "exclusive");
    /**
     * The result of the query, a map of modelIds to localIds.
     * Null if the query has not been executed or has not been cached.
     */
    __publicField(this, "result", null);
    /**
     * Determines whether the query results should be cached.
     */
    __publicField(this, "cache", true);
    __publicField(this, "serializeQueryParameters", (params) => {
      var _a2;
      const result = {
        categories: (_a2 = params.categories) == null ? void 0 : _a2.map((regex) => regex.source),
        attributes: params.attributes ? {
          aggregation: params.attributes.aggregation,
          queries: params.attributes.queries.map(
            this.serializeAttributeQuery
          )
        } : void 0,
        relation: params.relation ? {
          name: params.relation.name,
          query: params.relation.query ? this.serializeQueryParameters(params.relation.query) : void 0
        } : void 0
      };
      return result;
    });
    __publicField(this, "deserializeQueryParameters", (params) => {
      var _a2;
      const result = {
        categories: (_a2 = params.categories) == null ? void 0 : _a2.map((value) => new RegExp(value)),
        attributes: params.attributes ? {
          aggregation: params.attributes.aggregation,
          queries: params.attributes.queries.map(
            this.deserializeAttributeQuery
          )
        } : void 0,
        relation: params.relation ? {
          name: params.relation.name,
          query: params.relation.query ? this.deserializeQueryParameters(params.relation.query) : void 0
        } : void 0
      };
      return result;
    });
    this._components = components;
    this.queries = queries;
  }
  /**
   * The query parameters used to find items.
   */
  set queries(value) {
    this._queries = value;
    this.clearCache();
  }
  get queries() {
    return this._queries;
  }
  /**
   * Sets the aggregation value (AND/OR) for the query and resets the cache if the new value differs.
   */
  set aggregation(value) {
    if (value !== this._aggregation)
      this.clearCache();
    this._aggregation = value;
  }
  get aggregation() {
    return this._aggregation;
  }
  /**
   * Executes the finder query to retrieve items based on the configured query and optional model IDs.
   *
   * @param config - Optional configuration object.
   * @param config.modelIds - Optional array of model IDs to filter the search.
   * @param config.force - Optional boolean to force a new search, bypassing the cache. Defaults to `false`.
   * @returns A promise that resolves to a `ModelIdMap` containing the search results.
   */
  async test(config) {
    const { modelIds, force } = { force: false, ...config };
    if (this.result && !force)
      return this.result;
    const finder = this._components.get(ItemsFinder);
    const result = await finder.getItems(this.queries, {
      modelIds,
      aggregation: this.aggregation
    });
    if (this.cache)
      this.result = result;
    return result;
  }
  /**
   * Clears the cached result of the query, forcing a re-evaluation on the next access.
   */
  clearCache() {
    this.result = null;
  }
  serializeAttributeQuery(query) {
    let value;
    if (Array.isArray(query.value)) {
      value = query.value.map((regex) => regex.source);
    } else if (query.value instanceof RegExp) {
      value = query.value.source;
    } else {
      value = query.value;
    }
    const result = {
      name: query.name.source,
      value,
      type: query.type instanceof RegExp ? query.type.source : query.type,
      negate: query.negate,
      itemIds: query.itemIds
    };
    return result;
  }
  /**
   * Serializes the finder query into a JSON-compatible format.
   * Converts regular expressions to strings.
   *
   * @returns A `SerializedFinderQuery` object representing the serialized query.
   */
  toJSON() {
    const manager = this._components.get(ItemsFinder);
    const guid = manager.list.getKey(this) ?? UUID.create();
    const result = {
      guid,
      name: this.name,
      customData: this.customData,
      queries: this.queries.map(this.serializeQueryParameters),
      aggregation: this.aggregation,
      cache: this.cache
    };
    return result;
  }
  deserializeAttributeQuery(query) {
    let value;
    if (Array.isArray(query.value)) {
      value = query.value.map((val2) => new RegExp(val2));
    } else if (typeof query.value === "string") {
      value = new RegExp(query.value);
    } else {
      value = query.value;
    }
    const result = {
      name: new RegExp(query.name),
      value,
      type: query.type ? new RegExp(query.type) : void 0,
      negate: query.negate,
      itemIds: query.itemIds
    };
    return result;
  }
  /**
   * Deserializes a JSON object into a `FinderQuery` instance.
   *
   * @param data - A `SerializedFinderQuery` object representing the serialized query.
   * @returns A `FinderQuery` instance.
   */
  fromJSON(data) {
    this.name = data.name;
    this.customData = data.customData;
    this.aggregation = data.aggregation;
    this.cache = data.cache;
    this.queries = data.queries.map(this.deserializeQueryParameters);
    return this;
  }
}
const _ItemsFinder = class _ItemsFinder extends Component {
  constructor(components) {
    super(components);
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    /**
     * A map of FinderQuery objects, indexed by a string key.
     */
    __publicField(this, "list", new FRAGS.DataMap());
    components.add(_ItemsFinder.uuid, this);
  }
  // private clearCache() {
  //   for (const [, finderQuery] of this.list) {
  //     finderQuery.clearCache();
  //   }
  // }
  /**
   * Retrieves items from specified models based on a query.
   *
   * @param queries - The query parameters to filter items.
   * @param modelIds - Optional array of model IDs to include in the search. If not provided, all models are searched.
   * @returns A map of model IDs to sets of item IDs that match the query.
   */
  async getItems(queries, config) {
    let modelsToCheck;
    if (config) {
      const { modelIds, items } = config;
      if (items) {
        const itemsModels = Object.keys(items);
        if (itemsModels.length > 0)
          modelsToCheck = itemsModels.map((entry) => new RegExp(`^${entry}$`));
      } else if (modelIds) {
        modelsToCheck = modelIds;
      }
    }
    const aggregation = (config == null ? void 0 : config.aggregation) ?? "exclusive";
    const fragments = this.components.get(FragmentsManager);
    const results = await Promise.all(
      queries.map(async (query) => {
        const result = {};
        await Promise.all(
          Array.from(fragments.list).map(async ([id, model]) => {
            var _a2;
            if (modelsToCheck && !modelsToCheck.some((regex) => regex.test(id)))
              return;
            const localIds = (_a2 = config == null ? void 0 : config.items) == null ? void 0 : _a2[id];
            const items = await model.getItemsByQuery(query, { localIds: localIds ? [...localIds] : void 0 });
            result[id] = new Set(items);
          })
        );
        return result;
      })
    );
    const finalResult = aggregation === "inclusive" ? ModelIdMapUtils.join(results) : ModelIdMapUtils.intersect(results);
    return finalResult;
  }
  /**
   * Creates a new FinderQuery instance and adds it to the list of queries.
   *
   * @param name - The name of the query.
   * @param queries - The queries to use.
   * @returns The newly created FinderQuery instance.
   */
  create(name, queries) {
    const instance = new FinderQuery(this.components, queries);
    this.list.set(name, instance);
    return instance;
  }
  /**
   * Adds queries based on categories from items that have geometry.
   *
   * @param modelIds - An optional array of model IDs to filter fragments. If not provided, all fragments are processed.
   * @returns An array with the categories used to create the queries
   */
  async addFromCategories(modelIds) {
    const result = /* @__PURE__ */ new Set();
    const fragments = this.components.get(FragmentsManager);
    for (const [id, model] of fragments.list) {
      if (modelIds && !modelIds.some((regex) => regex.test(id)))
        continue;
      const categories = (await model.getItemsWithGeometryCategories()).filter(
        (category) => category !== null
      );
      const set = new Set(categories);
      for (const category of set) {
        if (this.list.has(category))
          continue;
        this.create(category, [{ categories: [new RegExp(`^${category}$`)] }]);
        result.add(category);
      }
    }
    return [...result];
  }
  /**
   * Imports a list of `FinderQuery` instances from a `SerializationResult` containing serialized finder query data.
   *
   * @param result - The `SerializationResult` containing the serialized `SerializedFinderQuery` data.
   * @returns An array of `FinderQuery` instances created from the serialized data. Returns an empty array if the input data is null or undefined.
   */
  import(result) {
    const { data } = result;
    const instances = [];
    if (!data)
      return instances;
    for (const value of data) {
      const finderQuery = this.create(value.guid, []);
      finderQuery.fromJSON(value);
      instances.push(finderQuery);
    }
    return instances;
  }
  /**
   * Serializes the ItemsFinder's data into a format suitable for export.
   *
   * @returns An object containing an array of serialized finder queries.
   */
  export() {
    const data = [];
    for (const [name, finderQuery] of this.list.entries()) {
      const partial = finderQuery.toJSON();
      const result = {
        ...partial,
        name
      };
      data.push(result);
    }
    return { data };
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_ItemsFinder, "uuid", "0da7ad77-f734-42ca-942f-a074adfd1e3a");
let ItemsFinder = _ItemsFinder;
const _Classifier = class _Classifier extends Component {
  constructor(components) {
    super(components);
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /**
     * A nested data map that organizes classification groups.
     * The outer map uses strings as keys, and the inner map contains ClassificationGroupData, also keyed by strings.
     */
    __publicField(this, "list", new FRAGS.DataMap());
    /**
     * The default save function used by the classifier.
     * It extracts the 'value' property from the item's Name and returns it as a string.
     * If the 'value' property does not exist, it returns null.
     *
     * @param item - The item data to extract the value from.
     * @returns The extracted value as a string, or null if the value does not exist.
     */
    __publicField(this, "defaultSaveFunction", (item) => {
      if (!("value" in item.Name))
        return null;
      return item.Name.value;
    });
    __publicField(this, "onBeforeFragmentsDispose", async (data) => {
      const { key: modelId, value: model } = data;
      const localIds = await model.getLocalIds();
      const modelIdMap = { [modelId]: new Set(localIds) };
      this.removeItems(modelIdMap);
    });
    components.add(_Classifier.uuid, this);
    this.setupEvents();
    const fragmentsManager = components.get(FragmentsManager);
    fragmentsManager.list.onBeforeDelete.add(this.onBeforeFragmentsDispose);
  }
  setupEvents() {
    this.list.onBeforeDelete.add(({ value: groups }) => groups.dispose());
  }
  getClassificationGroups(classification) {
    let groups = this.list.get(classification);
    if (!groups) {
      groups = new FRAGS.DataMap();
      this.list.set(classification, groups);
    }
    return groups;
  }
  getModelItems(classification, group, modelId) {
    const { map } = this.getGroupData(classification, group);
    let items = map[modelId];
    if (!items) {
      items = /* @__PURE__ */ new Set();
      map[modelId] = items;
    }
    return items;
  }
  /**
   * Retrieves data associated with a specific group within a classification.
   * If the group data does not exist, it creates a new entry.
   *
   * @param classification - The classification string.
   * @param group - The group string within the classification.
   * @returns The data object associated with the group, containing a map and a `get` method.
   */
  getGroupData(classification, group) {
    const finder = this.components.get(ItemsFinder);
    const groups = this.getClassificationGroups(classification);
    let data = groups.get(group);
    if (!data) {
      data = {
        map: {},
        // TODO: Evaluate if this is the best option for this
        get() {
          return new Promise((resolve) => {
            if (!data) {
              resolve({});
              return;
            }
            if (data.query) {
              const { name, config } = data.query;
              const instance = finder.list.get(name);
              if (!instance) {
                throw new Error(
                  "Classifier: the query name associated with the group doesn't exist in the ItemsFinder component"
                );
              }
              instance.test(config).then((queryMap) => {
                if (!data) {
                  resolve({});
                  return;
                }
                const result = ModelIdMapUtils.join([queryMap, data.map]);
                resolve(result);
              });
            } else {
              resolve(data.map);
            }
          });
        }
      };
      groups.set(group, data);
    }
    return data;
  }
  /**
   * Aggregates items based on a classification and query, applying a provided function to each item.
   *
   * @param classification - The classification string used to categorize the items.
   * @param query - The query parameters used to find items.
   * @param config - Optional configuration for data and item processing.
   * @param config.data - Optional data configuration to pass to the item retrieval.
   * @param config.aggregationCallback - Optional function to apply to each item; defaults to `this.defaultSaveFunction` if not provided.
   *                       This function receives the item data and a register function to associate item local IDs with names.
   *                       If no function is provided, the default save function is used.
   *
   * @remarks
   * The `register` function within the `config.func` allows associating item local IDs with a given name under the specified classification.
   * It is used to keep track of which items belong to which classification.
   */
  async aggregateItems(classification, query, config) {
    const data = (config == null ? void 0 : config.data) ?? void 0;
    const callback = (config == null ? void 0 : config.aggregationCallback) ?? this.defaultSaveFunction;
    const fragments = this.components.get(FragmentsManager);
    const finder = this.components.get(ItemsFinder);
    const resultMap = await finder.getItems([query], {
      modelIds: config == null ? void 0 : config.modelIds
    });
    for (const [modelId, localIds] of Object.entries(resultMap)) {
      const model = fragments.list.get(modelId);
      if (!model)
        continue;
      const register = (name, ...localIds2) => {
        const items2 = this.getModelItems(classification, name, modelId);
        for (const localId of localIds2) {
          items2.add(localId);
        }
      };
      const items = await model.getItemsData([...localIds], data);
      for (const item of items) {
        callback(item, register);
      }
    }
  }
  /**
   * Adds items to a specific group within a classification.
   *
   * @param classification - The classification to which the group belongs.
   * @param group - The group to which the items will be added.
   * @param items - A map of model IDs to add to the group.
   */
  addGroupItems(classification, group, items) {
    const { map } = this.getGroupData(classification, group);
    ModelIdMapUtils.add(map, items);
  }
  /**
   * Sets the query for a specific group within a classification.
   *
   * @param classification - The classification to target.
   * @param group - The group within the classification to target.
   * @param query - The query to set for the group.
   */
  setGroupQuery(classification, group, query) {
    const groupData = this.getGroupData(classification, group);
    groupData.query = query;
  }
  /**
   * Asynchronously finds a set of ModelIdMaps based on the provided classification data.
   * @param data An object with classifications as keys and an array of groups as values.
   * @returns A promise that resolves to a ModelIdMap representing the intersection of all ModelIdMaps found.
   */
  async find(data) {
    const modelIdMaps = [];
    for (const [classification, groups] of Object.entries(data)) {
      const maps = [];
      const classificationData = this.list.get(classification);
      if (!classificationData)
        continue;
      for (const group of groups) {
        const groupData = classificationData.get(group);
        if (!groupData)
          continue;
        const map = await groupData.get();
        maps.push(map);
      }
      const result2 = ModelIdMapUtils.join(maps);
      modelIdMaps.push(result2);
    }
    const result = ModelIdMapUtils.intersect(modelIdMaps);
    return result;
  }
  /**
   * From the items passing the query, use the specified relation to create groupings
   * This method retrieves and processes related items, applying a custom aggregation callback to register
   * relations between items based on their attributes and local IDs.
   *
   * @param classification - The classification type used to filter items.
   * @param query - Query parameters for filtering items, defined by `FRAGS.ItemsQueryParams`.
   * @param relation - The type of relation to aggregate (e.g., "ContainedInStructure", "HasAssociations").
   * @param config - Optional configuration for the aggregation process.
   * @returns A promise that resolves when the aggregation process is complete.
   * @remarks
   * - The `aggregationCallback` function processes each item and registers relations based on the item's
   *   attribute value and the local ID of its relations.
   * - Items without the specified attribute or relations are ignored during aggregation.
   */
  async aggregateItemRelations(classification, query, relation, config) {
    const attribute = (config == null ? void 0 : config.attribute) ?? "Name";
    const data = {
      relations: {
        [relation]: { attributes: true, relations: false }
      }
    };
    await this.aggregateItems(classification, query, {
      modelIds: config == null ? void 0 : config.modelIds,
      data,
      aggregationCallback: (item, register) => {
        if (!(item == null ? void 0 : item[attribute]))
          return;
        const attr = item[attribute];
        if (!("value" in attr))
          return;
        const relations = item[relation];
        if (!Array.isArray(relations))
          return;
        for (const relation2 of relations) {
          if (!("value" in relation2._localId))
            continue;
          register(attr.value, relation2._localId.value);
        }
      }
    });
  }
  /**
   * Asynchronously processes and adds classifications by IfcBuildingStorey.
   * @param config - Optional configuration for adding classifications.
   * @returns A promise that resolves once the storeys have been processed and added.
   */
  async byIfcBuildingStorey(config) {
    await this.aggregateItemRelations(
      (config == null ? void 0 : config.classificationName) ?? "Storeys",
      { categories: [/BUILDINGSTOREY/] },
      "ContainsElements",
      { modelIds: config == null ? void 0 : config.modelIds }
    );
  }
  /**
   * Asynchronously processes and adds classifications by category.
   * @param config - Optional configuration for adding classifications.
   * @returns A promise that resolves once the categories have been processed and added.
   */
  async byCategory(config) {
    const finder = this.components.get(ItemsFinder);
    const categories = await finder.addFromCategories(config == null ? void 0 : config.modelIds);
    for (const category of categories) {
      this.setGroupQuery((config == null ? void 0 : config.classificationName) ?? "Categories", category, {
        name: category
      });
    }
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list.clear();
    const fragmentsManager = this.components.get(FragmentsManager);
    fragmentsManager.list.onBeforeDelete.remove(this.onBeforeFragmentsDispose);
    this.onDisposed.trigger();
  }
  /**
   * Removes items from the classifier based on the provided model ID map and configuration.
   *
   * @param modelIdMap - A map containing model IDs to be removed.
   * @param config - Optional configuration for removing items.s.
   * @remarks If no configuration is provided, items will be removed from all classifications
   */
  removeItems(modelIdMap, config) {
    if (config && config.classificationName) {
      const groups = this.list.get(config.classificationName);
      if (!groups)
        return;
      if (config.groupName) {
        const groupData = groups.get(config.groupName);
        if (!groupData)
          return;
      }
      for (const [, data] of groups) {
        ModelIdMapUtils.remove(data.map, modelIdMap);
      }
      return;
    }
    for (const [, group] of this.list.entries()) {
      for (const [, data] of group) {
        ModelIdMapUtils.remove(data.map, modelIdMap);
      }
    }
  }
  /**
   * Asynchronously processes models based on the provided configuration and updates classification groups.
   *
   * @param config - Optional configuration for adding classifications. Contains the following properties.
   * @returns A promise that resolves when the processing is complete.
   */
  async byModel(config) {
    const fragments = this.components.get(FragmentsManager);
    const classification = (config == null ? void 0 : config.classificationName) ?? "Models";
    for (const [modelId, model] of fragments.list) {
      if (config && config.modelIds && !config.modelIds.some((regex) => regex.test(modelId))) {
        continue;
      }
      const localIds = await model.getItemsIdsWithGeometry();
      const modelIdMap = { [modelId]: new Set(localIds) };
      this.getGroupData(classification, modelId);
      this.addGroupItems(classification, modelId, modelIdMap);
    }
  }
  // /**
  //  * Exports the computed classification to persists them and import them back
  //  * later for faster loading.
  //  */
  // export() {
  //   const exported: ExportedClassification = {};
  //   for (const systemName in this.list) {
  //     exported[systemName] = {};
  //     const system = this.list[systemName];
  //     for (const groupName in system) {
  //       const group = system[groupName];
  //       exported[systemName][groupName] = {
  //         map: FRAGS.FragmentUtils.export(group.map),
  //         name: group.name,
  //         id: group.id,
  //       };
  //     }
  //   }
  //   return exported;
  // }
  // /**
  //  * Imports a classification previously exported with .export().
  //  * @param data the serialized classification to import.
  //  */
  // import(data: ExportedClassification) {
  //   for (const systemName in data) {
  //     if (!this.list[systemName]) {
  //       this.list[systemName] = {};
  //     }
  //     const system = data[systemName];
  //     for (const groupName in system) {
  //       const group = system[groupName];
  //       this.list[systemName][groupName] = {
  //         map: FRAGS.FragmentUtils.import(group.map),
  //         name: group.name,
  //         id: group.id,
  //       };
  //     }
  //   }
  //
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_Classifier, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
let Classifier = _Classifier;
class FastModelPicker {
  constructor(components, world) {
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    /** The components instance to which this FastModelPicker belongs. */
    __publicField(this, "components");
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /** The position of the mouse in the screen. */
    __publicField(this, "mouse");
    /**
     * A reference to the world instance to which this FastModelPicker belongs.
     * This is used to access the camera and scene.
     */
    __publicField(this, "world");
    /**
     * Whether debug mode is enabled. When enabled, shows the color-coded canvas.
     */
    __publicField(this, "debugMode", false);
    /**
     * Map from color (as RGB number) to model ID.
     * Color is encoded as: (r << 16) | (g << 8) | b
     */
    __publicField(this, "colorToModelId", /* @__PURE__ */ new Map());
    /**
     * Map from model ID to color.
     */
    __publicField(this, "modelIdToColor", /* @__PURE__ */ new Map());
    /**
     * Render target for the color-coded scene.
     */
    __publicField(this, "renderTarget");
    /**
     * Size of the render target (stored separately since getSize doesn't exist).
     */
    __publicField(this, "renderTargetSize", new THREE$1.Vector2());
    /**
     * Debug canvas element (shown when debugMode is true).
     */
    __publicField(this, "debugCanvas");
    /**
     * Debug container element.
     */
    __publicField(this, "debugContainer");
    /**
     * Material used for color-coding models.
     */
    __publicField(this, "colorMaterials", /* @__PURE__ */ new Map());
    /**
     * Original materials cache (to restore after picking).
     */
    __publicField(this, "originalMaterials", /* @__PURE__ */ new Map());
    __publicField(this, "originalLodColors", /* @__PURE__ */ new Map());
    /**
     * Whether colors need to be reassigned (when models change).
     */
    __publicField(this, "colorsNeedUpdate", true);
    const renderer = world.renderer;
    if (!renderer) {
      throw new Error("A renderer is needed for the FastModelPicker to work!");
    }
    this.world = world;
    this.mouse = new Mouse(renderer.three.domElement);
    this.components = components;
    this.setupRenderTarget();
    this.setupFragmentListeners();
  }
  /**
   * Sets up listeners for fragment model changes.
   */
  setupFragmentListeners() {
    const fragments = this.components.get(FragmentsManager);
    fragments.list.onItemSet.add(() => {
      this.colorsNeedUpdate = true;
    });
    fragments.list.onItemDeleted.add(() => {
      this.colorsNeedUpdate = true;
    });
  }
  /**
   * Sets up the render target for color-coded picking.
   */
  setupRenderTarget() {
    const renderer = this.world.renderer.three;
    const size = renderer.getSize(new THREE$1.Vector2());
    this.renderTargetSize.copy(size);
    this.renderTarget = new THREE$1.WebGLRenderTarget(size.x, size.y);
    this.renderTarget.texture.format = THREE$1.RGBAFormat;
    this.renderTarget.texture.type = THREE$1.UnsignedByteType;
    if (this.debugMode) {
      this.setupDebugCanvas();
    }
    this.world.renderer.onResize.add((size2) => {
      this.renderTargetSize.copy(size2);
      this.renderTarget.setSize(size2.x, size2.y);
      if (this.debugCanvas) {
        this.debugCanvas.width = size2.x;
        this.debugCanvas.height = size2.y;
      }
    });
  }
  /**
   * Sets up the debug canvas for visualization.
   */
  setupDebugCanvas() {
    if (this.debugCanvas)
      return;
    const size = this.world.renderer.three.getSize(new THREE$1.Vector2());
    this.debugContainer = document.createElement("div");
    this.debugContainer.style.position = "fixed";
    this.debugContainer.style.top = "10px";
    this.debugContainer.style.right = "10px";
    this.debugContainer.style.width = "300px";
    this.debugContainer.style.height = "300px";
    this.debugContainer.style.border = "2px solid #fff";
    this.debugContainer.style.backgroundColor = "#000";
    this.debugContainer.style.zIndex = "10000";
    this.debugContainer.style.pointerEvents = "none";
    this.debugCanvas = document.createElement("canvas");
    this.debugCanvas.width = size.x;
    this.debugCanvas.height = size.y;
    this.debugCanvas.style.width = "100%";
    this.debugCanvas.style.height = "100%";
    this.debugCanvas.style.imageRendering = "pixelated";
    this.debugContainer.appendChild(this.debugCanvas);
    document.body.appendChild(this.debugContainer);
  }
  /**
   * Generates a deterministic color for a model based on its ID.
   * This ensures the same model always gets the same color.
   */
  generateColorForModel(modelId) {
    let hash = 0;
    for (let i = 0; i < modelId.length; i++) {
      hash = (hash << 5) - hash + modelId.charCodeAt(i);
      hash &= hash;
    }
    let colorId = Math.abs(hash) % 16777215;
    if (colorId === 0) {
      colorId = 1;
    }
    const r = colorId >> 16 & 255 || 1;
    const g = colorId >> 8 & 255 || 1;
    const b = colorId & 255 || 1;
    return new THREE$1.Color(r / 255, g / 255, b / 255);
  }
  /**
   * Converts a color to a numeric ID.
   */
  colorToId(color) {
    const r = Math.round(color.r * 255);
    const g = Math.round(color.g * 255);
    const b = Math.round(color.b * 255);
    return r << 16 | g << 8 | b;
  }
  /**
   * Assigns unique colors to all fragment models.
   * Colors are deterministic based on model ID, so the same model always gets the same color.
   */
  assignColors() {
    const fragments = this.components.get(FragmentsManager);
    if (!fragments.initialized) {
      return;
    }
    if (!this.colorsNeedUpdate) {
      const currentModelIds = new Set(fragments.list.keys());
      const cachedModelIds = new Set(this.modelIdToColor.keys());
      if (currentModelIds.size !== cachedModelIds.size || [...currentModelIds].some((id) => !cachedModelIds.has(id))) {
        this.colorsNeedUpdate = true;
      }
    }
    if (!this.colorsNeedUpdate) {
      return;
    }
    this.colorToModelId.clear();
    this.modelIdToColor.clear();
    for (const material of this.colorMaterials.values()) {
      material.dispose();
    }
    this.colorMaterials.clear();
    for (const [modelId] of fragments.list) {
      const color = this.generateColorForModel(modelId);
      const colorId = this.colorToId(color);
      this.colorToModelId.set(colorId, modelId);
      this.modelIdToColor.set(modelId, color);
      const material = new THREE$1.MeshBasicMaterial({
        color,
        depthTest: true,
        depthWrite: true
      });
      this.colorMaterials.set(modelId, material);
    }
    this.colorsNeedUpdate = false;
  }
  /**
   * Applies color materials to fragment models.
   */
  applyColorMaterials() {
    const fragments = this.components.get(FragmentsManager);
    if (!fragments.initialized) {
      return;
    }
    for (const [modelId, model] of fragments.list) {
      const modelMaterial = this.colorMaterials.get(modelId);
      if (!modelMaterial)
        continue;
      model.object.traverse((child) => {
        if (child instanceof THREE$1.Mesh) {
          if ("isLODGeometry" in child.geometry) {
            const originalLodMaterial = child.material[0];
            const lodColor = originalLodMaterial.uniforms.lodColor;
            if (!this.originalLodColors.has(lodColor)) {
              this.originalLodColors.set(lodColor, lodColor.value);
            }
            lodColor.value = modelMaterial.color;
            return;
          }
          if (!this.originalMaterials.has(child)) {
            this.originalMaterials.set(child, child.material);
          }
          child.material = modelMaterial;
        }
      });
    }
  }
  /**
   * Restores original materials to fragment models.
   */
  restoreOriginalMaterials() {
    for (const [object, material] of this.originalMaterials) {
      object.material = material;
    }
    for (const [lodColor, color] of this.originalLodColors) {
      lodColor.value = color;
    }
    this.originalMaterials.clear();
  }
  /**
   * Renders the scene with color-coded models.
   */
  renderColorCoded() {
    if (!this.renderTarget || !this.world.renderer) {
      throw new Error("Render target not initialized!");
    }
    const renderer = this.world.renderer.three;
    const scene = this.world.scene.three;
    const camera = this.world.camera.three;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentAutoClear = renderer.autoClear;
    const currentClearColor = new THREE$1.Color();
    const currentClearAlpha = renderer.getClearAlpha();
    renderer.getClearColor(currentClearColor);
    this.applyColorMaterials();
    renderer.setRenderTarget(this.renderTarget);
    renderer.autoClear = true;
    renderer.setClearColor(0, 1);
    renderer.clear(true, true, false);
    renderer.render(scene, camera);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.autoClear = currentAutoClear;
    renderer.setClearColor(currentClearColor, currentClearAlpha);
    this.restoreOriginalMaterials();
    if (this.debugMode && this.debugCanvas) {
      this.updateDebugCanvas();
    }
  }
  /**
   * Updates the debug canvas with the color-coded render.
   */
  updateDebugCanvas() {
    if (!this.debugCanvas || !this.renderTarget || !this.world.renderer)
      return;
    const renderer = this.world.renderer.three;
    const size = this.renderTargetSize;
    const pixels = new Uint8Array(size.x * size.y * 4);
    renderer.readRenderTargetPixels(
      this.renderTarget,
      0,
      0,
      size.x,
      size.y,
      pixels
    );
    const ctx = this.debugCanvas.getContext("2d");
    if (!ctx)
      return;
    const imageData = ctx.createImageData(size.x, size.y);
    const rowSize = size.x * 4;
    for (let y = 0; y < size.y; y++) {
      const srcRow = y;
      const dstRow = size.y - 1 - y;
      const srcOffset = srcRow * rowSize;
      const dstOffset = dstRow * rowSize;
      imageData.data.set(
        pixels.subarray(srcOffset, srcOffset + rowSize),
        dstOffset
      );
    }
    ctx.putImageData(imageData, 0, 0);
  }
  /**
   * Gets the model ID at the given screen position.
   *
   * @param position - Optional screen position. If not provided, uses current mouse position.
   * @returns The model ID at the position, or null if no model is found.
   */
  async getModelAt(position) {
    if (!this.renderTarget || !this.world.renderer) {
      throw new Error("Render target not initialized!");
    }
    const fragments = this.components.get(FragmentsManager);
    if (!fragments.initialized || fragments.list.size === 0) {
      return null;
    }
    this.assignColors();
    this.renderColorCoded();
    const pos = position || this.mouse.position;
    const size = this.renderTargetSize;
    const x = Math.floor((pos.x + 1) * 0.5 * size.x);
    const y = Math.floor((pos.y + 1) * 0.5 * (size.y - 1));
    const clampedX = Math.max(0, Math.min(size.x - 1, x));
    const clampedY = Math.max(0, Math.min(size.y - 1, y));
    const renderer = this.world.renderer.three;
    const pixels = new Uint8Array(4);
    renderer.readRenderTargetPixels(
      this.renderTarget,
      clampedX,
      clampedY,
      1,
      1,
      pixels
    );
    const r = pixels[0];
    const g = pixels[1];
    const b = pixels[2];
    const colorId = r << 16 | g << 8 | b;
    const modelId = this.colorToModelId.get(colorId);
    return modelId || null;
  }
  /**
   * Enables or disables debug mode.
   * When enabled, shows a canvas with the color-coded render.
   */
  setDebugMode(enabled) {
    this.debugMode = enabled;
    if (enabled) {
      this.setupDebugCanvas();
    } else {
      this.removeDebugCanvas();
    }
  }
  /**
   * Removes the debug canvas.
   */
  removeDebugCanvas() {
    if (this.debugContainer) {
      this.debugContainer.remove();
      this.debugContainer = void 0;
      this.debugCanvas = void 0;
    }
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose();
    this.removeDebugCanvas();
    for (const material of this.colorMaterials.values()) {
      material.dispose();
    }
    this.colorMaterials.clear();
    if (this.renderTarget) {
      this.renderTarget.dispose();
    }
    this.colorToModelId.clear();
    this.modelIdToColor.clear();
    this.originalMaterials.clear();
    this.originalLodColors.clear();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
}
const _FastModelPickers = class _FastModelPickers extends Component {
  constructor(components) {
    super(components);
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    /**
     * A Map that stores FastModelPicker instances for each world.
     * The key is the world's UUID, and the value is the corresponding FastModelPicker instance.
     */
    __publicField(this, "list", /* @__PURE__ */ new Map());
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    components.add(_FastModelPickers.uuid, this);
  }
  /**
   * Retrieves a FastModelPicker instance for the given world.
   * If a FastModelPicker instance already exists for the world, it will be returned.
   * Otherwise, a new FastModelPicker instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a FastModelPicker instance.
   * @returns The FastModelPicker instance for the given world.
   */
  get(world) {
    if (this.list.has(world.uuid)) {
      return this.list.get(world.uuid);
    }
    const picker = new FastModelPicker(this.components, world);
    this.list.set(world.uuid, picker);
    world.onDisposed.add(() => {
      this.delete(world);
    });
    return picker;
  }
  /**
   * Deletes the FastModelPicker instance associated with the given world.
   * If a FastModelPicker instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the FastModelPicker instance.
   * @returns {void}
   */
  delete(world) {
    const picker = this.list.get(world.uuid);
    if (picker) {
      picker.dispose();
    }
    this.list.delete(world.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, picker] of this.list) {
      picker.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_FastModelPickers, "uuid", "4a82430c-7ff2-49ea-9401-60807502dad6");
let FastModelPickers = _FastModelPickers;
class SimpleRaycaster {
  constructor(components, world) {
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    /** The components instance to which this Raycaster belongs. */
    __publicField(this, "components");
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /** The position of the mouse in the screen. */
    __publicField(this, "mouse");
    /**
     * A reference to the Three.js Raycaster instance.
     * This is used for raycasting operations.
     */
    __publicField(this, "three", new THREE$1.Raycaster());
    /**
     * A reference to the world instance to which this Raycaster belongs.
     * This is used to access the camera and meshes.
     */
    __publicField(this, "world");
    /**
     * Whether to use fast model picking to optimize raycasting.
     * When enabled, the raycaster will first use FastModelPicker to identify
     * which model is under the mouse, then only raycast that specific model.
     * This can significantly improve performance when there are many models.
     */
    __publicField(this, "useFastModelPicking", false);
    const renderer = world.renderer;
    if (!renderer) {
      throw new Error("A renderer is needed for the raycaster to work!");
    }
    this.world = world;
    this.mouse = new Mouse(renderer.three.domElement);
    this.components = components;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  castRayToObjects(items = Array.from(this.world.meshes), position = this.mouse.position) {
    if (!this.world) {
      throw new Error("A world is needed to cast rays!");
    }
    const camera = this.world.camera.three;
    this.three.setFromCamera(position, camera);
    return this.intersect(items);
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   * @param position - the screen position to use for raycasting. If not provided,
   * the last pointer (mouse/touch) position will be used.
   */
  async castRay(data) {
    const snappingClasses = data == null ? void 0 : data.snappingClasses;
    const items = (data == null ? void 0 : data.items) ?? Array.from(this.world.meshes);
    const position = (data == null ? void 0 : data.position) ?? this.mouse.position;
    if (!this.world) {
      throw new Error("A world is needed to cast rays!");
    }
    const camera = this.world.camera.three;
    const fragments = this.components.get(FragmentsManager);
    const dom = this.world.renderer.three.domElement;
    const mouse = this.mouse.rawPosition;
    let fragResult = null;
    if (fragments.initialized) {
      if (this.useFastModelPicking) {
        const fastPickers = this.components.get(FastModelPickers);
        const fastPicker = fastPickers.get(this.world);
        const modelId = await fastPicker.getModelAt(position);
        if (modelId) {
          const model = fragments.list.get(modelId);
          if (model) {
            if (snappingClasses && snappingClasses.length > 0) {
              const snappingRaycast = await model.raycastWithSnapping({
                camera,
                dom,
                mouse,
                snappingClasses
              });
              if (snappingRaycast && snappingRaycast.length > 0) {
                fragResult = snappingRaycast[0];
              } else {
                fragResult = await model.raycast({
                  camera,
                  dom,
                  mouse
                });
              }
            } else {
              fragResult = await model.raycast({
                camera,
                dom,
                mouse
              });
            }
          }
        }
      } else {
        fragResult = await fragments.raycast({
          camera,
          dom,
          mouse,
          snappingClasses
        });
      }
      if (items.length === 0) {
        return fragResult;
      }
    }
    this.three.setFromCamera(position, camera);
    const itemsResult = this.intersect(items);
    if (!fragResult) {
      return itemsResult;
    }
    if (!itemsResult) {
      return fragResult;
    }
    if (itemsResult.distance < fragResult.distance) {
      return itemsResult;
    }
    return fragResult;
  }
  /**
   * Casts a ray from a given origin in a given direction and returns the first item found.
   * This method also takes into account the clipping planes used by the renderer.
   *
   * @param origin - The origin of the ray.
   * @param direction - The direction of the ray.
   * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
   * @returns The first intersection found or `null` if no intersection was found.
   */
  castRayFromVector(origin, direction, items = Array.from(this.world.meshes)) {
    this.three.set(origin, direction);
    return this.intersect(items);
  }
  intersect(items = Array.from(this.world.meshes)) {
    const result = this.three.intersectObjects(items);
    const filtered = this.filterClippingPlanes(result);
    return filtered.length > 0 ? filtered[0] : null;
  }
  filterClippingPlanes(objs) {
    if (!this.world.renderer) {
      throw new Error("Renderer not found!");
    }
    const renderer = this.world.renderer.three;
    if (!renderer.clippingPlanes) {
      return objs;
    }
    const planes = renderer.clippingPlanes;
    if (objs.length <= 0 || !planes || (planes == null ? void 0 : planes.length) <= 0)
      return objs;
    return objs.filter(
      (elem) => planes.every((elem2) => elem2.distanceToPoint(elem.point) > 0)
    );
  }
}
const _Raycasters = class _Raycasters extends Component {
  constructor(components) {
    super(components);
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    /**
     * A Map that stores raycasters for each world.
     * The key is the world's UUID, and the value is the corresponding SimpleRaycaster instance.
     */
    __publicField(this, "list", /* @__PURE__ */ new Map());
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    components.add(_Raycasters.uuid, this);
  }
  /**
   * Retrieves a SimpleRaycaster instance for the given world.
   * If a SimpleRaycaster instance already exists for the world, it will be returned.
   * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
   * @returns The SimpleRaycaster instance for the given world.
   */
  get(world) {
    if (this.list.has(world.uuid)) {
      return this.list.get(world.uuid);
    }
    const raycaster = new SimpleRaycaster(this.components, world);
    this.list.set(world.uuid, raycaster);
    world.onDisposed.add(() => {
      this.delete(world);
    });
    return raycaster;
  }
  /**
   * Deletes the SimpleRaycaster instance associated with the given world.
   * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the SimpleRaycaster instance.
   * @returns {void}
   */
  delete(world) {
    const raycaster = this.list.get(world.uuid);
    if (raycaster) {
      raycaster.dispose();
    }
    this.list.delete(world.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, raycaster] of this.list) {
      raycaster.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_Raycasters, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
let Raycasters = _Raycasters;
class SimpleWorld extends Base {
  constructor() {
    super(...arguments);
    __publicField(this, "onCameraChanged", new Event());
    /**
     * All the loaded [meshes](https://threejs.org/docs/#api/en/objects/Mesh). These meshes will be taken into account in operations like raycasting.
     */
    __publicField(this, "meshes", /* @__PURE__ */ new Set());
    /** {@link Updateable.onAfterUpdate} */
    __publicField(this, "onAfterUpdate", new Event());
    /** {@link Updateable.onBeforeUpdate} */
    __publicField(this, "onBeforeUpdate", new Event());
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /**
     * Indicates whether the world is currently being disposed. This is useful to prevent trying to access world's elements when it's being disposed, which could cause errors when you dispose a world.
     */
    __publicField(this, "isDisposing", false);
    /**
     * Indicates whether the world is currently enabled.
     * When disabled, the world will not be updated.
     */
    __publicField(this, "enabled", true);
    __publicField(this, "_dynamicAnchor", false);
    /**
     * A unique identifier for the world. Is not meant to be changed at any moment.
     */
    __publicField(this, "uuid", UUID.create());
    /**
     * An optional name for the world.
     */
    __publicField(this, "name");
    __publicField(this, "_scene");
    __publicField(this, "_camera");
    __publicField(this, "_renderer", null);
    __publicField(this, "onPointerDown", async (event) => {
      if (!this.camera.hasCameraControls()) {
        throw new Error(
          "World: can't set dynamic anchor if the camera doesn't have controls."
        );
      }
      const caster = this.components.get(Raycasters).get(this);
      const result = await caster.castRay();
      if (result && result.point && event.button === 0) {
        this.camera.controls.setOrbitPoint(
          result.point.x,
          result.point.y,
          result.point.z
        );
      }
    });
    __publicField(this, "_defaultCamera");
  }
  set dynamicAnchor(value) {
    var _a2;
    const container = (_a2 = this.renderer) == null ? void 0 : _a2.three.domElement.parentElement;
    if (!container) {
      throw new Error(
        "World: the renderer must have a parentElement to set dynamic anchoring."
      );
    }
    if (value) {
      if (this.camera.controls)
        this.camera.controls.minDistance = 0.01;
      container.addEventListener("pointerdown", this.onPointerDown);
    } else {
      container.removeEventListener("pointerdown", this.onPointerDown);
    }
  }
  get dynamicAnchor() {
    return this._dynamicAnchor;
  }
  get defaultCamera() {
    if (!this._defaultCamera) {
      throw new Error("World: there is no default camera defined.");
    }
    return this._defaultCamera;
  }
  set defaultCamera(value) {
    this._defaultCamera = value;
  }
  /**
   * Getter for the scene. If no scene is initialized, it throws an error.
   * @returns The current scene.
   */
  get scene() {
    if (!this._scene) {
      throw new Error("No scene initialized!");
    }
    return this._scene;
  }
  /**
   * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
   * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
   * @param scene - The new scene to be set.
   */
  set scene(scene) {
    this._scene = scene;
    scene.worlds.set(this.uuid, this);
    scene.currentWorld = this;
    scene.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the camera. If no camera is initialized, it throws an error.
   * @returns The current camera.
   */
  get camera() {
    if (!this._camera) {
      throw new Error("No camera initialized!");
    }
    return this._camera;
  }
  /**
   * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
   * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
   * @param camera - The new camera to be set.
   */
  set camera(camera) {
    if (!this._camera)
      this.defaultCamera = camera;
    this._camera = camera;
    camera.currentWorld = this;
    this.onCameraChanged.trigger(camera);
  }
  /**
   * Getter for the renderer.
   * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
   * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
   * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
   * @param renderer - The new renderer to be set or null to remove the current renderer.
   */
  set renderer(renderer) {
    this._renderer = renderer;
    if (renderer) {
      renderer.worlds.set(this.uuid, this);
      renderer.currentWorld = this;
      renderer.onWorldChanged.trigger({ world: this, action: "added" });
    }
  }
  useDefaultCamera() {
    this.camera = this.defaultCamera;
  }
  /** {@link Updateable.update} */
  update(delta) {
    if (!this.enabled)
      return;
    if (!this._scene || !this._camera) {
      return;
    }
    this.scene.currentWorld = this;
    this.camera.currentWorld = this;
    if (this.renderer) {
      this.renderer.currentWorld = this;
    }
    this.onBeforeUpdate.trigger();
    if (this.scene.isUpdateable()) {
      this.scene.update(delta);
    }
    if (this.camera.isUpdateable()) {
      this.camera.update(delta);
    }
    if (this.renderer) {
      this.renderer.update(delta);
    }
    this.onAfterUpdate.trigger();
  }
  /** {@link Disposable.dispose} */
  dispose(disposeResources = true) {
    this.enabled = false;
    this.isDisposing = true;
    this.scene.onWorldChanged.trigger({ world: this, action: "removed" });
    this.camera.onWorldChanged.trigger({ world: this, action: "removed" });
    if (this.renderer) {
      this.renderer.onWorldChanged.trigger({ world: this, action: "removed" });
    }
    if (disposeResources) {
      const disposer = this.components.get(Disposer);
      this.scene.dispose();
      if (this.camera.isDisposeable()) {
        this.camera.dispose();
      }
      if (this.renderer) {
        this.renderer.dispose();
      }
      for (const mesh of this.meshes) {
        disposer.destroy(mesh);
      }
      this.meshes.clear();
    }
    this._scene = null;
    this._camera = null;
    this._renderer = null;
    const worlds = this.components.get(Worlds);
    worlds.list.delete(this.uuid);
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
}
class DirectionalLightConfig {
  constructor(list, scene) {
    __publicField(this, "_list");
    __publicField(this, "_scene");
    this._list = list;
    this._scene = scene;
  }
  get color() {
    return this._list.directionalLight.color.value;
  }
  set color(value) {
    this._list.directionalLight.color.value = value;
    for (const [, light] of this._scene.directionalLights) {
      light.color.copy(value);
    }
  }
  get intensity() {
    return this._list.directionalLight.intensity.value;
  }
  set intensity(value) {
    this._list.directionalLight.intensity.value = value;
    for (const [, light] of this._scene.directionalLights) {
      light.intensity = value;
    }
  }
  get position() {
    return this._list.directionalLight.position.value.clone();
  }
  set position(value) {
    this._list.directionalLight.position.value = value;
    for (const [, light] of this._scene.directionalLights) {
      light.position.copy(value);
    }
  }
}
class AmbientLightConfig {
  constructor(list, scene) {
    __publicField(this, "_list");
    __publicField(this, "_scene");
    this._list = list;
    this._scene = scene;
  }
  get color() {
    return this._list.ambientLight.color.value;
  }
  set color(value) {
    this._list.ambientLight.color.value = value;
    for (const [, light] of this._scene.ambientLights) {
      light.color.copy(value);
    }
  }
  get intensity() {
    return this._list.ambientLight.intensity.value;
  }
  set intensity(value) {
    this._list.ambientLight.intensity.value = value;
    for (const [, light] of this._scene.ambientLights) {
      light.intensity = value;
    }
  }
}
class SimpleSceneConfigManager extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      backgroundColor: {
        value: new THREE$1.Color(),
        type: "Color"
      },
      ambientLight: {
        color: {
          type: "Color",
          value: new THREE$1.Color()
        },
        intensity: {
          type: "Number",
          interpolable: true,
          min: 0,
          max: 10,
          value: 2
        }
      },
      directionalLight: {
        color: {
          type: "Color",
          value: new THREE$1.Color()
        },
        intensity: {
          type: "Number",
          interpolable: true,
          min: 0,
          max: 10,
          value: 2
        },
        position: {
          type: "Vector3",
          value: new THREE$1.Vector3()
        }
      }
    });
    __publicField(this, "ambientLight", new AmbientLightConfig(this._config, this._component));
    __publicField(this, "directionalLight", new DirectionalLightConfig(this._config, this._component));
  }
  get backgroundColor() {
    return this._config.backgroundColor.value;
  }
  set backgroundColor(value) {
    this._config.backgroundColor.value = value;
    this._component.three.background = value;
  }
}
class SimpleScene extends BaseScene {
  constructor(components) {
    super(components);
    /** {@link Configurable.onSetup} */
    __publicField(this, "onSetup", new Event());
    /** {@link Configurable.isSetup} */
    __publicField(this, "isSetup", false);
    /**
     * The underlying Three.js scene object.
     * It is used to define the 3D space containing objects, lights, and cameras.
     */
    __publicField(this, "three");
    /** {@link Configurable.config} */
    __publicField(this, "config", new SimpleSceneConfigManager(this, this.components, "Scene"));
    __publicField(this, "_defaultConfig", {
      backgroundColor: new THREE$1.Color(2107698),
      directionalLight: {
        color: new THREE$1.Color("white"),
        intensity: 1.5,
        position: new THREE$1.Vector3(5, 10, 3)
      },
      ambientLight: {
        color: new THREE$1.Color("white"),
        intensity: 1
      }
    });
    this.three = new THREE$1.Scene();
    this.three.background = new THREE$1.Color(2107698);
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.backgroundColor = fullConfig.backgroundColor;
    const ambLightData = fullConfig.ambientLight;
    this.config.ambientLight.color = ambLightData.color;
    this.config.ambientLight.intensity = ambLightData.intensity;
    const dirLightData = fullConfig.directionalLight;
    this.config.directionalLight.color = dirLightData.color;
    this.config.directionalLight.intensity = dirLightData.intensity;
    this.config.directionalLight.position = dirLightData.position;
    this.deleteAllLights();
    const { color: dc, intensity: di } = this.config.directionalLight;
    const directionalLight = new THREE$1.DirectionalLight(dc, di);
    directionalLight.position.copy(dirLightData.position);
    const { color: ac, intensity: ai } = this.config.directionalLight;
    const ambientLight = new THREE$1.AmbientLight(ac, ai);
    this.three.add(directionalLight, ambientLight);
    this.directionalLights.set(directionalLight.uuid, directionalLight);
    this.ambientLights.set(ambientLight.uuid, ambientLight);
    this.isSetup = true;
    this.onSetup.trigger();
  }
  dispose() {
    super.dispose();
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
  }
}
var RendererMode = /* @__PURE__ */ ((RendererMode2) => {
  RendererMode2[RendererMode2["MANUAL"] = 0] = "MANUAL";
  RendererMode2[RendererMode2["AUTO"] = 1] = "AUTO";
  return RendererMode2;
})(RendererMode || {});
class SimpleRenderer extends BaseRenderer {
  /**
   * Constructor for the SimpleRenderer class.
   *
   * @param components - The components instance.
   * @param container - The HTML container where the THREE.js canvas will be rendered.
   * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
   */
  constructor(components, container, parameters) {
    super(components);
    /**
     * Indicates whether the renderer is enabled. If it's not, it won't be updated.
     * Default is `true`.
     */
    __publicField(this, "enabled", true);
    /**
     * The HTML container of the THREE.js canvas where the scene is rendered.
     */
    __publicField(this, "container");
    /**
     * The THREE.js WebGLRenderer instance.
     */
    __publicField(this, "three");
    /**
     * The mode of the renderer. If MANUAL, the renderer will be updated manually. If AUTO, the renderer will render on every update tick.
     */
    __publicField(this, "mode", 1);
    /**
     * Whether the renderer needs to be updated. If true, the renderer will be updated on the next frame.
     */
    __publicField(this, "needsUpdate", false);
    __publicField(this, "_canvas");
    __publicField(this, "_parameters");
    __publicField(this, "_resizeObserver", null);
    __publicField(this, "onContainerUpdated", new Event());
    __publicField(this, "_resizing", false);
    /** {@link Resizeable.resize} */
    __publicField(this, "resize", (size) => {
      if (this._resizing)
        return;
      this._resizing = true;
      this.onContainerUpdated.trigger();
      const width = size ? size.x : this.container.clientWidth;
      const height = size ? size.y : this.container.clientHeight;
      this.three.setSize(width, height);
      this.onResize.trigger(new THREE$1.Vector2(width, height));
      this._resizing = false;
    });
    __publicField(this, "resizeEvent", () => {
      this.resize();
    });
    __publicField(this, "onContextLost", (event) => {
      event.preventDefault();
      this.enabled = false;
    });
    __publicField(this, "onContextBack", () => {
      this.three.setRenderTarget(null);
      this.three.dispose();
      this.three = new THREE$1.WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      });
      this.enabled = true;
    });
    this.container = container;
    this._parameters = parameters;
    this.three = new THREE$1.WebGLRenderer({
      antialias: true,
      alpha: true,
      ...parameters
    });
    this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.setupRenderer();
    this.setupEvents(true);
    this.resize();
    this._canvas = this.three.domElement;
    const context = this.three.getContext();
    const { canvas } = context;
    canvas.addEventListener("webglcontextlost", this.onContextLost, false);
    canvas.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    if (this.mode === 0 && !this.needsUpdate) {
      return;
    }
    this.needsUpdate = false;
    this.onBeforeUpdate.trigger(this);
    const scene = this.currentWorld.scene.three;
    const camera = this.currentWorld.camera.three;
    this.three.render(scene, camera);
    this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.setupEvents(false);
    this.three.domElement.remove();
    this.three.forceContextLoss();
    this.three.dispose();
    this.onResize.reset();
    this.onAfterUpdate.reset();
    this.onBeforeUpdate.reset();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new THREE$1.Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  /**
   * Sets up and manages the event listeners for the renderer.
   *
   * @param active - A boolean indicating whether to activate or deactivate the event listeners.
   *
   * @throws Will throw an error if the renderer does not have an HTML container.
   */
  setupEvents(active) {
    const dom = this.three.domElement.parentElement;
    if (!dom) {
      throw new Error("This renderer needs to have an HTML container!");
    }
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
    window.removeEventListener("resize", this.resizeEvent);
    if (active) {
      this._resizeObserver = new ResizeObserver(this.resizeEvent);
      this._resizeObserver.observe(dom);
      window.addEventListener("resize", this.resizeEvent);
    }
  }
  setupRenderer() {
    this.three.localClippingEnabled = true;
    if (this.container) {
      this.container.appendChild(this.three.domElement);
    }
    this.onContainerUpdated.trigger();
  }
}
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const MOUSE_BUTTON = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
const ACTION = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  SCREEN_PAN: 4,
  OFFSET: 8,
  DOLLY: 16,
  ZOOM: 32,
  TOUCH_ROTATE: 64,
  TOUCH_TRUCK: 128,
  TOUCH_SCREEN_PAN: 256,
  TOUCH_OFFSET: 512,
  TOUCH_DOLLY: 1024,
  TOUCH_ZOOM: 2048,
  TOUCH_DOLLY_TRUCK: 4096,
  TOUCH_DOLLY_SCREEN_PAN: 8192,
  TOUCH_DOLLY_OFFSET: 16384,
  TOUCH_DOLLY_ROTATE: 32768,
  TOUCH_ZOOM_TRUCK: 65536,
  TOUCH_ZOOM_OFFSET: 131072,
  TOUCH_ZOOM_SCREEN_PAN: 262144,
  TOUCH_ZOOM_ROTATE: 524288
});
const DOLLY_DIRECTION = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function isPerspectiveCamera(camera) {
  return camera.isPerspectiveCamera;
}
function isOrthographicCamera(camera) {
  return camera.isOrthographicCamera;
}
const PI_2 = Math.PI * 2;
const PI_HALF = Math.PI / 2;
const EPSILON = 1e-5;
const DEG2RAD = Math.PI / 180;
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function approxZero(number, error = EPSILON) {
  return Math.abs(number) < error;
}
function approxEquals(a, b, error = EPSILON) {
  return approxZero(a - b, error);
}
function roundToStep(value, step) {
  return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
  if (isFinite(value))
    return value;
  if (value < 0)
    return -Number.MAX_VALUE;
  return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
  if (Math.abs(value) < Number.MAX_VALUE)
    return value;
  return value * Infinity;
}
function smoothDamp(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let change = current - target;
  const originalTo = target;
  const maxChange = maxSpeed * smoothTime;
  change = clamp(change, -maxChange, maxChange);
  target = current - change;
  const temp5 = (currentVelocityRef.value + omega * change) * deltaTime;
  currentVelocityRef.value = (currentVelocityRef.value - omega * temp5) * exp;
  let output = target + (change + temp5) * exp;
  if (originalTo - current > 0 === output > originalTo) {
    output = originalTo;
    currentVelocityRef.value = (output - originalTo) / deltaTime;
  }
  return output;
}
function smoothDampVec3(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let targetX = target.x;
  let targetY = target.y;
  let targetZ = target.z;
  let changeX = current.x - targetX;
  let changeY = current.y - targetY;
  let changeZ = current.z - targetZ;
  const originalToX = targetX;
  const originalToY = targetY;
  const originalToZ = targetZ;
  const maxChange = maxSpeed * smoothTime;
  const maxChangeSq = maxChange * maxChange;
  const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;
  if (magnitudeSq > maxChangeSq) {
    const magnitude = Math.sqrt(magnitudeSq);
    changeX = changeX / magnitude * maxChange;
    changeY = changeY / magnitude * maxChange;
    changeZ = changeZ / magnitude * maxChange;
  }
  targetX = current.x - changeX;
  targetY = current.y - changeY;
  targetZ = current.z - changeZ;
  const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;
  const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;
  const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;
  currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;
  currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;
  currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;
  out.x = targetX + (changeX + tempX) * exp;
  out.y = targetY + (changeY + tempY) * exp;
  out.z = targetZ + (changeZ + tempZ) * exp;
  const origMinusCurrentX = originalToX - current.x;
  const origMinusCurrentY = originalToY - current.y;
  const origMinusCurrentZ = originalToZ - current.z;
  const outMinusOrigX = out.x - originalToX;
  const outMinusOrigY = out.y - originalToY;
  const outMinusOrigZ = out.z - originalToZ;
  if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {
    out.x = originalToX;
    out.y = originalToY;
    out.z = originalToZ;
    currentVelocityRef.x = (out.x - originalToX) / deltaTime;
    currentVelocityRef.y = (out.y - originalToY) / deltaTime;
    currentVelocityRef.z = (out.z - originalToZ) / deltaTime;
  }
  return out;
}
function extractClientCoordFromEvent(pointers, out) {
  out.set(0, 0);
  pointers.forEach((pointer) => {
    out.x += pointer.clientX;
    out.y += pointer.clientY;
  });
  out.x /= pointers.length;
  out.y /= pointers.length;
}
function notSupportedInOrthographicCamera(camera, message) {
  if (isOrthographicCamera(camera)) {
    console.warn(`${message} is not supported in OrthographicCamera`);
    return true;
  }
  return false;
}
class EventDispatcher {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners[type] === void 0)
      listeners[type] = [];
    if (listeners[type].indexOf(listener) === -1)
      listeners[type].push(listener);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1)
        listenerArray.splice(index, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(type) {
    if (!type) {
      this._listeners = {};
      return;
    }
    if (Array.isArray(this._listeners[type]))
      this._listeners[type].length = 0;
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
}
var _a;
const VERSION = "2.10.1";
const TOUCH_DOLLY_FACTOR = 1 / 8;
const isMac = /Mac/.test((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.platform);
let THREE;
let _ORIGIN;
let _AXIS_Y;
let _AXIS_Z;
let _v2$1;
let _v3A;
let _v3B;
let _v3C;
let _cameraDirection;
let _xColumn;
let _yColumn;
let _zColumn;
let _deltaTarget;
let _deltaOffset;
let _sphericalA;
let _sphericalB;
let _box3A;
let _box3B;
let _sphere;
let _quaternionA;
let _quaternionB;
let _rotationMatrix;
let _raycaster$1;
class CameraControls extends EventDispatcher {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(libs) {
    THREE = libs.THREE;
    _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
    _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
    _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
    _v2$1 = new THREE.Vector2();
    _v3A = new THREE.Vector3();
    _v3B = new THREE.Vector3();
    _v3C = new THREE.Vector3();
    _cameraDirection = new THREE.Vector3();
    _xColumn = new THREE.Vector3();
    _yColumn = new THREE.Vector3();
    _zColumn = new THREE.Vector3();
    _deltaTarget = new THREE.Vector3();
    _deltaOffset = new THREE.Vector3();
    _sphericalA = new THREE.Spherical();
    _sphericalB = new THREE.Spherical();
    _box3A = new THREE.Box3();
    _box3B = new THREE.Box3();
    _sphere = new THREE.Sphere();
    _quaternionA = new THREE.Quaternion();
    _quaternionB = new THREE.Quaternion();
    _rotationMatrix = new THREE.Matrix4();
    _raycaster$1 = new THREE.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return ACTION;
  }
  /**
   * @deprecated Use `cameraControls.mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.
   */
  set verticalDragToForward(_) {
    console.warn("camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.");
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(camera, domElement) {
    super();
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.minDistance = Number.EPSILON;
    this.maxDistance = Infinity;
    this.infinityDolly = false;
    this.minZoom = 0.01;
    this.maxZoom = Infinity;
    this.smoothTime = 0.25;
    this.draggingSmoothTime = 0.125;
    this.maxSpeed = Infinity;
    this.azimuthRotateSpeed = 1;
    this.polarRotateSpeed = 1;
    this.dollySpeed = 1;
    this.dollyDragInverted = false;
    this.truckSpeed = 2;
    this.dollyToCursor = false;
    this.dragToOffset = false;
    this.boundaryFriction = 0;
    this.restThreshold = 0.01;
    this.colliderMeshes = [];
    this.cancel = () => {
    };
    this._enabled = true;
    this._state = ACTION.NONE;
    this._viewport = null;
    this._changedDolly = 0;
    this._changedZoom = 0;
    this._hasRested = true;
    this._boundaryEnclosesCamera = false;
    this._needsUpdate = true;
    this._updatedLastTime = false;
    this._elementRect = new DOMRect();
    this._isDragging = false;
    this._dragNeedsUpdate = true;
    this._activePointers = [];
    this._lockedPointer = null;
    this._interactiveArea = new DOMRect(0, 0, 1, 1);
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._isUserControllingOffset = false;
    this._isUserControllingZoom = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._thetaVelocity = { value: 0 };
    this._phiVelocity = { value: 0 };
    this._radiusVelocity = { value: 0 };
    this._targetVelocity = new THREE.Vector3();
    this._focalOffsetVelocity = new THREE.Vector3();
    this._zoomVelocity = { value: 0 };
    this._truckInternal = (deltaX, deltaY, dragToOffset, screenSpacePanning) => {
      let truckX;
      let pedestalY;
      if (isPerspectiveCamera(this._camera)) {
        const offset = _v3A.copy(this._camera.position).sub(this._target);
        const fov = this._camera.getEffectiveFOV() * DEG2RAD;
        const targetDistance = offset.length() * Math.tan(fov * 0.5);
        truckX = this.truckSpeed * deltaX * targetDistance / this._elementRect.height;
        pedestalY = this.truckSpeed * deltaY * targetDistance / this._elementRect.height;
      } else if (isOrthographicCamera(this._camera)) {
        const camera2 = this._camera;
        truckX = this.truckSpeed * deltaX * (camera2.right - camera2.left) / camera2.zoom / this._elementRect.width;
        pedestalY = this.truckSpeed * deltaY * (camera2.top - camera2.bottom) / camera2.zoom / this._elementRect.height;
      } else {
        return;
      }
      if (screenSpacePanning) {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(truckX, 0, true);
        this.forward(-pedestalY, true);
      } else {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
      }
    };
    this._rotateInternal = (deltaX, deltaY) => {
      const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
      const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
      this.rotate(theta, phi, true);
    };
    this._dollyInternal = (delta, x, y) => {
      const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
      const lastDistance = this._sphericalEnd.radius;
      const distance = this._sphericalEnd.radius * dollyScale;
      const clampedDistance = clamp(distance, this.minDistance, this.maxDistance);
      const overflowedDistance = clampedDistance - distance;
      if (this.infinityDolly && this.dollyToCursor) {
        this._dollyToNoClamp(distance, true);
      } else if (this.infinityDolly && !this.dollyToCursor) {
        this.dollyInFixed(overflowedDistance, true);
        this._dollyToNoClamp(clampedDistance, true);
      } else {
        this._dollyToNoClamp(clampedDistance, true);
      }
      if (this.dollyToCursor) {
        this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;
        this._dollyControlCoord.set(x, y);
      }
      this._lastDollyDirection = Math.sign(-delta);
    };
    this._zoomInternal = (delta, x, y) => {
      const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
      const lastZoom = this._zoom;
      const zoom = this._zoom * zoomScale;
      this.zoomTo(zoom, true);
      if (this.dollyToCursor) {
        this._changedZoom += zoom - lastZoom;
        this._dollyControlCoord.set(x, y);
      }
    };
    if (typeof THREE === "undefined") {
      console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.");
    }
    this._camera = camera;
    this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();
    this._state = ACTION.NONE;
    this._target = new THREE.Vector3();
    this._targetEnd = this._target.clone();
    this._focalOffset = new THREE.Vector3();
    this._focalOffsetEnd = this._focalOffset.clone();
    this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
    this._sphericalEnd = this._spherical.clone();
    this._lastDistance = this._spherical.radius;
    this._zoom = this._camera.zoom;
    this._zoomEnd = this._zoom;
    this._lastZoom = this._zoom;
    this._nearPlaneCorners = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    this._updateNearPlaneCorners();
    this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
    this._cameraUp0 = this._camera.up.clone();
    this._target0 = this._target.clone();
    this._position0 = this._camera.position.clone();
    this._zoom0 = this._zoom;
    this._focalOffset0 = this._focalOffset.clone();
    this._dollyControlCoord = new THREE.Vector2();
    this.mouseButtons = {
      left: ACTION.ROTATE,
      middle: ACTION.DOLLY,
      right: ACTION.TRUCK,
      wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera(this._camera) ? ACTION.ZOOM : ACTION.NONE
    };
    this.touches = {
      one: ACTION.TOUCH_ROTATE,
      two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE,
      three: ACTION.TOUCH_TRUCK
    };
    const dragStartPosition = new THREE.Vector2();
    const lastDragPosition = new THREE.Vector2();
    const dollyStart = new THREE.Vector2();
    const onPointerDown2 = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = event.pointerType !== "mouse" ? null : (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)
        return;
      const pointer = {
        pointerId: event.pointerId,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp2);
      this._isDragging = true;
      startDragging(event);
    };
    const onPointerMove2 = (event) => {
      if (event.cancelable)
        event.preventDefault();
      const pointerId = event.pointerId;
      const pointer = this._lockedPointer || this._findPointerById(pointerId);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._isDragging && this._lockedPointer || this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      dragging();
    };
    const onPointerUp2 = (event) => {
      const pointer = this._findPointerById(event.pointerId);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 0:
            this._state = ACTION.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = ACTION.NONE;
      }
      endDragging();
    };
    let lastScrollTimeStamp = -1;
    const onMouseWheel = (event) => {
      if (!this._domElement)
        return;
      if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      event.preventDefault();
      if (this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) {
        const now = performance.now();
        if (lastScrollTimeStamp - now < 1e3)
          this._getClientRect(this._elementRect);
        lastScrollTimeStamp = now;
      }
      const deltaYFactor = isMac ? -1 : -3;
      const delta = event.deltaMode === 1 || event.ctrlKey ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
      const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
      const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case ACTION.ROTATE: {
          this._rotateInternal(event.deltaX, event.deltaY);
          this._isUserControllingRotate = true;
          break;
        }
        case ACTION.TRUCK: {
          this._truckInternal(event.deltaX, event.deltaY, false, false);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.SCREEN_PAN: {
          this._truckInternal(event.deltaX, event.deltaY, false, true);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.OFFSET: {
          this._truckInternal(event.deltaX, event.deltaY, true, false);
          this._isUserControllingOffset = true;
          break;
        }
        case ACTION.DOLLY: {
          this._dollyInternal(-delta, x, y);
          this._isUserControllingDolly = true;
          break;
        }
        case ACTION.ZOOM: {
          this._zoomInternal(-delta, x, y);
          this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    };
    const onContextMenu = (event) => {
      if (!this._domElement || !this._enabled)
        return;
      if (this.mouseButtons.right === CameraControls.ACTION.NONE) {
        const pointerId = event instanceof PointerEvent ? event.pointerId : 0;
        const pointer = this._findPointerById(pointerId);
        pointer && this._disposePointer(pointer);
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
        return;
      }
      event.preventDefault();
    };
    const startDragging = (event) => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v2$1);
      this._getClientRect(this._elementRect);
      dragStartPosition.copy(_v2$1);
      lastDragPosition.copy(_v2$1);
      const isMultiTouch = this._activePointers.length >= 2;
      if (isMultiTouch) {
        const dx = _v2$1.x - this._activePointers[1].clientX;
        const dy = _v2$1.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
        const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
        const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        lastDragPosition.set(x, y);
      }
      this._state = 0;
      if (!event) {
        if (this._lockedPointer)
          this._state = this._state | this.mouseButtons.left;
      } else if ("pointerType" in event && event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._sphericalEnd.theta = this._spherical.theta;
        this._sphericalEnd.phi = this._spherical.phi;
        this._thetaVelocity.value = 0;
        this._phiVelocity.value = 0;
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN) {
        this._targetEnd.copy(this._target);
        this._targetVelocity.set(0, 0, 0);
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {
        this._sphericalEnd.radius = this._spherical.radius;
        this._radiusVelocity.value = 0;
      }
      if ((this._state & ACTION.ZOOM) === ACTION.ZOOM || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._zoomEnd = this._zoom;
        this._zoomVelocity.value = 0;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._focalOffsetEnd.copy(this._focalOffset);
        this._focalOffsetVelocity.set(0, 0, 0);
      }
      this.dispatchEvent({ type: "controlstart" });
    };
    const dragging = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false;
      extractClientCoordFromEvent(this._activePointers, _v2$1);
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;
      const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v2$1.x;
      const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v2$1.y;
      lastDragPosition.copy(_v2$1);
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._rotateInternal(deltaX, deltaY);
        this._isUserControllingRotate = true;
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        const dollyDirection = this.dollyDragInverted ? -1 : 1;
        if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {
          this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        const dx = _v2$1.x - this._activePointers[1].clientX;
        const dy = _v2$1.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const dollyDelta = dollyStart.y - distance;
        dollyStart.set(0, distance);
        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {
          this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._truckInternal(deltaX, deltaY, false, false);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN) {
        this._truckInternal(deltaX, deltaY, false, true);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._truckInternal(deltaX, deltaY, true, false);
        this._isUserControllingOffset = true;
      }
      this.dispatchEvent({ type: "control" });
    };
    const endDragging = () => {
      extractClientCoordFromEvent(this._activePointers, _v2$1);
      lastDragPosition.copy(_v2$1);
      this._dragNeedsUpdate = false;
      if (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) {
        this._isDragging = false;
      }
      if (this._activePointers.length === 0 && this._domElement) {
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
        this.dispatchEvent({ type: "controlend" });
      }
    };
    this.lockPointer = () => {
      if (!this._enabled || !this._domElement)
        return;
      this.cancel();
      this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      };
      this._activePointers.push(this._lockedPointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.requestPointerLock();
      this._domElement.ownerDocument.addEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.addEventListener("pointerlockerror", onPointerLockError);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp2);
      startDragging();
    };
    this.unlockPointer = () => {
      var _a2, _b, _c;
      if (this._lockedPointer !== null) {
        this._disposePointer(this._lockedPointer);
        this._lockedPointer = null;
      }
      (_a2 = this._domElement) === null || _a2 === void 0 ? void 0 : _a2.ownerDocument.exitPointerLock();
      (_b = this._domElement) === null || _b === void 0 ? void 0 : _b.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      (_c = this._domElement) === null || _c === void 0 ? void 0 : _c.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
      this.cancel();
    };
    const onPointerLockChange = () => {
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      if (!isPointerLockActive)
        this.unlockPointer();
    };
    const onPointerLockError = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (domElement2) => {
      this._domElement = domElement2;
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
      this._domElement.addEventListener("pointerdown", onPointerDown2);
      this._domElement.addEventListener("pointercancel", onPointerUp2);
      this._domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.addEventListener("contextmenu", onContextMenu);
    };
    this._removeAllEventListeners = () => {
      if (!this._domElement)
        return;
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
      this._domElement.removeEventListener("pointerdown", onPointerDown2);
      this._domElement.removeEventListener("pointercancel", onPointerUp2);
      this._domElement.removeEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.removeEventListener("contextmenu", onContextMenu);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    this.cancel = () => {
      if (this._state === ACTION.NONE)
        return;
      this._state = ACTION.NONE;
      this._activePointers.length = 0;
      endDragging();
    };
    if (domElement)
      this.connect(domElement);
    this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this.updateCameraUp();
    this._camera.updateProjectionMatrix();
    this._updateNearPlaneCorners();
    this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    if (!this._domElement)
      return;
    if (enabled) {
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
    } else {
      this.cancel();
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
    }
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(distance) {
    if (this._spherical.radius === distance && this._sphericalEnd.radius === distance)
      return;
    this._spherical.radius = distance;
    this._sphericalEnd.radius = distance;
    this._needsUpdate = true;
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(azimuthAngle) {
    if (this._spherical.theta === azimuthAngle && this._sphericalEnd.theta === azimuthAngle)
      return;
    this._spherical.theta = azimuthAngle;
    this._sphericalEnd.theta = azimuthAngle;
    this._needsUpdate = true;
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(polarAngle) {
    if (this._spherical.phi === polarAngle && this._sphericalEnd.phi === polarAngle)
      return;
    this._spherical.phi = polarAngle;
    this._sphericalEnd.phi = polarAngle;
    this._needsUpdate = true;
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(boundaryEnclosesCamera) {
    this._boundaryEnclosesCamera = boundaryEnclosesCamera;
    this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(interactiveArea) {
    this._interactiveArea.width = clamp(interactiveArea.width, 0, 1);
    this._interactiveArea.height = clamp(interactiveArea.height, 0, 1);
    this._interactiveArea.x = clamp(interactiveArea.x, 0, 1 - this._interactiveArea.width);
    this._interactiveArea.y = clamp(interactiveArea.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    super.addEventListener(type, listener);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(azimuthAngle, polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(azimuthAngle, enableTransition = false) {
    return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
    this._isUserControllingRotate = false;
    const theta = clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
    const phi = clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = theta;
    this._sphericalEnd.phi = phi;
    this._sphericalEnd.makeSafe();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.theta = this._sphericalEnd.theta;
      this._spherical.phi = this._sphericalEnd.phi;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(distance, enableTransition = false) {
    return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(distance, enableTransition = false) {
    this._isUserControllingDolly = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    return this._dollyToNoClamp(clamp(distance, this.minDistance, this.maxDistance), enableTransition);
  }
  _dollyToNoClamp(distance, enableTransition = false) {
    const lastRadius = this._sphericalEnd.radius;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (hasCollider) {
      const maxDistanceByCollisionTest = this._collisionTest();
      const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
      const isDollyIn = lastRadius > distance;
      if (!isDollyIn && isCollided)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);
    } else {
      this._sphericalEnd.radius = distance;
    }
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.radius = this._sphericalEnd.radius;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(distance, enableTransition = false) {
    this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(zoomStep, enableTransition = false) {
    return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(zoom, enableTransition = false) {
    this._isUserControllingZoom = false;
    this._zoomEnd = clamp(zoom, this.minZoom, this.maxZoom);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._zoom = this._zoomEnd;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
    this._changedZoom = 0;
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(x, y, enableTransition = false) {
    console.warn("`pan` has been renamed to `truck`");
    return this.truck(x, y, enableTransition);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(x, y, enableTransition = false) {
    this._camera.updateMatrix();
    _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
    _xColumn.multiplyScalar(x);
    _yColumn.multiplyScalar(-y);
    const offset = _v3A.copy(_xColumn).add(_yColumn);
    const to = _v3B.copy(this._targetEnd).add(offset);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(distance, enableTransition = false) {
    _v3A.setFromMatrixColumn(this._camera.matrix, 0);
    _v3A.crossVectors(this._camera.up, _v3A);
    _v3A.multiplyScalar(distance);
    const to = _v3B.copy(this._targetEnd).add(_v3A);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(height, enableTransition = false) {
    _v3A.copy(this._camera.up).multiplyScalar(height);
    return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(x, y, z, enableTransition = false) {
    this._isUserControllingTruck = false;
    const offset = _v3A.set(x, y, z).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(x, y, z, enableTransition = false) {
    const point = _v3A.set(x, y, z);
    const direction = point.sub(this._targetEnd).normalize();
    const position = direction.multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(position.x, position.y, position.z, enableTransition);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
    const promises = [];
    const aabb = box3OrObject.isBox3 ? _box3A.copy(box3OrObject) : _box3A.setFromObject(box3OrObject);
    if (aabb.isEmpty()) {
      console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting");
      Promise.resolve();
    }
    const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
    const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
    promises.push(this.rotateTo(theta, phi, enableTransition));
    const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
    const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
    const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
    if (viewFromPolar) {
      rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
    }
    rotation.multiply(this._yAxisUpSpaceInverse);
    const bb = _box3B.makeEmpty();
    _v3B.copy(aabb.min).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    bb.min.x -= paddingLeft;
    bb.min.y -= paddingBottom;
    bb.max.x += paddingRight;
    bb.max.y += paddingTop;
    rotation.setFromUnitVectors(_AXIS_Z, normal);
    if (viewFromPolar) {
      rotation.premultiply(_quaternionB.invert());
    }
    rotation.premultiply(this._yAxisUpSpace);
    const bbSize = bb.getSize(_v3A);
    const center = bb.getCenter(_v3B).applyQuaternion(rotation);
    if (isPerspectiveCamera(this._camera)) {
      const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.dollyTo(distance, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const width = camera.right - camera.left;
      const height = camera.top - camera.bottom;
      const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.zoomTo(zoom, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    }
    return Promise.all(promises);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(sphereOrMesh, enableTransition) {
    const promises = [];
    const isObject3D = "isObject3D" in sphereOrMesh;
    const boundingSphere = isObject3D ? CameraControls.createBoundingSphere(sphereOrMesh, _sphere) : _sphere.copy(sphereOrMesh);
    promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
    if (isPerspectiveCamera(this._camera)) {
      const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
      promises.push(this.dollyTo(distanceToFit, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const width = this._camera.right - this._camera.left;
      const height = this._camera.top - this._camera.bottom;
      const diameter = 2 * boundingSphere.radius;
      const zoom = Math.min(width / diameter, height / diameter);
      promises.push(this.zoomTo(zoom, enableTransition));
    }
    promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    return Promise.all(promises);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const target = _v3B.set(targetX, targetY, targetZ);
    const position = _v3A.set(positionX, positionY, positionZ);
    this._targetEnd.copy(target);
    this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const targetA = _v3A.set(targetAX, targetAY, targetAZ);
    const positionA = _v3B.set(positionAX, positionAY, positionAZ);
    _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
    const targetB = _v3C.set(targetBX, targetBY, targetBZ);
    const positionB = _v3B.set(positionBX, positionBY, positionBZ);
    _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
    this._targetEnd.copy(targetA.lerp(targetB, t));
    const deltaTheta = _sphericalB.theta - _sphericalA.theta;
    const deltaPhi = _sphericalB.phi - _sphericalA.phi;
    const deltaRadius = _sphericalB.radius - _sphericalA.radius;
    this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(positionX, positionY, positionZ, enableTransition = false) {
    return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(targetX, targetY, targetZ, enableTransition = false) {
    const pos = this.getPosition(_v3A);
    const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
    this._sphericalEnd.phi = clamp(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);
    return promise;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(x, y, z, enableTransition = false) {
    this._isUserControllingOffset = false;
    this._focalOffsetEnd.set(x, y, z);
    this._needsUpdate = true;
    if (!enableTransition)
      this._focalOffset.copy(this._focalOffsetEnd);
    const resolveImmediately = !enableTransition || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(targetX, targetY, targetZ) {
    this._camera.updateMatrixWorld();
    _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
    _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const position = _v3A.set(targetX, targetY, targetZ);
    const distance = position.distanceTo(this._camera.position);
    const cameraToPoint = position.sub(this._camera.position);
    _xColumn.multiplyScalar(cameraToPoint.x);
    _yColumn.multiplyScalar(cameraToPoint.y);
    _zColumn.multiplyScalar(cameraToPoint.z);
    _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
    _v3A.z = _v3A.z + distance;
    this.dollyTo(distance, false);
    this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
    this.moveTo(targetX, targetY, targetZ, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(box3) {
    if (!box3) {
      this._boundary.min.set(-Infinity, -Infinity, -Infinity);
      this._boundary.max.set(Infinity, Infinity, Infinity);
      this._needsUpdate = true;
      return;
    }
    this._boundary.copy(box3);
    this._boundary.clampPoint(this._targetEnd, this._targetEnd);
    this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(viewportOrX, y, width, height) {
    if (viewportOrX === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new THREE.Vector4();
    if (typeof viewportOrX === "number") {
      this._viewport.set(viewportOrX, y, width, height);
    } else {
      this._viewport.copy(viewportOrX);
    }
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(width, height, depth, cover = false) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const boundingRectAspect = width / height;
    const fov = this._camera.getEffectiveFOV() * DEG2RAD;
    const aspect = this._camera.aspect;
    const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;
    return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(radius) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;
    const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
    const fov = 1 < this._camera.aspect ? vFOV : hFOV;
    return radius / Math.sin(fov * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(out, receiveEndValue = true) {
    const _out = out || new THREE.Spherical();
    return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
    if (this._sphericalEnd.theta < 0)
      this._sphericalEnd.theta += PI_2;
    this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd);
    this._target.copy(this._targetEnd);
    this._spherical.copy(this._sphericalEnd);
    this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(enableTransition = false) {
    if (!approxEquals(this._camera.up.x, this._cameraUp0.x) || !approxEquals(this._camera.up.y, this._cameraUp0.y) || !approxEquals(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const position = this.getPosition(_v3A);
      this.updateCameraUp();
      this.setPosition(position.x, position.y, position.z);
    }
    const promises = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
      this.zoomTo(this._zoom0, enableTransition)
    ];
    return Promise.all(promises);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up);
    this.getTarget(this._target0);
    this.getPosition(this._position0);
    this._zoom0 = this._zoom;
    this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();
    const side = _v3B.crossVectors(cameraDirection, this._camera.up);
    this._camera.up.crossVectors(side, cameraDirection).normalize();
    this._camera.updateMatrixWorld();
    const position = this.getPosition(_v3A);
    this.updateCameraUp();
    this.setPosition(position.x, position.y, position.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(delta) {
    const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
    const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
    const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
    const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
    const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
    const deltaZoom = this._zoomEnd - this._zoom;
    if (approxZero(deltaTheta)) {
      this._thetaVelocity.value = 0;
      this._spherical.theta = this._sphericalEnd.theta;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaPhi)) {
      this._phiVelocity.value = 0;
      this._spherical.phi = this._sphericalEnd.phi;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaRadius)) {
      this._radiusVelocity.value = 0;
      this._spherical.radius = this._sphericalEnd.radius;
    } else {
      const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {
      this._targetVelocity.set(0, 0, 0);
      this._target.copy(this._targetEnd);
    } else {
      const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);
      this._needsUpdate = true;
    }
    if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {
      this._focalOffsetVelocity.set(0, 0, 0);
      this._focalOffset.copy(this._focalOffsetEnd);
    } else {
      const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);
      this._needsUpdate = true;
    }
    if (approxZero(deltaZoom)) {
      this._zoomVelocity.value = 0;
      this._zoom = this._zoomEnd;
    } else {
      const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);
    }
    if (this.dollyToCursor) {
      if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {
        const dollyControlAmount = this._spherical.radius - this._lastDistance;
        const camera = this._camera;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();
        if (planeX.lengthSq() === 0)
          planeX.x = 1;
        const planeY = _v3B.crossVectors(planeX, cameraDirection);
        const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);
        const prevRadius = this._sphericalEnd.radius - dollyControlAmount;
        const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
        const cursor = _v3C.copy(this._targetEnd).add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect)).add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;
        const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (isMin || isMax)) {
          this._sphericalEnd.radius -= dollyControlAmount;
          this._spherical.radius -= dollyControlAmount;
          const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);
          newTargetEnd.add(dollyAmount);
        }
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedDolly -= dollyControlAmount;
        if (approxZero(this._changedDolly))
          this._changedDolly = 0;
      } else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {
        const dollyControlAmount = this._zoom - this._lastZoom;
        const camera = this._camera;
        const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
        const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
        const prevZoom = this._zoom - dollyControlAmount;
        const lerpRatio = -(prevZoom - this._zoom) / this._zoom;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const newPlaneConstant = newTargetEnd.dot(cameraDirection);
        const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
        newTargetEnd.sub(pullBack);
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedZoom -= dollyControlAmount;
        if (approxZero(this._changedZoom))
          this._changedZoom = 0;
      }
    }
    if (this._camera.zoom !== this._zoom) {
      this._camera.zoom = this._zoom;
      this._camera.updateProjectionMatrix();
      this._updateNearPlaneCorners();
      this._needsUpdate = true;
    }
    this._dragNeedsUpdate = true;
    const maxDistance = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
    this._spherical.makeSafe();
    this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
    this._camera.lookAt(this._target);
    const affectOffset = !approxZero(this._focalOffset.x) || !approxZero(this._focalOffset.y) || !approxZero(this._focalOffset.z);
    if (affectOffset) {
      _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
      _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
      _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
      _xColumn.multiplyScalar(this._focalOffset.x);
      _yColumn.multiplyScalar(-this._focalOffset.y);
      _zColumn.multiplyScalar(this._focalOffset.z);
      _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
      this._camera.position.add(_v3A);
      this._camera.updateMatrixWorld();
    }
    if (this._boundaryEnclosesCamera) {
      this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    }
    const updated = this._needsUpdate;
    if (updated && !this._updatedLastTime) {
      this._hasRested = false;
      this.dispatchEvent({ type: "wake" });
      this.dispatchEvent({ type: "update" });
    } else if (updated) {
      this.dispatchEvent({ type: "update" });
      if (approxZero(deltaTheta, this.restThreshold) && approxZero(deltaPhi, this.restThreshold) && approxZero(deltaRadius, this.restThreshold) && approxZero(deltaTarget.x, this.restThreshold) && approxZero(deltaTarget.y, this.restThreshold) && approxZero(deltaTarget.z, this.restThreshold) && approxZero(deltaOffset.x, this.restThreshold) && approxZero(deltaOffset.y, this.restThreshold) && approxZero(deltaOffset.z, this.restThreshold) && approxZero(deltaZoom, this.restThreshold) && !this._hasRested) {
        this._hasRested = true;
        this.dispatchEvent({ type: "rest" });
      }
    } else if (!updated && this._updatedLastTime) {
      this.dispatchEvent({ type: "sleep" });
    }
    this._lastDistance = this._spherical.radius;
    this._lastZoom = this._zoom;
    this._updatedLastTime = updated;
    this._needsUpdate = false;
    return updated;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: infinityToMaxNumber(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: infinityToMaxNumber(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
      minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
      maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      target: this._targetEnd.toArray(),
      position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(json, enableTransition = false) {
    const obj = JSON.parse(json);
    this.enabled = obj.enabled;
    this.minDistance = obj.minDistance;
    this.maxDistance = maxNumberToInfinity(obj.maxDistance);
    this.minZoom = obj.minZoom;
    this.maxZoom = maxNumberToInfinity(obj.maxZoom);
    this.minPolarAngle = obj.minPolarAngle;
    this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
    this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
    this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
    this.smoothTime = obj.smoothTime;
    this.draggingSmoothTime = obj.draggingSmoothTime;
    this.dollySpeed = obj.dollySpeed;
    this.truckSpeed = obj.truckSpeed;
    this.dollyToCursor = obj.dollyToCursor;
    this._target0.fromArray(obj.target0);
    this._position0.fromArray(obj.position0);
    this._zoom0 = obj.zoom0;
    this._focalOffset0.fromArray(obj.focalOffset0);
    this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
    _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
    this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
    this.dollyTo(_sphericalA.radius, enableTransition);
    this.zoomTo(obj.zoom, enableTransition);
    this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
    this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(domElement) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    domElement.setAttribute("data-camera-controls-version", VERSION);
    this._addAllEventListeners(domElement);
    this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel();
    this._removeAllEventListeners();
    if (this._domElement) {
      this._domElement.removeAttribute("data-camera-controls-version");
      this._domElement = void 0;
    }
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners();
    this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(out) {
    return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(out) {
    return this._getTargetDirection(out).negate();
  }
  _findPointerById(pointerId) {
    return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);
  }
  _findPointerByMouseButton(mouseButton) {
    return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);
  }
  _disposePointer(pointer) {
    this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
  }
  _encloseToBoundary(position, offset, friction) {
    const offsetLength2 = offset.lengthSq();
    if (offsetLength2 === 0) {
      return position;
    }
    const newTarget = _v3B.copy(offset).add(position);
    const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
    const deltaClampedTarget = clampedTarget.sub(newTarget);
    const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
    if (deltaClampedTargetLength2 === 0) {
      return position.add(offset);
    } else if (deltaClampedTargetLength2 === offsetLength2) {
      return position;
    } else if (friction === 0) {
      return position.add(offset).add(deltaClampedTarget);
    } else {
      const offsetFactor = 1 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
      return position.add(_v3B.copy(offset).multiplyScalar(offsetFactor)).add(deltaClampedTarget.multiplyScalar(1 - friction));
    }
  }
  _updateNearPlaneCorners() {
    if (isPerspectiveCamera(this._camera)) {
      const camera = this._camera;
      const near = camera.near;
      const fov = camera.getEffectiveFOV() * DEG2RAD;
      const heightHalf = Math.tan(fov * 0.5) * near;
      const widthHalf = heightHalf * camera.aspect;
      this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
      this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const zoomInv = 1 / camera.zoom;
      const left = camera.left * zoomInv;
      const right = camera.right * zoomInv;
      const top = camera.top * zoomInv;
      const bottom = camera.bottom * zoomInv;
      this._nearPlaneCorners[0].set(left, top, 0);
      this._nearPlaneCorners[1].set(right, top, 0);
      this._nearPlaneCorners[2].set(right, bottom, 0);
      this._nearPlaneCorners[3].set(left, bottom, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let distance = Infinity;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (!hasCollider)
      return distance;
    if (notSupportedInOrthographicCamera(this._camera, "_collisionTest"))
      return distance;
    const rayDirection = this._getTargetDirection(_cameraDirection);
    _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);
      nearPlaneCorner.applyMatrix4(_rotationMatrix);
      const origin = _v3C.addVectors(this._target, nearPlaneCorner);
      _raycaster$1.set(origin, rayDirection);
      _raycaster$1.far = this._spherical.radius + 1;
      const intersects = _raycaster$1.intersectObjects(this.colliderMeshes);
      if (intersects.length !== 0 && intersects[0].distance < distance) {
        distance = intersects[0].distance;
      }
    }
    return distance;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(target) {
    if (!this._domElement)
      return;
    const rect = this._domElement.getBoundingClientRect();
    target.x = rect.left;
    target.y = rect.top;
    if (this._viewport) {
      target.x += this._viewport.x;
      target.y += rect.height - this._viewport.w - this._viewport.y;
      target.width = this._viewport.z;
      target.height = this._viewport.w;
    } else {
      target.width = rect.width;
      target.height = rect.height;
    }
    return target;
  }
  _createOnRestPromise(resolveImmediately) {
    if (resolveImmediately)
      return Promise.resolve();
    this._hasRested = false;
    this.dispatchEvent({ type: "transitionstart" });
    return new Promise((resolve) => {
      const onResolve = () => {
        this.removeEventListener("rest", onResolve);
        resolve();
      };
      this.addEventListener("rest", onResolve);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(_domElement) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(_) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(_) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(object3d, out = new THREE.Sphere()) {
    const boundingSphere = out;
    const center = boundingSphere.center;
    _box3A.makeEmpty();
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      _box3A.expandByObject(object);
    });
    _box3A.getCenter(center);
    let maxRadiusSq = 0;
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      const mesh = object;
      if (!mesh.geometry)
        return;
      const geometry = mesh.geometry.clone();
      geometry.applyMatrix4(mesh.matrixWorld);
      const bufferGeometry = geometry;
      const position = bufferGeometry.attributes.position;
      for (let i = 0, l = position.count; i < l; i++) {
        _v3A.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
      }
    });
    boundingSphere.radius = Math.sqrt(maxRadiusSq);
    return boundingSphere;
  }
}
class SimpleCamera extends BaseCamera {
  constructor(components) {
    super(components);
    /** {@link Updateable.onBeforeUpdate} */
    __publicField(this, "onBeforeUpdate", new Event());
    /** {@link Updateable.onAfterUpdate} */
    __publicField(this, "onAfterUpdate", new Event());
    /**
     * Event that is triggered when the aspect of the camera has been updated.
     * This event is useful when you need to perform actions after the aspect of the camera has been changed.
     */
    __publicField(this, "onAspectUpdated", new Event());
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /**
     * A three.js PerspectiveCamera or OrthographicCamera instance.
     * This camera is used for rendering the scene.
     */
    __publicField(this, "three");
    __publicField(this, "_allControls", /* @__PURE__ */ new Map());
    /**
     * Updates the aspect of the camera to match the size of the
     * {@link Components.renderer}.
     */
    __publicField(this, "updateAspect", () => {
      var _a2;
      if (!this.currentWorld || !this.currentWorld.renderer)
        return;
      if (this.three instanceof THREE$1.OrthographicCamera) {
        this.onAspectUpdated.trigger();
        return;
      }
      if ((_a2 = this.currentWorld.renderer) == null ? void 0 : _a2.isResizeable()) {
        const size = this.currentWorld.renderer.getSize();
        this.three.aspect = size.width / size.height;
        this.three.updateProjectionMatrix();
        this.onAspectUpdated.trigger();
      }
    });
    this.three = this.setupCamera();
    this.setupEvents(true);
    this.worlds.onItemSet.add(({ value: world }) => {
      const controls = this.newCameraControls();
      this._allControls.set(world.uuid, controls);
    });
    this.worlds.onBeforeDelete.add(({ value: world }) => {
      const controls = this._allControls.get(world.uuid);
      if (controls) {
        controls.dispose();
        this._allControls.delete(world.uuid);
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld) {
      throw new Error("This camera needs a world to work!");
    }
    const controls = this._allControls.get(this.currentWorld.uuid);
    if (!controls) {
      throw new Error("Controls not found!");
    }
    return controls;
  }
  /**
   * Getter for the enabled state of the camera controls.
   * If the current world is null, it returns false.
   * Otherwise, it returns the enabled state of the camera controls.
   *
   * @returns {boolean} The enabled state of the camera controls.
   */
  get enabled() {
    if (this.currentWorld === null) {
      return false;
    }
    return this.controls.enabled;
  }
  /**
   * Setter for the enabled state of the camera controls.
   * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
   *
   * @param {boolean} enabled - The new enabled state of the camera controls.
   */
  set enabled(enabled) {
    if (this.currentWorld !== null) {
      this.controls.enabled = enabled;
    }
  }
  set currentWorld(value) {
    super.currentWorld = value;
    if (!value)
      return;
    const existingWorld = this.worlds.get(value.uuid);
    if (!existingWorld)
      this.worlds.set(value.uuid, value);
  }
  get currentWorld() {
    return this._currentWorld;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false);
    this.onAspectUpdated.reset();
    this.onBeforeUpdate.reset();
    this.onAfterUpdate.reset();
    this.three.removeFromParent();
    this.onDisposed.trigger();
    this.onDisposed.reset();
    for (const [_id, controls] of this._allControls) {
      controls.dispose();
    }
    this.worlds.clear();
  }
  async fitToItems(items) {
    const sphere = await this.getItemsBounding(items);
    await this.controls.fitToSphere(sphere, true);
  }
  async setOrbitToItems(items) {
    const sphere = await this.getItemsBounding(items);
    this.controls.setOrbitPoint(
      sphere.center.x,
      sphere.center.y,
      sphere.center.z
    );
  }
  /** {@link Updateable.update} */
  update(_delta) {
    if (this.enabled) {
      this.onBeforeUpdate.trigger(this);
      this.controls.update(_delta);
      this.onAfterUpdate.trigger(this);
    }
  }
  async getItemsBounding(items) {
    const fragments = this.components.get(FragmentsManager);
    const boxer = this.components.get(BoundingBoxer);
    boxer.list.clear();
    const sphere = new THREE$1.Sphere();
    if (items) {
      await boxer.addFromModelIdMap(items);
    } else {
      for (const [, model] of fragments.list) {
        boxer.list.add(model.box);
      }
    }
    boxer.get().getBoundingSphere(sphere);
    boxer.list.clear();
    return sphere;
  }
  setupCamera() {
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new THREE$1.PerspectiveCamera(60, aspect, 1, 1e3);
    camera.position.set(50, 50, 50);
    camera.lookAt(new THREE$1.Vector3(0, 0, 0));
    return camera;
  }
  newCameraControls() {
    if (!this.currentWorld) {
      throw new Error("This camera needs a world to work!");
    }
    if (!this.currentWorld.renderer) {
      throw new Error("This camera needs a renderer to work!");
    }
    CameraControls.install({ THREE: SimpleCamera.getSubsetOfThree() });
    const { domElement } = this.currentWorld.renderer.three;
    const controls = new CameraControls(this.three, domElement);
    controls.smoothTime = 0.2;
    controls.dollyToCursor = true;
    controls.infinityDolly = true;
    controls.minDistance = 6;
    return controls;
  }
  setupEvents(active) {
    if (active) {
      window.addEventListener("resize", this.updateAspect);
    } else {
      window.removeEventListener("resize", this.updateAspect);
    }
  }
  static getSubsetOfThree() {
    return {
      MOUSE: THREE$1.MOUSE,
      Vector2: THREE$1.Vector2,
      Vector3: THREE$1.Vector3,
      Vector4: THREE$1.Vector4,
      Quaternion: THREE$1.Quaternion,
      Matrix4: THREE$1.Matrix4,
      Spherical: THREE$1.Spherical,
      Box3: THREE$1.Box3,
      Sphere: THREE$1.Sphere,
      Raycaster: THREE$1.Raycaster,
      MathUtils: THREE$1.MathUtils
    };
  }
}
const _Worlds = class _Worlds extends Component {
  constructor(components) {
    super(components);
    /** {@link Updateable.onAfterUpdate} */
    __publicField(this, "onAfterUpdate", new Event());
    /** {@link Updateable.onBeforeUpdate} */
    __publicField(this, "onBeforeUpdate", new Event());
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /**
     * A collection of worlds managed by this component.
     * The key is the unique identifier (UUID) of the world, and the value is the World instance.
     */
    __publicField(this, "list", new DataMap$1());
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    components.add(_Worlds.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const world = new SimpleWorld(this.components);
    const id = world.uuid;
    if (this.list.has(id)) {
      throw new Error("There is already a world with this name!");
    }
    this.list.set(id, world);
    return world;
  }
  /**
   * Deletes a world from the list of worlds.
   *
   * @param {World} world - The world to be deleted.
   *
   * @throws {Error} - Throws an error if the provided world is not found in the list.
   */
  delete(world) {
    if (!this.list.has(world.uuid)) {
      throw new Error("The provided world is not found in the list!");
    }
    this.list.delete(world.uuid);
    world.dispose();
  }
  /**
   * Disposes of the Worlds component and all its managed worlds.
   * This method sets the enabled flag to false, disposes of all worlds, clears the list,
   * and triggers the onDisposed event.
   */
  dispose() {
    this.enabled = false;
    for (const [_id, world] of this.list) {
      world.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update(delta) {
    if (!this.enabled)
      return;
    for (const [_id, world] of this.list) {
      world.update(delta);
    }
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_Worlds, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
let Worlds = _Worlds;
class SimpleGridConfigManager extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      visible: {
        value: true,
        type: "Boolean"
      },
      color: {
        value: new THREE$1.Color(),
        type: "Color"
      },
      primarySize: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1e3
      },
      secondarySize: {
        type: "Number",
        interpolable: true,
        value: 10,
        min: 0,
        max: 1e3
      },
      distance: {
        type: "Number",
        interpolable: true,
        value: 500,
        min: 0,
        max: 500
      }
    });
  }
  /**
   * Whether the grid is visible or not.
   */
  get visible() {
    return this._config.visible.value;
  }
  /**
   * Whether the grid is visible or not.
   */
  set visible(value) {
    this._config.visible.value = value;
    this._component.visible = value;
  }
  /**
   * The color of the grid lines.
   */
  get color() {
    return this._config.color.value;
  }
  /**
   * The color of the grid lines.
   */
  set color(value) {
    this._config.color.value = value;
    this._component.material.uniforms.uColor.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The size of the primary grid lines.
   */
  get primarySize() {
    return this._config.primarySize.value;
  }
  /**
   * The size of the primary grid lines.
   */
  set primarySize(value) {
    this._config.primarySize.value = value;
    this._component.material.uniforms.uSize1.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The size of the secondary grid lines.
   */
  get secondarySize() {
    return this._config.secondarySize.value;
  }
  /**
   * The size of the secondary grid lines.
   */
  set secondarySize(value) {
    this._config.secondarySize.value = value;
    this._component.material.uniforms.uSize2.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  get distance() {
    return this._config.distance.value;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  set distance(value) {
    this._config.distance.value = value;
    this._component.material.uniforms.uDistance.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
}
class SimpleGrid {
  constructor(components, world) {
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /** {@link Configurable.onSetup} */
    __publicField(this, "onSetup", new Event());
    /** {@link Configurable.isSetup} */
    __publicField(this, "isSetup", false);
    /** The world instance to which this Raycaster belongs. */
    __publicField(this, "world");
    /** The components instance to which this grid belongs. */
    __publicField(this, "components");
    /** {@link Configurable.config} */
    __publicField(this, "config");
    __publicField(this, "_defaultConfig", {
      visible: true,
      color: new THREE$1.Color(12303291),
      primarySize: 1,
      secondarySize: 10,
      distance: 500
    });
    /** The Three.js mesh that contains the infinite grid. */
    __publicField(this, "three");
    __publicField(this, "_fade", 3);
    __publicField(this, "updateZoom", () => {
      if (!(this.world.camera instanceof SimpleCamera)) {
        return;
      }
      this.material.uniforms.uZoom.value = this.world.camera.three.zoom;
    });
    this.world = world;
    const { color, primarySize, secondarySize, distance } = this._defaultConfig;
    this.components = components;
    this.config = new SimpleGridConfigManager(this, this.components, "Grid");
    const geometry = new THREE$1.PlaneGeometry(2, 2, 1, 1);
    const material = new THREE$1.ShaderMaterial({
      side: THREE$1.DoubleSide,
      uniforms: {
        uSize1: {
          value: primarySize
        },
        uSize2: {
          value: secondarySize
        },
        uColor: {
          value: color
        },
        uDistance: {
          value: distance
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: true
      }
    });
    this.three = new THREE$1.Mesh(geometry, material);
    this.three.frustumCulled = false;
    world.scene.three.add(this.three);
    this.setupEvents(true);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(visible) {
    this.three.visible = visible;
    if (visible) {
      const scene = this.world.scene.three;
      scene.add(this.three);
    } else {
      this.three.removeFromParent();
    }
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(active) {
    this._fade = active ? 3 : 0;
    this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.visible = true;
    this.config.color = fullConfig.color;
    this.config.primarySize = fullConfig.primarySize;
    this.config.secondarySize = fullConfig.secondarySize;
    this.config.distance = fullConfig.distance;
    this.isSetup = true;
    this.onSetup.trigger();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false);
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
    const disposer = this.components.get(Disposer);
    disposer.destroy(this.three);
    this.onDisposed.trigger();
    this.onDisposed.reset();
    this.world = null;
    this.components = null;
  }
  setupEvents(active) {
    if (this.world.isDisposing) {
      return;
    }
    if (!(this.world.camera instanceof SimpleCamera)) {
      return;
    }
    const controls = this.world.camera.controls;
    if (active) {
      controls.addEventListener("update", this.updateZoom);
    } else {
      controls.removeEventListener("update", this.updateZoom);
    }
  }
}
const _Grids = class _Grids extends Component {
  constructor(components) {
    super(components);
    /**
     * A map of world UUIDs to their corresponding grid instances.
     */
    __publicField(this, "list", /* @__PURE__ */ new Map());
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    components.add(_Grids.uuid, this);
  }
  /**
   * Creates a new grid for the given world.
   * Throws an error if a grid already exists for the world.
   *
   * @param world - The world to create the grid for.
   * @returns The newly created grid.
   *
   * @throws Will throw an error if a grid already exists for the given world.
   */
  create(world) {
    if (this.list.has(world.uuid)) {
      throw new Error("This world already has a grid!");
    }
    const grid = new SimpleGrid(this.components, world);
    this.list.set(world.uuid, grid);
    world.onDisposed.add(() => {
      this.delete(world);
    });
    return grid;
  }
  /**
   * Deletes the grid associated with the given world.
   * If a grid does not exist for the given world, this method does nothing.
   *
   * @param world - The world for which to delete the grid.
   *
   * @remarks
   * This method will dispose of the grid and remove it from the internal list.
   * If the world is disposed before calling this method, the grid will be automatically deleted.
   */
  delete(world) {
    const grid = this.list.get(world.uuid);
    if (grid) {
      grid.dispose();
    }
    this.list.delete(world.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, grid] of this.list) {
      grid.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_Grids, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
let Grids = _Grids;
const CENTER = 0;
const AVERAGE = 1;
const SAH = 2;
const CONTAINED = 2;
const TRIANGLE_INTERSECT_COST = 1.25;
const TRAVERSAL_COST = 1;
const BYTES_PER_NODE = 6 * 4 + 4 + 4;
const IS_LEAFNODE_FLAG = 65535;
const FLOAT32_EPSILON = Math.pow(2, -24);
const SKIP_GENERATION = Symbol("SKIP_GENERATION");
function getVertexCount(geo) {
  return geo.index ? geo.index.count : geo.attributes.position.count;
}
function getTriCount(geo) {
  return getVertexCount(geo) / 3;
}
function getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {
  if (vertexCount > 65535) {
    return new Uint32Array(new BufferConstructor(4 * vertexCount));
  } else {
    return new Uint16Array(new BufferConstructor(2 * vertexCount));
  }
}
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    const index = getIndexArray(vertexCount, BufferConstructor);
    geo.setIndex(new BufferAttribute(index, 1));
    for (let i = 0; i < vertexCount; i++) {
      index[i] = i;
    }
  }
}
function getFullGeometryRange(geo) {
  const triCount = getTriCount(geo);
  const drawRange = geo.drawRange;
  const start = drawRange.start / 3;
  const end = (drawRange.start + drawRange.count) / 3;
  const offset = Math.max(0, start);
  const count = Math.min(triCount, end) - offset;
  return [{
    offset: Math.floor(offset),
    count: Math.floor(count)
  }];
}
function getRootIndexRanges(geo) {
  if (!geo.groups || !geo.groups.length) {
    return getFullGeometryRange(geo);
  }
  const ranges = [];
  const rangeBoundaries = /* @__PURE__ */ new Set();
  const drawRange = geo.drawRange;
  const drawRangeStart = drawRange.start / 3;
  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;
  for (const group of geo.groups) {
    const groupStart = group.start / 3;
    const groupEnd = (group.start + group.count) / 3;
    rangeBoundaries.add(Math.max(drawRangeStart, groupStart));
    rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));
  }
  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);
  for (let i = 0; i < sortedBoundaries.length - 1; i++) {
    const start = sortedBoundaries[i];
    const end = sortedBoundaries[i + 1];
    ranges.push({
      offset: Math.floor(start),
      count: Math.floor(end - start)
    });
  }
  return ranges;
}
function hasGroupGaps(geometry) {
  if (geometry.groups.length === 0) {
    return false;
  }
  const vertexCount = getTriCount(geometry);
  const groups = getRootIndexRanges(geometry).sort((a, b) => a.offset - b.offset);
  const finalGroup = groups[groups.length - 1];
  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);
  let total = 0;
  groups.forEach(({ count }) => total += count);
  return vertexCount !== total;
}
function arrayToBox(nodeIndex32, array, target) {
  target.min.x = array[nodeIndex32];
  target.min.y = array[nodeIndex32 + 1];
  target.min.z = array[nodeIndex32 + 2];
  target.max.x = array[nodeIndex32 + 3];
  target.max.y = array[nodeIndex32 + 4];
  target.max.z = array[nodeIndex32 + 5];
  return target;
}
function makeEmptyBounds(target) {
  target[0] = target[1] = target[2] = Infinity;
  target[3] = target[4] = target[5] = -Infinity;
}
function getLongestEdgeIndex(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i = 0; i < 3; i++) {
    const dist = bounds[i + 3] - bounds[i];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i;
    }
  }
  return splitDimIdx;
}
function copyBounds(source, target) {
  target.set(source);
}
function unionBounds(a, b, target) {
  let aVal, bVal;
  for (let d = 0; d < 3; d++) {
    const d3 = d + 3;
    aVal = a[d];
    bVal = b[d];
    target[d] = aVal < bVal ? aVal : bVal;
    aVal = a[d3];
    bVal = b[d3];
    target[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds(startIndex, triangleBounds, bounds) {
  for (let d = 0; d < 3; d++) {
    const tCenter = triangleBounds[startIndex + 2 * d];
    const tHalf = triangleBounds[startIndex + 2 * d + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d]) {
      bounds[d] = tMin;
    }
    if (tMax > bounds[d + 3]) {
      bounds[d + 3] = tMax;
    }
  }
}
function computeSurfaceArea(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}
function getBounds(triangleBounds, offset, count, target, centroidTarget = null) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  const includeCentroid = centroidTarget !== null;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    const hx = triangleBounds[i + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx)
      minx = lx;
    if (rx > maxx)
      maxx = rx;
    if (includeCentroid && cx < cminx)
      cminx = cx;
    if (includeCentroid && cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    const hy = triangleBounds[i + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny)
      miny = ly;
    if (ry > maxy)
      maxy = ry;
    if (includeCentroid && cy < cminy)
      cminy = cy;
    if (includeCentroid && cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    const hz = triangleBounds[i + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz)
      minz = lz;
    if (rz > maxz)
      maxz = rz;
    if (includeCentroid && cz < cminz)
      cminz = cz;
    if (includeCentroid && cz > cmaxz)
      cmaxz = cz;
  }
  target[0] = minx;
  target[1] = miny;
  target[2] = minz;
  target[3] = maxx;
  target[4] = maxy;
  target[5] = maxz;
  if (includeCentroid) {
    centroidTarget[0] = cminx;
    centroidTarget[1] = cminy;
    centroidTarget[2] = cminz;
    centroidTarget[3] = cmaxx;
    centroidTarget[4] = cmaxy;
    centroidTarget[5] = cmaxz;
  }
}
function getCentroidBounds(triangleBounds, offset, count, centroidTarget) {
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    if (cx < cminx)
      cminx = cx;
    if (cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    if (cy < cminy)
      cminy = cy;
    if (cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    if (cz < cminz)
      cminz = cz;
    if (cz > cmaxz)
      cmaxz = cz;
  }
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function computeTriangleBounds(geo, fullBounds) {
  makeEmptyBounds(fullBounds);
  const posAttr = geo.attributes.position;
  const index = geo.index ? geo.index.array : null;
  const triCount = getTriCount(geo);
  const triangleBounds = new Float32Array(triCount * 6);
  const normalized = posAttr.normalized;
  const posArr = posAttr.array;
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  const getters = ["getX", "getY", "getZ"];
  for (let tri = 0; tri < triCount; tri++) {
    const tri3 = tri * 3;
    const tri6 = tri * 6;
    let ai = tri3 + 0;
    let bi = tri3 + 1;
    let ci = tri3 + 2;
    if (index) {
      ai = index[ai];
      bi = index[bi];
      ci = index[ci];
    }
    if (!normalized) {
      ai = ai * stride + bufferOffset;
      bi = bi * stride + bufferOffset;
      ci = ci * stride + bufferOffset;
    }
    for (let el = 0; el < 3; el++) {
      let a, b, c;
      if (normalized) {
        a = posAttr[getters[el]](ai);
        b = posAttr[getters[el]](bi);
        c = posAttr[getters[el]](ci);
      } else {
        a = posArr[ai + el];
        b = posArr[bi + el];
        c = posArr[ci + el];
      }
      let min = a;
      if (b < min)
        min = b;
      if (c < min)
        min = c;
      let max = a;
      if (b > max)
        max = b;
      if (c > max)
        max = c;
      const halfExtents = (max - min) / 2;
      const el2 = el * 2;
      triangleBounds[tri6 + el2 + 0] = min + halfExtents;
      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;
      if (min < fullBounds[el])
        fullBounds[el] = min;
      if (max > fullBounds[el + 3])
        fullBounds[el + 3] = max;
    }
  }
  return triangleBounds;
}
const BIN_COUNT = 32;
const binsSort = (a, b) => a.candidate - b.candidate;
const sahBins = new Array(BIN_COUNT).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
const leftBounds = new Float32Array(6);
function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER) {
    axis = getLongestEdgeIndex(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE) {
    axis = getLongestEdgeIndex(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH) {
    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST * count;
    const cStart = offset * 6;
    const cEnd = (offset + count) * 6;
    for (let a = 0; a < 3; a++) {
      const axisLeft = centroidBoundingData[a];
      const axisRight = centroidBoundingData[a + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT;
      if (count < BIN_COUNT / 4) {
        const truncatedBins = [...sahBins];
        truncatedBins.length = count;
        let b = 0;
        for (let c = cStart; c < cEnd; c += 6, b++) {
          const bin = truncatedBins[b];
          bin.candidate = triangleBounds[c + 2 * a];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d = 0; d < 3; d++) {
            rightCacheBounds[d] = Infinity;
            rightCacheBounds[d + 3] = -Infinity;
            leftCacheBounds[d] = Infinity;
            leftCacheBounds[d + 3] = -Infinity;
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
          expandByTriangleBounds(c, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort);
        let splitCount = count;
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi + 1, 1);
            splitCount--;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const center = triangleBounds[c + 2 * a];
          for (let bi = 0; bi < splitCount; bi++) {
            const bin = truncatedBins[bi];
            if (center >= bin.candidate) {
              expandByTriangleBounds(c, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds(c, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds2 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds2) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i = 0; i < BIN_COUNT; i++) {
          const bin = sahBins[i];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i * binWidth;
          const bounds = bin.bounds;
          for (let d = 0; d < 3; d++) {
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const triCenter = triangleBounds[c + 2 * a];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT)
            binIndex = BIN_COUNT - 1;
          const bin = sahBins[binIndex];
          bin.count++;
          expandByTriangleBounds(c, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins[BIN_COUNT - 1];
        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i = BIN_COUNT - 2; i >= 0; i--) {
          const bin = sahBins[i];
          const nextBin = sahBins[i + 1];
          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i = 0; i < BIN_COUNT - 1; i++) {
          const bin = sahBins[i];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins[i + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds(bounds, leftBounds);
            } else {
              unionBounds(bounds, leftBounds, leftBounds);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage(triangleBounds, offset, count, axis) {
  let avg = 0;
  for (let i = offset, end = offset + count; i < end; i++) {
    avg += triangleBounds[i * 6 + axis * 2];
  }
  return avg / count;
}
class MeshBVHNode {
  constructor() {
  }
}
function partition(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i = 0; i < 3; i++) {
        let t0 = index[left * 3 + i];
        index[left * 3 + i] = index[right * 3 + i];
        index[right * 3 + i] = t0;
      }
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
function partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      let t = indirectBuffer[left];
      indirectBuffer[left] = indirectBuffer[right];
      indirectBuffer[right] = t;
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
function generateIndirectBuffer(geometry, useSharedArrayBuffer) {
  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;
  const useUint32 = triCount > 2 ** 16;
  const byteCount = useUint32 ? 4 : 2;
  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);
  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);
  for (let i = 0, l = indirectBuffer.length; i < l; i++) {
    indirectBuffer[i] = i;
  }
  return indirectBuffer;
}
function buildTree(bvh, options) {
  const geometry = bvh.geometry;
  const indexArray = geometry.index ? geometry.index.array : null;
  const maxDepth = options.maxDepth;
  const verbose = options.verbose;
  const maxLeafTris = options.maxLeafTris;
  const strategy = options.strategy;
  const onProgress = options.onProgress;
  const totalTriangles = getTriCount(geometry);
  const indirectBuffer = bvh._indirectBuffer;
  let reachedMaxDepth = false;
  const fullBounds = new Float32Array(6);
  const cacheCentroidBoundingData = new Float32Array(6);
  const triangleBounds = computeTriangleBounds(geometry, fullBounds);
  const partionFunc = options.indirect ? partition_indirect : partition;
  const roots = [];
  const ranges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);
  if (ranges.length === 1) {
    const range = ranges[0];
    const root = new MeshBVHNode();
    root.boundingData = fullBounds;
    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);
    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
    roots.push(root);
  } else {
    for (let range of ranges) {
      const root = new MeshBVHNode();
      root.boundingData = new Float32Array(6);
      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);
      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
      roots.push(root);
    }
  }
  return roots;
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geometry);
      }
    }
    if (count <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);
    if (split.axis === -1) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);
    if (splitOffset === offset || splitOffset === offset + count) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode();
      const lstart = offset;
      const lcount = splitOffset - offset;
      node.left = left;
      left.boundingData = new Float32Array(6);
      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode();
      const rstart = splitOffset;
      const rcount = count - lcount;
      node.right = right;
      right.boundingData = new Float32Array(6);
      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
}
function buildPackedTree(bvh, options) {
  const geometry = bvh.geometry;
  if (options.indirect) {
    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);
    if (hasGroupGaps(geometry) && !options.verbose) {
      console.warn(
        'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
      );
    }
  }
  if (!bvh._indirectBuffer) {
    ensureIndex(geometry, options);
  }
  const roots = buildTree(bvh, options);
  let float32Array;
  let uint32Array;
  let uint16Array;
  const packedRoots = [];
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let i = 0; i < roots.length; i++) {
    const root = roots[i];
    let nodeCount = countNodes(root);
    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);
    float32Array = new Float32Array(buffer);
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    populateBuffer(0, root);
    packedRoots.push(buffer);
  }
  bvh._roots = packedRoots;
  return;
  function countNodes(node) {
    if (node.count) {
      return 1;
    } else {
      return 1 + countNodes(node.left) + countNodes(node.right);
    }
  }
  function populateBuffer(byteOffset, node) {
    const stride4Offset = byteOffset / 4;
    const stride2Offset = byteOffset / 2;
    const isLeaf = !!node.count;
    const boundingData = node.boundingData;
    for (let i = 0; i < 6; i++) {
      float32Array[stride4Offset + i] = boundingData[i];
    }
    if (isLeaf) {
      const offset = node.offset;
      const count = node.count;
      uint32Array[stride4Offset + 6] = offset;
      uint16Array[stride2Offset + 14] = count;
      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;
      return byteOffset + BYTES_PER_NODE;
    } else {
      const left = node.left;
      const right = node.right;
      const splitAxis = node.splitAxis;
      let nextUnusedPointer;
      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);
      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      }
      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;
      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);
      uint32Array[stride4Offset + 7] = splitAxis;
      return nextUnusedPointer;
    }
  }
}
class SeparatingAxisBounds {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val2 = p[field];
      min = val2 < min ? val2 : min;
      max = val2 > max ? val2 : max;
    }
    this.min = min;
    this.max = max;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val2 = axis.dot(p);
      min = val2 < min ? val2 : min;
      max = val2 > max ? val2 : max;
    }
    this.min = min;
    this.max = max;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
}
SeparatingAxisBounds.prototype.setFromBox = function() {
  const p = new Vector3();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y + boxMax.y * (1 - y);
          p.z = boxMin.z * z + boxMax.z * (1 - z);
          const val2 = axis.dot(p);
          min = Math.min(val2, min);
          max = Math.max(val2, max);
        }
      }
    }
    this.min = min;
    this.max = max;
  };
}();
const closestPointLineToLine = function() {
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const v02 = new Vector3();
  return function closestPointLineToLine2(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v2 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v2);
    dir1.subVectors(l1.end, l1.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d, d2;
    if (denom !== 0) {
      d = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d = 0;
    }
    d2 = (d0232 + d * d3210) / d3232;
    result.x = d;
    result.y = d2;
  };
}();
const closestPointsSegmentToSegment = function() {
  const paramResult = new Vector2();
  const temp12 = new Vector3();
  const temp22 = new Vector3();
  return function closestPointsSegmentToSegment2(l1, l2, target1, target2) {
    closestPointLineToLine(l1, l2, paramResult);
    let d = paramResult.x;
    let d2 = paramResult.y;
    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {
      l1.at(d, target1);
      l2.at(d2, target2);
      return;
    } else if (d >= 0 && d <= 1) {
      if (d2 < 0) {
        l2.at(0, target2);
      } else {
        l2.at(1, target2);
      }
      l1.closestPointToPoint(target2, true, target1);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target2);
      return;
    } else {
      let p;
      if (d < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d2 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp12;
      const closestPoint2 = temp22;
      l1.closestPointToPoint(p2, true, temp12);
      l2.closestPointToPoint(p, true, temp22);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target2.copy(p2);
        return;
      } else {
        target1.copy(p);
        target2.copy(closestPoint2);
        return;
      }
    }
  };
}();
const sphereIntersectTriangle = function() {
  const closestPointTemp = new Vector3();
  const projectedPointTemp = new Vector3();
  const planeTemp = new Plane();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle2(sphere, triangle3) {
    const { radius, center } = sphere;
    const { a, b, c } = triangle3;
    lineTemp.start = a;
    lineTemp.end = b;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius)
      return true;
    lineTemp.start = a;
    lineTemp.end = c;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius)
      return true;
    lineTemp.start = b;
    lineTemp.end = c;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius)
      return true;
    const plane = triangle3.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle3.containsPoint(pp);
      if (cp)
        return true;
    }
    return false;
  };
}();
const ZERO_EPSILON = 1e-15;
function isNearZero(value) {
  return Math.abs(value) < ZERO_EPSILON;
}
class ExtendedTriangle extends Triangle {
  constructor(...args) {
    super(...args);
    this.isExtendedTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector3());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());
    this.points = [this.a, this.b, this.c];
    this.sphere = new Sphere();
    this.plane = new Plane();
    this.needsUpdate = true;
  }
  intersectsSphere(sphere) {
    return sphereIntersectTriangle(sphere, this);
  }
  update() {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a, b);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b, c);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c, a);
    sab3.setFromPoints(axis3, points);
    this.sphere.setFromPoints(this.points);
    this.plane.setFromNormalAndCoplanarPoint(axis0, a);
    this.needsUpdate = false;
  }
}
ExtendedTriangle.prototype.closestPointToSegment = function() {
  const point1 = new Vector3();
  const point2 = new Vector3();
  const edge = new Line3();
  return function distanceToSegment(segment, target1 = null, target2 = null) {
    const { start, end } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      const nexti = (i + 1) % 3;
      edge.start.copy(points[i]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
    }
    this.closestPointToPoint(start, point1);
    distSq = start.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(start);
    }
    this.closestPointToPoint(end, point1);
    distSq = end.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(end);
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
ExtendedTriangle.prototype.intersectsTriangle = function() {
  const saTri2 = new ExtendedTriangle();
  const arr1 = new Array(3);
  const arr2 = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  const dir = new Vector3();
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const tempDir = new Vector3();
  const edge = new Line3();
  const edge1 = new Line3();
  const edge2 = new Line3();
  const tempPoint = new Vector3();
  function triIntersectPlane(tri, plane, targetEdge) {
    const points = tri.points;
    let count = 0;
    let startPointIntersection = -1;
    for (let i = 0; i < 3; i++) {
      const { start, end } = edge;
      start.copy(points[i]);
      end.copy(points[(i + 1) % 3]);
      edge.delta(dir);
      const startIntersects = isNearZero(plane.distanceToPoint(start));
      if (isNearZero(plane.normal.dot(dir)) && startIntersects) {
        targetEdge.copy(edge);
        count = 2;
        break;
      }
      const doesIntersect = plane.intersectLine(edge, tempPoint);
      if (!doesIntersect && startIntersects) {
        tempPoint.copy(start);
      }
      if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {
        if (count <= 1) {
          const point = count === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          if (startIntersects) {
            startPointIntersection = count;
          }
        } else if (count >= 2) {
          const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          count = 2;
          break;
        }
        count++;
        if (count === 2 && startPointIntersection === -1) {
          break;
        }
      }
    }
    return count;
  }
  return function intersectsTriangle(other, target = null, suppressLog = false) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isExtendedTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const plane1 = this.plane;
    const plane2 = other.plane;
    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {
      const satBounds1 = this.satBounds;
      const satAxes1 = this.satAxes;
      arr2[0] = other.a;
      arr2[1] = other.b;
      arr2[2] = other.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds1[i];
        const sa = satAxes1[i];
        cachedSatBounds.setFromPoints(sa, arr2);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      const satBounds2 = other.satBounds;
      const satAxes2 = other.satAxes;
      arr1[0] = this.a;
      arr1[1] = this.b;
      arr1[2] = this.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds2[i];
        const sa = satAxes2[i];
        cachedSatBounds.setFromPoints(sa, arr1);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      for (let i = 0; i < 4; i++) {
        const sa1 = satAxes1[i];
        for (let i2 = 0; i2 < 4; i2++) {
          const sa2 = satAxes2[i2];
          cachedAxis.crossVectors(sa1, sa2);
          cachedSatBounds.setFromPoints(cachedAxis, arr1);
          cachedSatBounds2.setFromPoints(cachedAxis, arr2);
          if (cachedSatBounds.isSeparated(cachedSatBounds2))
            return false;
        }
      }
      if (target) {
        if (!suppressLog) {
          console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
        }
        target.start.set(0, 0, 0);
        target.end.set(0, 0, 0);
      }
      return true;
    } else {
      const count1 = triIntersectPlane(this, plane2, edge1);
      if (count1 === 1 && other.containsPoint(edge1.end)) {
        if (target) {
          target.start.copy(edge1.end);
          target.end.copy(edge1.end);
        }
        return true;
      } else if (count1 !== 2) {
        return false;
      }
      const count2 = triIntersectPlane(other, plane1, edge2);
      if (count2 === 1 && this.containsPoint(edge2.end)) {
        if (target) {
          target.start.copy(edge2.end);
          target.end.copy(edge2.end);
        }
        return true;
      } else if (count2 !== 2) {
        return false;
      }
      edge1.delta(dir1);
      edge2.delta(dir2);
      if (dir1.dot(dir2) < 0) {
        let tmp = edge2.start;
        edge2.start = edge2.end;
        edge2.end = tmp;
      }
      const s1 = edge1.start.dot(dir1);
      const e1 = edge1.end.dot(dir1);
      const s2 = edge2.start.dot(dir1);
      const e2 = edge2.end.dot(dir1);
      const separated1 = e1 < s2;
      const separated2 = s1 < e2;
      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {
        return false;
      }
      if (target) {
        tempDir.subVectors(edge1.start, edge2.start);
        if (tempDir.dot(dir1) > 0) {
          target.start.copy(edge1.start);
        } else {
          target.start.copy(edge2.start);
        }
        tempDir.subVectors(edge1.end, edge2.end);
        if (tempDir.dot(dir1) < 0) {
          target.end.copy(edge1.end);
        } else {
          target.end.copy(edge2.end);
        }
      }
      return true;
    }
  };
}();
ExtendedTriangle.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
ExtendedTriangle.prototype.distanceToTriangle = function() {
  const point = new Vector3();
  const point2 = new Vector3();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line3();
  const line2 = new Line3();
  return function distanceToTriangle(other, target1 = null, target2 = null) {
    const lineTarget = target1 || target2 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target2) {
        if (target1)
          lineTarget.getCenter(target1);
        if (target2)
          lineTarget.getCenter(target2);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      let dist;
      const field = cornerFields[i];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(point);
        if (target2)
          target2.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(thisVec);
        if (target2)
          target2.copy(point);
      }
    }
    for (let i = 0; i < 3; i++) {
      const f11 = cornerFields[i];
      const f12 = cornerFields[(i + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i2 = 0; i2 < 3; i2++) {
        const f21 = cornerFields[i2];
        const f22 = cornerFields[(i2 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point);
          if (target2)
            target2.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
class OrientedBox {
  constructor(min, max, matrix) {
    this.isOrientedBox = true;
    this.min = new Vector3();
    this.max = new Vector3();
    this.matrix = new Matrix4();
    this.invMatrix = new Matrix4();
    this.points = new Array(8).fill().map(() => new Vector3());
    this.satAxes = new Array(3).fill().map(() => new Vector3());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.needsUpdate = false;
    if (min)
      this.min.copy(min);
    if (max)
      this.max.copy(max);
    if (matrix)
      this.matrix.copy(matrix);
  }
  set(min, max, matrix) {
    this.min.copy(min);
    this.max.copy(max);
    this.matrix.copy(matrix);
    this.needsUpdate = true;
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
}
OrientedBox.prototype.update = /* @__PURE__ */ function() {
  return function update() {
    const matrix = this.matrix;
    const min = this.min;
    const max = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;
          const v = points[i];
          v.x = x ? max.x : min.x;
          v.y = y ? max.y : min.y;
          v.z = z ? max.z : min.z;
          v.applyMatrix4(matrix);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      const index = 1 << i;
      const pi = points[index];
      axis.subVectors(minVec, pi);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
}();
OrientedBox.prototype.intersectsBox = function() {
  const aabbBounds = new SeparatingAxisBounds();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds))
      return false;
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds))
        return false;
    }
    return true;
  };
}();
OrientedBox.prototype.intersectsTriangle = function() {
  const saTri = new ExtendedTriangle();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  return function intersectsTriangle(triangle3) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle3.isExtendedTriangle) {
      saTri.copy(triangle3);
      saTri.update();
      triangle3 = saTri;
    } else if (triangle3.needsUpdate) {
      triangle3.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle3.a;
    pointsArr[1] = triangle3.b;
    pointsArr[2] = triangle3.c;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds[i];
      const sa = satAxes[i];
      cachedSatBounds.setFromPoints(sa, pointsArr);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    const triSatBounds = triangle3.satBounds;
    const triSatAxes = triangle3.satAxes;
    const points = this.points;
    for (let i = 0; i < 3; i++) {
      const sb = triSatBounds[i];
      const sa = triSatAxes[i];
      cachedSatBounds.setFromPoints(sa, points);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    for (let i = 0; i < 3; i++) {
      const sa1 = satAxes[i];
      for (let i2 = 0; i2 < 4; i2++) {
        const sa2 = triSatAxes[i2];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2))
          return false;
      }
    }
    return true;
  };
}();
OrientedBox.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function closestPointToPoint2(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
}();
OrientedBox.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
OrientedBox.prototype.distanceToBox = function() {
  const xyzFields = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line3());
  const segments2 = new Array(12).fill().map(() => new Line3());
  const point1 = new Vector3();
  const point2 = new Vector3();
  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target2) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 8; i++) {
      const p = points[i];
      point2.copy(p).clamp(min, max);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(p);
        if (target2)
          target2.copy(point2);
        if (dist < threshold2)
          return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i = 0; i < 3; i++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i2 = 0; i2 <= 1; i2++) {
          const nextIndex = (i + 1) % 3;
          const nextIndex2 = (i + 2) % 3;
          const index = i1 << nextIndex | i2 << nextIndex2;
          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields[i];
          const f2 = xyzFields[nextIndex];
          const f3 = xyzFields[nextIndex2];
          const line2 = segments2[count];
          const start = line2.start;
          const end = line2.end;
          start[f1] = min[f1];
          start[f2] = i1 ? min[f2] : max[f2];
          start[f3] = i2 ? min[f3] : max[f2];
          end[f1] = max[f1];
          end[f2] = i1 ? min[f2] : max[f2];
          end[f3] = i2 ? min[f3] : max[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          point2.x = x ? max.x : min.x;
          point2.y = y ? max.y : min.y;
          point2.z = z ? max.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1)
              target1.copy(point1);
            if (target2)
              target2.copy(point2);
            if (dist < threshold2)
              return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i = 0; i < 12; i++) {
      const l1 = segments1[i];
      for (let i2 = 0; i2 < 12; i2++) {
        const l2 = segments2[i2];
        closestPointsSegmentToSegment(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point1);
          if (target2)
            target2.copy(point2);
          if (dist < threshold2)
            return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
class PrimitivePool {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives = this._primitives;
    if (primitives.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
}
class ExtendedTrianglePoolBase extends PrimitivePool {
  constructor() {
    super(() => new ExtendedTriangle());
  }
}
const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();
function IS_LEAF(n16, uint16Array) {
  return uint16Array[n16 + 15] === 65535;
}
function OFFSET(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function COUNT(n16, uint16Array) {
  return uint16Array[n16 + 14];
}
function LEFT_NODE(n32) {
  return n32 + 8;
}
function RIGHT_NODE(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function SPLIT_AXIS(n32, uint32Array) {
  return uint32Array[n32 + 7];
}
function BOUNDING_DATA_INDEX(n32) {
  return n32;
}
class _BufferStack {
  constructor() {
    this.float32Array = null;
    this.uint16Array = null;
    this.uint32Array = null;
    const stack = [];
    let prevBuffer = null;
    this.setBuffer = (buffer) => {
      if (prevBuffer) {
        stack.push(prevBuffer);
      }
      prevBuffer = buffer;
      this.float32Array = new Float32Array(buffer);
      this.uint16Array = new Uint16Array(buffer);
      this.uint32Array = new Uint32Array(buffer);
    };
    this.clearBuffer = () => {
      prevBuffer = null;
      this.float32Array = null;
      this.uint16Array = null;
      this.uint32Array = null;
      if (stack.length !== 0) {
        this.setBuffer(stack.pop());
      }
    };
  }
}
const BufferStack = new _BufferStack();
let _box1, _box2;
const boxStack = [];
const boxPool = /* @__PURE__ */ new PrimitivePool(() => new Box3());
function shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {
  _box1 = boxPool.getPrimitive();
  _box2 = boxPool.getPrimitive();
  boxStack.push(_box1, _box2);
  BufferStack.setBuffer(bvh._roots[root]);
  const result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
  BufferStack.clearBuffer();
  boxPool.releasePrimitive(_box1);
  boxPool.releasePrimitive(_box2);
  boxStack.pop();
  boxStack.pop();
  const length = boxStack.length;
  if (length > 0) {
    _box2 = boxStack[length - 1];
    _box1 = boxStack[length - 2];
  }
  return result;
}
function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);
    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);
  } else {
    let getLeftOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = LEFT_NODE(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2);
    }, getRightEndOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array2);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2) + COUNT(nodeIndex162, uint16Array2);
    };
    const left = LEFT_NODE(nodeIndex32);
    const right = RIGHT_NODE(nodeIndex32, uint32Array);
    let c1 = left;
    let c2 = right;
    let score1, score2;
    let box1, box2;
    if (nodeScoreFunc) {
      box1 = _box1;
      box2 = _box2;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);
      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);
      score1 = nodeScoreFunc(box1);
      score2 = nodeScoreFunc(box2);
      if (score2 < score1) {
        c1 = right;
        c2 = left;
        const temp5 = score1;
        score1 = score2;
        score2 = temp5;
        box1 = box2;
      }
    }
    if (!box1) {
      box1 = _box1;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);
    }
    const isC1Leaf = IS_LEAF(c1 * 2, uint16Array);
    const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);
    let c1StopTraversal;
    if (c1Intersection === CONTAINED) {
      const offset = getLeftOffset(c1);
      const end = getRightEndOffset(c1);
      const count = end - offset;
      c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);
    } else {
      c1StopTraversal = c1Intersection && shapecastTraverse(
        c1,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c1StopTraversal)
      return true;
    box2 = _box2;
    arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);
    const isC2Leaf = IS_LEAF(c2 * 2, uint16Array);
    const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);
    let c2StopTraversal;
    if (c2Intersection === CONTAINED) {
      const offset = getLeftOffset(c2);
      const end = getRightEndOffset(c2);
      const count = end - offset;
      c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);
    } else {
      c2StopTraversal = c2Intersection && shapecastTraverse(
        c2,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c2StopTraversal)
      return true;
    return false;
  }
}
const temp = /* @__PURE__ */ new Vector3();
const temp1$2 = /* @__PURE__ */ new Vector3();
function closestPointToPoint(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
  const minThresholdSq = minThreshold * minThreshold;
  const maxThresholdSq = maxThreshold * maxThreshold;
  let closestDistanceSq = Infinity;
  let closestDistanceTriIndex = null;
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        temp.copy(point).clamp(box.min, box.max);
        return temp.distanceToSquared(point);
      },
      intersectsBounds: (box, isLeaf, score) => {
        return score < closestDistanceSq && score < maxThresholdSq;
      },
      intersectsTriangle: (tri, triIndex) => {
        tri.closestPointToPoint(point, temp);
        const distSq = point.distanceToSquared(temp);
        if (distSq < closestDistanceSq) {
          temp1$2.copy(temp);
          closestDistanceSq = distSq;
          closestDistanceTriIndex = triIndex;
        }
        if (distSq < minThresholdSq) {
          return true;
        } else {
          return false;
        }
      }
    }
  );
  if (closestDistanceSq === Infinity)
    return null;
  const closestDistance = Math.sqrt(closestDistanceSq);
  if (!target.point)
    target.point = temp1$2.clone();
  else
    target.point.copy(temp1$2);
  target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;
  return target;
}
const _vA = /* @__PURE__ */ new Vector3();
const _vB = /* @__PURE__ */ new Vector3();
const _vC = /* @__PURE__ */ new Vector3();
const _uvA = /* @__PURE__ */ new Vector2();
const _uvB = /* @__PURE__ */ new Vector2();
const _uvC = /* @__PURE__ */ new Vector2();
const _normalA = /* @__PURE__ */ new Vector3();
const _normalB = /* @__PURE__ */ new Vector3();
const _normalC = /* @__PURE__ */ new Vector3();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
function checkIntersection(ray2, pA, pB, pC, point, side) {
  let intersect;
  if (side === BackSide) {
    intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray2.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  const distance = ray2.origin.distanceTo(point);
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection(ray2, position, normal, uv, uv1, a, b, c, side) {
  _vA.fromBufferAttribute(position, a);
  _vB.fromBufferAttribute(position, b);
  _vC.fromBufferAttribute(position, c);
  const intersection = checkIntersection(ray2, _vA, _vB, _vC, _intersectionPoint, side);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);
      _uvB.fromBufferAttribute(uv, b);
      _uvC.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv1) {
      _uvA.fromBufferAttribute(uv1, a);
      _uvB.fromBufferAttribute(uv1, b);
      _uvC.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3());
      if (intersection.normal.dot(ray2.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
    intersection.faceIndex = a;
  }
  return intersection;
}
function intersectTri(geo, side, ray2, tri, intersections) {
  const triOffset = tri * 3;
  let a = triOffset + 0;
  let b = triOffset + 1;
  let c = triOffset + 2;
  const index = geo.index;
  if (geo.index) {
    a = index.getX(a);
    b = index.getX(b);
    c = index.getX(c);
  }
  const { position, normal, uv, uv1 } = geo.attributes;
  const intersection = checkBufferGeometryIntersection(ray2, position, normal, uv, uv1, a, b, c, side);
  if (intersection) {
    intersection.faceIndex = tri;
    if (intersections)
      intersections.push(intersection);
    return intersection;
  }
  return null;
}
function setTriangle(tri, i, index, pos) {
  const ta = tri.a;
  const tb = tri.b;
  const tc = tri.c;
  let i0 = i;
  let i1 = i + 1;
  let i2 = i + 2;
  if (index) {
    i0 = index.getX(i0);
    i1 = index.getX(i1);
    i2 = index.getX(i2);
  }
  ta.x = pos.getX(i0);
  ta.y = pos.getY(i0);
  ta.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc.x = pos.getX(i2);
  tc.y = pos.getY(i2);
  tc.z = pos.getZ(i2);
}
function intersectTris(bvh, side, ray2, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    intersectTri(geometry, side, ray2, i, intersections);
  }
}
function intersectClosestTri(bvh, side, ray2, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray2, i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle3) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = i;
    setTriangle(triangle3, tri * 3, index, pos);
    triangle3.needsUpdate = true;
    if (intersectsTriangleFunc(triangle3, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}
function refit(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {
        let index = indexArr[i];
        const x = posAttr.getX(index);
        const y = posAttr.getY(index);
        const z = posAttr.getZ(index);
        if (x < minx)
          minx = x;
        if (x > maxx)
          maxx = x;
        if (y < miny)
          miny = y;
        if (y > maxy)
          maxy = y;
        if (z < minz)
          minz = z;
        if (z > maxz)
          maxz = z;
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}
const _boundingBox = /* @__PURE__ */ new Box3();
function intersectRay(nodeIndex32, array, ray2, target) {
  arrayToBox(nodeIndex32, array, _boundingBox);
  return ray2.intersectBox(_boundingBox, target);
}
function intersectTris_indirect(bvh, side, ray2, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    let vi = _indirectBuffer ? _indirectBuffer[i] : i;
    intersectTri(geometry, side, ray2, vi, intersections);
  }
}
function intersectClosestTri_indirect(bvh, side, ray2, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray2, _indirectBuffer ? _indirectBuffer[i] : i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles_indirect(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle3) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = bvh.resolveTriangleIndex(i);
    setTriangle(triangle3, tri * 3, index, pos);
    triangle3.needsUpdate = true;
    if (intersectsTriangleFunc(triangle3, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}
const _boxIntersection$3 = /* @__PURE__ */ new Vector3();
function raycast(bvh, root, side, ray2, intersects) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast$1(0, bvh, side, ray2, intersects);
  BufferStack.clearBuffer();
}
function _raycast$1(nodeIndex32, bvh, side, ray2, intersects) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris(bvh, side, ray2, offset, count, intersects);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray2, _boxIntersection$3)) {
      _raycast$1(leftIndex, bvh, side, ray2, intersects);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray2, _boxIntersection$3)) {
      _raycast$1(rightIndex, bvh, side, ray2, intersects);
    }
  }
}
const _boxIntersection$2 = /* @__PURE__ */ new Vector3();
const _xyzFields$1 = ["x", "y", "z"];
function raycastFirst(bvh, root, side, ray2) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst$1(0, bvh, side, ray2);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst$1(nodeIndex32, bvh, side, ray2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri(bvh, side, ray2, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields$1[splitAxis];
    const rayDir = ray2.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array, ray2, _boxIntersection$2);
    const c1Result = c1Intersection ? _raycastFirst$1(c1, bvh, side, ray2) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array, ray2, _boxIntersection$2);
    const c2Result = c2Intersection ? _raycastFirst$1(c2, bvh, side, ray2) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
const boundingBox$1 = /* @__PURE__ */ new Box3();
const triangle$1 = /* @__PURE__ */ new ExtendedTriangle();
const triangle2$1 = /* @__PURE__ */ new ExtendedTriangle();
const invertedMat$1 = /* @__PURE__ */ new Matrix4();
const obb$4 = /* @__PURE__ */ new OrientedBox();
const obb2$3 = /* @__PURE__ */ new OrientedBox();
function intersectsGeometry(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry$1(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry$1(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb$4.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb$4;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    invertedMat$1.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2$3);
      obb2$3.matrix.copy(invertedMat$1);
      obb2$3.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2$3.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
            setTriangle(triangle2$1, i, thisIndex, thisPos);
            triangle2$1.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2$1)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
        setTriangle(triangle$1, i, thisIndex, thisPos);
        triangle$1.a.applyMatrix4(invertedMat$1);
        triangle$1.b.applyMatrix4(invertedMat$1);
        triangle$1.c.applyMatrix4(invertedMat$1);
        triangle$1.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle(triangle2$1, i2, index, pos);
          triangle2$1.needsUpdate = true;
          if (triangle$1.intersectsTriangle(triangle2$1)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox$1);
    const leftIntersection = cachedObb.intersectsBox(boundingBox$1) && _intersectsGeometry$1(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox$1);
    const rightIntersection = cachedObb.intersectsBox(boundingBox$1) && _intersectsGeometry$1(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}
const tempMatrix$1 = /* @__PURE__ */ new Matrix4();
const obb$3 = /* @__PURE__ */ new OrientedBox();
const obb2$2 = /* @__PURE__ */ new OrientedBox();
const temp1$1 = /* @__PURE__ */ new Vector3();
const temp2$1 = /* @__PURE__ */ new Vector3();
const temp3$1 = /* @__PURE__ */ new Vector3();
const temp4$1 = /* @__PURE__ */ new Vector3();
function closestPointToGeometry(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb$3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb$3.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle3 = ExtendedTrianglePool.getPrimitive();
  const triangle22 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp1$1;
  let tempTargetDest1 = temp2$1;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3$1;
    tempTargetDest2 = temp4$1;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix$1.copy(geometryToBvh).invert();
  obb2$2.matrix.copy(tempMatrix$1);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb$3.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb2$2.min.copy(box.min);
            obb2$2.max.copy(box.max);
            obb2$2.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb2$2.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                setTriangle(triangle22, 3 * i2, otherIndex, otherPos);
                triangle22.a.applyMatrix4(geometryToBvh);
                triangle22.b.applyMatrix4(geometryToBvh);
                triangle22.c.applyMatrix4(geometryToBvh);
                triangle22.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  setTriangle(triangle3, 3 * i, index, pos);
                  triangle3.needsUpdate = true;
                  const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle22, 3 * i2, otherIndex, otherPos);
            triangle22.a.applyMatrix4(geometryToBvh);
            triangle22.b.applyMatrix4(geometryToBvh);
            triangle22.c.applyMatrix4(geometryToBvh);
            triangle22.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              setTriangle(triangle3, 3 * i, index, pos);
              triangle3.needsUpdate = true;
              const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle3);
  ExtendedTrianglePool.releasePrimitive(triangle22);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point)
      target2.point = tempTargetDest2.clone();
    else
      target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix$1);
    tempTargetDest1.applyMatrix4(tempMatrix$1);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}
function refit_indirect(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = offset, l = offset + count; i < l; i++) {
        const t = 3 * bvh.resolveTriangleIndex(i);
        for (let j = 0; j < 3; j++) {
          let index = t + j;
          index = indexArr ? indexArr[index] : index;
          const x = posAttr.getX(index);
          const y = posAttr.getY(index);
          const z = posAttr.getZ(index);
          if (x < minx)
            minx = x;
          if (x > maxx)
            maxx = x;
          if (y < miny)
            miny = y;
          if (y > maxy)
            maxy = y;
          if (z < minz)
            minz = z;
          if (z > maxz)
            maxz = z;
        }
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}
const _boxIntersection$1 = /* @__PURE__ */ new Vector3();
function raycast_indirect(bvh, root, side, ray2, intersects) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast(0, bvh, side, ray2, intersects);
  BufferStack.clearBuffer();
}
function _raycast(nodeIndex32, bvh, side, ray2, intersects) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris_indirect(bvh, side, ray2, offset, count, intersects);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray2, _boxIntersection$1)) {
      _raycast(leftIndex, bvh, side, ray2, intersects);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray2, _boxIntersection$1)) {
      _raycast(rightIndex, bvh, side, ray2, intersects);
    }
  }
}
const _boxIntersection = /* @__PURE__ */ new Vector3();
const _xyzFields = ["x", "y", "z"];
function raycastFirst_indirect(bvh, root, side, ray2) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst(0, bvh, side, ray2);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst(nodeIndex32, bvh, side, ray2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri_indirect(bvh, side, ray2, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields[splitAxis];
    const rayDir = ray2.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array, ray2, _boxIntersection);
    const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray2) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array, ray2, _boxIntersection);
    const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray2) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
const boundingBox = /* @__PURE__ */ new Box3();
const triangle = /* @__PURE__ */ new ExtendedTriangle();
const triangle2 = /* @__PURE__ */ new ExtendedTriangle();
const invertedMat = /* @__PURE__ */ new Matrix4();
const obb$2 = /* @__PURE__ */ new OrientedBox();
const obb2$1 = /* @__PURE__ */ new OrientedBox();
function intersectsGeometry_indirect(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb$2.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb$2;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    invertedMat.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2$1);
      obb2$1.matrix.copy(invertedMat);
      obb2$1.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2$1.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset, l = count + offset; i < l; i++) {
            setTriangle(triangle2, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);
            triangle2.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset, l = count + offset; i < l; i++) {
        const ti = bvh.resolveTriangleIndex(i);
        setTriangle(triangle, 3 * ti, thisIndex, thisPos);
        triangle.a.applyMatrix4(invertedMat);
        triangle.b.applyMatrix4(invertedMat);
        triangle.c.applyMatrix4(invertedMat);
        triangle.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle(triangle2, i2, index, pos);
          triangle2.needsUpdate = true;
          if (triangle.intersectsTriangle(triangle2)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);
    const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);
    const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}
const tempMatrix = /* @__PURE__ */ new Matrix4();
const obb$1 = /* @__PURE__ */ new OrientedBox();
const obb2 = /* @__PURE__ */ new OrientedBox();
const temp1 = /* @__PURE__ */ new Vector3();
const temp2 = /* @__PURE__ */ new Vector3();
const temp3 = /* @__PURE__ */ new Vector3();
const temp4 = /* @__PURE__ */ new Vector3();
function closestPointToGeometry_indirect(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb$1.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb$1.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle3 = ExtendedTrianglePool.getPrimitive();
  const triangle22 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp1;
  let tempTargetDest1 = temp2;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3;
    tempTargetDest2 = temp4;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix.copy(geometryToBvh).invert();
  obb2.matrix.copy(tempMatrix);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb$1.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb2.min.copy(box.min);
            obb2.max.copy(box.max);
            obb2.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb2.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                const ti2 = otherBvh.resolveTriangleIndex(i2);
                setTriangle(triangle22, 3 * ti2, otherIndex, otherPos);
                triangle22.a.applyMatrix4(geometryToBvh);
                triangle22.b.applyMatrix4(geometryToBvh);
                triangle22.c.applyMatrix4(geometryToBvh);
                triangle22.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  const ti = bvh.resolveTriangleIndex(i);
                  setTriangle(triangle3, 3 * ti, index, pos);
                  triangle3.needsUpdate = true;
                  const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle22, 3 * i2, otherIndex, otherPos);
            triangle22.a.applyMatrix4(geometryToBvh);
            triangle22.b.applyMatrix4(geometryToBvh);
            triangle22.c.applyMatrix4(geometryToBvh);
            triangle22.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              const ti = bvh.resolveTriangleIndex(i);
              setTriangle(triangle3, 3 * ti, index, pos);
              triangle3.needsUpdate = true;
              const dist = triangle3.distanceToTriangle(triangle22, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle3);
  ExtendedTrianglePool.releasePrimitive(triangle22);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point)
      target2.point = tempTargetDest2.clone();
    else
      target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix);
    tempTargetDest1.applyMatrix4(tempMatrix);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}
function isSharedArrayBufferSupported() {
  return typeof SharedArrayBuffer !== "undefined";
}
const _bufferStack1 = new BufferStack.constructor();
const _bufferStack2 = new BufferStack.constructor();
const _boxPool = new PrimitivePool(() => new Box3());
const _leftBox1 = new Box3();
const _rightBox1 = new Box3();
const _leftBox2 = new Box3();
const _rightBox2 = new Box3();
let _active = false;
function bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {
  if (_active) {
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  }
  _active = true;
  const roots = bvh._roots;
  const otherRoots = otherBvh._roots;
  let result;
  let offset1 = 0;
  let offset2 = 0;
  const invMat = new Matrix4().copy(matrixToLocal).invert();
  for (let i = 0, il = roots.length; i < il; i++) {
    _bufferStack1.setBuffer(roots[i]);
    offset2 = 0;
    const localBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, localBox);
    localBox.applyMatrix4(invMat);
    for (let j = 0, jl = otherRoots.length; j < jl; j++) {
      _bufferStack2.setBuffer(otherRoots[i]);
      result = _traverse(
        0,
        0,
        matrixToLocal,
        invMat,
        intersectsRanges,
        offset1,
        offset2,
        0,
        0,
        localBox
      );
      _bufferStack2.clearBuffer();
      offset2 += otherRoots[j].length;
      if (result) {
        break;
      }
    }
    _boxPool.releasePrimitive(localBox);
    _bufferStack1.clearBuffer();
    offset1 += roots[i].length;
    if (result) {
      break;
    }
  }
  _active = false;
  return result;
}
function _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset = 0, node2IndexByteOffset = 0, depth1 = 0, depth2 = 0, currBox = null, reversed = false) {
  let bufferStack1, bufferStack2;
  if (reversed) {
    bufferStack1 = _bufferStack2;
    bufferStack2 = _bufferStack1;
  } else {
    bufferStack1 = _bufferStack1;
    bufferStack2 = _bufferStack2;
  }
  const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;
  const node1Index16 = node1Index32 * 2;
  const node2Index16 = node2Index32 * 2;
  const isLeaf1 = IS_LEAF(node1Index16, uint16Array1);
  const isLeaf2 = IS_LEAF(node2Index16, uint16Array2);
  let result = false;
  if (isLeaf2 && isLeaf1) {
    if (reversed) {
      result = intersectsRangesFunc(
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        depth2,
        node2IndexByteOffset + node2Index32,
        depth1,
        node1IndexByteOffset + node1Index32
      );
    } else {
      result = intersectsRangesFunc(
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        depth1,
        node1IndexByteOffset + node1Index32,
        depth2,
        node2IndexByteOffset + node2Index32
      );
    }
  } else if (isLeaf2) {
    const newBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(node2Index32), float32Array2, newBox);
    newBox.applyMatrix4(matrix2to1);
    const cl1 = LEFT_NODE(node1Index32);
    const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
    arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
    arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
    const intersectCl1 = newBox.intersectsBox(_leftBox1);
    const intersectCr1 = newBox.intersectsBox(_rightBox1);
    result = intersectCl1 && _traverse(
      node2Index32,
      cl1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    ) || intersectCr1 && _traverse(
      node2Index32,
      cr1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    );
    _boxPool.releasePrimitive(newBox);
  } else {
    const cl2 = LEFT_NODE(node2Index32);
    const cr2 = RIGHT_NODE(node2Index32, uint32Array2);
    arrayToBox(BOUNDING_DATA_INDEX(cl2), float32Array2, _leftBox2);
    arrayToBox(BOUNDING_DATA_INDEX(cr2), float32Array2, _rightBox2);
    const leftIntersects = currBox.intersectsBox(_leftBox2);
    const rightIntersects = currBox.intersectsBox(_rightBox2);
    if (leftIntersects && rightIntersects) {
      result = _traverse(
        node1Index32,
        cl2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      ) || _traverse(
        node1Index32,
        cr2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      );
    } else if (leftIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cl2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_leftBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cl2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cl2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    } else if (rightIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cr2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_rightBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cr2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cr2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    }
  }
  return result;
}
const obb = /* @__PURE__ */ new OrientedBox();
const tempBox = /* @__PURE__ */ new Box3();
class MeshBVH {
  static serialize(bvh, options = {}) {
    options = {
      cloneBuffers: true,
      ...options
    };
    const geometry = bvh.geometry;
    const rootData = bvh._roots;
    const indirectBuffer = bvh._indirectBuffer;
    const indexAttribute = geometry.getIndex();
    let result;
    if (options.cloneBuffers) {
      result = {
        roots: rootData.map((root) => root.slice()),
        index: indexAttribute.array.slice(),
        indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null
      };
    } else {
      result = {
        roots: rootData,
        index: indexAttribute.array,
        indirectBuffer
      };
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    options = {
      setIndex: true,
      indirect: Boolean(data.indirectBuffer),
      ...options
    };
    const { index, roots, indirectBuffer } = data;
    const bvh = new MeshBVH(geometry, { ...options, [SKIP_GENERATION]: true });
    bvh._roots = roots;
    bvh._indirectBuffer = indirectBuffer || null;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      strategy: CENTER,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [SKIP_GENERATION]: false
    }, options);
    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this.geometry = geometry;
    this._roots = null;
    this._indirectBuffer = null;
    if (!options[SKIP_GENERATION]) {
      buildPackedTree(this, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box3());
      }
    }
    const { _indirectBuffer } = this;
    this.resolveTriangleIndex = options.indirect ? (i) => _indirectBuffer[i] : (i) => i;
  }
  refit(nodeIndices = null) {
    const refitFunc = this.indirect ? refit_indirect : refit;
    return refitFunc(this, nodeIndices);
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array = new Uint32Array(buffer);
    const uint16Array = new Uint16Array(buffer);
    _traverse2(0);
    function _traverse2(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array[node32Index + 6];
        const count = uint16Array[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = node32Index + BYTES_PER_NODE / 4;
        const right = uint32Array[node32Index + 6];
        const splitAxis = uint32Array[node32Index + 7];
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse2(left, depth + 1);
          _traverse2(right, depth + 1);
        }
      }
    }
  }
  /* Core Cast Functions */
  raycast(ray2, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const intersects = [];
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFunc = this.indirect ? raycast_indirect : raycast;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const startCount = intersects.length;
      raycastFunc(this, i, materialSide, ray2, intersects);
      if (isArrayMaterial) {
        const materialIndex = groups[i].materialIndex;
        for (let j = startCount, jl = intersects.length; j < jl; j++) {
          intersects[j].face.materialIndex = materialIndex;
        }
      }
    }
    return intersects;
  }
  raycastFirst(ray2, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    let closestResult = null;
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const result = raycastFirstFunc(this, i, materialSide, ray2);
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
        if (isArrayMaterial) {
          result.face.materialIndex = groups[i].materialIndex;
        }
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    let result = false;
    const roots = this._roots;
    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;
    for (let i = 0, l = roots.length; i < l; i++) {
      result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks) {
    const triangle3 = ExtendedTrianglePool.getPrimitive();
    const iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle3);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle3);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let byteOffset = 0;
    const roots = this._roots;
    for (let i = 0, l = roots.length; i < l; i++) {
      const root = roots[i];
      result = shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
      if (result) {
        break;
      }
      byteOffset += root.byteLength;
    }
    ExtendedTrianglePool.releasePrimitive(triangle3);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const triangle1 = ExtendedTrianglePool.getPrimitive();
    const indexAttr1 = this.geometry.index;
    const positionAttr1 = this.geometry.attributes.position;
    const assignTriangle1 = this.indirect ? (i1) => {
      const ti = this.resolveTriangleIndex(i1);
      setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);
    } : (i1) => {
      setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);
    };
    const triangle22 = ExtendedTrianglePool.getPrimitive();
    const indexAttr2 = otherBvh.geometry.index;
    const positionAttr2 = otherBvh.geometry.attributes.position;
    const assignTriangle2 = otherBvh.indirect ? (i2) => {
      const ti2 = otherBvh.resolveTriangleIndex(i2);
      setTriangle(triangle22, ti2 * 3, indexAttr2, positionAttr2);
    } : (i2) => {
      setTriangle(triangle22, i2 * 3, indexAttr2, positionAttr2);
    };
    if (intersectsTriangles) {
      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {
        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {
          assignTriangle2(i2);
          triangle22.a.applyMatrix4(matrixToLocal);
          triangle22.b.applyMatrix4(matrixToLocal);
          triangle22.c.applyMatrix4(matrixToLocal);
          triangle22.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            assignTriangle1(i1);
            triangle1.needsUpdate = true;
            if (intersectsTriangles(triangle1, triangle22, i1, i2, depth1, index1, depth2, index2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    return bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);
  }
  /* Derived Cast Functions */
  intersectsBox(box, boxToMesh) {
    obb.set(box.min, box.max, boxToMesh);
    obb.needsUpdate = true;
    return this.shapecast(
      {
        intersectsBounds: (box2) => obb.intersectsBox(box2),
        intersectsTriangle: (tri) => obb.intersectsTriangle(tri)
      }
    );
  }
  intersectsSphere(sphere) {
    return this.shapecast(
      {
        intersectsBounds: (box) => sphere.intersectsBox(box),
        intersectsTriangle: (tri) => tri.intersectsSphere(sphere)
      }
    );
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;
    return closestPointToGeometryFunc(
      this,
      otherGeometry,
      geometryToBvh,
      target1,
      target2,
      minThreshold,
      maxThreshold
    );
  }
  closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
    return closestPointToPoint(
      this,
      point,
      target,
      minThreshold,
      maxThreshold
    );
  }
  getBoundingBox(target) {
    target.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox(0, new Float32Array(buffer), tempBox);
      target.union(tempBox);
    });
    return target;
  }
}
function convertRaycastIntersect(hit, object, raycaster) {
  if (hit === null) {
    return null;
  }
  hit.point.applyMatrix4(object.matrixWorld);
  hit.distance = hit.point.distanceTo(raycaster.ray.origin);
  hit.object = object;
  if (hit.distance < raycaster.near || hit.distance > raycaster.far) {
    return null;
  } else {
    return hit;
  }
}
const ray = /* @__PURE__ */ new Ray();
const tmpInverseMatrix = /* @__PURE__ */ new Matrix4();
const origMeshRaycastFunc = Mesh.prototype.raycast;
function acceleratedRaycast(raycaster, intersects) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    tmpInverseMatrix.copy(this.matrixWorld).invert();
    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
    const bvh = this.geometry.boundsTree;
    if (raycaster.firstHitOnly === true) {
      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material), this, raycaster);
      if (hit) {
        intersects.push(hit);
      }
    } else {
      const hits = bvh.raycast(ray, this.material);
      for (let i = 0, l = hits.length; i < l; i++) {
        const hit = convertRaycastIntersect(hits[i], this, raycaster);
        if (hit) {
          intersects.push(hit);
        }
      }
    }
  } else {
    origMeshRaycastFunc.call(this, raycaster, intersects);
  }
}
function computeBoundsTree(options) {
  this.boundsTree = new MeshBVH(this, options);
  return this.boundsTree;
}
function disposeBoundsTree() {
  this.boundsTree = null;
}
const _Components = class _Components {
  constructor() {
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /**
     * The list of components created in this app.
     * The keys are UUIDs and the values are instances of the components.
     */
    __publicField(this, "list", new DataMap$1());
    /**
     * If disabled, the animation loop will be stopped.
     * Default value is false.
     */
    __publicField(this, "enabled", false);
    __publicField(this, "_clock");
    /**
     * Event that triggers the Components instance is initialized.
     *
     * @remarks
     * This event is triggered once when the {@link Components.init} method has been called and finish processing.
     * This is useful to set configuration placeholders that need to be executed when the components instance is initialized.
     * For example, enabling and configuring custom effects in a post-production renderer.
     *
     * @example
     * ```typescript
     * const components = new Components();
     * components.onInit.add(() => {
     *   // Enable custom effects in the post-production renderer
     *   // or any other operation dependant on the component initialization
     * });
     * components.init();
     * ```
     */
    __publicField(this, "onInit", new Event());
    __publicField(this, "update", () => {
      if (!this.enabled)
        return;
      const delta = this._clock.getDelta();
      for (const [_id, component] of this.list) {
        if (component.enabled && component.isUpdateable()) {
          component.update(delta);
        }
      }
      requestAnimationFrame(this.update);
    });
    this._clock = new THREE$1.Clock();
    _Components.setupBVH();
  }
  /**
   * Adds a component to the list of components.
   * Throws an error if a component with the same UUID already exists.
   *
   * @param uuid - The unique identifier of the component.
   * @param instance - The instance of the component to be added.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   */
  add(uuid, instance) {
    if (this.list.has(uuid))
      throw new Error(
        `You're trying to add a component that already exists in the components instance. Use Components.get() instead.`
      );
    UUID.validate(uuid);
    this.list.set(uuid, instance);
  }
  /**
   * Retrieves a component instance by its constructor function.
   * If the component does not exist in the list, it will be created and added.
   *
   * @template U - The type of the component to retrieve.
   * @param Component - The constructor function of the component to retrieve.
   *
   * @returns The instance of the requested component.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   */
  get(Component2) {
    var _a2;
    const uuid = Component2.uuid;
    if (!this.list.has(uuid)) {
      const toolInstance = new Component2(this);
      if ((_a2 = toolInstance.isDisposeable) == null ? void 0 : _a2.call(toolInstance)) {
        toolInstance.onDisposed.add(() => this.list.delete(uuid));
      }
      if (!this.list.has(uuid)) {
        this.add(uuid, toolInstance);
      }
      return toolInstance;
    }
    return this.list.get(uuid);
  }
  /**
   * Initializes the Components instance.
   * This method starts the animation loop, sets the enabled flag to true,
   * and calls the update method.
   */
  init() {
    this.enabled = true;
    for (const [_, component] of this.list.entries()) {
      component.enabled = true;
    }
    this._clock.start();
    this.update();
    this.onInit.trigger();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries,materials, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = false;
    let fragments;
    for (const [_id, component] of this.list) {
      component.enabled = false;
      if (_id === FragmentsManager.uuid) {
        fragments = component;
        continue;
      }
      if (component.isDisposeable()) {
        component.dispose();
      }
    }
    fragments == null ? void 0 : fragments.dispose();
    this._clock.stop();
    this.onDisposed.trigger();
  }
  static setupBVH() {
    THREE$1.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
    THREE$1.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
    THREE$1.Mesh.prototype.raycast = acceleratedRaycast;
  }
};
/**
 * The version of the @thatopen/components library.
 */
__publicField(_Components, "release", "2.4.3");
let Components = _Components;
class FirstPersonMode {
  constructor(camera) {
    /** {@link NavigationMode.enabled} */
    __publicField(this, "enabled", false);
    /** {@link NavigationMode.id} */
    __publicField(this, "id", "FirstPerson");
    this.camera = camera;
  }
  /** {@link NavigationMode.set} */
  set(active) {
    this.enabled = active;
    if (active) {
      const projection = this.camera.projection.current;
      if (projection !== "Perspective") {
        this.camera.set("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const controls = this.camera.controls;
    const newTargetPosition = new THREE$1.Vector3();
    controls.distance--;
    controls.getPosition(newTargetPosition);
    controls.minDistance = 1;
    controls.maxDistance = 1;
    controls.distance = 1;
    controls.moveTo(
      newTargetPosition.x,
      newTargetPosition.y,
      newTargetPosition.z
    );
    controls.truckSpeed = 50;
    controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    controls.touches.two = CameraControls.ACTION.TOUCH_ZOOM_TRUCK;
  }
}
class OrbitMode {
  constructor(camera) {
    /** {@link NavigationMode.enabled} */
    __publicField(this, "enabled", true);
    /** {@link NavigationMode.id} */
    __publicField(this, "id", "Orbit");
    this.camera = camera;
    this.activateOrbitControls();
  }
  /** {@link NavigationMode.set} */
  set(active) {
    this.enabled = active;
    if (active) {
      this.activateOrbitControls();
    }
  }
  activateOrbitControls() {
    const controls = this.camera.controls;
    controls.minDistance = 1;
    controls.maxDistance = 300;
    const position = new THREE$1.Vector3();
    controls.getPosition(position);
    const distance = position.length();
    controls.distance = distance;
    controls.truckSpeed = 2;
    const { rotation } = this.camera.three;
    const direction = new THREE$1.Vector3(0, 0, -1).applyEuler(rotation);
    const target = position.addScaledVector(direction, distance);
    controls.moveTo(target.x, target.y, target.z);
  }
}
class PlanMode {
  constructor(camera) {
    /** {@link NavigationMode.enabled} */
    __publicField(this, "enabled", false);
    /** {@link NavigationMode.id} */
    __publicField(this, "id", "Plan");
    __publicField(this, "mouseAction1");
    __publicField(this, "mouseAction2");
    __publicField(this, "mouseInitialized", false);
    __publicField(this, "defaultAzimuthSpeed");
    __publicField(this, "defaultPolarSpeed");
    this.camera = camera;
    this.defaultAzimuthSpeed = camera.controls.azimuthRotateSpeed;
    this.defaultPolarSpeed = camera.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.set} */
  set(active) {
    this.enabled = active;
    const controls = this.camera.controls;
    controls.azimuthRotateSpeed = active ? 0 : this.defaultAzimuthSpeed;
    controls.polarRotateSpeed = active ? 0 : this.defaultPolarSpeed;
    if (!this.mouseInitialized) {
      this.mouseAction1 = controls.touches.one;
      this.mouseAction2 = controls.touches.two;
      this.mouseInitialized = true;
    }
    if (active) {
      controls.mouseButtons.left = CameraControls.ACTION.TRUCK;
      controls.touches.one = CameraControls.ACTION.TOUCH_TRUCK;
      controls.touches.two = CameraControls.ACTION.TOUCH_ZOOM;
    } else {
      controls.mouseButtons.left = CameraControls.ACTION.ROTATE;
      controls.touches.one = this.mouseAction1;
      controls.touches.two = this.mouseAction2;
    }
  }
}
class ProjectionManager {
  constructor(camera) {
    /**
     * Event that fires when the {@link CameraProjection} changes.
     */
    __publicField(this, "onChanged", new Event());
    /**
     * Current projection mode of the camera.
     * Default is "Perspective".
     */
    __publicField(this, "current", "Perspective");
    /**
     * The camera controlled by this ProjectionManager.
     * It can be either a PerspectiveCamera or an OrthographicCamera.
     */
    __publicField(this, "camera");
    /** Match Ortho zoom with Perspective distance when changing projection mode */
    __publicField(this, "matchOrthoDistanceEnabled", false);
    __publicField(this, "_component");
    __publicField(this, "_previousDistance", -1);
    this._component = camera;
    this.camera = camera.three;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async set(projection) {
    if (this.current === projection)
      return;
    if (projection === "Orthographic") {
      this.setOrthoCamera();
    } else {
      await this.setPerspectiveCamera();
    }
    this.onChanged.trigger(this.camera);
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and vice versa.
   */
  async toggle() {
    const isPerspective = this.current === "Perspective";
    const target = isPerspective ? "Orthographic" : "Perspective";
    await this.set(target);
  }
  setOrthoCamera() {
    if (this._component.mode === null)
      return;
    if (this._component.mode.id === "FirstPerson") {
      return;
    }
    this._previousDistance = this._component.controls.distance;
    this._component.controls.distance = 200;
    const dims = this.getPerspectiveDims();
    if (!dims) {
      return;
    }
    const { width, height } = dims;
    this.setupOrthoCamera(height, width);
    this.camera = this._component.threeOrtho;
    this.current = "Orthographic";
  }
  getPerspectiveDims() {
    const world = this._component.currentWorld;
    if (!world || !world.renderer) {
      return null;
    }
    const lineOfSight = new THREE$1.Vector3();
    this._component.threePersp.getWorldDirection(lineOfSight);
    const target = new THREE$1.Vector3();
    this._component.controls.getTarget(target);
    const distance = target.clone().sub(this._component.threePersp.position);
    const depth = distance.dot(lineOfSight);
    const dims = world.renderer.getSize();
    const aspect = dims.x / dims.y;
    const camera = this._component.threePersp;
    const height = depth * 2 * Math.atan(camera.fov * (Math.PI / 180) / 2);
    const width = height * aspect;
    return { width, height };
  }
  setupOrthoCamera(height, width) {
    this._component.controls.mouseButtons.wheel = CameraControls.ACTION.ZOOM;
    this._component.controls.mouseButtons.middle = CameraControls.ACTION.ZOOM;
    const pCamera = this._component.threePersp;
    const oCamera = this._component.threeOrtho;
    oCamera.zoom = 1;
    oCamera.left = width / -2;
    oCamera.right = width / 2;
    oCamera.top = height / 2;
    oCamera.bottom = height / -2;
    oCamera.updateProjectionMatrix();
    oCamera.position.copy(pCamera.position);
    oCamera.quaternion.copy(pCamera.quaternion);
    this._component.controls.camera = oCamera;
  }
  getDistance() {
    const pCamera = this._component.threePersp;
    const oCamera = this._component.threeOrtho;
    const depth = (oCamera.top - oCamera.bottom) / oCamera.zoom / (2 * Math.atan(pCamera.fov * (Math.PI / 180) / 2));
    return depth;
  }
  async setPerspectiveCamera() {
    this._component.controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    this._component.controls.mouseButtons.middle = CameraControls.ACTION.DOLLY;
    const pCamera = this._component.threePersp;
    const oCamera = this._component.threeOrtho;
    pCamera.position.copy(oCamera.position);
    pCamera.quaternion.copy(oCamera.quaternion);
    this._component.controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    if (this.matchOrthoDistanceEnabled) {
      this._component.controls.distance = this.getDistance();
    } else {
      this._component.controls.distance = this._previousDistance;
    }
    await this._component.controls.zoomTo(1);
    pCamera.updateProjectionMatrix();
    this._component.controls.camera = pCamera;
    this.camera = pCamera;
    this.current = "Perspective";
  }
}
class OrthoPerspectiveCamera extends SimpleCamera {
  constructor(components) {
    super(components);
    /**
     * A ProjectionManager instance that manages the projection modes of the camera.
     */
    __publicField(this, "projection");
    /**
     * A THREE.OrthographicCamera instance that represents the orthographic camera.
     * This camera is used when the projection mode is set to orthographic.
     */
    __publicField(this, "threeOrtho");
    /**
     * A THREE.PerspectiveCamera instance that represents the perspective camera.
     * This camera is used when the projection mode is set to perspective.
     */
    __publicField(this, "threePersp");
    __publicField(this, "_userInputButtons", {});
    __publicField(this, "_frustumSize", 50);
    __publicField(this, "_navigationModes", /* @__PURE__ */ new Map());
    __publicField(this, "_mode", null);
    __publicField(this, "previousSize", null);
    this.threePersp = this.three;
    this.threeOrtho = this.newOrthoCamera();
    this.projection = new ProjectionManager(this);
    this.onAspectUpdated.add(() => {
      this.setOrthoPerspCameraAspect();
    });
    this.projection.onChanged.add(
      (camera) => {
        this.three = camera;
        this.updateAspect();
      }
    );
    this.worlds.onItemSet.add(() => {
      this._navigationModes.clear();
      this._navigationModes.set("Orbit", new OrbitMode(this));
      this._navigationModes.set("FirstPerson", new FirstPersonMode(this));
      this._navigationModes.set("Plan", new PlanMode(this));
      this._mode = this._navigationModes.get("Orbit");
      this.mode.set(true, { preventTargetAdjustment: true });
      if (this.currentWorld && this.currentWorld.renderer) {
        this.previousSize = this.currentWorld.renderer.getSize().clone();
      }
    });
    this.worlds.onItemDeleted.add(() => {
      this._navigationModes.clear();
    });
  }
  /**
   * Getter for the current navigation mode.
   * Throws an error if the mode is not found or the camera is not initialized.
   *
   * @returns {NavigationMode} The current navigation mode.
   *
   * @throws {Error} Throws an error if the mode is not found or the camera is not initialized.
   */
  get mode() {
    if (!this._mode) {
      throw new Error("Mode not found, camera not initialized");
    }
    return this._mode;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose();
    this.threeOrtho.removeFromParent();
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  set(mode) {
    if (this.mode === null)
      return;
    if (this.mode.id === mode)
      return;
    this.mode.set(false);
    if (!this._navigationModes.has(mode)) {
      throw new Error("The specified mode does not exist!");
    }
    this._mode = this._navigationModes.get(mode);
    this.mode.set(true);
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(meshes, offset = 1.5) {
    if (!this.enabled)
      return;
    const maxNum = Number.MAX_VALUE;
    const minNum = Number.MIN_VALUE;
    const min = new THREE$1.Vector3(maxNum, maxNum, maxNum);
    const max = new THREE$1.Vector3(minNum, minNum, minNum);
    for (const mesh of meshes) {
      const box2 = new THREE$1.Box3().setFromObject(mesh);
      if (box2.min.x < min.x)
        min.x = box2.min.x;
      if (box2.min.y < min.y)
        min.y = box2.min.y;
      if (box2.min.z < min.z)
        min.z = box2.min.z;
      if (box2.max.x > max.x)
        max.x = box2.max.x;
      if (box2.max.y > max.y)
        max.y = box2.max.y;
      if (box2.max.z > max.z)
        max.z = box2.max.z;
    }
    const box = new THREE$1.Box3(min, max);
    const fragments = this.components.get(FragmentsManager);
    if (fragments.initialized) {
      for (const [, model] of fragments.list) {
        const aabb = model.box;
        if (aabb.min.x < min.x)
          min.x = aabb.min.x;
        if (aabb.min.y < min.y)
          min.y = aabb.min.y;
        if (aabb.min.z < min.z)
          min.z = aabb.min.z;
        if (aabb.max.x > max.x)
          max.x = aabb.max.x;
        if (aabb.max.y > max.y)
          max.y = aabb.max.y;
        if (aabb.max.z > max.z)
          max.z = aabb.max.z;
      }
    }
    const sceneSize = new THREE$1.Vector3();
    box.getSize(sceneSize);
    const sceneCenter = new THREE$1.Vector3();
    box.getCenter(sceneCenter);
    const radius = Math.max(sceneSize.x, sceneSize.y, sceneSize.z) * offset;
    const sphere = new THREE$1.Sphere(sceneCenter, radius);
    await this.controls.fitToSphere(sphere, true);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  setUserInput(active) {
    if (active) {
      this.enableUserInput();
    } else {
      this.disableUserInput();
    }
  }
  /**
   * Adds a custom {@link NavigationMode} to the camera that can be used using the {@link OrthoPerspectiveCamera.set} method.
   *
   * @param mode - The custom {@link NavigationMode} to add.
   */
  addCustomNavigationMode(mode) {
    this._navigationModes.set(mode.id, mode);
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left;
    this._userInputButtons.right = this.controls.mouseButtons.right;
    this._userInputButtons.middle = this.controls.mouseButtons.middle;
    this._userInputButtons.wheel = this.controls.mouseButtons.wheel;
    this.controls.mouseButtons.left = 0;
    this.controls.mouseButtons.right = 0;
    this.controls.mouseButtons.middle = 0;
    this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    if (Object.keys(this._userInputButtons).length === 0)
      return;
    this.controls.mouseButtons.left = this._userInputButtons.left;
    this.controls.mouseButtons.right = this._userInputButtons.right;
    this.controls.mouseButtons.middle = this._userInputButtons.middle;
    this.controls.mouseButtons.wheel = this._userInputButtons.wheel;
  }
  newOrthoCamera() {
    const aspect = window.innerWidth / window.innerHeight;
    return new THREE$1.OrthographicCamera(
      this._frustumSize * aspect / -2,
      this._frustumSize * aspect / 2,
      this._frustumSize / 2,
      this._frustumSize / -2,
      0.1,
      1e3
    );
  }
  setOrthoPerspCameraAspect() {
    if (!this.currentWorld || !this.currentWorld.renderer) {
      return;
    }
    if (!this.previousSize)
      return;
    const size = this.currentWorld.renderer.getSize();
    const previousHeight = this.threeOrtho.top;
    const previousWidth = this.threeOrtho.right;
    const heightSizeFactor = size.y / this.previousSize.y;
    const widthSizeFactor = size.x / this.previousSize.x;
    const newHeight = previousHeight * heightSizeFactor;
    const newWidth = previousWidth * widthSizeFactor;
    this.threeOrtho.left = -newWidth;
    this.threeOrtho.right = newWidth;
    this.threeOrtho.top = newHeight;
    this.threeOrtho.bottom = -newHeight;
    this.threeOrtho.updateProjectionMatrix();
    this.previousSize.copy(size);
  }
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jszip_min = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(module, exports) {
  !function(e) {
    module.exports = e();
  }(function() {
    return function s(a, o, h) {
      function u(r, e2) {
        if (!o[r]) {
          if (!a[r]) {
            var t = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e2 && t)
              return t(r, true);
            if (l)
              return l(r, true);
            var n = new Error("Cannot find module '" + r + "'");
            throw n.code = "MODULE_NOT_FOUND", n;
          }
          var i = o[r] = { exports: {} };
          a[r][0].call(i.exports, function(e3) {
            var t2 = a[r][1][e3];
            return u(t2 || e3);
          }, i, i.exports, s, a, o, h);
        }
        return o[r].exports;
      }
      for (var l = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < h.length; e++)
        u(h[e]);
      return u;
    }({ 1: [function(e, t, r) {
      var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(e2) {
        for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
          f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
        return h.join("");
      }, r.decode = function(e2) {
        var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
        if (e2.substr(0, u.length) === u)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
          t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
        return l;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
      var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
      function o(e2, t2, r2, n2, i2) {
        this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
      }
      o.prototype = { getContentWorker: function() {
        var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
        return e2.on("end", function() {
          if (this.streamInfo.data_length !== t2.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), e2;
      }, getCompressedWorker: function() {
        return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, o.createWorkerFrom = function(e2, t2, r2) {
        return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
      }, t.exports = o;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
      var n = e("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function() {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, r.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
      var n = e("./utils");
      var o = function() {
        for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
          e2 = r2;
          for (var n2 = 0; n2 < 8; n2++)
            e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[r2] = e2;
        }
        return t2;
      }();
      t.exports = function(e2, t2) {
        return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
          var i = o, s = n2 + r2;
          e3 ^= -1;
          for (var a = n2; a < s; a++)
            e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
          return -1 ^ e3;
        }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
          var i = o, s = n2 + r2;
          e3 ^= -1;
          for (var a = n2; a < s; a++)
            e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
          return -1 ^ e3;
        }(0 | t2, e2, e2.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, t, r) {
      r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(e, t, r) {
      var n = null;
      n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
    }, { lie: 37 }], 7: [function(e, t, r) {
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
      function h(e2, t2) {
        a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
      }
      r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
        this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
      }, h.prototype.flush = function() {
        a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
      }, h.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var t2 = this;
        this._pako.onData = function(e2) {
          t2.push({ data: e2, meta: t2.meta });
        };
      }, r.compressWorker = function(e2) {
        return new h("Deflate", e2);
      }, r.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
      function A(e2, t2) {
        var r2, n2 = "";
        for (r2 = 0; r2 < t2; r2++)
          n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
        return n2;
      }
      function n(e2, t2, r2, n2, i2, s2) {
        var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
        var S = 0;
        t2 && (S |= 8), l || !_ && !g || (S |= 2048);
        var z = 0, C = 0;
        w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
          var r3 = e3;
          return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
        }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
          return 63 & (e3 || 0);
        }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
        var E = "";
        return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
      }
      var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
      function s(e2, t2, r2, n2) {
        i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      I.inherits(s, i), s.prototype.push = function(e2) {
        var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
      }, s.prototype.openedSource = function(e2) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
        var t2 = this.streamFiles && !e2.file.dir;
        if (t2) {
          var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r2.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, s.prototype.closedSource = function(e2) {
        this.accumulate = false;
        var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r2.dirRecord), t2)
          this.push({ data: function(e3) {
            return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
          }(e2), meta: { percent: 100 } });
        else
          for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, s.prototype.flush = function() {
        for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
          this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
        var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
          var s2 = I.transformTo("string", i2(n3));
          return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
        }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
        this.push({ data: n2, meta: { percent: 100 } });
      }, s.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, s.prototype.registerPrevious = function(e2) {
        this._sources.push(e2);
        var t2 = this;
        return e2.on("data", function(e3) {
          t2.processChunk(e3);
        }), e2.on("end", function() {
          t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
        }), e2.on("error", function(e3) {
          t2.error(e3);
        }), this;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, s.prototype.error = function(e2) {
        var t2 = this._sources;
        if (!i.prototype.error.call(this, e2))
          return false;
        for (var r2 = 0; r2 < t2.length; r2++)
          try {
            t2[r2].error(e2);
          } catch (e3) {
          }
        return true;
      }, s.prototype.lock = function() {
        i.prototype.lock.call(this);
        for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
          e2[t2].lock();
      }, t.exports = s;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
      var u = e("../compressions"), n = e("./ZipFileWorker");
      r.generateWorker = function(e2, a, t2) {
        var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
        try {
          e2.forEach(function(e3, t3) {
            h++;
            var r2 = function(e4, t4) {
              var r3 = e4 || t4, n3 = u[r3];
              if (!n3)
                throw new Error(r3 + " is not a valid compression method !");
              return n3;
            }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
            t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
          }), o.entriesCount = h;
        } catch (e3) {
          o.error(e3);
        }
        return o;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
      function n() {
        if (!(this instanceof n))
          return new n();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var e2 = new n();
          for (var t2 in this)
            "function" != typeof this[t2] && (e2[t2] = this[t2]);
          return e2;
        };
      }
      (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
        return new n().loadAsync(e2, t2);
      }, n.external = e("./external"), t.exports = n;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
      var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
      function f(n2) {
        return new i.Promise(function(e2, t2) {
          var r2 = n2.decompressed.getContentWorker().pipe(new a());
          r2.on("error", function(e3) {
            t2(e3);
          }).on("end", function() {
            r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
          }).resume();
        });
      }
      t.exports = function(e2, o) {
        var h = this;
        return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
          var t2 = new s(o);
          return t2.load(e3), t2;
        }).then(function(e3) {
          var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
          if (o.checkCRC32)
            for (var n2 = 0; n2 < r2.length; n2++)
              t2.push(f(r2[n2]));
          return i.Promise.all(t2);
        }).then(function(e3) {
          for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
            var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
            h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
          }
          return t2.zipComment.length && (h.comment = t2.zipComment), h;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
      var n = e("../utils"), i = e("../stream/GenericWorker");
      function s(e2, t2) {
        i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
      }
      n.inherits(s, i), s.prototype._bindStream = function(e2) {
        var t2 = this;
        (this._stream = e2).pause(), e2.on("data", function(e3) {
          t2.push({ data: e3, meta: { percent: 0 } });
        }).on("error", function(e3) {
          t2.isPaused ? this.generatedError = e3 : t2.error(e3);
        }).on("end", function() {
          t2.isPaused ? t2._upstreamEnded = true : t2.end();
        });
      }, s.prototype.pause = function() {
        return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, t.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
      var i = e("readable-stream").Readable;
      function n(e2, t2, r2) {
        i.call(this, t2), this._helper = e2;
        var n2 = this;
        e2.on("data", function(e3, t3) {
          n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
        }).on("error", function(e3) {
          n2.emit("error", e3);
        }).on("end", function() {
          n2.push(null);
        });
      }
      e("../utils").inherits(n, i), n.prototype._read = function() {
        this._helper.resume();
      }, t.exports = n;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
      t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(e2, t2);
        if ("number" == typeof e2)
          throw new Error('The "data" argument must not be a number');
        return new Buffer(e2, t2);
      }, allocBuffer: function(e2) {
        if (Buffer.alloc)
          return Buffer.alloc(e2);
        var t2 = new Buffer(e2);
        return t2.fill(0), t2;
      }, isBuffer: function(e2) {
        return Buffer.isBuffer(e2);
      }, isStream: function(e2) {
        return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
      } };
    }, {}], 15: [function(e, t, r) {
      function s(e2, t2, r2) {
        var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
        s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
        var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
        r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
        var o2 = null;
        o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
        var h2 = new d(e2, o2, s2);
        this.files[e2] = h2;
      }
      var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
        "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
        var t2 = e2.lastIndexOf("/");
        return 0 < t2 ? e2.substring(0, t2) : "";
      }, g = function(e2) {
        return "/" !== e2.slice(-1) && (e2 += "/"), e2;
      }, b = function(e2, t2) {
        return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
      };
      function h(e2) {
        return "[object RegExp]" === Object.prototype.toString.call(e2);
      }
      var n = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(e2) {
        var t2, r2, n2;
        for (t2 in this.files)
          n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
      }, filter: function(r2) {
        var n2 = [];
        return this.forEach(function(e2, t2) {
          r2(e2, t2) && n2.push(t2);
        }), n2;
      }, file: function(e2, t2, r2) {
        if (1 !== arguments.length)
          return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
        if (h(e2)) {
          var n2 = e2;
          return this.filter(function(e3, t3) {
            return !t3.dir && n2.test(e3);
          });
        }
        var i2 = this.files[this.root + e2];
        return i2 && !i2.dir ? i2 : null;
      }, folder: function(r2) {
        if (!r2)
          return this;
        if (h(r2))
          return this.filter(function(e3, t3) {
            return t3.dir && r2.test(e3);
          });
        var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
        return n2.root = t2.name, n2;
      }, remove: function(r2) {
        r2 = this.root + r2;
        var e2 = this.files[r2];
        if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
          delete this.files[r2];
        else
          for (var t2 = this.filter(function(e3, t3) {
            return t3.name.slice(0, r2.length) === r2;
          }), n2 = 0; n2 < t2.length; n2++)
            delete this.files[t2[n2].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(e2) {
        var t2, r2 = {};
        try {
          if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
            throw new Error("No output type specified.");
          u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
          var n2 = r2.comment || this.comment || "";
          t2 = o.generateWorker(this, r2, n2);
        } catch (e3) {
          (t2 = new l("error")).error(e3);
        }
        return new a(t2, r2.type || "string", r2.mimeType);
      }, generateAsync: function(e2, t2) {
        return this.generateInternalStream(e2).accumulate(t2);
      }, generateNodeStream: function(e2, t2) {
        return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
      } };
      t.exports = n;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
      t.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, t, r) {
      var n = e("./DataReader");
      function i(e2) {
        n.call(this, e2);
        for (var t2 = 0; t2 < this.data.length; t2++)
          e2[t2] = 255 & e2[t2];
      }
      e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
        return this.data[this.zero + e2];
      }, i.prototype.lastIndexOfSignature = function(e2) {
        for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
          if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
            return s - this.zero;
        return -1;
      }, i.prototype.readAndCheckSignature = function(e2) {
        var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
        return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
      }, i.prototype.readData = function(e2) {
        if (this.checkOffset(e2), 0 === e2)
          return [];
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
      var n = e("../utils");
      function i(e2) {
        this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
      }
      i.prototype = { checkOffset: function(e2) {
        this.checkIndex(this.index + e2);
      }, checkIndex: function(e2) {
        if (this.length < this.zero + e2 || e2 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
      }, setIndex: function(e2) {
        this.checkIndex(e2), this.index = e2;
      }, skip: function(e2) {
        this.setIndex(this.index + e2);
      }, byteAt: function() {
      }, readInt: function(e2) {
        var t2, r2 = 0;
        for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
          r2 = (r2 << 8) + this.byteAt(t2);
        return this.index += e2, r2;
      }, readString: function(e2) {
        return n.transformTo("string", this.readData(e2));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var e2 = this.readInt(4);
        return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
      } }, t.exports = i;
    }, { "../utils": 32 }], 19: [function(e, t, r) {
      var n = e("./Uint8ArrayReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
        this.checkOffset(e2);
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
      var n = e("./DataReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
        return this.data.charCodeAt(this.zero + e2);
      }, i.prototype.lastIndexOfSignature = function(e2) {
        return this.data.lastIndexOf(e2) - this.zero;
      }, i.prototype.readAndCheckSignature = function(e2) {
        return e2 === this.readData(4);
      }, i.prototype.readData = function(e2) {
        this.checkOffset(e2);
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
      var n = e("./ArrayReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
        if (this.checkOffset(e2), 0 === e2)
          return new Uint8Array(0);
        var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
      var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
      t.exports = function(e2) {
        var t2 = n.getTypeOf(e2);
        return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, t, r) {
      var n = e("./GenericWorker"), i = e("../utils");
      function s(e2) {
        n.call(this, "ConvertWorker to " + e2), this.destType = e2;
      }
      i.inherits(s, n), s.prototype.processChunk = function(e2) {
        this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
      var n = e("./GenericWorker"), i = e("../crc32");
      function s() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
        this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
      }, t.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
      var n = e("../utils"), i = e("./GenericWorker");
      function s(e2) {
        i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
      }
      n.inherits(s, i), s.prototype.processChunk = function(e2) {
        if (e2) {
          var t2 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = t2 + e2.data.length;
        }
        i.prototype.processChunk.call(this, e2);
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
      var n = e("../utils"), i = e("./GenericWorker");
      function s(e2) {
        i.call(this, "DataWorker");
        var t2 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
          t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
        }, function(e3) {
          t2.error(e3);
        });
      }
      n.inherits(s, i), s.prototype.cleanUp = function() {
        i.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var e2 = null, t2 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            e2 = this.data.substring(this.index, t2);
            break;
          case "uint8array":
            e2 = this.data.subarray(this.index, t2);
            break;
          case "array":
          case "nodebuffer":
            e2 = this.data.slice(this.index, t2);
        }
        return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
      function n(e2) {
        this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(e2) {
        this.emit("data", e2);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (e2) {
          this.emit("error", e2);
        }
        return true;
      }, error: function(e2) {
        return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
      }, on: function(e2, t2) {
        return this._listeners[e2].push(t2), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(e2, t2) {
        if (this._listeners[e2])
          for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
            this._listeners[e2][r2].call(this, t2);
      }, pipe: function(e2) {
        return e2.registerPrevious(this);
      }, registerPrevious: function(e2) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
        var t2 = this;
        return e2.on("data", function(e3) {
          t2.processChunk(e3);
        }), e2.on("end", function() {
          t2.end();
        }), e2.on("error", function(e3) {
          t2.error(e3);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var e2 = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
      }, flush: function() {
      }, processChunk: function(e2) {
        this.push(e2);
      }, withStreamInfo: function(e2, t2) {
        return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var e2 in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var e2 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + e2 : e2;
      } }, t.exports = n;
    }, {}], 29: [function(e, t, r) {
      var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
      if (n.nodestream)
        try {
          o = e("../nodejs/NodejsStreamOutputAdapter");
        } catch (e2) {
        }
      function l(e2, o2) {
        return new a.Promise(function(t2, r2) {
          var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
          e2.on("data", function(e3, t3) {
            n2.push(e3), o2 && o2(t3);
          }).on("error", function(e3) {
            n2 = [], r2(e3);
          }).on("end", function() {
            try {
              var e3 = function(e4, t3, r3) {
                switch (e4) {
                  case "blob":
                    return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                  case "base64":
                    return u.encode(t3);
                  default:
                    return h.transformTo(e4, t3);
                }
              }(s2, function(e4, t3) {
                var r3, n3 = 0, i3 = null, s3 = 0;
                for (r3 = 0; r3 < t3.length; r3++)
                  s3 += t3[r3].length;
                switch (e4) {
                  case "string":
                    return t3.join("");
                  case "array":
                    return Array.prototype.concat.apply([], t3);
                  case "uint8array":
                    for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                      i3.set(t3[r3], n3), n3 += t3[r3].length;
                    return i3;
                  case "nodebuffer":
                    return Buffer.concat(t3);
                  default:
                    throw new Error("concat : unsupported type '" + e4 + "'");
                }
              }(i2, n2), a2);
              t2(e3);
            } catch (e4) {
              r2(e4);
            }
            n2 = [];
          }).resume();
        });
      }
      function f(e2, t2, r2) {
        var n2 = t2;
        switch (t2) {
          case "blob":
          case "arraybuffer":
            n2 = "uint8array";
            break;
          case "base64":
            n2 = "string";
        }
        try {
          this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
        } catch (e3) {
          this._worker = new s("error"), this._worker.error(e3);
        }
      }
      f.prototype = { accumulate: function(e2) {
        return l(this, e2);
      }, on: function(e2, t2) {
        var r2 = this;
        return "data" === e2 ? this._worker.on(e2, function(e3) {
          t2.call(r2, e3.data, e3.meta);
        }) : this._worker.on(e2, function() {
          h.delay(t2, arguments, r2);
        }), this;
      }, resume: function() {
        return h.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(e2) {
        if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
          throw new Error(this._outputType + " is not supported by this method");
        return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
      } }, t.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
      if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
        r.blob = false;
      else {
        var n = new ArrayBuffer(0);
        try {
          r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
        } catch (e2) {
          try {
            var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
          } catch (e3) {
            r.blob = false;
          }
        }
      }
      try {
        r.nodestream = !!e("readable-stream").Readable;
      } catch (e2) {
        r.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(e, t, s) {
      for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
        u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
      u[254] = u[254] = 1;
      function a() {
        n.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function l() {
        n.call(this, "utf-8 encode");
      }
      s.utf8encode = function(e2) {
        return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
          var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
          for (i2 = 0; i2 < a2; i2++)
            55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
            55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }(e2);
      }, s.utf8decode = function(e2) {
        return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
          var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
          for (t2 = r2 = 0; t2 < s2; )
            if ((n2 = e3[t2++]) < 128)
              a2[r2++] = n2;
            else if (4 < (i2 = u[n2]))
              a2[r2++] = 65533, t2 += i2 - 1;
            else {
              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                n2 = n2 << 6 | 63 & e3[t2++], i2--;
              1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
            }
          return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
        }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
      }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
        var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
        if (this.leftOver && this.leftOver.length) {
          if (h.uint8array) {
            var r2 = t2;
            (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
          } else
            t2 = this.leftOver.concat(t2);
          this.leftOver = null;
        }
        var n2 = function(e3, t3) {
          var r3;
          for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
            r3--;
          return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
        }(t2), i2 = t2;
        n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
      }, a.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
        this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
      }, s.Utf8EncodeWorker = l;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
      var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
      function n(e2) {
        return e2;
      }
      function l(e2, t2) {
        for (var r2 = 0; r2 < e2.length; ++r2)
          t2[r2] = 255 & e2.charCodeAt(r2);
        return t2;
      }
      e("setimmediate"), a.newBlob = function(t2, r2) {
        a.checkSupport("blob");
        try {
          return new Blob([t2], { type: r2 });
        } catch (e2) {
          try {
            var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return n2.append(t2), n2.getBlob(r2);
          } catch (e3) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var i = { stringifyByChunk: function(e2, t2, r2) {
        var n2 = [], i2 = 0, s2 = e2.length;
        if (s2 <= r2)
          return String.fromCharCode.apply(null, e2);
        for (; i2 < s2; )
          "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
        return n2.join("");
      }, stringifyByChar: function(e2) {
        for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
          t2 += String.fromCharCode(e2[r2]);
        return t2;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
        } catch (e2) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
        } catch (e2) {
          return false;
        }
      }() } };
      function s(e2) {
        var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
        if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
          for (; 1 < t2; )
            try {
              return i.stringifyByChunk(e2, r2, t2);
            } catch (e3) {
              t2 = Math.floor(t2 / 2);
            }
        return i.stringifyByChar(e2);
      }
      function f(e2, t2) {
        for (var r2 = 0; r2 < e2.length; r2++)
          t2[r2] = e2[r2];
        return t2;
      }
      a.applyFromCharCode = s;
      var c = {};
      c.string = { string: n, array: function(e2) {
        return l(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return c.string.uint8array(e2).buffer;
      }, uint8array: function(e2) {
        return l(e2, new Uint8Array(e2.length));
      }, nodebuffer: function(e2) {
        return l(e2, r.allocBuffer(e2.length));
      } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
        return new Uint8Array(e2).buffer;
      }, uint8array: function(e2) {
        return new Uint8Array(e2);
      }, nodebuffer: function(e2) {
        return r.newBufferFrom(e2);
      } }, c.arraybuffer = { string: function(e2) {
        return s(new Uint8Array(e2));
      }, array: function(e2) {
        return f(new Uint8Array(e2), new Array(e2.byteLength));
      }, arraybuffer: n, uint8array: function(e2) {
        return new Uint8Array(e2);
      }, nodebuffer: function(e2) {
        return r.newBufferFrom(new Uint8Array(e2));
      } }, c.uint8array = { string: s, array: function(e2) {
        return f(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return e2.buffer;
      }, uint8array: n, nodebuffer: function(e2) {
        return r.newBufferFrom(e2);
      } }, c.nodebuffer = { string: s, array: function(e2) {
        return f(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return c.nodebuffer.uint8array(e2).buffer;
      }, uint8array: function(e2) {
        return f(e2, new Uint8Array(e2.length));
      }, nodebuffer: n }, a.transformTo = function(e2, t2) {
        if (t2 = t2 || "", !e2)
          return t2;
        a.checkSupport(e2);
        var r2 = a.getTypeOf(t2);
        return c[r2][e2](t2);
      }, a.resolve = function(e2) {
        for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
          var i2 = t2[n2];
          "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
        }
        return r2.join("/");
      }, a.getTypeOf = function(e2) {
        return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a.checkSupport = function(e2) {
        if (!o[e2.toLowerCase()])
          throw new Error(e2 + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
        var t2, r2, n2 = "";
        for (r2 = 0; r2 < (e2 || "").length; r2++)
          n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
        return n2;
      }, a.delay = function(e2, t2, r2) {
        setImmediate(function() {
          e2.apply(r2 || null, t2 || []);
        });
      }, a.inherits = function(e2, t2) {
        function r2() {
        }
        r2.prototype = t2.prototype, e2.prototype = new r2();
      }, a.extend = function() {
        var e2, t2, r2 = {};
        for (e2 = 0; e2 < arguments.length; e2++)
          for (t2 in arguments[e2])
            Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
        return r2;
      }, a.prepareContent = function(r2, e2, n2, i2, s2) {
        return u.Promise.resolve(e2).then(function(n3) {
          return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
            var e3 = new FileReader();
            e3.onload = function(e4) {
              t2(e4.target.result);
            }, e3.onerror = function(e4) {
              r3(e4.target.error);
            }, e3.readAsArrayBuffer(n3);
          }) : n3;
        }).then(function(e3) {
          var t2 = a.getTypeOf(e3);
          return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
            return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
          }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
      var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
      function h(e2) {
        this.files = [], this.loadOptions = e2;
      }
      h.prototype = { checkSignature: function(e2) {
        if (!this.reader.readAndCheckSignature(e2)) {
          this.reader.index -= 4;
          var t2 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
        }
      }, isSignature: function(e2, t2) {
        var r2 = this.reader.index;
        this.reader.setIndex(e2);
        var n2 = this.reader.readString(4) === t2;
        return this.reader.setIndex(r2), n2;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
        this.zipComment = this.loadOptions.decodeFileName(r2);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
          e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var e2, t2;
        for (e2 = 0; e2 < this.files.length; e2++)
          t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
      }, readCentralDir: function() {
        var e2;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
          (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
        if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (e2 < 0)
          throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(e2);
        var t2 = e2;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r2 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
        var n2 = t2 - r2;
        if (0 < n2)
          this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
        else if (n2 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
      }, prepareReader: function(e2) {
        this.reader = n(e2);
      }, load: function(e2) {
        this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, t.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
      var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
      function l(e2, t2) {
        this.options = e2, this.loadOptions = t2;
      }
      l.prototype = { isEncrypted: function() {
        return 1 == (1 & this.bitFlag);
      }, useUTF8: function() {
        return 2048 == (2048 & this.bitFlag);
      }, readLocalPart: function(e2) {
        var t2, r2;
        if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if (null === (t2 = function(e3) {
          for (var t3 in h)
            if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
              return h[t3];
          return null;
        }(this.compressionMethod)))
          throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
        this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
      }, readCentralPart: function(e2) {
        this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
        var t2 = e2.readInt(2);
        if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var e2 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var e2 = n(this.extraFields[1].value);
          this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
        }
      }, readExtraFields: function(e2) {
        var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
          t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
        e2.setIndex(i2);
      }, handleUTF8: function() {
        var e2 = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
        else {
          var t2 = this.findExtraFieldUnicodePath();
          if (null !== t2)
            this.fileNameStr = t2;
          else {
            var r2 = s.transformTo(e2, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r2);
          }
          var n2 = this.findExtraFieldUnicodeComment();
          if (null !== n2)
            this.fileCommentStr = n2;
          else {
            var i2 = s.transformTo(e2, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(i2);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var e2 = this.extraFields[28789];
        if (e2) {
          var t2 = n(e2.value);
          return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var e2 = this.extraFields[25461];
        if (e2) {
          var t2 = n(e2.value);
          return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
        }
        return null;
      } }, t.exports = l;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
      function n(e2, t2, r2) {
        this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
      }
      var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
      n.prototype = { internalStream: function(e2) {
        var t2 = null, r2 = "string";
        try {
          if (!e2)
            throw new Error("No output type specified.");
          var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
          "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
          var i2 = !this._dataBinary;
          i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
        } catch (e3) {
          (t2 = new h("error")).error(e3);
        }
        return new s(t2, r2, "");
      }, async: function(e2, t2) {
        return this.internalStream(e2).accumulate(t2);
      }, nodeStream: function(e2, t2) {
        return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
      }, _compressWorker: function(e2, t2) {
        if (this._data instanceof o && this._data.compression.magic === e2.magic)
          return this._data.getCompressedWorker();
        var r2 = this._decompressWorker();
        return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
      }, _decompressWorker: function() {
        return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < u.length; f++)
        n.prototype[u[f]] = l;
      t.exports = n;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
      (function(t2) {
        var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
        if (e2) {
          var i = 0, s = new e2(u), a = t2.document.createTextNode("");
          s.observe(a, { characterData: true }), r = function() {
            a.data = i = ++i % 2;
          };
        } else if (t2.setImmediate || void 0 === t2.MessageChannel)
          r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
            var e3 = t2.document.createElement("script");
            e3.onreadystatechange = function() {
              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
            }, t2.document.documentElement.appendChild(e3);
          } : function() {
            setTimeout(u, 0);
          };
        else {
          var o = new t2.MessageChannel();
          o.port1.onmessage = u, r = function() {
            o.port2.postMessage(0);
          };
        }
        var h = [];
        function u() {
          var e3, t3;
          n = true;
          for (var r2 = h.length; r2; ) {
            for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
              t3[e3]();
            r2 = h.length;
          }
          n = false;
        }
        l.exports = function(e3) {
          1 !== h.push(e3) || n || r();
        };
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}], 37: [function(e, t, r) {
      var i = e("immediate");
      function u() {
      }
      var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
      function o(e2) {
        if ("function" != typeof e2)
          throw new TypeError("resolver must be a function");
        this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
      }
      function h(e2, t2, r2) {
        this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
      }
      function f(t2, r2, n2) {
        i(function() {
          var e2;
          try {
            e2 = r2(n2);
          } catch (e3) {
            return l.reject(t2, e3);
          }
          e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
        });
      }
      function c(e2) {
        var t2 = e2 && e2.then;
        if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
          return function() {
            t2.apply(e2, arguments);
          };
      }
      function d(t2, e2) {
        var r2 = false;
        function n2(e3) {
          r2 || (r2 = true, l.reject(t2, e3));
        }
        function i2(e3) {
          r2 || (r2 = true, l.resolve(t2, e3));
        }
        var s2 = p(function() {
          e2(i2, n2);
        });
        "error" === s2.status && n2(s2.value);
      }
      function p(e2, t2) {
        var r2 = {};
        try {
          r2.value = e2(t2), r2.status = "success";
        } catch (e3) {
          r2.status = "error", r2.value = e3;
        }
        return r2;
      }
      (t.exports = o).prototype.finally = function(t2) {
        if ("function" != typeof t2)
          return this;
        var r2 = this.constructor;
        return this.then(function(e2) {
          return r2.resolve(t2()).then(function() {
            return e2;
          });
        }, function(e2) {
          return r2.resolve(t2()).then(function() {
            throw e2;
          });
        });
      }, o.prototype.catch = function(e2) {
        return this.then(null, e2);
      }, o.prototype.then = function(e2, t2) {
        if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
          return this;
        var r2 = new this.constructor(u);
        this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
        return r2;
      }, h.prototype.callFulfilled = function(e2) {
        l.resolve(this.promise, e2);
      }, h.prototype.otherCallFulfilled = function(e2) {
        f(this.promise, this.onFulfilled, e2);
      }, h.prototype.callRejected = function(e2) {
        l.reject(this.promise, e2);
      }, h.prototype.otherCallRejected = function(e2) {
        f(this.promise, this.onRejected, e2);
      }, l.resolve = function(e2, t2) {
        var r2 = p(c, t2);
        if ("error" === r2.status)
          return l.reject(e2, r2.value);
        var n2 = r2.value;
        if (n2)
          d(e2, n2);
        else {
          e2.state = a, e2.outcome = t2;
          for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
            e2.queue[i2].callFulfilled(t2);
        }
        return e2;
      }, l.reject = function(e2, t2) {
        e2.state = s, e2.outcome = t2;
        for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
          e2.queue[r2].callRejected(t2);
        return e2;
      }, o.resolve = function(e2) {
        if (e2 instanceof this)
          return e2;
        return l.resolve(new this(u), e2);
      }, o.reject = function(e2) {
        var t2 = new this(u);
        return l.reject(t2, e2);
      }, o.all = function(e2) {
        var r2 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e2))
          return this.reject(new TypeError("must be an array"));
        var n2 = e2.length, i2 = false;
        if (!n2)
          return this.resolve([]);
        var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
        for (; ++t2 < n2; )
          h2(e2[t2], t2);
        return o2;
        function h2(e3, t3) {
          r2.resolve(e3).then(function(e4) {
            s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
          }, function(e4) {
            i2 || (i2 = true, l.reject(o2, e4));
          });
        }
      }, o.race = function(e2) {
        var t2 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e2))
          return this.reject(new TypeError("must be an array"));
        var r2 = e2.length, n2 = false;
        if (!r2)
          return this.resolve([]);
        var i2 = -1, s2 = new this(u);
        for (; ++i2 < r2; )
          a2 = e2[i2], t2.resolve(a2).then(function(e3) {
            n2 || (n2 = true, l.resolve(s2, e3));
          }, function(e3) {
            n2 || (n2 = true, l.reject(s2, e3));
          });
        var a2;
        return s2;
      };
    }, { immediate: 36 }], 38: [function(e, t, r) {
      var n = {};
      (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
      var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
      function p(e2) {
        if (!(this instanceof p))
          return new p(e2);
        this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
        var t2 = this.options;
        t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
        var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
        if (r2 !== l)
          throw new Error(i[r2]);
        if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
          var n2;
          if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
            throw new Error(i[r2]);
          this._dict_set = true;
        }
      }
      function n(e2, t2) {
        var r2 = new p(t2);
        if (r2.push(e2, true), r2.err)
          throw r2.msg || i[r2.err];
        return r2.result;
      }
      p.prototype.push = function(e2, t2) {
        var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
        if (this.ended)
          return false;
        n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
        do {
          if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
            return this.onEnd(r2), !(this.ended = true);
          0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
        } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
        return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
      }, p.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, p.prototype.onEnd = function(e2) {
        e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
        return (t2 = t2 || {}).raw = true, n(e2, t2);
      }, r.gzip = function(e2, t2) {
        return (t2 = t2 || {}).gzip = true, n(e2, t2);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
      var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
      function a(e2) {
        if (!(this instanceof a))
          return new a(e2);
        this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
        var t2 = this.options;
        t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
        var r2 = c.inflateInit2(this.strm, t2.windowBits);
        if (r2 !== m.Z_OK)
          throw new Error(n[r2]);
        this.header = new s(), c.inflateGetHeader(this.strm, this.header);
      }
      function o(e2, t2) {
        var r2 = new a(t2);
        if (r2.push(e2, true), r2.err)
          throw r2.msg || n[r2.err];
        return r2.result;
      }
      a.prototype.push = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
        if (this.ended)
          return false;
        n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
        do {
          if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
            return this.onEnd(r2), !(this.ended = true);
          h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
        } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
        return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
      }, a.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, a.prototype.onEnd = function(e2) {
        e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
        return (t2 = t2 || {}).raw = true, o(e2, t2);
      }, r.ungzip = o;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
      r.assign = function(e2) {
        for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
          var r2 = t2.shift();
          if (r2) {
            if ("object" != typeof r2)
              throw new TypeError(r2 + "must be non-object");
            for (var n2 in r2)
              r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
          }
        }
        return e2;
      }, r.shrinkBuf = function(e2, t2) {
        return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
      };
      var i = { arraySet: function(e2, t2, r2, n2, i2) {
        if (t2.subarray && e2.subarray)
          e2.set(t2.subarray(r2, r2 + n2), i2);
        else
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
      }, flattenChunks: function(e2) {
        var t2, r2, n2, i2, s2, a;
        for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
          n2 += e2[t2].length;
        for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
          s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
        return a;
      } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
        for (var s2 = 0; s2 < n2; s2++)
          e2[i2 + s2] = t2[r2 + s2];
      }, flattenChunks: function(e2) {
        return [].concat.apply([], e2);
      } };
      r.setTyped = function(e2) {
        e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
      }, r.setTyped(n);
    }, {}], 42: [function(e, t, r) {
      var h = e("./common"), i = true, s = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (e2) {
        i = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e2) {
        s = false;
      }
      for (var u = new h.Buf8(256), n = 0; n < 256; n++)
        u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
      function l(e2, t2) {
        if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
          return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
        for (var r2 = "", n2 = 0; n2 < t2; n2++)
          r2 += String.fromCharCode(e2[n2]);
        return r2;
      }
      u[254] = u[254] = 1, r.string2buf = function(e2) {
        var t2, r2, n2, i2, s2, a = e2.length, o = 0;
        for (i2 = 0; i2 < a; i2++)
          55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
        for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
          55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
        return t2;
      }, r.buf2binstring = function(e2) {
        return l(e2, e2.length);
      }, r.binstring2buf = function(e2) {
        for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
          t2[r2] = e2.charCodeAt(r2);
        return t2;
      }, r.buf2string = function(e2, t2) {
        var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
        for (r2 = n2 = 0; r2 < a; )
          if ((i2 = e2[r2++]) < 128)
            o[n2++] = i2;
          else if (4 < (s2 = u[i2]))
            o[n2++] = 65533, r2 += s2 - 1;
          else {
            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
              i2 = i2 << 6 | 63 & e2[r2++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
        return l(o, n2);
      }, r.utf8border = function(e2, t2) {
        var r2;
        for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
          r2--;
        return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
      };
    }, { "./common": 41 }], 43: [function(e, t, r) {
      t.exports = function(e2, t2, r2, n) {
        for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
          for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
            ;
          i %= 65521, s %= 65521;
        }
        return i | s << 16 | 0;
      };
    }, {}], 44: [function(e, t, r) {
      t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, t, r) {
      var o = function() {
        for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
          e2 = r2;
          for (var n = 0; n < 8; n++)
            e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[r2] = e2;
        }
        return t2;
      }();
      t.exports = function(e2, t2, r2, n) {
        var i = o, s = n + r2;
        e2 ^= -1;
        for (var a = n; a < s; a++)
          e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
        return -1 ^ e2;
      };
    }, {}], 46: [function(e, t, r) {
      var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
      function R(e2, t2) {
        return e2.msg = n[t2], t2;
      }
      function T(e2) {
        return (e2 << 1) - (4 < e2 ? 9 : 0);
      }
      function D(e2) {
        for (var t2 = e2.length; 0 <= --t2; )
          e2[t2] = 0;
      }
      function F(e2) {
        var t2 = e2.state, r2 = t2.pending;
        r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
      }
      function N(e2, t2) {
        u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
      }
      function U(e2, t2) {
        e2.pending_buf[e2.pending++] = t2;
      }
      function P(e2, t2) {
        e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
      }
      function L(e2, t2) {
        var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
        e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
        do {
          if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
            s2 += 2, r2++;
            do {
            } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
            if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
              if (e2.match_start = t2, o2 <= (a2 = n2))
                break;
              d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
            }
          }
        } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
        return a2 <= e2.lookahead ? a2 : e2.lookahead;
      }
      function j(e2) {
        var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
        do {
          if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
            for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            i2 += f2;
          }
          if (0 === e2.strm.avail_in)
            break;
          if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
            for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
              ;
        } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
      }
      function Z(e2, t2) {
        for (var r2, n2; ; ) {
          if (e2.lookahead < z) {
            if (j(e2), e2.lookahead < z && t2 === l)
              return A;
            if (0 === e2.lookahead)
              break;
          }
          if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
            if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
              for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                ;
              e2.strstart++;
            } else
              e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
          else
            n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
          if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
            return A;
        }
        return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
      }
      function W(e2, t2) {
        for (var r2, n2, i2; ; ) {
          if (e2.lookahead < z) {
            if (j(e2), e2.lookahead < z && t2 === l)
              return A;
            if (0 === e2.lookahead)
              break;
          }
          if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
            for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
              ;
            if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          } else if (e2.match_available) {
            if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
              return A;
          } else
            e2.match_available = 1, e2.strstart++, e2.lookahead--;
        }
        return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
      }
      function M(e2, t2, r2, n2, i2) {
        this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
      }
      function H() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function G(e2) {
        var t2;
        return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
      }
      function K(e2) {
        var t2 = G(e2);
        return t2 === m && function(e3) {
          e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
        }(e2.state), t2;
      }
      function Y(e2, t2, r2, n2, i2, s2) {
        if (!e2)
          return _;
        var a2 = 1;
        if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
          return R(e2, _);
        8 === n2 && (n2 = 9);
        var o2 = new H();
        return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
      }
      h = [new M(0, 0, 0, 0, function(e2, t2) {
        var r2 = 65535;
        for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
          if (e2.lookahead <= 1) {
            if (j(e2), 0 === e2.lookahead && t2 === l)
              return A;
            if (0 === e2.lookahead)
              break;
          }
          e2.strstart += e2.lookahead, e2.lookahead = 0;
          var n2 = e2.block_start + r2;
          if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
            return A;
          if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
            return A;
        }
        return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
      }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
        return Y(e2, t2, v, 15, 8, 0);
      }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
        return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
      }, r.deflate = function(e2, t2) {
        var r2, n2, i2, s2;
        if (!e2 || !e2.state || 5 < t2 || t2 < 0)
          return e2 ? R(e2, _) : _;
        if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
          return R(e2, 0 === e2.avail_out ? -5 : _);
        if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
          if (2 === n2.wrap)
            e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
          else {
            var a2 = v + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
          }
        if (69 === n2.status)
          if (n2.gzhead.extra) {
            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
              U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else
            n2.status = 73;
        if (73 === n2.status)
          if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
          } else
            n2.status = 91;
        if (91 === n2.status)
          if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
          } else
            n2.status = 103;
        if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
          if (F(e2), 0 === e2.avail_out)
            return n2.last_flush = -1, m;
        } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
          return R(e2, -5);
        if (666 === n2.status && 0 !== e2.avail_in)
          return R(e2, -5);
        if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
          var o2 = 2 === n2.strategy ? function(e3, t3) {
            for (var r3; ; ) {
              if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                if (t3 === l)
                  return A;
                break;
              }
              if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                return A;
            }
            return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
          }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
            for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
              if (e3.lookahead <= S) {
                if (j(e3), e3.lookahead <= S && t3 === l)
                  return A;
                if (0 === e3.lookahead)
                  break;
              }
              if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                s3 = e3.strstart + S;
                do {
                } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
              }
              if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                return A;
            }
            return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
          }(n2, t2) : h[n2.level].func(n2, t2);
          if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
            return 0 === e2.avail_out && (n2.last_flush = -1), m;
          if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
            return n2.last_flush = -1, m;
        }
        return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
      }, r.deflateEnd = function(e2) {
        var t2;
        return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
      }, r.deflateSetDictionary = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
        if (!e2 || !e2.state)
          return _;
        if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
          return _;
        for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
          for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
            ;
          r2.strstart = n2, r2.lookahead = x - 1, j(r2);
        }
        return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
      t.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(e, t, r) {
      t.exports = function(e2, t2) {
        var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
        r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
        e:
          do {
            p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
            t:
              for (; ; ) {
                if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                  C[s++] = 65535 & v;
                else {
                  if (!(16 & y)) {
                    if (0 == (64 & y)) {
                      v = m[(65535 & v) + (d & (1 << y) - 1)];
                      continue t;
                    }
                    if (32 & y) {
                      r2.mode = 12;
                      break e;
                    }
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break e;
                  }
                  w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                  r:
                    for (; ; ) {
                      if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                        if (0 == (64 & y)) {
                          v = _[(65535 & v) + (d & (1 << y) - 1)];
                          continue r;
                        }
                        e2.msg = "invalid distance code", r2.mode = 30;
                        break e;
                      }
                      if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                        e2.msg = "invalid distance too far back", r2.mode = 30;
                        break e;
                      }
                      if (d >>>= y, p -= y, (y = s - a) < k) {
                        if (l < (y = k - y) && r2.sane) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (S = c, (x = 0) === f) {
                          if (x += u - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                        } else if (f < y) {
                          if (x += u + f - y, (y -= f) < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            if (x = 0, f < w) {
                              for (w -= y = f; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          }
                        } else if (x += f - y, y < w) {
                          for (w -= y; C[s++] = c[x++], --y; )
                            ;
                          x = s - k, S = C;
                        }
                        for (; 2 < w; )
                          C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                        w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                      } else {
                        for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                          ;
                        w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (n < i && s < o);
        n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
      };
    }, {}], 49: [function(e, t, r) {
      var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
      function L(e2) {
        return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
      }
      function s() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function a(e2) {
        var t2;
        return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
      }
      function o(e2) {
        var t2;
        return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
      }
      function h(e2, t2) {
        var r2, n2;
        return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
      }
      function u(e2, t2) {
        var r2, n2;
        return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
      }
      var l, f, c = true;
      function j(e2) {
        if (c) {
          var t2;
          for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
            e2.lens[t2++] = 8;
          for (; t2 < 256; )
            e2.lens[t2++] = 9;
          for (; t2 < 280; )
            e2.lens[t2++] = 7;
          for (; t2 < 288; )
            e2.lens[t2++] = 8;
          for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
            e2.lens[t2++] = 5;
          T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
        }
        e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
      }
      function Z(e2, t2, r2, n2) {
        var i2, s2 = e2.state;
        return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
      }
      r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
        return u(e2, 15);
      }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
          return U;
        12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
        e:
          for (; ; )
            switch (r2.mode) {
              case P:
                if (0 === r2.wrap) {
                  r2.mode = 13;
                  break;
                }
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (2 & r2.wrap && 35615 === u2) {
                  E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                  e2.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if (8 != (15 & u2)) {
                  e2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                  r2.wbits = k;
                else if (k > r2.wbits) {
                  e2.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                break;
              case 2:
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.flags = u2, 8 != (255 & r2.flags)) {
                  e2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  e2.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
              case 3:
                for (; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
              case 4:
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                } else
                  r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                  break e;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (0 === o2)
                    break e;
                  for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                    break e;
                } else
                  r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (0 === o2)
                    break e;
                  for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                    break e;
                } else
                  r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (65535 & r2.check)) {
                    e2.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
              case 11:
                if (0 === r2.havedict)
                  return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                e2.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (5 === t2 || 6 === t2)
                  break e;
              case 13:
                if (r2.last) {
                  u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                  break;
                }
                for (; l2 < 3; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (j(r2), r2.mode = 20, 6 !== t2)
                      break;
                    u2 >>>= 2, l2 -= 2;
                    break e;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    e2.msg = "invalid block type", r2.mode = 30;
                }
                u2 >>>= 2, l2 -= 2;
                break;
              case 14:
                for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                  e2.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                  break e;
              case 15:
                r2.mode = 16;
              case 16:
                if (d = r2.length) {
                  if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                    break e;
                  I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (; l2 < 14; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                  e2.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (; r2.have < r2.ncode; ) {
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                }
                for (; r2.have < 19; )
                  r2.lens[A[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  e2.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (; r2.have < r2.nlen + r2.ndist; ) {
                  for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (b < 16)
                    u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                  else {
                    if (16 === b) {
                      for (z = _ + 2; l2 < z; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                    } else if (17 === b) {
                      for (z = _ + 3; l2 < z; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                    } else {
                      for (z = _ + 7; l2 < z; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                    }
                    if (r2.have + d > r2.nlen + r2.ndist) {
                      e2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (; d--; )
                      r2.lens[r2.have++] = k;
                  }
                }
                if (30 === r2.mode)
                  break;
                if (0 === r2.lens[256]) {
                  e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  e2.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                  e2.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, 6 === t2)
                  break e;
              case 20:
                r2.mode = 21;
              case 21:
                if (6 <= o2 && 258 <= h2) {
                  e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                  break;
                }
                for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (g && 0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                  r2.mode = 26;
                  break;
                }
                if (32 & g) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & g) {
                  e2.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & g, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                  e2.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  e2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (0 === h2)
                  break e;
                if (d = c2 - h2, r2.offset > d) {
                  if ((d = r2.offset - d) > r2.whave && r2.sane) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                } else
                  m = i2, p = a2 - r2.offset, d = r2.length;
                for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                  ;
                0 === r2.length && (r2.mode = 21);
                break;
              case 26:
                if (0 === h2)
                  break e;
                i2[a2++] = r2.length, h2--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 |= n2[s2++] << l2, l2 += 8;
                  }
                  if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                    e2.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (4294967295 & r2.total)) {
                    e2.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 29;
              case 29:
                x = 1;
                break e;
              case 30:
                x = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return U;
            }
        return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
      }, r.inflateEnd = function(e2) {
        if (!e2 || !e2.state)
          return U;
        var t2 = e2.state;
        return t2.window && (t2.window = null), e2.state = null, N;
      }, r.inflateGetHeader = function(e2, t2) {
        var r2;
        return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
      }, r.inflateSetDictionary = function(e2, t2) {
        var r2, n2 = t2.length;
        return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
      var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      t.exports = function(e2, t2, r2, n, i, s, a, o) {
        var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
        for (b = 0; b <= 15; b++)
          O[b] = 0;
        for (v = 0; v < n; v++)
          O[t2[r2 + v]]++;
        for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
          ;
        if (w < k && (k = w), 0 === w)
          return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
        for (y = 1; y < w && 0 === O[y]; y++)
          ;
        for (k < y && (k = y), b = z = 1; b <= 15; b++)
          if (z <<= 1, (z -= O[b]) < 0)
            return -1;
        if (0 < z && (0 === e2 || 1 !== w))
          return -1;
        for (B[1] = 0, b = 1; b < 15; b++)
          B[b + 1] = B[b] + O[b];
        for (v = 0; v < n; v++)
          0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
        if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
          return 1;
        for (; ; ) {
          for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
            ;
          for (h = 1 << b - 1; E & h; )
            h >>= 1;
          if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
            if (b === w)
              break;
            b = t2[r2 + a[v]];
          }
          if (k < b && (E & f) !== l) {
            for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
              x++, z <<= 1;
            if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
              return 1;
            i[l = E & f] = k << 24 | x << 16 | c - s | 0;
          }
        }
        return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, t, r) {
      t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, t, r) {
      var i = e("../utils/common"), o = 0, h = 1;
      function n(e2) {
        for (var t2 = e2.length; 0 <= --t2; )
          e2[t2] = 0;
      }
      var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
      n(z);
      var C = new Array(2 * f);
      n(C);
      var E = new Array(512);
      n(E);
      var A = new Array(256);
      n(A);
      var I = new Array(a);
      n(I);
      var O, B, R, T = new Array(f);
      function D(e2, t2, r2, n2, i2) {
        this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
      }
      function F(e2, t2) {
        this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
      }
      function N(e2) {
        return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
      }
      function U(e2, t2) {
        e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
      }
      function P(e2, t2, r2) {
        e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
      }
      function L(e2, t2, r2) {
        P(e2, r2[2 * t2], r2[2 * t2 + 1]);
      }
      function j(e2, t2) {
        for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
          ;
        return r2 >>> 1;
      }
      function Z(e2, t2, r2) {
        var n2, i2, s2 = new Array(g + 1), a2 = 0;
        for (n2 = 1; n2 <= g; n2++)
          s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
        for (i2 = 0; i2 <= t2; i2++) {
          var o2 = e2[2 * i2 + 1];
          0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
        }
      }
      function W(e2) {
        var t2;
        for (t2 = 0; t2 < l; t2++)
          e2.dyn_ltree[2 * t2] = 0;
        for (t2 = 0; t2 < f; t2++)
          e2.dyn_dtree[2 * t2] = 0;
        for (t2 = 0; t2 < c; t2++)
          e2.bl_tree[2 * t2] = 0;
        e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
      }
      function M(e2) {
        8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
      }
      function H(e2, t2, r2, n2) {
        var i2 = 2 * t2, s2 = 2 * r2;
        return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
      }
      function G(e2, t2, r2) {
        for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
          e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
        e2.heap[r2] = n2;
      }
      function K(e2, t2, r2) {
        var n2, i2, s2, a2, o2 = 0;
        if (0 !== e2.last_lit)
          for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
            ;
        L(e2, m, t2);
      }
      function Y(e2, t2) {
        var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
        for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
          0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
        for (; e2.heap_len < 2; )
          s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
        for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
          G(e2, s2, r2);
        for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
          ;
        e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
          var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
          for (s3 = 0; s3 <= g; s3++)
            e3.bl_count[s3] = 0;
          for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
            p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
          if (0 !== m2) {
            do {
              for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                s3--;
              e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
            } while (0 < m2);
            for (s3 = p2; 0 !== s3; s3--)
              for (n3 = e3.bl_count[s3]; 0 !== n3; )
                u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
          }
        }(e2, t2), Z(s2, u2, e2.bl_count);
      }
      function X(e2, t2, r2) {
        var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
        for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
          i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
      }
      function V(e2, t2, r2) {
        var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
        for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
          if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
            if (o2 < u2)
              for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                ;
            else
              0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
            s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
          }
      }
      n(T);
      var q = false;
      function J(e2, t2, r2, n2) {
        P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
          M(e3), U(e3, r3), U(e3, ~r3), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
        }(e2, t2, r2);
      }
      r._tr_init = function(e2) {
        q || (function() {
          var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
          for (n2 = r2 = 0; n2 < a - 1; n2++)
            for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
              A[r2++] = n2;
          for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
            for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
              E[i2++] = n2;
          for (i2 >>= 7; n2 < f; n2++)
            for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
              E[256 + i2++] = n2;
          for (t2 = 0; t2 <= g; t2++)
            s2[t2] = 0;
          for (e3 = 0; e3 <= 143; )
            z[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (; e3 <= 255; )
            z[2 * e3 + 1] = 9, e3++, s2[9]++;
          for (; e3 <= 279; )
            z[2 * e3 + 1] = 7, e3++, s2[7]++;
          for (; e3 <= 287; )
            z[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
            C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
          O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
        }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
      }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
        var i2, s2, a2 = 0;
        0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
          var t3, r3 = 4093624447;
          for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
            if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
              return o;
          if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
            return h;
          for (t3 = 32; t3 < u; t3++)
            if (0 !== e3.dyn_ltree[2 * t3])
              return h;
          return o;
        }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
          var t3;
          for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--)
            ;
          return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
        }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
          var i3;
          for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
            P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
          V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
        }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
      }, r._tr_tally = function(e2, t2, r2) {
        return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
      }, r._tr_align = function(e2) {
        P(e2, 2, 3), L(e2, m, z), function(e3) {
          16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
        }(e2);
      };
    }, { "../utils/common": 41 }], 53: [function(e, t, r) {
      t.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, t, r) {
      (function(e2) {
        !function(r2, n) {
          if (!r2.setImmediate) {
            var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
            e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
              process.nextTick(function() {
                c(e4);
              });
            } : function() {
              if (r2.postMessage && !r2.importScripts) {
                var e4 = true, t3 = r2.onmessage;
                return r2.onmessage = function() {
                  e4 = false;
                }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
              }
            }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
              r2.postMessage(a + e4, "*");
            }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
              c(e4.data);
            }, function(e4) {
              t2.port2.postMessage(e4);
            }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
              var t3 = l.createElement("script");
              t3.onreadystatechange = function() {
                c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
              }, s.appendChild(t3);
            }) : function(e4) {
              setTimeout(c, 0, e4);
            }, e3.setImmediate = function(e4) {
              "function" != typeof e4 && (e4 = new Function("" + e4));
              for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                t3[r3] = arguments[r3 + 1];
              var n2 = { callback: e4, args: t3 };
              return h[o] = n2, i(o), o++;
            }, e3.clearImmediate = f;
          }
          function f(e4) {
            delete h[e4];
          }
          function c(e4) {
            if (u)
              setTimeout(c, 0, e4);
            else {
              var t3 = h[e4];
              if (t3) {
                u = true;
                try {
                  !function(e5) {
                    var t4 = e5.callback, r3 = e5.args;
                    switch (r3.length) {
                      case 0:
                        t4();
                        break;
                      case 1:
                        t4(r3[0]);
                        break;
                      case 2:
                        t4(r3[0], r3[1]);
                        break;
                      case 3:
                        t4(r3[0], r3[1], r3[2]);
                        break;
                      default:
                        t4.apply(n, r3);
                    }
                  }(t3);
                } finally {
                  f(e4), u = false;
                }
              }
            }
          }
          function d(e4) {
            e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
          }
        }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(jszip_min);
var jszip_minExports = jszip_min.exports;
const JSZip = /* @__PURE__ */ getDefaultExportFromCjs(jszip_minExports);
class Comment {
  /**
   * Constructs a new BCF Topic Comment instance.
   * @param components - The Components instance.
   * @param text - The initial comment text.
   */
  constructor(components, text) {
    __publicField(this, "date", /* @__PURE__ */ new Date());
    __publicField(this, "author");
    __publicField(this, "guid", UUID.create());
    __publicField(this, "viewpoint");
    __publicField(this, "modifiedAuthor");
    __publicField(this, "modifiedDate");
    __publicField(this, "topic");
    __publicField(this, "_components");
    __publicField(this, "_comment", "");
    this._components = components;
    this._comment = text;
    const manager = this._components.get(BCFTopics);
    this.author = manager.config.author;
  }
  /**
   * Sets the comment text and updates the modified date and author.
   * The author will be the one defined in BCFTopics.config.author
   * @param value - The new comment text.
   */
  set comment(value) {
    var _a2;
    const manager = this._components.get(BCFTopics);
    this._comment = value;
    this.modifiedDate = /* @__PURE__ */ new Date();
    this.modifiedAuthor = manager.config.author;
    (_a2 = this.topic) == null ? void 0 : _a2.comments.set(this.guid, this);
  }
  /**
   * Gets the comment text.
   * @returns The comment text.
   */
  get comment() {
    return this._comment;
  }
  toJSON() {
    var _a2, _b;
    const result = {
      guid: this.guid,
      date: this.date.toISOString(),
      author: this.author,
      comment: this.comment,
      topic_guid: (_a2 = this.topic) == null ? void 0 : _a2.guid,
      viewpoint_guid: this.viewpoint,
      modified_date: (_b = this.modifiedDate) == null ? void 0 : _b.toISOString(),
      modified_author: this.modifiedAuthor
    };
    for (const [key, value] of Object.entries(result)) {
      if (value === void 0)
        delete result[key];
    }
    return result;
  }
}
const _Topic = class _Topic {
  /**
   * Initializes a new instance of the `Topic` class representing a BCF (BIM Collaboration Format) topic.
   * It provides methods and properties to manage and serialize BCF topics.
   *
   * @remarks
   * The default creationUser is the one set in BCFTopics.config.author
   * It should not be created manually. Better use BCFTopics.create().
   *
   * @param components - The `Components` instance that provides access to other components and services.
   */
  constructor(components) {
    /**
     * A unique identifier for the topic.
     *
     * @remarks
     * The `guid` is automatically generated upon topic creation and by no means it should change.
     */
    __publicField(this, "guid", UUID.create());
    __publicField(this, "title", _Topic.default.title);
    __publicField(this, "creationDate", /* @__PURE__ */ new Date());
    __publicField(this, "creationAuthor", "");
    // Store viewpoint guids instead of the actual Viewpoint to prevent a possible memory leak
    __publicField(this, "viewpoints", new DataSet$1());
    // Store topic guids instead of the actual Topic to prevent a possible memory leak
    __publicField(this, "relatedTopics", new DataSet$1());
    // There is no problem to store the comment it-self as it is not referenced anywhere else
    __publicField(this, "comments", new DataMap$1());
    // Store document reference guids instead of the actual thing to prevent a possible memory leak
    __publicField(this, "documentReferences", new DataSet$1());
    __publicField(this, "customData", {});
    __publicField(this, "description");
    __publicField(this, "serverAssignedId");
    __publicField(this, "dueDate");
    __publicField(this, "modifiedAuthor");
    __publicField(this, "modifiedDate");
    __publicField(this, "index");
    // Based on the BCF API documentation, the files associated with a topic are the models that should be loaded when displaying the topic's viewpoints.
    // files: any
    __publicField(this, "_type", _Topic.default.type);
    __publicField(this, "_status", _Topic.default.status);
    __publicField(this, "_priority", _Topic.default.priority);
    __publicField(this, "_stage", _Topic.default.stage);
    __publicField(this, "_assignedTo", _Topic.default.assignedTo);
    __publicField(this, "_labels", _Topic.default.labels ?? /* @__PURE__ */ new Set());
    __publicField(this, "_components");
    this._components = components;
    const manager = components.get(BCFTopics);
    this.creationAuthor = manager.config.author;
    this.relatedTopics.guard = (guid) => guid !== this.guid;
  }
  set type(value) {
    const manager = this._components.get(BCFTopics);
    const { strict, types } = manager.config;
    const valid = strict ? types.has(value) : true;
    if (!valid)
      return;
    this._type = value;
  }
  get type() {
    return this._type;
  }
  set status(value) {
    const manager = this._components.get(BCFTopics);
    const { strict, statuses } = manager.config;
    const valid = strict ? statuses.has(value) : true;
    if (!valid)
      return;
    this._status = value;
  }
  get status() {
    return this._status;
  }
  set priority(value) {
    const manager = this._components.get(BCFTopics);
    if (value) {
      const { strict, priorities } = manager.config;
      const valid = strict ? priorities.has(value) : true;
      if (!valid)
        return;
      this._priority = value;
    } else {
      this._priority = value;
    }
  }
  get priority() {
    return this._priority;
  }
  set stage(value) {
    const manager = this._components.get(BCFTopics);
    if (value) {
      const { strict, stages } = manager.config;
      const valid = strict ? stages.has(value) : true;
      if (!valid)
        return;
      this._stage = value;
    } else {
      this._stage = value;
    }
  }
  get stage() {
    return this._stage;
  }
  set assignedTo(value) {
    const manager = this._components.get(BCFTopics);
    if (value) {
      const { strict, users } = manager.config;
      const valid = strict ? users.has(value) : true;
      if (!valid)
        return;
      this._assignedTo = value;
    } else {
      this._assignedTo = value;
    }
  }
  get assignedTo() {
    return this._assignedTo;
  }
  set labels(value) {
    const manager = this._components.get(BCFTopics);
    const { strict, labels } = manager.config;
    if (strict) {
      const _value = /* @__PURE__ */ new Set();
      for (const label of value) {
        const valid = strict ? labels.has(label) : true;
        if (!valid)
          continue;
        _value.add(label);
      }
      this._labels = _value;
    } else {
      this._labels = value;
    }
  }
  get labels() {
    return this._labels;
  }
  get _managerVersion() {
    const manager = this._components.get(BCFTopics);
    return manager.config.version;
  }
  /**
   * Sets properties of the BCF Topic based on the provided data.
   *
   * @remarks
   * This method iterates over the provided `data` object and updates the corresponding properties of the BCF Topic.
   * It skips the `guid` property as it should not be modified.
   *
   * @param data - An object containing the properties to be updated.
   * @returns The topic
   *
   * @example
   * ```typescript
   * const topic = new Topic(components);
   * topic.set({
   *   title: "New BCF Topic Title",
   *   description: "This is a new description.",
   *   status: "Resolved",
   * });
   * ```
   */
  set(data) {
    const _data = data;
    const _this = this;
    for (const key in data) {
      if (key === "guid")
        continue;
      const value = _data[key];
      if (key in this)
        _this[key] = value;
    }
    const manager = this._components.get(BCFTopics);
    manager.list.set(this.guid, this);
    return this;
  }
  /**
   * Creates a new comment associated with the current topic.
   *
   * @param text - The text content of the comment.
   * @param viewpoint - (Optional) The viewpoint associated with the comment.
   *
   * @returns The newly created comment.
   *
   * @example
   * ```typescript
   * const viewpoint = viewpoints.create(world); // Created with an instance of Viewpoints
   * const topic = topics.create(); // Created with an instance of BCFTopics
   * topic.viewpoints.add(viewpoint);
   * const comment = topic.createComment("This is a new comment", viewpoint);
   * ```
   */
  createComment(text, viewpoint) {
    const comment = new Comment(this._components, text);
    comment.viewpoint = viewpoint;
    comment.topic = this;
    this.comments.set(comment.guid, comment);
    return comment;
  }
  createLabelTags() {
    const labels = [...this.labels];
    const manager = this._components.get(BCFTopics);
    if (manager.config.exportCustomDataAsLabels) {
      for (const key in this.customData) {
        const value = this.customData[key];
        if (typeof value !== "string")
          continue;
        labels.push(value);
      }
    }
    return labels;
  }
  createCommentTags() {
    return [...this.comments.values()].map((comment) => {
      var _a2;
      return {
        $Guid: comment.guid,
        Date: comment.date.toISOString(),
        Author: comment.author,
        Comment: comment.comment,
        ModifiedAuthor: comment.modifiedAuthor,
        ModifiedDate: (_a2 = comment.modifiedDate) == null ? void 0 : _a2.toISOString(),
        Viewpoint: comment.viewpoint ? { $Guid: comment.viewpoint } : void 0
      };
    });
  }
  createViewpointTags() {
    const manager = this._components.get(Viewpoints);
    const viewpoints = [...this.viewpoints].map((viewpointID) => manager.list.get(viewpointID)).filter((viewpoint) => viewpoint);
    return viewpoints.map((viewpoint) => {
      const xmlData = {
        $Guid: viewpoint.guid,
        Viewpoint: `${viewpoint.title ?? viewpoint.guid}.bcfv`
      };
      const snapshotData = manager.snapshots.get(viewpoint.snapshot);
      if (snapshotData) {
        const snapshotExtension = manager.getSnapshotExtension(
          viewpoint.snapshot
        );
        xmlData.Snapshot = `${viewpoint.snapshot}.${snapshotExtension}`;
      }
      return xmlData;
    });
  }
  createRelatedTopicTags() {
    return [...this.relatedTopics].map((guid) => {
      return { $Guid: guid };
    });
  }
  createDocumentReferencesTag(version = this._managerVersion) {
    const references = [];
    if (!(version === "3" || version === "2.1"))
      return references;
    const manager = this._components.get(BCFTopics);
    for (const guid of this.documentReferences) {
      const doc = manager.documents.get(guid);
      if (!doc)
        continue;
      let reference = {
        $Guid: UUID.create(),
        Description: doc.description
      };
      if (version === "2.1") {
        reference = {
          ...reference,
          $isExternal: doc.type === "external" ? true : void 0,
          ReferencedDocument: doc.type === "external" ? doc.url : `../${doc.fileName}`
        };
      }
      if (version === "3") {
        reference = {
          ...reference,
          DocumentGuid: doc.type === "internal" ? guid : void 0,
          Url: doc.type === "external" ? doc.url : void 0
        };
      }
      if (Object.keys(reference).length > 0)
        references.push(reference);
    }
    return references;
  }
  toJSON() {
    var _a2, _b;
    const result = {
      guid: this.guid,
      server_assigned_id: this.serverAssignedId,
      topic_type: this.type,
      topic_status: this.status,
      title: this.title,
      priority: this.priority,
      index: this.index,
      labels: [...this.labels],
      creation_date: this.creationDate.toISOString(),
      creation_author: this.creationAuthor,
      modified_date: (_a2 = this.modifiedDate) == null ? void 0 : _a2.toISOString(),
      modified_author: this.modifiedAuthor,
      assigned_to: this.assignedTo,
      stage: this.stage,
      description: this.description,
      due_date: (_b = this.dueDate) == null ? void 0 : _b.toISOString(),
      comments: [...this.comments].map(([_, comment]) => comment.toJSON()),
      relatedTopics: [...this.relatedTopics].map((guid) => {
        return { related_topic_guid: guid };
      })
    };
    const viewpointsManager = this._components.get(Viewpoints);
    for (const guid of this.viewpoints) {
      const viewpoint = viewpointsManager.list.get(guid);
      if (!viewpoint)
        continue;
      if (!result.viewpoints)
        result.viewpoints = [];
      result.viewpoints.push(viewpoint.toJSON());
    }
    const topicsManager = this._components.get(BCFTopics);
    for (const guid of this.documentReferences) {
      const reference = topicsManager.documents.get(guid);
      if (!reference)
        continue;
      if (!result.document_references)
        result.document_references = [];
      if (reference.type === "external") {
        result.document_references.push({
          guid: UUID.create(),
          // TODO: this is for sure incorrect!
          description: reference.description,
          url: reference.url
        });
      } else {
        result.document_references.push({
          guid: UUID.create(),
          // TODO: this is for sure incorrect!
          description: reference.description,
          document_guid: guid
        });
      }
    }
    for (const [key, value] of Object.entries(result)) {
      if (value === void 0 || Array.isArray(value) && value.length === 0) {
        delete result[key];
      }
    }
    return result;
  }
  /**
   * Serializes the BCF Topic instance into an XML string representation based on the official schema.
   *
   * @remarks
   * This method constructs an XML string based on the properties of the BCF Topic instance.
   * It includes the topic's guid, type, status, creation date, creation author, priority, index,
   * modified date, modified author, due date, assigned to, description, stage, labels, related topics,
   * comments, and viewpoints.
   *
   * @returns A string representing the XML serialization of the BCF Topic.
   *
   * @example
   * ```typescript
   * const topic = bcfTopics.create(); // Created with an instance of BCFTopics
   * const xml = topic.serialize();
   * console.log(xml);
   * ```
   */
  serialize() {
    var _a2, _b;
    const version = this._managerVersion;
    const topic = {
      $Guid: this.guid,
      $TopicType: this.type,
      $TopicStatus: this.status,
      $ServerAssignedId: this.serverAssignedId,
      Title: this.title,
      CreationAuthor: this.creationAuthor,
      CreationDate: this.creationDate.toISOString(),
      Priority: this.priority,
      Index: version === "2.1" ? this.index : void 0,
      ModifiedDate: (_a2 = this.modifiedDate) == null ? void 0 : _a2.toISOString(),
      ModifiedAuthor: this.modifiedAuthor,
      DueDate: (_b = this.dueDate) == null ? void 0 : _b.toISOString(),
      AssignedTo: this.assignedTo,
      Description: this.description,
      Stage: this.stage,
      DocumentReferences: version === "3" ? { DocumentReference: this.createDocumentReferencesTag(version) } : void 0,
      RelatedTopics: version === "3" ? { RelatedTopic: this.createRelatedTopicTags() } : void 0,
      RelatedTopic: version === "2.1" ? this.createRelatedTopicTags() : void 0,
      Labels: version === "3" ? { Label: this.createLabelTags() } : void 0,
      Viewpoints: version === "3" ? { ViewPoint: this.createViewpointTags() } : void 0,
      Comments: version === "3" ? { Comment: this.createCommentTags() } : void 0
    };
    if (version === "2.1") {
      topic.Labels = this.createLabelTags();
      topic.DocumentReference = this.createDocumentReferencesTag(version);
    }
    const markup = {
      Markup: { Topic: topic }
    };
    if (version === "2.1") {
      markup.Markup.Viewpoints = this.createViewpointTags();
      markup.Markup.Comment = this.createCommentTags();
    }
    return `<?xml version="1.0" encoding="UTF-8"?>
    ${XML.builder.build(markup)}`;
  }
};
/**
 * Default values for a BCF Topic, excluding `guid`, `creationDate`, and `creationAuthor`.
 */
__publicField(_Topic, "default", {
  title: "BCF Topic",
  type: "Issue",
  status: "Active"
});
let Topic = _Topic;
const extensionsImporter = (manager, extensionsXML) => {
  if (extensionsXML.trim() === "")
    return;
  const extensions = BCFTopics.xmlParser.parse(extensionsXML).Extensions;
  if (!extensions)
    return;
  const { Priorities, TopicStatuses, TopicTypes, Users } = extensions;
  if (Priorities && Priorities.Priority) {
    const priorities = Array.isArray(Priorities.Priority) ? Priorities.Priority : [Priorities.Priority];
    for (const priority of priorities) {
      manager.config.priorities.add(priority);
    }
  }
  if (TopicStatuses && TopicStatuses.TopicStatus) {
    const statuses = Array.isArray(TopicStatuses.TopicStatus) ? TopicStatuses.TopicStatus : [TopicStatuses.TopicStatus];
    for (const status of statuses) {
      manager.config.statuses.add(status);
    }
  }
  if (TopicTypes && TopicTypes.TopicType) {
    const types = Array.isArray(TopicTypes.TopicType) ? TopicTypes.TopicType : [TopicTypes.TopicType];
    for (const type of types) {
      manager.config.types.add(type);
    }
  }
  if (Users && Users.User) {
    const users = Array.isArray(Users.User) ? Users.User : [Users.User];
    for (const user of users) {
      manager.config.users.add(user);
    }
  }
};
class BCFTopicsConfigManager extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      version: {
        type: "Select",
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        multiple: false,
        value: ""
      },
      author: {
        type: "Text",
        value: ""
      },
      types: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      statuses: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      priorities: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      labels: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      stages: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      users: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      includeSelectionTag: {
        type: "Boolean",
        value: false
      },
      updateExtensionsOnImport: {
        type: "Boolean",
        value: false
      },
      strict: {
        type: "Boolean",
        value: false
      },
      includeAllExtensionsOnExport: {
        type: "Boolean",
        value: false
      },
      fallbackVersionOnImport: {
        type: "Select",
        multiple: false,
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        value: ""
      },
      ignoreIncompleteTopicsOnImport: {
        type: "Boolean",
        value: false
      },
      exportCustomDataAsLabels: {
        type: "Boolean",
        value: false
      }
    });
  }
  get version() {
    return this._config.version.value;
  }
  set version(value) {
    this._config.version.value = value;
  }
  get author() {
    return this._config.author.value;
  }
  set author(value) {
    this._config.author.value = value;
  }
  get types() {
    return this._config.types.value;
  }
  set types(value) {
    this._config.types.value = value;
  }
  get statuses() {
    return this._config.statuses.value;
  }
  set statuses(value) {
    this._config.statuses.value = value;
  }
  get priorities() {
    return this._config.priorities.value;
  }
  set priorities(value) {
    this._config.priorities.value = value;
  }
  get labels() {
    return this._config.labels.value;
  }
  set labels(value) {
    this._config.labels.value = value;
  }
  get stages() {
    return this._config.stages.value;
  }
  set stages(value) {
    this._config.stages.value = value;
  }
  get users() {
    return this._config.users.value;
  }
  set users(value) {
    this._config.users.value = value;
  }
  get includeSelectionTag() {
    return this._config.includeSelectionTag.value;
  }
  set includeSelectionTag(value) {
    this._config.includeSelectionTag.value = value;
  }
  get updateExtensionsOnImport() {
    return this._config.updateExtensionsOnImport.value;
  }
  set updateExtensionsOnImport(value) {
    this._config.updateExtensionsOnImport.value = value;
  }
  get strict() {
    return this._config.strict.value;
  }
  set strict(value) {
    this._config.strict.value = value;
  }
  get includeAllExtensionsOnExport() {
    return this._config.includeAllExtensionsOnExport.value;
  }
  set includeAllExtensionsOnExport(value) {
    this._config.includeAllExtensionsOnExport.value = value;
  }
  get fallbackVersionOnImport() {
    return this._config.fallbackVersionOnImport.value;
  }
  set fallbackVersionOnImport(value) {
    this._config.fallbackVersionOnImport.value = value;
  }
  get ignoreIncompleteTopicsOnImport() {
    return this._config.ignoreIncompleteTopicsOnImport.value;
  }
  set ignoreIncompleteTopicsOnImport(value) {
    this._config.ignoreIncompleteTopicsOnImport.value = value;
  }
  get exportCustomDataAsLabels() {
    return this._config.exportCustomDataAsLabels.value;
  }
  set exportCustomDataAsLabels(value) {
    this._config.exportCustomDataAsLabels.value = value;
  }
}
const _BCFTopics = class _BCFTopics extends Component {
  constructor() {
    super(...arguments);
    __publicField(this, "enabled", false);
    __publicField(this, "_defaultConfig", {
      author: "jhon.doe@example.com",
      version: "2.1",
      types: /* @__PURE__ */ new Set([
        "Clash",
        "Failure",
        "Fault",
        "Inquiry",
        "Issue",
        "Remark",
        "Request"
      ]),
      statuses: /* @__PURE__ */ new Set(["Active", "In Progress", "Done", "In Review", "Closed"]),
      priorities: /* @__PURE__ */ new Set(["On hold", "Minor", "Normal", "Major", "Critical"]),
      labels: /* @__PURE__ */ new Set(),
      stages: /* @__PURE__ */ new Set(),
      users: /* @__PURE__ */ new Set(),
      includeSelectionTag: false,
      updateExtensionsOnImport: true,
      strict: false,
      includeAllExtensionsOnExport: true,
      fallbackVersionOnImport: "2.1",
      ignoreIncompleteTopicsOnImport: false,
      exportCustomDataAsLabels: false
    });
    __publicField(this, "config", new BCFTopicsConfigManager(
      this,
      this.components,
      "BCF Topics",
      _BCFTopics.uuid
    ));
    __publicField(this, "list", new DataMap$1());
    __publicField(this, "documents", new DataMap$1());
    __publicField(this, "onSetup", new Event());
    __publicField(this, "isSetup", false);
    __publicField(this, "onBCFImported", new Event());
    __publicField(this, "onDisposed", new Event());
  }
  setup(config) {
    if (this.isSetup)
      return;
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.version = fullConfig.version;
    this.config.author = fullConfig.author;
    this.config.types = fullConfig.types;
    this.config.statuses = fullConfig.statuses;
    this.config.priorities = fullConfig.priorities;
    this.config.labels = fullConfig.labels;
    this.config.stages = fullConfig.stages;
    this.config.users = fullConfig.users;
    this.config.includeSelectionTag = fullConfig.includeSelectionTag;
    this.config.updateExtensionsOnImport = fullConfig.updateExtensionsOnImport;
    this.config.strict = fullConfig.strict;
    this.config.includeAllExtensionsOnExport = fullConfig.includeAllExtensionsOnExport;
    this.config.fallbackVersionOnImport = fullConfig.fallbackVersionOnImport || "";
    this.config.ignoreIncompleteTopicsOnImport = fullConfig.ignoreIncompleteTopicsOnImport;
    this.isSetup = true;
    this.enabled = true;
    this.onSetup.trigger();
  }
  /**
   * Creates a new BCFTopic instance and adds it to the list.
   *
   * @param data - Optional partial BCFTopic object to initialize the new topic with.
   * If not provided, default values will be used.
   * @returns The newly created BCFTopic instance.
   */
  create(data) {
    const topic = new Topic(this.components);
    if (data) {
      topic.guid = data.guid ?? topic.guid;
      topic.set(data);
    } else {
      this.list.set(topic.guid, topic);
    }
    return topic;
  }
  /**
   * Disposes of the BCFTopics component and triggers the onDisposed event.
   *
   * @remarks
   * This method clears the list of topics and triggers the onDisposed event.
   * It also resets the onDisposed event listener.
   */
  dispose() {
    this.list.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Retrieves the unique set of topic types used across all topics.
   *
   * @returns A Set containing the unique topic types.
   */
  get usedTypes() {
    const types = [...this.list].map(([_, topic]) => topic.type);
    return new Set(types);
  }
  /**
   * Retrieves the unique set of topic statuses used across all topics.
   *
   * @returns A Set containing the unique topic statuses.
   */
  get usedStatuses() {
    const statuses = [...this.list].map(([_, topic]) => topic.status);
    return new Set(statuses);
  }
  /**
   * Retrieves the unique set of topic priorities used across all topics.
   *
   * @returns A Set containing the unique topic priorities.
   * Note: This method filters out any null or undefined priorities.
   */
  get usedPriorities() {
    const priorities = [...this.list].map(([_, topic]) => topic.priority).filter((priority) => priority);
    return new Set(priorities);
  }
  /**
   * Retrieves the unique set of topic stages used across all topics.
   *
   * @returns A Set containing the unique topic stages.
   * Note: This method filters out any null or undefined stages.
   */
  get usedStages() {
    const stages = [...this.list].map(([_, topic]) => topic.stage).filter((stage) => stage);
    return new Set(stages);
  }
  /**
   * Retrieves the unique set of users associated with topics.
   *
   * @returns A Set containing the unique users.
   * Note: This method collects users from the creation author, assigned to, modified author, and comment authors.
   */
  get usedUsers() {
    const users = [];
    for (const [_, topic] of this.list) {
      users.push(topic.creationAuthor);
      if (topic.assignedTo)
        users.push(topic.assignedTo);
      if (topic.modifiedAuthor)
        users.push(topic.modifiedAuthor);
      for (const [_2, comment] of topic.comments) {
        users.push(comment.author);
        if (comment.modifiedAuthor)
          users.push(comment.modifiedAuthor);
      }
    }
    return new Set(users);
  }
  /**
   * Retrieves the unique set of labels used across all topics.
   *
   * @returns A Set containing the unique labels.
   */
  get usedLabels() {
    const labels = [];
    for (const [_, topic] of this.list)
      labels.push(...topic.labels);
    return new Set(labels);
  }
  /**
   * Updates the set of extensions (types, statuses, priorities, labels, stages, users) based on the current topics.
   * This method iterates through each topic in the list and adds its properties to the corresponding sets in the config.
   */
  updateExtensions() {
    for (const [_, topic] of this.list) {
      for (const label of topic.labels)
        this.config.labels.add(label);
      this.config.types.add(topic.type);
      if (topic.priority)
        this.config.priorities.add(topic.priority);
      if (topic.stage)
        this.config.stages.add(topic.stage);
      this.config.statuses.add(topic.status);
      this.config.users.add(topic.creationAuthor);
      if (topic.assignedTo)
        this.config.users.add(topic.assignedTo);
      if (topic.modifiedAuthor)
        this.config.users.add(topic.modifiedAuthor);
      for (const [_2, comment] of topic.comments) {
        this.config.users.add(comment.author);
        if (comment.modifiedAuthor)
          this.config.users.add(comment.modifiedAuthor);
      }
    }
  }
  /**
   * Updates the references to viewpoints in the topics.
   * This function iterates through each topic and checks if the viewpoints exist in the viewpoints list.
   * If a viewpoint does not exist, it is removed from the topic's viewpoints.
   */
  updateViewpointReferences() {
    const viewpoints = this.components.get(Viewpoints);
    for (const [_, topic] of this.list) {
      for (const viewpointID of topic.viewpoints) {
        const exists = viewpoints.list.has(viewpointID);
        if (!exists)
          topic.viewpoints.delete(viewpointID);
      }
    }
  }
  /**
   * Exports the given topics to a BCF (Building Collaboration Format) zip file.
   *
   * @param topics - The topics to export. Defaults to all topics in the list.
   * @returns A promise that resolves to a Blob containing the exported BCF zip file.
   */
  async export(topics = this.list.values()) {
    const zip = new JSZip();
    zip.file(
      "bcf.version",
      `<?xml version="1.0" encoding="UTF-8"?>
    <Version VersionId="${this.config.version}" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/buildingSMART/BCF-XML/release_3_0/Schemas/version.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    </Version>`
    );
    for (const [guid, doc] of this.documents.entries()) {
      if (doc.type === "external")
        continue;
      zip.file(
        this.config.version === "2.1" ? doc.fileName : `documents/${guid}`,
        doc.data
      );
    }
    if (this.config.version === "3") {
      const docTags = [];
      for (const [guid, doc] of this.documents.entries()) {
        const { type, description } = doc;
        if (type === "external")
          continue;
        docTags.push(`<Document Guid="${guid}">
        <Filename>${doc.fileName}</Filename>
        ${description ? `<Description>${description}</Description>` : ""}
      </Document>`);
      }
      if (docTags.length > 0) {
        zip.file(
          "documents.xml",
          `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  <DocumentInfo xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="documents.xsd">
    <Documents>
      ${docTags.join("\n")}
    </Documents>
  </DocumentInfo>`
        );
      }
    }
    zip.file("bcf.extensions", this.serializeExtensions());
    const viewpoints = this.components.get(Viewpoints);
    for (const topic of topics) {
      const topicFolder = zip.folder(topic.guid);
      topicFolder.file("markup.bcf", topic.serialize());
      for (const viewpointID of topic.viewpoints) {
        const viewpoint = viewpoints.list.get(viewpointID);
        if (!viewpoint)
          continue;
        const viewpointFileName = viewpoint.title ?? viewpoint.guid;
        topicFolder.file(
          `${viewpointFileName}.bcfv`,
          await viewpoint.serialize()
        );
        const snapshotData = viewpoints.snapshots.get(viewpoint.snapshot);
        if (!snapshotData)
          continue;
        const snapshotFileName = snapshotData ? viewpoint.snapshot : viewpoint.guid;
        const snapshotExtension = viewpoints.getSnapshotExtension(
          viewpoint.snapshot
        );
        topicFolder.file(
          `${snapshotFileName}.${snapshotExtension}`,
          snapshotData,
          {
            binary: true
          }
        );
      }
    }
    const content = await zip.generateAsync({ type: "blob" });
    return content;
  }
  serializeExtensions() {
    const types = [...this.config.types].map((type) => `<TopicType>${type}</TopicType>`).join("\n");
    const statuses = [...this.config.statuses].map((status) => `<TopicStatus>${status}</TopicStatus>`).join("\n");
    const priorities = [...this.config.priorities].map((priority) => `<Priority>${priority}</Priority>`).join("\n");
    const labels = [...this.config.labels].map((label) => `<TopicLabel>${label}</TopicLabel>`).join("\n");
    const stages = [...this.config.stages].map((stage) => `<Stage>${stage}</Stage>`).join("\n");
    const users = [...this.config.users].map((user) => `<User>${user}</User>`).join("\n");
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Extensions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="your-schema-location.xsd">
        ${types.length !== 0 ? `<TopicTypes>
${types}
</TopicTypes>` : ""}
        ${statuses.length !== 0 ? `<TopicStatuses>
${statuses}
</TopicStatuses>` : ""}
        ${priorities.length !== 0 ? `<Priorities>
${priorities}
</Priorities>` : ""}
        ${labels.length !== 0 ? `<TopicLabels>
${labels}
</TopicLabels>` : ""}
        ${stages.length !== 0 ? `<Stages>
${stages}
</Stages>` : ""}
        ${users.length !== 0 ? `<Users>
${users}
</Users>` : ""}
      </Extensions>
    `;
  }
  processMarkupComment(markupComment) {
    const {
      Guid,
      Date: CommentDate,
      Author,
      Comment: CommentText,
      Viewpoint: Viewpoint2
    } = markupComment;
    if (!(Guid && CommentDate && Author && (Comment || Viewpoint2)))
      return null;
    const comment = new Comment(this.components, CommentText ?? "");
    comment.guid = Guid;
    comment.date = new Date(CommentDate);
    comment.author = Author;
    comment.viewpoint = Viewpoint2 == null ? void 0 : Viewpoint2.Guid;
    comment.modifiedAuthor = markupComment.ModifiedAuthor;
    comment.modifiedDate = markupComment.ModifiedDate ? new Date(markupComment.ModifiedDate) : void 0;
    return comment;
  }
  getMarkupComments(markup, version) {
    var _a2;
    let data;
    if (version === "2.1")
      data = markup.Comment;
    if (version === "3")
      data = (_a2 = markup.Topic.Comments) == null ? void 0 : _a2.Comment;
    if (!data)
      return [];
    data = Array.isArray(data) ? data : [data];
    const comments = data.map((comment) => this.processMarkupComment(comment)).filter((comment) => comment);
    const array = Array.isArray(comments) ? comments : [comments];
    return array;
  }
  getMarkupLabels(markup, version) {
    var _a2;
    let data;
    if (version === "2.1")
      data = markup.Topic.Labels;
    if (version === "3")
      data = (_a2 = markup.Topic.Labels) == null ? void 0 : _a2.Label;
    if (!data)
      return [];
    const labels = Array.isArray(data) ? data : [data];
    return labels;
  }
  getMarkupViewpoints(markup, version) {
    var _a2;
    let data;
    if (version === "2.1")
      data = markup.Viewpoints;
    if (version === "3")
      data = (_a2 = markup.Topic.Viewpoints) == null ? void 0 : _a2.ViewPoint;
    if (!data)
      return [];
    data = Array.isArray(data) ? data : [data];
    return data;
  }
  getMarkupRelatedTopics(markup, version) {
    var _a2;
    let data;
    if (version === "2.1")
      data = markup.Topic.RelatedTopic;
    if (version === "3")
      data = (_a2 = markup.Topic.RelatedTopics) == null ? void 0 : _a2.RelatedTopic;
    if (!data)
      return [];
    const topics = Array.isArray(data) ? data : [data];
    return topics.map((topic) => topic.Guid);
  }
  getMarkupDocumentReferences(markup, version) {
    var _a2;
    let data;
    if (version === "2.1")
      data = markup.Topic.DocumentReference;
    if (version === "3")
      data = (_a2 = markup.Topic.DocumentReferences) == null ? void 0 : _a2.DocumentReference;
    if (!data)
      return [];
    const references = Array.isArray(data) ? data : [data];
    return references;
  }
  /**
   * Loads BCF (Building Collaboration Format) data into the engine.
   *
   * @param world - The default world where the viewpoints are going to be created.
   * @param data - The BCF data to load.
   *
   * @returns A promise that resolves to an object containing the created viewpoints and topics.
   *
   * @throws An error if the BCF version is not supported.
   */
  async load(data) {
    var _a2, _b, _c;
    const {
      fallbackVersionOnImport,
      ignoreIncompleteTopicsOnImport,
      updateExtensionsOnImport
    } = this.config;
    const zip = new JSZip();
    await zip.loadAsync(data);
    const files = Object.values(zip.files);
    let version = fallbackVersionOnImport;
    const versionFile = files.find((file) => file.name.endsWith(".version"));
    if (versionFile) {
      const versionXML = await versionFile.async("string");
      const bcfVersion = _BCFTopics.xmlParser.parse(versionXML).Version.VersionId;
      version = String(bcfVersion);
    }
    if (!(version && (version === "2.1" || version === "3"))) {
      throw new Error(`BCFTopics: ${version} is not supported.`);
    }
    const extensionsFile = files.find(
      (file) => file.name.endsWith(".extensions")
    );
    if (updateExtensionsOnImport && extensionsFile) {
      const extensionsXML = await extensionsFile.async("string");
      extensionsImporter(this, extensionsXML);
    }
    const createdViewpoints = [];
    const viewpoints = this.components.get(Viewpoints);
    const viewpointFiles = files.filter((file) => file.name.endsWith(".bcfv"));
    for (const viewpointFile of viewpointFiles) {
      const xml = await viewpointFile.async("string");
      const visualizationInfo = _BCFTopics.xmlParser.parse(xml).VisualizationInfo;
      if (!visualizationInfo) {
        console.warn("Missing VisualizationInfo in Viewpoint");
        continue;
      }
      const bcfViewpoint = {};
      const {
        Guid,
        ClippingPlanes,
        Components: Components2,
        OrthogonalCamera,
        PerspectiveCamera
      } = visualizationInfo;
      if (Guid)
        bcfViewpoint.guid = Guid;
      if (Components2) {
        const components = {
          selection: [],
          coloring: [],
          visibility: {
            default_visibility: false,
            exceptions: [],
            view_setup_hints: {
              spaces_visible: false,
              space_boundaries_visible: false,
              openings_visible: false
            }
          }
        };
        bcfViewpoint.components = components;
        const { Selection, Visibility } = Components2;
        if (Selection && Selection.Component) {
          const selectionComponents = Array.isArray(Selection.Component) ? Selection.Component : [Selection.Component];
          components.selection = selectionComponents.map((component) => {
            if (!component.IfcGuid)
              return null;
            return { ifc_guid: component.IfcGuid };
          }).filter((data2) => data2 !== null);
        }
        if (Visibility && "DefaultVisibility" in Visibility) {
          components.visibility.default_visibility = Visibility.DefaultVisibility;
        }
        if (Visibility && Visibility.Exceptions && "Component" in Visibility.Exceptions) {
          const { Component: Component2 } = Visibility.Exceptions;
          const exceptionComponents = Array.isArray(Component2) ? Component2 : [Component2];
          components.visibility.exceptions = exceptionComponents.map((component) => {
            if (!component.IfcGuid)
              return null;
            return { ifc_guid: component.IfcGuid };
          }).filter((data2) => data2 !== null);
        }
        let ViewSetupHints;
        if (version === "2.1") {
          ViewSetupHints = Components2.ViewSetupHints;
        }
        if (version === "3") {
          ViewSetupHints = (_a2 = Components2.Visibility) == null ? void 0 : _a2.ViewSetupHints;
        }
        if (ViewSetupHints) {
          if ("OpeningsVisible" in ViewSetupHints) {
            components.visibility.view_setup_hints.openings_visible = ViewSetupHints.OpeningsVisible;
          }
          if ("SpacesVisible" in ViewSetupHints) {
            components.visibility.view_setup_hints.spaces_visible = ViewSetupHints.SpacesVisible;
          }
          if ("SpaceBoundariesVisible" in ViewSetupHints) {
            components.visibility.view_setup_hints.space_boundaries_visible = ViewSetupHints.SpaceBoundariesVisible;
          }
        }
        const { Coloring } = Components2;
        if (Coloring && Coloring.Color) {
          const colors = Array.isArray(Coloring.Color) ? Coloring.Color : [Coloring.Color];
          for (const colorData of colors) {
            const { Color, Component: Component2 } = colorData;
            if (!(Color.length === 6 || Color.length === 8))
              continue;
            const color = Color.length === 6 ? Color : Color.slice(2);
            const colorComponents = Array.isArray(Component2) ? Component2 : [Component2];
            const guids = colorComponents.map((component) => {
              if (!component.IfcGuid)
                return null;
              return { ifc_guid: component.IfcGuid };
            }).filter((data2) => data2 !== null);
            components.coloring.push({
              color,
              components: guids
            });
          }
        }
      }
      if (OrthogonalCamera || PerspectiveCamera) {
        const camera = visualizationInfo.PerspectiveCamera ?? visualizationInfo.OrthogonalCamera;
        const { CameraViewPoint, CameraDirection } = camera;
        const position = new THREE$1.Vector3(
          Number(CameraViewPoint.X),
          Number(CameraViewPoint.Z),
          Number(-CameraViewPoint.Y)
        );
        const direction = new THREE$1.Vector3(
          Number(CameraDirection.X),
          Number(CameraDirection.Z),
          Number(-CameraDirection.Y)
        );
        const viewpointCamera = {
          camera_view_point: { x: position.x, y: position.y, z: position.z },
          camera_direction: { x: direction.x, y: direction.y, z: direction.z },
          aspect_ratio: "AspectRatio" in camera ? camera.AspectRatio : 1,
          // TODO: Better define camera_up_vector
          camera_up_vector: {
            x: 0,
            y: 0,
            z: 0
          }
        };
        if ("ViewToWorldScale" in camera) {
          bcfViewpoint.orthogonal_camera = {
            ...viewpointCamera,
            view_to_world_scale: camera.ViewToWorldScale
          };
        }
        if ("FieldOfView" in camera) {
          bcfViewpoint.perspective_camera = {
            ...viewpointCamera,
            field_of_view: camera.FieldOfView
          };
        }
      }
      if (ClippingPlanes) {
        const planes = Array.isArray(ClippingPlanes.ClippingPlane) ? ClippingPlanes.ClippingPlane : [ClippingPlanes.ClippingPlane];
        const clippingPlanes = planes.map(
          ({ Location, Direction }) => {
            return {
              location: { x: Location.x, y: Location.y, z: Location.z },
              direction: { x: Direction.x, y: Direction.y, z: Direction.z }
            };
          }
        );
        bcfViewpoint.clipping_planes = clippingPlanes;
      }
      const viewpoint = new Viewpoint(this.components, bcfViewpoint);
      createdViewpoints.push(viewpoint);
    }
    const topicRelations = {};
    const topics = [];
    const markupFiles = files.filter((file) => file.name.endsWith(".bcf"));
    for (const markupFile of markupFiles) {
      const xml = await markupFile.async("string");
      const markup = _BCFTopics.xmlParser.parse(xml).Markup;
      const markupTopic = markup.Topic;
      const {
        Guid,
        TopicType,
        TopicStatus,
        Title,
        CreationDate,
        CreationAuthor
      } = markupTopic;
      if (ignoreIncompleteTopicsOnImport) {
        if (!(Guid && TopicType && TopicStatus && Title && CreationDate && CreationAuthor))
          continue;
      }
      const topic = new Topic(this.components);
      topic.guid = Guid ?? topic.guid;
      const relatedTopics = this.getMarkupRelatedTopics(markup, version);
      topicRelations[topic.guid] = new Set(relatedTopics);
      topic.type = TopicType ?? topic.type;
      topic.status = TopicStatus ?? topic.status;
      topic.title = Title ?? topic.title;
      topic.creationDate = CreationDate ? new Date(CreationDate) : topic.creationDate;
      topic.creationAuthor = CreationAuthor ?? topic.creationAuthor;
      topic.serverAssignedId = markupTopic.ServerAssignedId;
      topic.priority = markupTopic.Priority;
      topic.index = markupTopic.Index;
      topic.modifiedDate = markupTopic.ModifiedDate ? new Date(markupTopic.ModifiedDate) : void 0;
      topic.modifiedAuthor = markupTopic.ModifiedAuthor;
      topic.dueDate = markupTopic.DueDate ? new Date(markupTopic.DueDate) : void 0;
      topic.assignedTo = markupTopic.AssignedTo;
      topic.description = markupTopic.Description;
      topic.stage = markupTopic.Stage;
      const labels = this.getMarkupLabels(markup, version);
      for (const label of labels)
        topic.labels.add(label);
      const comments = this.getMarkupComments(markup, version);
      for (const comment of comments)
        topic.comments.set(comment.guid, comment);
      const markupViewpoints = this.getMarkupViewpoints(markup, version);
      for (const markupViewpoint of markupViewpoints) {
        if (!(markupViewpoint && markupViewpoint.Guid))
          continue;
        const viewpoint = viewpoints.list.get(markupViewpoint.Guid);
        if (!viewpoint)
          continue;
        topic.viewpoints.add(viewpoint.guid);
        const snapshotName = `${topic.guid}/${markupViewpoint.Snapshot}`;
        const snapshotFile = files.find(({ name }) => name === snapshotName);
        if (snapshotFile) {
          const buffer = await snapshotFile.async("arraybuffer");
          const bytes = new Uint8Array(buffer);
          viewpoints.snapshots.set(viewpoint.guid, bytes);
          viewpoint.snapshot = viewpoint.guid ?? null;
        }
      }
      const markupDocReferences = this.getMarkupDocumentReferences(
        markup,
        version
      );
      const documentsFile = files.find((file) => file.name === "documents.xml");
      let documentsData = [];
      const documentsListXML = await (documentsFile == null ? void 0 : documentsFile.async("string"));
      if (documentsListXML) {
        const data2 = (_c = (_b = XML.parser.parse(documentsListXML).DocumentInfo) == null ? void 0 : _b.Documents) == null ? void 0 : _c.Document;
        documentsData = Array.isArray(data2) ? data2 : [data2];
      }
      for (const reference of markupDocReferences) {
        const {
          Description: description,
          // From 3.0
          DocumentGuid,
          Url: url,
          // From 2.1
          isExternal,
          ReferencedDocument
        } = reference;
        if (DocumentGuid && documentsData.length > 0) {
          const docInfo = documentsData.find(
            ({ Guid: Guid2 }) => Guid2 === DocumentGuid
          );
          const docFile = files.find(
            (file) => file.name.endsWith(DocumentGuid)
          );
          const data2 = await (docFile == null ? void 0 : docFile.async("uint8array"));
          if (!(docInfo && data2))
            continue;
          const { Description: description2, Filename: fileName } = docInfo;
          this.documents.set(DocumentGuid, {
            type: "internal",
            fileName,
            description: description2,
            data: data2
          });
          topic.documentReferences.add(DocumentGuid);
        }
        if (url) {
          const docGuid = this.documents.add({
            type: "external",
            url,
            description
          });
          topic.documentReferences.add(docGuid);
        }
        if (ReferencedDocument) {
          let docGuid = null;
          if (isExternal) {
            docGuid = this.documents.add({
              type: "external",
              url: ReferencedDocument,
              description
            });
          } else {
            const splitPath = ReferencedDocument.split("/");
            const fileName = splitPath[splitPath.length - 1];
            const docFile = files.find((file) => file.name.endsWith(fileName));
            const data2 = await (docFile == null ? void 0 : docFile.async("uint8array"));
            if (!data2)
              continue;
            docGuid = this.documents.add({
              type: "internal",
              fileName,
              data: data2,
              description
            });
          }
          topic.documentReferences.add(docGuid);
        }
      }
      this.list.set(topic.guid, topic);
      topics.push(topic);
    }
    for (const topicID in topicRelations) {
      const topic = this.list.get(topicID);
      if (!topic)
        continue;
      const relations = topicRelations[topicID];
      for (const guid of relations) {
        topic.relatedTopics.add(guid);
      }
    }
    this.onBCFImported.trigger(topics);
    return { viewpoints: createdViewpoints, topics };
  }
};
__publicField(_BCFTopics, "uuid", "de977976-e4f6-4e4f-a01a-204727839802");
__publicField(_BCFTopics, "xmlParser", new fxp.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
let BCFTopics = _BCFTopics;
const _raycaster = new Raycaster();
const _tempVector = new Vector3();
const _tempVector2 = new Vector3();
const _tempQuaternion = new Quaternion();
const _unit = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
const _changeEvent = { type: "change" };
const _mouseDownEvent = { type: "mouseDown", mode: null };
const _mouseUpEvent = { type: "mouseUp", mode: null };
const _objectChangeEvent = { type: "objectChange" };
class TransformControls extends Controls {
  /**
   * Constructs a new controls instance.
   *
   * @param {Camera} camera - The camera of the rendered scene.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(camera, domElement = null) {
    super(void 0, domElement);
    const root = new TransformControlsRoot(this);
    this._root = root;
    const gizmo = new TransformControlsGizmo();
    this._gizmo = gizmo;
    root.add(gizmo);
    const plane = new TransformControlsPlane();
    this._plane = plane;
    root.add(plane);
    const scope = this;
    function defineProperty(propName2, defaultValue) {
      let propValue = defaultValue;
      Object.defineProperty(scope, propName2, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            plane[propName2] = value;
            gizmo[propName2] = value;
            scope.dispatchEvent({ type: propName2 + "-changed", value });
            scope.dispatchEvent(_changeEvent);
          }
        }
      });
      scope[propName2] = defaultValue;
      plane[propName2] = defaultValue;
      gizmo[propName2] = defaultValue;
    }
    defineProperty("camera", camera);
    defineProperty("object", void 0);
    defineProperty("enabled", true);
    defineProperty("axis", null);
    defineProperty("mode", "translate");
    defineProperty("translationSnap", null);
    defineProperty("rotationSnap", null);
    defineProperty("scaleSnap", null);
    defineProperty("space", "world");
    defineProperty("size", 1);
    defineProperty("dragging", false);
    defineProperty("showX", true);
    defineProperty("showY", true);
    defineProperty("showZ", true);
    defineProperty("minX", -Infinity);
    defineProperty("maxX", Infinity);
    defineProperty("minY", -Infinity);
    defineProperty("maxY", Infinity);
    defineProperty("minZ", -Infinity);
    defineProperty("maxZ", Infinity);
    const worldPosition = new Vector3();
    const worldPositionStart = new Vector3();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector3();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector3();
    const pointEnd = new Vector3();
    const rotationAxis = new Vector3();
    const rotationAngle = 0;
    const eye = new Vector3();
    defineProperty("worldPosition", worldPosition);
    defineProperty("worldPositionStart", worldPositionStart);
    defineProperty("worldQuaternion", worldQuaternion);
    defineProperty("worldQuaternionStart", worldQuaternionStart);
    defineProperty("cameraPosition", cameraPosition);
    defineProperty("cameraQuaternion", cameraQuaternion);
    defineProperty("pointStart", pointStart);
    defineProperty("pointEnd", pointEnd);
    defineProperty("rotationAxis", rotationAxis);
    defineProperty("rotationAngle", rotationAngle);
    defineProperty("eye", eye);
    this._offset = new Vector3();
    this._startNorm = new Vector3();
    this._endNorm = new Vector3();
    this._cameraScale = new Vector3();
    this._parentPosition = new Vector3();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector3();
    this._worldScaleStart = new Vector3();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector3();
    this._positionStart = new Vector3();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector3();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    if (domElement !== null) {
      this.connect(domElement);
    }
  }
  connect(element) {
    super.connect(element);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.style.touchAction = "auto";
  }
  /**
   * Returns the visual representation of the controls. Add the helper to your scene to
   * visually transform the attached  3D object.
   *
   * @return {TransformControlsRoot} The helper.
   */
  getHelper() {
    return this._root;
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true)
      return;
    if (pointer !== null)
      _raycaster.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer != null && pointer.button !== 0)
      return;
    if (this.axis !== null) {
      if (pointer !== null)
        _raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space = this.space;
    if (mode === "scale") {
      space = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer !== null && pointer.button !== -1)
      return;
    if (pointer !== null)
      _raycaster.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
    if (!planeIntersect)
      return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1)
        this._offset.x = 0;
      if (axis.indexOf("Y") === -1)
        this._offset.y = 0;
      if (axis.indexOf("Z") === -1)
        this._offset.z = 0;
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
      object.position.x = Math.max(this.minX, Math.min(this.maxX, object.position.x));
      object.position.y = Math.max(this.minY, Math.min(this.maxY, object.position.y));
      object.position.z = Math.max(this.minZ, Math.min(this.maxZ, object.position.z));
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0)
          d *= -1;
        _tempVector2.set(d, d, d);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      let _inPlaneRotation = false;
      if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        _tempVector.cross(this.eye);
        if (_tempVector.length() === 0) {
          _inPlaneRotation = true;
        } else {
          this.rotationAngle = this._offset.dot(_tempVector.normalize()) * ROTATION_SPEED;
        }
      }
      if (axis === "E" || _inPlaneRotation) {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      }
      if (this.rotationSnap)
        this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer !== null && pointer.button !== 0)
      return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.disconnect();
    this._root.dispose();
  }
  /**
   * Sets the 3D object that should be transformed and ensures the controls UI is visible.
   *
   * @param {Object3D} object -  The 3D object that should be transformed.
   * @return {TransformControls} A reference to this controls.
   */
  attach(object) {
    this.object = object;
    this._root.visible = true;
    return this;
  }
  /**
   * Removes the current 3D object from the controls and makes the helper UI invisible.
   *
   * @return {TransformControls} A reference to this controls.
   */
  detach() {
    this.object = void 0;
    this.axis = null;
    this._root.visible = false;
    return this;
  }
  /**
   * Resets the object's position, rotation and scale to when the current transform began.
   */
  reset() {
    if (!this.enabled)
      return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  /**
   * Returns the raycaster that is used for user interaction. This object is shared between all
   * instances of `TransformControls`.
   *
   * @returns {Raycaster} The internal raycaster.
   */
  getRaycaster() {
    return _raycaster;
  }
  /**
   * Returns the transformation mode.
   *
   * @returns {'translate'|'rotate'|'scale'} The transformation mode.
   */
  getMode() {
    return this.mode;
  }
  /**
   * Sets the given transformation mode.
   *
   * @param {'translate'|'rotate'|'scale'} mode - The transformation mode to set.
   */
  setMode(mode) {
    this.mode = mode;
  }
  /**
   * Sets the translation snap.
   *
   * @param {?number} translationSnap - The translation snap to set.
   */
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  /**
   * Sets the rotation snap.
   *
   * @param {?number} rotationSnap - The rotation snap to set.
   */
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  /**
   * Sets the scale snap.
   *
   * @param {?number} scaleSnap - The scale snap to set.
   */
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  /**
   * Sets the size of the helper UI.
   *
   * @param {number} size - The size to set.
   */
  setSize(size) {
    this.size = size;
  }
  /**
   * Sets the coordinate space in which transformations are applied.
   *
   * @param {'world'|'local'} space - The space to set.
   */
  setSpace(space) {
    this.space = space;
  }
}
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) / rect.width * 2 - 1,
      y: -(event.clientY - rect.top) / rect.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled)
    return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown(event) {
  if (!this.enabled)
    return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
  if (!this.enabled)
    return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
  if (!this.enabled)
    return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
const _tempEuler = new Euler();
const _alignVector = new Vector3(0, 1, 0);
const _zeroVector = new Vector3(0, 0, 0);
const _lookAtMatrix = new Matrix4();
const _tempQuaternion2 = new Quaternion();
const _identityQuaternion = new Quaternion();
const _dirVector = new Vector3();
const _tempMatrix = new Matrix4();
const _unitX = new Vector3(1, 0, 0);
const _unitY = new Vector3(0, 1, 0);
const _unitZ = new Vector3(0, 0, 1);
const _v1 = new Vector3();
const _v2 = new Vector3();
const _v3 = new Vector3();
class TransformControlsRoot extends Object3D {
  constructor(controls) {
    super();
    this.isTransformControlsRoot = true;
    this.controls = controls;
    this.visible = false;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(force) {
    const controls = this.controls;
    if (controls.object !== void 0) {
      controls.object.updateMatrixWorld();
      if (controls.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        controls.object.parent.matrixWorld.decompose(controls._parentPosition, controls._parentQuaternion, controls._parentScale);
      }
      controls.object.matrixWorld.decompose(controls.worldPosition, controls.worldQuaternion, controls._worldScale);
      controls._parentQuaternionInv.copy(controls._parentQuaternion).invert();
      controls._worldQuaternionInv.copy(controls.worldQuaternion).invert();
    }
    controls.camera.updateMatrixWorld();
    controls.camera.matrixWorld.decompose(controls.cameraPosition, controls.cameraQuaternion, controls._cameraScale);
    if (controls.camera.isOrthographicCamera) {
      controls.camera.getWorldDirection(controls.eye).negate();
    } else {
      controls.eye.copy(controls.cameraPosition).sub(controls.worldPosition).normalize();
    }
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.traverse(function(child) {
      if (child.geometry)
        child.geometry.dispose();
      if (child.material)
        child.material.dispose();
    });
  }
}
class TransformControlsGizmo extends Object3D {
  constructor() {
    super();
    this.isTransformControlsGizmo = true;
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(force) {
    const space = this.mode === "scale" ? "local" : this.space;
    const quaternion = space === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_THRESHOLD = 0.99;
        const PLANE_HIDE_THRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
}
class TransformControlsPlane extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    );
    this.isTransformControlsPlane = true;
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale")
      space = "local";
    _v1.copy(_unitX).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v2.copy(_unitY).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v2);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v2);
            _dirVector.copy(_v2).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v2);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
}
class SimplePlane {
  constructor(components, world, origin, normal, material, size = 5, activateControls = true) {
    /** Event that fires when the user starts dragging a clipping plane. */
    __publicField(this, "onDraggingStarted", new Event());
    /** Event that fires when the user stops dragging a clipping plane. */
    __publicField(this, "onDraggingEnded", new Event());
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /**
     * The normal vector of the clipping plane.
     */
    __publicField(this, "normal");
    /**
     * The origin point of the clipping plane.
     */
    __publicField(this, "origin");
    /**
     * The THREE.js Plane object representing the clipping plane.
     */
    __publicField(this, "three", new THREE$1.Plane());
    /** The components instance to which this plane belongs. */
    __publicField(this, "components");
    /** The world instance to which this plane belongs. */
    __publicField(this, "world");
    /** A custom string to identify what this plane is used for. */
    __publicField(this, "type", "default");
    __publicField(this, "_title", "Clipping Plane");
    __publicField(this, "_helper");
    __publicField(this, "_visible", true);
    __publicField(this, "_enabled", true);
    __publicField(this, "_controlsActive", false);
    __publicField(this, "_arrowBoundBox", new THREE$1.Mesh());
    __publicField(this, "_planeMesh");
    __publicField(this, "_controls");
    __publicField(this, "_hiddenMaterial", new THREE$1.MeshBasicMaterial({
      visible: false
    }));
    __publicField(this, "_visibilityBeforeDisabled", true);
    __publicField(this, "notifyManager", () => {
      const clipper = this.components.get(Clipper);
      const id = clipper.list.getKey(this);
      if (id)
        clipper.list.set(id, this);
    });
    /** {@link Updateable.update} */
    __publicField(this, "update", () => {
      if (!this._enabled)
        return;
      this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    });
    __publicField(this, "changeDrag", (event) => {
      this._visible = !event.value;
      this.preventCameraMovement();
      this.notifyDraggingChanged(event);
    });
    this.components = components;
    this.world = world;
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    this.normal = normal;
    this.origin = origin;
    world.renderer.setPlane(true, this.three);
    this._planeMesh = SimplePlane.newPlaneMesh(size, material);
    this._helper = this.newHelper();
    this._controls = this.newTransformControls();
    this.three.setFromNormalAndCoplanarPoint(normal, origin);
    if (activateControls) {
      this.toggleControls(true);
    }
  }
  set title(value) {
    this._title = value;
    this.notifyManager();
  }
  get title() {
    return this._title;
  }
  /**
   * Getter for the enabled state of the clipping plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the clipping plane.
   * Updates the clipping plane state in the renderer and throws an error if no renderer is found.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(state) {
    if (this.world.isDisposing) {
      return;
    }
    if (!this.world.renderer) {
      throw new Error("No renderer found for clipping plane!");
    }
    this._enabled = state;
    if (state) {
      this.visible = this._visibilityBeforeDisabled;
    } else {
      this._visibilityBeforeDisabled = this.visible;
      this.visible = false;
    }
    this.world.renderer.setPlane(state, this.three);
    this.notifyManager();
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(state) {
    this._visible = state;
    this._controls.getHelper().visible = state;
    this._helper.visible = state;
    this.toggleControls(state);
    this.notifyManager();
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(material) {
    this._planeMesh.material = material;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(size) {
    this._planeMesh.scale.set(size, size, size);
  }
  /**
   * Getter for the helper object of the clipping plane.
   * The helper object is a THREE.Object3D that contains the clipping plane mesh and other related objects.
   * It is used for positioning, rotating, and scaling the clipping plane in the 3D scene.
   *
   * @returns {THREE.Object3D} The helper object of the clipping plane.
   */
  get helper() {
    return this._helper;
  }
  /**
   * Getter for the transform controls of the clipping plane.
   * The controls allow interactive manipulation (translation, rotation, etc.) of the clipping plane.
   *
   * @returns {TransformControls} The transform controls of the clipping plane.
   */
  get controls() {
    return this._controls;
  }
  /**
   * Sets the clipping plane's normal and origin from the given normal and point.
   * This method resets the clipping plane's state, updates the normal and origin,
   * and positions the helper object accordingly.
   *
   * @param normal - The new normal vector for the clipping plane.
   * @param point - The new origin point for the clipping plane.
   *
   * @returns {void}
   */
  setFromNormalAndCoplanarPoint(normal, point) {
    this.reset();
    if (!this.normal.equals(normal)) {
      this.normal.copy(normal);
      this._helper.lookAt(normal);
    }
    this.origin.copy(point);
    this._helper.position.copy(point);
    this._helper.updateMatrix();
    this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    this.onDraggingStarted.reset();
    this.onDraggingEnded.reset();
    this._helper.removeFromParent();
    if (this.world.renderer) {
      this.world.renderer.setPlane(false, this.three);
    }
    this._arrowBoundBox.removeFromParent();
    this._arrowBoundBox.geometry.dispose();
    this._planeMesh.geometry.dispose();
    this._controls.getHelper().removeFromParent();
    this._controls.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  reset() {
    const normal = new THREE$1.Vector3(1, 0, 0);
    const point = new THREE$1.Vector3();
    if (!this.normal.equals(normal)) {
      this.normal.copy(normal);
      this._helper.lookAt(normal);
    }
    this.origin.copy(point);
    this._helper.position.copy(point);
    this._helper.updateMatrix();
  }
  toggleControls(state) {
    if (state) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update);
      this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else {
      this._controls.removeEventListener("change", this.update);
      this._controls.removeEventListener("dragging-changed", this.changeDrag);
    }
    this._controlsActive = state;
  }
  newTransformControls() {
    if (!this.world.renderer) {
      throw new Error("No renderer found for clipping plane!");
    }
    const camera = this.world.camera.three;
    const container = this.world.renderer.three.domElement;
    const controls = new TransformControls(camera, container);
    this.initializeControls(controls);
    this.world.scene.three.add(controls.getHelper());
    return controls;
  }
  initializeControls(controls) {
    controls.attach(this._helper);
    controls.showX = false;
    controls.showY = false;
    controls.setSpace("local");
    this.createArrowBoundingBox();
    controls.getHelper().children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new THREE$1.CylinderGeometry(0.18, 0.18, 1.2);
    this._arrowBoundBox.material = this._hiddenMaterial;
    this._arrowBoundBox.rotateX(Math.PI / 2);
    this._arrowBoundBox.updateMatrix();
    this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(event) {
    if (event.value) {
      this.onDraggingStarted.trigger();
    } else {
      this.onDraggingEnded.trigger();
    }
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const helper = new THREE$1.Object3D();
    helper.lookAt(this.normal);
    helper.position.copy(this.origin);
    this._planeMesh.position.z += 0.01;
    helper.add(this._planeMesh);
    this.world.scene.three.add(helper);
    return helper;
  }
  static newPlaneMesh(size, material) {
    const planeGeom = new THREE$1.PlaneGeometry(1);
    const mesh = new THREE$1.Mesh(planeGeom, material);
    mesh.scale.set(size, size, size);
    return mesh;
  }
}
class ClipperConfigManager extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      enabled: {
        value: true,
        type: "Boolean"
      },
      visible: {
        value: true,
        type: "Boolean"
      },
      color: {
        value: new THREE$1.Color(),
        type: "Color"
      },
      opacity: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1
      },
      size: {
        type: "Number",
        interpolable: true,
        value: 2,
        min: 0,
        max: 100
      }
    });
  }
  get enabled() {
    return this._config.enabled.value;
  }
  set enabled(value) {
    this._config.enabled.value = value;
    this._component.enabled = value;
  }
  get visible() {
    return this._config.visible.value;
  }
  set visible(value) {
    this._config.visible.value = value;
    this._component.visible = value;
  }
  get color() {
    return this._config.color.value;
  }
  set color(value) {
    this._config.color.value = value;
    this._component.material.color.copy(value);
  }
  get opacity() {
    return this._config.opacity.value;
  }
  set opacity(value) {
    this._config.opacity.value = value;
    this._component.material.opacity = value;
  }
  get size() {
    return this._config.size.value;
  }
  set size(value) {
    this._config.size.value = value;
    this._component.size = value;
  }
}
const _Clipper = class _Clipper extends Component {
  constructor(components) {
    super(components);
    /** {@link Configurable.onSetup} */
    __publicField(this, "onSetup", new Event());
    /** Event that fires when the user starts dragging a clipping plane. */
    __publicField(this, "onBeforeDrag", new Event());
    /** Event that fires when the user stops dragging a clipping plane. */
    __publicField(this, "onAfterDrag", new Event());
    /**
     * Event that fires when the user starts creating a clipping plane.
     */
    __publicField(this, "onBeforeCreate", new Event());
    /**
     * Event that fires when the user cancels the creation of a clipping plane.
     */
    __publicField(this, "onBeforeCancel", new Event());
    /**
     * Event that fires after the user cancels the creation of a clipping plane.
     */
    __publicField(this, "onAfterCancel", new Event());
    /**
     * Event that fires when the user starts deleting a clipping plane.
     */
    __publicField(this, "onBeforeDelete", new Event());
    /**
     * Event that fires after a clipping plane has been created.
     * @param plane - The newly created clipping plane.
     */
    __publicField(this, "onAfterCreate", new Event());
    /**
     * Event that fires after a clipping plane has been deleted.
     * @param plane - The deleted clipping plane.
     */
    __publicField(this, "onAfterDelete", new Event());
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /** {@link Configurable.isSetup} */
    __publicField(this, "isSetup", false);
    /**
     * Whether to force the clipping plane to be orthogonal in the Y direction
     * (up). This is desirable when clipping a building horizontally and a
     * clipping plane is created in its roof, which might have a slight
     * slope for draining purposes.
     */
    __publicField(this, "orthogonalY", false);
    /**
     * The tolerance that determines whether an almost-horizontal clipping plane
     * will be forced to be orthogonal to the Y direction. {@link orthogonalY}
     * has to be `true` for this to apply.
     */
    __publicField(this, "toleranceOrthogonalY", 0.7);
    /**
     * The type of clipping plane to be created.
     * Default is {@link SimplePlane}.
     */
    __publicField(this, "Type", SimplePlane);
    /**
     * A list of all the clipping planes created by this component.
     */
    __publicField(this, "list", new FRAGS.DataMap());
    /** {@link Configurable.config} */
    __publicField(this, "config", new ClipperConfigManager(
      this,
      this.components,
      "Clipper",
      _Clipper.uuid
    ));
    __publicField(this, "_defaultConfig", {
      color: new THREE$1.Color(12255487),
      opacity: 0.2,
      size: 2
    });
    /** The material used in all the clipping planes. */
    __publicField(this, "_material", new THREE$1.MeshBasicMaterial({
      color: 12255487,
      side: THREE$1.DoubleSide,
      transparent: true,
      opacity: 0.2
    }));
    __publicField(this, "_size", 5);
    __publicField(this, "_enabled", false);
    __publicField(this, "_visible", true);
    __publicField(this, "onStateChanged", new Event());
    __publicField(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    });
    __publicField(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    });
    this.components.add(_Clipper.uuid, this);
    this.setEvents();
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(state) {
    this._enabled = state;
    this.onStateChanged.trigger(["enabled"]);
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(state) {
    this._visible = state;
    for (const [_, plane] of this.list) {
      plane.visible = state;
    }
    this.onStateChanged.trigger(["visibility"]);
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(material) {
    this._material = material;
    for (const [_, plane] of this.list) {
      plane.planeMaterial = material;
    }
    this.onStateChanged.trigger(["material"]);
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(size) {
    this._size = size;
    for (const [_, plane] of this.list) {
      plane.size = size;
    }
    this.onStateChanged.trigger(["size"]);
  }
  setEvents() {
    this.list.onBeforeDelete.add(({ value: plane }) => {
      if (!plane.world.renderer) {
        throw new Error("Renderer not found for this plane's world!");
      }
      plane.world.renderer.setPlane(false, plane.three);
      plane.dispose();
      this.updateMaterialsAndPlanes();
      this.onAfterDelete.trigger(plane);
    });
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
    this.list.clear();
    this._material.dispose();
    this.onBeforeCreate.reset();
    this.onBeforeCancel.reset();
    this.onBeforeDelete.reset();
    this.onBeforeDrag.reset();
    this.onAfterCreate.reset();
    this.onAfterCancel.reset();
    this.onAfterDelete.reset();
    this.onAfterDrag.reset();
    this.onDisposed.trigger(_Clipper.uuid);
    this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  async create(world) {
    const casters = this.components.get(Raycasters);
    const caster = casters.get(world);
    const intersects = await caster.castRay();
    if (intersects) {
      return this.createPlaneFromIntersection(world, intersects);
    }
    return null;
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(world, normal, point) {
    const id = this.newPlane(world, point, normal);
    this.updateMaterialsAndPlanes();
    return id;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param planeId - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  async delete(world, planeId) {
    if (!planeId) {
      const plane = await this.pickPlane(world);
      if (!plane)
        return;
      planeId = this.list.getKey(plane);
    }
    if (!planeId) {
      return;
    }
    this.list.delete(planeId);
  }
  /**
   * Deletes all the existing clipping planes.
   *
   * @param types - the types of planes to be deleted. If not provided, all planes will be deleted.
   */
  deleteAll(types) {
    for (const [id, plane] of this.list) {
      if (!types || types.has(plane.type)) {
        this.list.delete(id);
      }
    }
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.color = fullConfig.color;
    this.config.opacity = fullConfig.opacity;
    this.config.size = fullConfig.size;
    this.isSetup = true;
    this.onSetup.trigger();
  }
  // private deletePlane(plane: SimplePlane) {
  //   const index = this.list.indexOf(plane);
  //   if (index !== -1) {
  //     this.list.splice(index, 1);
  //     if (!plane.world.renderer) {
  //       throw new Error("Renderer not found for this plane's world!");
  //     }
  //     plane.world.renderer.setPlane(false, plane.three);
  //     plane.dispose();
  //     this.updateMaterialsAndPlanes();
  //     this.onAfterDelete.trigger(plane);
  //   }
  // }
  async pickPlane(world) {
    const casters = this.components.get(Raycasters);
    const caster = casters.get(world);
    const items = this.getAllPlaneMeshes();
    const intersects = await caster.castRay({ items });
    if (intersects) {
      const found = intersects.object;
      return [...this.list.values()].find((p) => p.meshes.includes(found));
    }
    return void 0;
  }
  getAllPlaneMeshes() {
    const meshes = [];
    for (const [_, plane] of this.list) {
      meshes.push(...plane.meshes);
    }
    return meshes;
  }
  createPlaneFromIntersection(world, intersect) {
    var _a2;
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    const constant = intersect.point.distanceTo(new THREE$1.Vector3(0, 0, 0));
    const normal = intersect.normal || ((_a2 = intersect.face) == null ? void 0 : _a2.normal);
    if (!constant || !normal) {
      return null;
    }
    const worldNormal = this.getWorldNormal(intersect, normal);
    const id = this.newPlane(world, intersect.point, worldNormal.negate());
    const plane = this.list.get(id);
    plane.visible = this._visible;
    plane.size = this._size;
    world.renderer.setPlane(true, plane.three);
    this.updateMaterialsAndPlanes();
    return plane;
  }
  getWorldNormal(intersect, normal) {
    const object = intersect.object;
    let transform = intersect.object.matrixWorld.clone();
    const isInstance = object instanceof THREE$1.InstancedMesh;
    if (isInstance && intersect.instanceId !== void 0) {
      const temp5 = new THREE$1.Matrix4();
      object.getMatrixAt(intersect.instanceId, temp5);
      transform = temp5.multiply(transform);
    }
    const normalMatrix = new THREE$1.Matrix3().getNormalMatrix(transform);
    const worldNormal = normal.clone().applyMatrix3(normalMatrix).normalize();
    this.normalizePlaneDirectionY(worldNormal);
    return worldNormal;
  }
  normalizePlaneDirectionY(normal) {
    if (this.orthogonalY) {
      if (normal.y > this.toleranceOrthogonalY) {
        normal.x = 0;
        normal.y = 1;
        normal.z = 0;
      }
      if (normal.y < -this.toleranceOrthogonalY) {
        normal.x = 0;
        normal.y = -1;
        normal.z = 0;
      }
    }
  }
  newPlane(world, point, normal) {
    const plane = new this.Type(
      this.components,
      world,
      point,
      normal,
      this._material
    );
    plane.onDraggingStarted.add(this._onStartDragging);
    plane.onDraggingEnded.add(this._onEndDragging);
    const id = UUID.create();
    this.list.set(id, plane);
    this.onAfterCreate.trigger(plane);
    return id;
  }
  updateMaterialsAndPlanes() {
    const worlds = this.components.get(Worlds);
    for (const [_id, world] of worlds.list) {
      if (!world.renderer) {
        continue;
      }
      world.renderer.updateClippingPlanes();
      const { clippingPlanes } = world.renderer;
      for (const model of world.meshes) {
        if (!model.material) {
          continue;
        }
        if (Array.isArray(model.material)) {
          for (const mat of model.material) {
            mat.clippingPlanes = clippingPlanes;
          }
        } else {
          model.material.clippingPlanes = clippingPlanes;
        }
      }
    }
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_Clipper, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
let Clipper = _Clipper;
class Viewpoint {
  constructor(components, data) {
    __publicField(this, "title");
    __publicField(this, "guid", UUID.create());
    /**
     * ClippingPlanes can be used to define a subsection of a building model that is related to the topic.
     * Each clipping plane is defined by Location and Direction.
     * The Direction vector points in the invisible direction meaning the half-space that is clipped.
     */
    __publicField(this, "clippingPlanes", new FRAGS.DataSet());
    __publicField(this, "camera", {
      aspect_ratio: 1,
      field_of_view: 60,
      camera_direction: { x: 0, y: 0, z: 0 },
      camera_view_point: { x: 0, y: 0, z: 0 },
      camera_up_vector: { x: 0, y: 1, z: 0 }
    });
    __publicField(this, "customData", {});
    /**
     * A list of components GUIDs to hide when defaultVisibility = true or to show when defaultVisibility = false
     */
    __publicField(this, "exceptionComponents", new FRAGS.DataSet());
    /**
     * A list of components GUIDs that should be selected (highlighted) when displaying a viewpoint.
     */
    __publicField(this, "selectionComponents", new FRAGS.DataSet());
    // this is not directly a ModelIdMap because a viewpoint should be able to reference elements from models that are not loaded, usually from information comming externally
    /**
     * A map of colors and components GUIDs that should be colorized when displaying a viewpoint.
     * For this to work, call viewpoint.colorize()
     */
    __publicField(this, "componentColors", new FRAGS.DataMap());
    /**
     * Boolean flags to allow fine control over the visibility of spaces.
     * A typical use of these flags is when DefaultVisibility=true but spaces should remain hidden.
     * @default false
     */
    __publicField(this, "spacesVisible", false);
    /**
     * Boolean flags to allow fine control over the visibility of space boundaries.
     * A typical use of these flags is when DefaultVisibility=true but space boundaries should remain hidden.
     * @default false
     */
    __publicField(this, "spaceBoundariesVisible", false);
    /**
     * Boolean flags to allow fine control over the visibility of openings.
     * A typical use of these flags is when DefaultVisibility=true but openings should remain hidden.
     * @default false
     */
    __publicField(this, "openingsVisible", false);
    /**
     * When true, all components should be visible unless listed in the exceptions
     * When false all components should be invisible unless listed in the exceptions
     */
    __publicField(this, "defaultVisibility", true);
    /**
     * The snapshotID that will be used for this viewpoint when exported.
     */
    __publicField(this, "snapshot", this.guid);
    __publicField(this, "_components");
    __publicField(this, "_world", null);
    __publicField(this, "notifyUpdate", () => {
      const manager = this._components.get(Viewpoints);
      manager.list.set(this.guid, this);
    });
    this._components = components;
    if (data) {
      this.guid = data.guid ?? this.guid;
      this.set(data);
    }
    this.setEvents();
  }
  async getSelectionMap() {
    const fragments = this._components.get(FragmentsManager);
    const modelIdMap = await fragments.guidsToModelIdMap([
      ...this.selectionComponents
    ]);
    return modelIdMap;
  }
  async getExceptionMap() {
    const fragments = this._components.get(FragmentsManager);
    const modelIdMap = await fragments.guidsToModelIdMap([
      ...this.exceptionComponents
    ]);
    return modelIdMap;
  }
  /**
   * Retrieves the projection type of the viewpoint's camera.
   *
   * @returns A string representing the projection type of the viewpoint's camera.
   *          It can be either 'Perspective' or 'Orthographic'.
   */
  get projection() {
    if ("field_of_view" in this.camera)
      return "Perspective";
    return "Orthographic";
  }
  /**
   * Retrieves the position vector of the viewpoint's camera.
   *
   * @returns A THREE.Vector3 representing the position of the viewpoint's camera.
   */
  get position() {
    const fragments = this._components.get(FragmentsManager);
    const { camera_view_point } = this.camera;
    const { x, y, z } = camera_view_point;
    const vector = new THREE$1.Vector3(x, y, z);
    fragments.applyBaseCoordinateSystem(vector, new THREE$1.Matrix4());
    return vector;
  }
  /**
   * Sets the position of the viewpoint's camera.
   * @param value - The new position for the viewpoint's camera.
   */
  set position(value) {
    const position = value.clone();
    const fragments = this._components.get(FragmentsManager);
    value.clone().applyMatrix4(fragments.baseCoordinationMatrix.clone().invert());
    this.camera.camera_view_point = {
      x: position.x,
      y: position.y,
      z: position.z
    };
  }
  /**
   * Retrieves the direction vector of the viewpoint's camera.
   * @returns A THREE.Vector3 representing the direction of the viewpoint's camera.
   */
  get direction() {
    const { camera_direction } = this.camera;
    const { x, y, z } = camera_direction;
    const vector = new THREE$1.Vector3(x, y, z);
    return vector;
  }
  /**
   * Represents the world in which the viewpoint will take effect.
   */
  set world(value) {
    this._world = value;
  }
  get world() {
    return this._world;
  }
  get _managerVersion() {
    const manager = this._components.get(BCFTopics);
    return manager.config.version;
  }
  /**
   * Retrieves the list of BCF topics associated with the current viewpoint.
   *
   * @remarks
   * This function retrieves the BCFTopics manager from the components,
   * then filters the list of topics to find those associated with the current viewpoint.
   *
   * @returns An array of BCF topics associated with the current viewpoint.
   */
  get topics() {
    const manager = this._components.get(BCFTopics);
    const topicsList = [...manager.list.values()];
    const topics = topicsList.filter(
      (topic) => topic.viewpoints.has(this.guid)
    );
    return topics;
  }
  // TODO: Remove the notifyUpdate when needed
  setEvents() {
    this.selectionComponents.onUpdated.add(this.notifyUpdate);
    this.exceptionComponents.onUpdated.add(this.notifyUpdate);
    this.clippingPlanes.onUpdated.add(this.notifyUpdate);
    this.componentColors.onItemSet.add(this.notifyUpdate);
    this.componentColors.onItemDeleted.add(this.notifyUpdate);
    this.componentColors.onItemUpdated.add(this.notifyUpdate);
    this.componentColors.onCleared.add(this.notifyUpdate);
  }
  /**
   * Fully replace the properties of the viewpoint with the provided data.
   * The properties not included will remain unchanged.
   *
   * @remarks The guid will be ommited as it shouldn't change after it has been initially set.
   *
   * @param data - An object containing the properties to be set.
   */
  set(data) {
    this.title = data.title;
    const {
      components,
      perspective_camera,
      orthogonal_camera,
      clipping_planes
    } = data;
    if (components) {
      const { selection, visibility, coloring } = components;
      if (selection) {
        this.selectionComponents.clear();
        for (const { ifc_guid } of selection) {
          if (!ifc_guid)
            continue;
          this.selectionComponents.add(ifc_guid);
        }
      }
      if (visibility) {
        const { default_visibility, exceptions, view_setup_hints } = visibility;
        if (default_visibility !== void 0) {
          this.defaultVisibility = default_visibility;
        }
        if (exceptions) {
          this.exceptionComponents.clear();
          for (const { ifc_guid } of exceptions) {
            if (!ifc_guid)
              continue;
            this.exceptionComponents.add(ifc_guid);
          }
        }
        if (view_setup_hints) {
          const { spaces_visible, space_boundaries_visible, openings_visible } = view_setup_hints;
          if (spaces_visible !== void 0) {
            this.spacesVisible = spaces_visible;
          }
          if (space_boundaries_visible !== void 0) {
            this.spaceBoundariesVisible = space_boundaries_visible;
          }
          if (openings_visible !== void 0) {
            this.openingsVisible = openings_visible;
          }
        }
      }
      if (coloring) {
        this.componentColors.clear();
        for (const description of coloring) {
          const { color, components: components2 } = description;
          const guids = components2.map((component) => component.ifc_guid).filter((guid) => guid !== null);
          this.componentColors.set(color, guids);
        }
      }
    }
    if (perspective_camera || orthogonal_camera) {
      this.camera = perspective_camera ?? orthogonal_camera;
    }
    if (clipping_planes && this.world) {
      const clipper = this._components.get(Clipper);
      for (const data2 of clipping_planes) {
        const { location, direction } = data2;
        const locationVector = new THREE$1.Vector3(
          location.x,
          location.z,
          -location.y
        );
        const directionVector = new THREE$1.Vector3(
          direction.x,
          direction.z,
          -direction.y
        );
        const id = clipper.createFromNormalAndCoplanarPoint(
          this.world,
          directionVector,
          locationVector
        );
        this.clippingPlanes.add(id);
        clipper.list.get(id).enabled = false;
        clipper.list.get(id).visible = false;
      }
    }
    this.notifyUpdate();
  }
  /**
   * Sets the viewpoint of the camera in the world.
   *
   * @remarks
   * This function calculates the target position based on the viewpoint information.
   * It sets the visibility of the viewpoint components and then applies the viewpoint using the camera's controls.
   *
   * @param transition - Indicates whether the camera movement should have a transition effect.
   *                      Default value is `true`.
   *
   * @throws An error if the world's camera does not have camera controls.
   *
   * @returns A Promise that resolves when the camera has been set.
   */
  async go(_config) {
    if (!this.world)
      return;
    const { camera } = this.world;
    if (!(camera instanceof OrthoPerspectiveCamera)) {
      throw new Error(
        "Viewpoint: the world's camera component must be of type OrthoPerspectiveCamera to switch between perspective and orthographic projections."
      );
    }
    const { transition, applyClippings, applyVisibility, clippingsVisibility } = {
      transition: true,
      applyClippings: true,
      applyVisibility: true,
      clippingsVisibility: true,
      ..._config
    };
    camera.projection.set(this.projection);
    const basePosition = new THREE$1.Vector3(
      this.camera.camera_view_point.x,
      this.camera.camera_view_point.y,
      this.camera.camera_view_point.z
    );
    const baseTarget = new THREE$1.Vector3(
      this.camera.camera_direction.x,
      this.camera.camera_direction.y,
      this.camera.camera_direction.z
    );
    if (basePosition.equals(new THREE$1.Vector3()) && baseTarget.equals(new THREE$1.Vector3())) {
      return;
    }
    const position = this.position;
    const direction = this.direction;
    const factor = 80;
    const target = {
      x: position.x + direction.x * factor,
      y: position.y + direction.y * factor,
      z: position.z + direction.z * factor
    };
    const promises = [];
    if (applyClippings)
      this.setClippingState(true);
    if (applyVisibility)
      promises.push(this.applyVisibility());
    this.setClippingVisibility(clippingsVisibility);
    promises.push(
      camera.controls.setLookAt(
        position.x,
        position.y,
        position.z,
        target.x,
        target.y,
        target.z,
        transition
      )
    );
    await Promise.all(promises);
  }
  /**
   * Updates the camera settings of the viewpoint based on the current world's camera and renderer.
   * @returns A boolean indicating if the camera data was updated or not.
   */
  async updateCamera(takeSnapshot = true) {
    return new Promise((resolve) => {
      if (!this.world) {
        resolve(false);
        return;
      }
      const { camera, renderer } = this.world;
      if (!renderer) {
        throw new Error("Viewpoint: the world needs to have a renderer!");
      }
      if (!camera.hasCameraControls()) {
        throw new Error("Viewpoint: world's camera need camera controls!");
      }
      const position = new THREE$1.Vector3();
      camera.controls.getPosition(position);
      const threeCamera = camera.three;
      const direction = new THREE$1.Vector3(0, 0, -1).applyEuler(
        threeCamera.rotation
      );
      const { width, height } = renderer.getSize();
      let aspect_ratio = width / height;
      if (Number.isNaN(aspect_ratio))
        aspect_ratio = 1;
      const fragments = this._components.get(FragmentsManager);
      position.applyMatrix4(fragments.baseCoordinationMatrix.clone().invert());
      const partialCamera = {
        aspect_ratio,
        camera_view_point: { x: position.x, y: position.y, z: position.z },
        camera_direction: { x: direction.x, y: direction.y, z: direction.z },
        camera_up_vector: { x: 0, y: 1, z: 0 }
      };
      if (threeCamera instanceof THREE$1.PerspectiveCamera) {
        this.camera = {
          ...partialCamera,
          field_of_view: threeCamera.fov
        };
      } else if (threeCamera instanceof THREE$1.OrthographicCamera) {
        this.camera = {
          ...partialCamera,
          view_to_world_scale: threeCamera.top - threeCamera.bottom
        };
      }
      if (takeSnapshot) {
        const manager = this._components.get(Viewpoints);
        const canvas = renderer.three.domElement;
        renderer.three.render(this.world.scene.three, camera.three);
        canvas.toBlob(async (blob) => {
          if (blob) {
            const data = await blob.arrayBuffer();
            const buffer = new Uint8Array(data);
            manager.snapshots.set(this.guid, buffer);
          }
          this.notifyUpdate();
          resolve(true);
        });
      } else {
        this.notifyUpdate();
        resolve(true);
      }
    });
  }
  /**
   * Captures a snapshot of the current viewpoint and stores it in the snapshots manager.
   */
  takeSnapshot() {
    return new Promise((resolve) => {
      if (!this.world) {
        resolve(false);
        return;
      }
      const { camera, renderer } = this.world;
      if (!renderer) {
        throw new Error("Viewpoint: the world needs to have a renderer!");
      }
      const manager = this._components.get(Viewpoints);
      const canvas = renderer.three.domElement;
      renderer.three.render(this.world.scene.three, camera.three);
      canvas.toBlob(async (blob) => {
        if (blob) {
          const data = await blob.arrayBuffer();
          const buffer = new Uint8Array(data);
          manager.snapshots.set(this.guid, buffer);
        }
        this.notifyUpdate();
        resolve(true);
      });
    });
  }
  /**
   * Updates the collection of clipping planes by clearing the current set and adding enabled planes
   * from the associated `Clipper` component.
   */
  updateClippingPlanes() {
    this.clippingPlanes.clear();
    const clipper = this._components.get(Clipper);
    for (const [id, plane] of clipper.list) {
      if (!plane.enabled)
        continue;
      this.clippingPlanes.add(id);
    }
  }
  /**
   * Applies visibility settings to components based on default visibility, exceptions, and selections.
   *
   * This method adjusts the visibility of components using the `Hider` instance. It ensures that:
   * - The default visibility is applied to all components.
   * - Exceptions are handled to override the default visibility.
   * - Selected components are always visible.
   */
  async applyVisibility() {
    const hider = this._components.get(Hider);
    hider.set(this.defaultVisibility);
    const exception = await this.getExceptionMap();
    hider.set(!this.defaultVisibility, exception);
    const selection = await this.getSelectionMap();
    hider.set(true, selection);
  }
  // TODO: Analyze how this works along with the Highlighter
  /**
   * Asynchronously sets the colorization state for the viewpoint's components.
   * When the state is true, it applies the defined component colors to the corresponding fragments.
   * When the state is false, it resets the highlight for the corresponding fragments.
   *
   * @param state - A boolean indicating whether to apply or reset the colorization.
   *                If true, the components will be colorized. If false, the colorization will be reset.
   * @returns A Promise that resolves when all colorization or reset operations are complete.
   * @remarks Be careful when using this method along with the Highlighter as it can cause unwanted results
   */
  async setColorizationState(state) {
    const fragments = this._components.get(FragmentsManager);
    const promises = [];
    if (state) {
      for (const [color, guids] of this.componentColors) {
        const hexColorString = `#${color}`;
        const modelIdMap = await fragments.guidsToModelIdMap(guids);
        for (const [modelId, localIds] of Object.entries(modelIdMap)) {
          const model = fragments.list.get(modelId);
          if (!model)
            continue;
          promises.push(
            model.highlight([...localIds], {
              customId: hexColorString,
              color: new THREE$1.Color(hexColorString),
              renderedFaces: FRAGS.RenderedFaces.ONE,
              opacity: 1,
              transparent: false
            })
          );
        }
      }
    } else {
      for (const [_, guids] of this.componentColors) {
        const modelIdMap = await fragments.guidsToModelIdMap(guids);
        for (const [modelId, localIds] of Object.entries(modelIdMap)) {
          const model = fragments.list.get(modelId);
          if (!model)
            continue;
          promises.push(model.resetHighlight([...localIds]));
        }
      }
    }
    promises.push(fragments.core.update(true));
    await Promise.all(promises);
  }
  /**
   * Sets the enabled state of all clipping planes associated with this viewpoint.
   * @param state A boolean indicating whether the clipping planes should be enabled or disabled.
   */
  setClippingState(state) {
    const clipper = this._components.get(Clipper);
    for (const [id, plane] of clipper.list) {
      plane.enabled = state && this.clippingPlanes.has(id);
    }
  }
  /**
   * Sets the visibility of all clipping planes associated with this viewpoint.
   *
   * @param visibility - A boolean indicating whether the clipping planes should be visible (`true`) or hidden (`false`).
   */
  setClippingVisibility(visibility) {
    const clipper = this._components.get(Clipper);
    for (const id of this.clippingPlanes) {
      const plane = clipper.list.get(id);
      if (!plane)
        continue;
      plane.visible = visibility;
    }
  }
  async createComponentTags(from) {
    var _a2;
    const fragments = this._components.get(FragmentsManager);
    const manager = this._components.get(BCFTopics);
    let tags = "";
    if (manager.config.includeSelectionTag) {
      const modelIdMap = from === "selection" ? await this.getSelectionMap() : await this.getExceptionMap();
      for (const modelID in modelIdMap) {
        const model = fragments.list.get(modelID);
        if (!model)
          continue;
        const localIds = modelIdMap[modelID];
        for (const localId of localIds) {
          const item = model.getItem(localId);
          const globalID = await item.getGuid();
          if (!globalID)
            continue;
          const tag = (_a2 = await item.getAttributes()) == null ? void 0 : _a2.getValue("Tag");
          let tagAttribute = null;
          if (tag)
            tagAttribute = `AuthoringToolId="${tag}"`;
          tags += `
<Component IfcGuid="${globalID}" ${tagAttribute ?? ""} />`;
        }
      }
    } else {
      tags = [...this.selectionComponents].map((globalId) => `<Component IfcGuid="${globalId}" />`).join(`
`);
    }
    return tags;
  }
  createColorTags() {
    let colorTags = "";
    for (const [color, components] of this.componentColors.entries()) {
      const tags = components.map((globalId) => `
<Component IfcGuid="${globalId}" />`).join("\n");
      colorTags += `<Color Color="${color}">
${tags}
</Color>`;
    }
    if (colorTags.length !== 0) {
      return `<Coloring>
${colorTags}
</Coloring>`;
    }
    return `<Coloring />`;
  }
  /**
   * Converts the current viewpoint instance into a JSON representation compliant with the BCFViewpoint format.
   *
   * @returns A BCF API JSON complaint object representing the viewpoint, including its GUID, components,
   * visibility settings, clipping planes, camera configuration, and snapshot data.
   */
  toJSON() {
    const clipper = this._components.get(Clipper);
    const result = {
      guid: this.guid,
      components: {
        selection: [...this.selectionComponents].map((guid) => {
          return { ifc_guid: guid, authoring_tool_id: null };
        }),
        coloring: [...this.componentColors].map(([color, guids]) => {
          return {
            color,
            components: guids.map((guid) => {
              return { ifc_guid: guid, authoring_tool_id: null };
            })
          };
        }),
        visibility: {
          default_visibility: this.defaultVisibility,
          exceptions: [...this.exceptionComponents].map((guid) => {
            return { ifc_guid: guid, authoring_tool_id: null };
          }),
          view_setup_hints: {
            spaces_visible: this.spacesVisible,
            space_boundaries_visible: this.spaceBoundariesVisible,
            openings_visible: this.openingsVisible
          }
        }
      },
      clipping_planes: [...this.clippingPlanes].map((id) => {
        const plane = clipper.list.get(id);
        if (!plane)
          return null;
        const origin = plane._controls.worldPosition ?? plane.origin;
        const { normal } = plane;
        return {
          location: { x: origin.x, y: -origin.z, z: origin.y },
          direction: { x: normal.x, y: -normal.z, z: normal.y }
        };
      }).filter((plane) => plane !== null)
    };
    if ("field_of_view" in this.camera) {
      result.perspective_camera = this.camera;
    } else {
      result.orthogonal_camera = this.camera;
    }
    const manager = this._components.get(Viewpoints);
    const snapshot = manager.snapshots.get(this.snapshot);
    if (snapshot) {
      const str = snapshot.toString();
      const base64Data = btoa(str);
      const extension = manager.getSnapshotExtension(this.snapshot);
      result.snapshot = { snapshot_type: extension, snapshot_data: base64Data };
    }
    return result;
  }
  /**
   * Serializes the viewpoint into a buildingSMART compliant XML string for export.
   *
   * @param version - The version of the BCF Manager to use for serialization.
   *                   If not provided, the current version of the manager will be used.
   *
   * @returns A Promise that resolves to an XML string representing the viewpoint.
   *          The XML string follows the BCF VisualizationInfo schema.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  async serialize(version = this._managerVersion) {
    const fragments = this._components.get(FragmentsManager);
    const position = this.position;
    position.applyMatrix4(fragments.baseCoordinationMatrix.clone().invert());
    const direction = this.direction;
    direction.normalize();
    const rotationMatrix = new THREE$1.Matrix4().makeRotationX(Math.PI / 2);
    const upVector = direction.clone().applyMatrix4(rotationMatrix);
    upVector.normalize();
    const cameraViewpointXML = `<CameraViewPoint>
      <X>${position.x}</X>
      <Y>${-position.z}</Y>
      <Z>${position.y}</Z>
    </CameraViewPoint>`;
    const cameraDirectionXML = `<CameraDirection>
      <X>${direction.x}</X>
      <Y>${-direction.z}</Y>
      <Z>${direction.y}</Z>
    </CameraDirection>`;
    const cameraUpVectorXML = `<CameraUpVector>
      <X>${upVector.x}</X>
      <Y>${-upVector.z}</Y>
      <Z>${upVector.y}</Z>
    </CameraUpVector>`;
    const cameraRatioXML = `<AspectRatio>${this.camera.aspect_ratio}</AspectRatio>`;
    let cameraXML = "";
    if ("view_to_world_scale" in this.camera) {
      cameraXML = `<OrthogonalCamera>
        ${cameraViewpointXML}
        ${cameraDirectionXML}
        ${cameraUpVectorXML}
        ${cameraRatioXML}
        <ViewToWorldScale>${this.camera.view_to_world_scale}</ViewToWorldScale>
      </OrthogonalCamera>`;
    } else if ("field_of_view" in this.camera) {
      cameraXML = `<PerspectiveCamera>
        ${cameraViewpointXML}
        ${cameraDirectionXML}
        ${cameraUpVectorXML}
        ${cameraRatioXML}
        <FieldOfView>${this.camera.field_of_view}</FieldOfView>
      </PerspectiveCamera>`;
    }
    const viewSetupHints = `<ViewSetupHints SpacesVisible="${this.spacesVisible ?? false}" SpaceBoundariesVisible="${this.spaceBoundariesVisible ?? false}" OpeningsVisible="${this.openingsVisible ?? false}" />`;
    const selectionTags = (await this.createComponentTags("selection")).trim();
    const exceptionTags = (await this.createComponentTags("exception")).trim();
    const colorTags = this.createColorTags();
    return `<?xml version="1.0" encoding="UTF-8"?>
    <VisualizationInfo Guid="${this.guid}">
      <Components>
        ${version === "2.1" ? viewSetupHints : ""}
        ${selectionTags.length !== 0 ? `<Selection>${selectionTags}</Selection>` : ""}
        <Visibility DefaultVisibility="${this.defaultVisibility}">
          ${version === "3" ? viewSetupHints : ""}
          ${exceptionTags.length !== 0 ? `<Exceptions>${exceptionTags}</Exceptions>` : ""}
        </Visibility>
        ${colorTags}
      </Components>
      ${cameraXML}
    </VisualizationInfo>`;
  }
}
class ViewpointsConfigManager extends Configurator {
  constructor() {
    super(...arguments);
    __publicField(this, "_config", {
      overwriteColors: {
        value: false,
        type: "Boolean"
      }
    });
  }
  get overwriteColors() {
    return this._config.overwriteColors.value;
  }
  set overwriteColors(value) {
    this._config.overwriteColors.value = value;
  }
}
const _Viewpoints = class _Viewpoints extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    /**
     * Represents the default world where all viewpoints will be created.
     * A viewpoint can specify a different world if necessary.
     */
    __publicField(this, "world", null);
    /**
     * A DataMap that stores Viewpoint instances, indexed by their unique identifiers (guid).
     * This map is used to manage and retrieve Viewpoint instances within the Viewpoints component.
     */
    __publicField(this, "list", new DataMap$1());
    /**
     * A collection of snapshots represented as a mapping between string keys and their corresponding binary data.
     */
    __publicField(this, "snapshots", new DataMap$1());
    __publicField(this, "isSetup", false);
    __publicField(this, "onSetup", new Event());
    __publicField(this, "config", new ViewpointsConfigManager(
      this,
      this.components,
      "Viewpoints",
      _Viewpoints.uuid
    ));
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    components.add(_Viewpoints.uuid, this);
  }
  /**
   * Creates a new Viewpoint instance and adds it to the list.
   *
   * @param data - Optional partial data for the Viewpoint. If not provided, default data will be used.
   *
   * @returns The newly created Viewpoint instance.
   */
  create(data) {
    const viewpoint = new Viewpoint(this.components, data);
    viewpoint.world = this.world;
    if (!data)
      this.list.set(viewpoint.guid, viewpoint);
    return viewpoint;
  }
  /**
   * Determines the file extension of a snapshot based on its header bytes.
   *
   * @param name - The name of the snapshot from the list to retrieve its extension.
   * @returns The file extension as a string. Defaults to "jpeg" if the snapshot
   *          does not exist or the header bytes do not match known formats.
   */
  getSnapshotExtension(name) {
    let extension = "jpeg";
    const bytes = this.snapshots.get(name);
    if (!bytes)
      return extension;
    const headerBytes = bytes.subarray(0, 4);
    let header = "";
    for (let i = 0; i < headerBytes.length; i++) {
      header += headerBytes[i].toString(16);
    }
    if (header.startsWith("89504e47")) {
      extension = "png";
    }
    if (header.startsWith("ffd8ffe")) {
      extension = "jpeg";
    }
    return extension;
  }
  setup() {
  }
  /**
   * Disposes of the Viewpoints component and its associated resources.
   *
   * This method is responsible for cleaning up any resources held by the Viewpoints component,
   * such as disposing of the DataMap of Viewpoint instances and triggering and resetting the
   * onDisposed event.
   */
  dispose() {
    this.list.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
};
__publicField(_Viewpoints, "uuid", "ee867824-a796-408d-8aa0-4e5962a83c66");
let Viewpoints = _Viewpoints;
class View {
  constructor(components, config) {
    __publicField(this, "_components");
    __publicField(this, "_cameraOffset", 10);
    __publicField(this, "_planeHelper");
    __publicField(this, "_farPlaneHelper");
    __publicField(this, "_cameraHelper");
    __publicField(this, "onStateChanged", new Event());
    __publicField(this, "onUpdated", new Event());
    __publicField(this, "onDisposed", new Event());
    __publicField(this, "camera");
    __publicField(this, "plane", new THREE$1.Plane());
    __publicField(this, "farPlane", new THREE$1.Plane());
    __publicField(this, "id", UUID.create());
    // A flag to indicate when this view has been opened by its manager
    __publicField(this, "_open", false);
    // Defines how far from the plane the second cut will be made
    __publicField(this, "_range", Views.defaultRange);
    __publicField(this, "_world", null);
    __publicField(this, "_helpersVisible", false);
    __publicField(this, "_planesEnabled", false);
    this._components = components;
    this.camera = new OrthoPerspectiveCamera(this._components);
    const { threeOrtho: camera } = this.camera;
    if (config == null ? void 0 : config.id)
      this.id = config.id;
    if ((config == null ? void 0 : config.normal) && (config == null ? void 0 : config.point)) {
      const { normal, point } = config;
      this.plane.setFromNormalAndCoplanarPoint(normal, point);
    }
    this._cameraHelper = new THREE$1.CameraHelper(camera);
    this._planeHelper = new THREE$1.PlaneHelper(this.plane, 50);
    this._farPlaneHelper = new THREE$1.PlaneHelper(this.farPlane, 50);
    this.farPlaneHelperColor = new THREE$1.Color("blue");
    this.update();
  }
  get _planeNormalOpposite() {
    return this.plane.normal.clone().negate();
  }
  get _planePosition() {
    return this.plane.normal.clone().multiplyScalar(-this.plane.constant);
  }
  get _cameraPosition() {
    return this._planePosition.addScaledVector(
      this._planeNormalOpposite,
      this._cameraOffset
    );
  }
  set open(value) {
    this._open = value;
    this.onStateChanged.trigger(["open"]);
  }
  get open() {
    return this._open;
  }
  set planeHelperColor(value) {
    if (!Array.isArray(this._planeHelper.material) && "color" in this._planeHelper.material && this._planeHelper.material.color instanceof THREE$1.Color) {
      this._planeHelper.material.color = value;
    }
  }
  set farPlaneHelperColor(value) {
    if (!Array.isArray(this._farPlaneHelper.material) && "color" in this._farPlaneHelper.material && this._farPlaneHelper.material.color instanceof THREE$1.Color) {
      this._farPlaneHelper.material.color = value;
    }
  }
  set range(value) {
    this._range = value;
    this.update();
  }
  get range() {
    return this._range;
  }
  set distance(value) {
    this.plane.constant = value;
    this.update();
  }
  get distance() {
    return this.plane.constant;
  }
  set world(value) {
    this._world = value;
    this.camera.currentWorld = value;
    if (value) {
      this.camera.projection.set("Orthographic");
      this.camera.set("Plan");
      this.camera.controls.dollySpeed = 6;
      this.camera.controls.restThreshold = 5e-3;
      this.update();
    }
  }
  get world() {
    return this._world;
  }
  set helpersVisible(value) {
    if (!value) {
      this._helpersVisible = value;
      this._planeHelper.removeFromParent();
      this._farPlaneHelper.removeFromParent();
      this._cameraHelper.removeFromParent();
      return;
    }
    if (!this.world)
      return;
    this._helpersVisible = value;
    this.world.scene.three.add(
      this._planeHelper,
      this._farPlaneHelper
      // this._cameraHelper,
    );
  }
  get helpersVisible() {
    return this._helpersVisible;
  }
  // for debugging purposes
  // Section the model based on the planes
  // without using the camera
  set planesEnabled(value) {
    const { world } = this;
    if (!world)
      return;
    const { renderer } = world;
    if (!renderer)
      return;
    renderer.setPlane(value, this.plane);
    renderer.setPlane(value, this.farPlane);
    this._planesEnabled = value;
  }
  get planesEnabled() {
    return this._planesEnabled;
  }
  dispose() {
    this.helpersVisible = false;
    const disposer = this._components.get(Disposer);
    disposer.destroy(this._planeHelper);
    disposer.destroy(this._farPlaneHelper);
    disposer.destroy(this._cameraHelper);
    this.camera.dispose();
    this.onDisposed.trigger();
  }
  // update based on changes made to this.plane
  update() {
    if (this.world) {
      const position = this._cameraPosition;
      const target = this._planePosition;
      this.camera.controls.setLookAt(
        position.x,
        position.y,
        position.z,
        target.x,
        target.y,
        target.z,
        false
      );
    }
    this.farPlane.normal.copy(this._planeNormalOpposite);
    this.farPlane.constant = this.range - this.plane.constant;
    this.onUpdated.trigger();
  }
  flip() {
    this.plane.normal.negate();
    this.update();
  }
}
const _Views = class _Views extends Component {
  constructor(components) {
    super(components);
    /**
     * A readonly map that associates string keys with `View` instances.
     * This map is used to store and manage a collection of views.
     */
    __publicField(this, "list", new DataMap$1());
    __publicField(this, "enabled", true);
    /**
     * The default world to be used when creating views.
     *
     * - If `world` is set to `null`, views can still specify another world directly in their instance.
     * - This property allows views to inherit a default world context unless explicitly overridden.
     */
    __publicField(this, "world", null);
    __publicField(this, "_fragmentsUpdateEvent", () => {
      const fragments = this.components.get(FragmentsManager);
      fragments.core.update(true);
    });
    components.add(_Views.uuid, this);
    this.setupEvents();
  }
  /**
   * Determines whether there are any open views in this component's list.
   */
  get hasOpenViews() {
    return [...this.list.values()].some((v) => v.open);
  }
  setupEvents() {
    this.list.onBeforeDelete.add(({ key, value: view }) => {
      if (view.open)
        this.close(key);
      view.dispose();
    });
  }
  /**
   * Creates a new view with the specified normal vector, point, and optional configuration.
   *
   * @param normal - The normal vector defining the orientation of the view.
   * @param point - The point in space where the view is centered.
   * @param config - Optional configuration for the view creation.
   * @returns The newly created `View` instance.
   * @remarks The created view will be added to the component's list data map.
   */
  create(normal, point, config) {
    const view = new View(this.components, { id: config == null ? void 0 : config.id, normal, point });
    view.world = (config == null ? void 0 : config.world) ?? this.world;
    this.list.set(view.id, view);
    return view;
  }
  /**
   * Creates a new view from the specified plane and optional configuration.
   *
   * @param plane - The `THREE.Plane` object representing the plane to create the view from.
   * @param config - Optional configuration for creating the view.
   * @returns The newly created `View` instance.
   * @remarks The created view will be added to the component's list data map.
   */
  createFromPlane(plane, config) {
    const view = new View(this.components, { id: config == null ? void 0 : config.id });
    view.plane.copy(plane);
    view.update();
    view.world = (config == null ? void 0 : config.world) ?? this.world;
    this.list.set(view.id, view);
    return view;
  }
  /**
   * Creates views from IFC storeys based on the provided configuration.
   * This method iterates through the fragments of the model, filters storeys
   * based on the configuration, and generates views for each storey.
   *
   * @param config - Optional configuration for creating views from IFC storeys.
   * @returns A promise that resolves to an array of `View` objects created from the IFC storeys.
   *
   * @remarks Each IfcBuilsingStorey is represented as a plane in 3D space, with its elevation adjusted by the `offset`. The created views will be added to the component's list data map.
   */
  async createFromIfcStoreys(config) {
    const result = [];
    const fragments = this.components.get(FragmentsManager);
    const offset = (config == null ? void 0 : config.offset) === void 0 ? 0.25 : config.offset;
    for (const [modelId, model] of fragments.list) {
      if (config && config.modelIds && !config.modelIds.some((regex) => regex.test(modelId))) {
        continue;
      }
      const storeys = Object.values(
        await model.getItemsOfCategories([/BUILDINGSTOREY/])
      ).flat();
      if (storeys.length === 0)
        continue;
      const storeysData = await model.getItemsData(storeys);
      const [, coordHeight] = await model.getCoordinates();
      const normal = new THREE$1.Vector3(0, -1, 0);
      for (const storey of storeysData) {
        if (!("value" in storey.Name && "value" in storey.Elevation)) {
          continue;
        }
        const { value: name } = storey.Name;
        if ((config == null ? void 0 : config.storeyNames) && !config.storeyNames.some((value) => value.test(name))) {
          continue;
        }
        const height = storey.Elevation.value + coordHeight + offset;
        const plane = new THREE$1.Plane(normal, height);
        const view = this.createFromPlane(plane, {
          id: name,
          world: config == null ? void 0 : config.world
        });
        result.push(view);
      }
    }
    return result;
  }
  /**
   * Creates views representing the front, back, left, and right sides of bounding boxes for specified models or a combined bounding box of all models.
   *
   * @param config - Optional configuration object for creating bounding views.
   * @returns A promise that resolves to an array of `View` objects created from the boundings.
   * @remarks The method calculates bounding boxes for the specified models, optionally combines them into a single bounding box, and creates views for the planes representing the bounding box sides.
   */
  createElevations(config) {
    const result = [];
    const fragments = this.components.get(FragmentsManager);
    const combine = (config == null ? void 0 : config.combine) === void 0 ? false : config.combine;
    const namingFunction = (config == null ? void 0 : config.namingCallback) ?? ((modelId) => {
      return {
        front: `${combine ? "Front" : `${modelId}: Front`}`,
        back: `${combine ? "Back" : `${modelId}: Back`}`,
        left: `${combine ? "Left" : `${modelId}: Left`}`,
        right: `${combine ? "Right" : `${modelId}: Right`}`
      };
    });
    let boxes = [];
    for (const [id, model] of fragments.list) {
      if (config && config.modelIds && !config.modelIds.some((regex) => regex.test(id))) {
        continue;
      }
      boxes.push({ id, box: model.box });
    }
    if (combine) {
      const boxer = this.components.get(BoundingBoxer);
      boxer.list.clear();
      boxer.list.add(...boxes.map((data) => data.box));
      const box = boxer.get();
      boxes = [{ id: "combined", box }];
    }
    for (const { id: modelId, box } of boxes) {
      const { min, max } = box;
      const xLength = Math.abs(max.x - min.x);
      const zLength = Math.abs(max.z - min.z);
      const center = new THREE$1.Vector3();
      box.getCenter(center);
      const frontPlane = new THREE$1.Plane(new THREE$1.Vector3(0, 0, -1), max.z);
      const backPlane = new THREE$1.Plane(new THREE$1.Vector3(0, 0, 1), -min.z);
      const leftPlane = new THREE$1.Plane(new THREE$1.Vector3(-1, 0, 0), max.x);
      const rightPlane = new THREE$1.Plane(new THREE$1.Vector3(1, 0, 0), -min.x);
      const {
        front: frontName,
        back: backName,
        left: leftName,
        right: rightName
      } = namingFunction(modelId);
      const frontView = this.createFromPlane(frontPlane, {
        id: frontName,
        world: config == null ? void 0 : config.world
      });
      frontView.range = zLength;
      const backView = this.createFromPlane(backPlane, {
        id: backName,
        world: config == null ? void 0 : config.world
      });
      backView.range = zLength;
      const leftView = this.createFromPlane(leftPlane, {
        id: leftName,
        world: config == null ? void 0 : config.world
      });
      leftView.range = xLength;
      const rightView = this.createFromPlane(rightPlane, {
        id: rightName,
        world: config == null ? void 0 : config.world
      });
      rightView.range = xLength;
      result.push(frontView, backView, leftView, rightView);
    }
    return result;
  }
  /**
   * Opens a view by its unique identifier. Ensures that no more than one view
   * is opened in the same world at a time. If the view is already open, the method
   * returns without performing any action.
   *
   * @param id - The unique identifier of the view to open.
   * @remarks This method changes world camera to use the view's.
   */
  open(id) {
    const view = this.list.get(id);
    if (!view) {
      throw new Error(`Views: the view with id ${id} doesn't exist.`);
    }
    if (view.open)
      return;
    const { world } = view;
    if (!world) {
      throw new Error(`Views: no world found for view with id ${id}.`);
    }
    const { renderer } = world;
    if (!renderer) {
      throw new Error(
        `Views: no renderer found for world with id ${world.uuid}.`
      );
    }
    for (const [, existingView] of this.list) {
      if (existingView.world !== world)
        continue;
      this.close(existingView.id);
    }
    renderer.setPlane(true, view.plane);
    renderer.setPlane(true, view.farPlane);
    view.camera.controls.addEventListener("rest", this._fragmentsUpdateEvent);
    world.camera = view.camera;
    view.open = true;
  }
  /**
   * Closes a view by its unique identifier and performs necessary cleanup operations.
   *
   * @param id - The unique identifier of the view to be closed. If not provided, all opened views across worlds will be closed.
   * @remarks This method resets the world to use its default camera.
   */
  close(id) {
    let view;
    if (id) {
      view = this.list.get(id);
    } else {
      view = [...this.list.values()].find((v) => v.open);
    }
    if (id && !view) {
      throw new Error(`Views: the view with id ${id} doesn't exist.`);
    }
    if (!view)
      return;
    if (!view.open)
      return;
    const { world } = view;
    if (!world) {
      throw new Error(`Views: no world found for view with id ${id}.`);
    }
    const { renderer } = world;
    if (!renderer) {
      throw new Error(
        `Views: no renderer found for world with id ${world.uuid}.`
      );
    }
    renderer.setPlane(false, view.plane);
    renderer.setPlane(false, view.farPlane);
    view.camera.controls.removeEventListener(
      "rest",
      this._fragmentsUpdateEvent
    );
    world.useDefaultCamera();
    view.open = false;
  }
};
__publicField(_Views, "uuid", "fb22f1f5-6598-4664-a11d-de8963ae420f");
/**
 * The default range value used by the Views component.
 * This represents the standard range setting applied unless explicitly overridden.
 */
__publicField(_Views, "defaultRange", 15);
let Views = _Views;
function clientWaitAsync(gl, sync, flags, intervalMilliseconds) {
  return new Promise((resolve, reject) => {
    function test() {
      const res = gl.clientWaitSync(sync, flags, 0);
      if (res === gl.WAIT_FAILED) {
        reject();
        return;
      }
      if (res === gl.TIMEOUT_EXPIRED) {
        setTimeout(test, intervalMilliseconds);
        return;
      }
      resolve();
    }
    test();
  });
}
async function getBufferSubDataAsync(gl, target, buffer, srcByteOffset, dstBuffer, dstOffset, length) {
  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
  gl.flush();
  await clientWaitAsync(gl, sync, 0, 10);
  gl.deleteSync(sync);
  gl.bindBuffer(target, buffer);
  gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
  gl.bindBuffer(target, null);
}
async function readPixelsAsync(gl, x, y, w, h, format, type, dest) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
  gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
  gl.readPixels(x, y, w, h, format, type, 0);
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
  await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);
  gl.deleteBuffer(buf);
  return dest;
}
class DistanceRenderer {
  constructor(components, world) {
    /** {@link Disposable.onDisposed} */
    __publicField(this, "onDisposed", new Event());
    /**
     * Fires after making the visibility check to the meshes. It lists the
     * meshes that are currently visible, and the ones that were visible
     * just before but not anymore.
     */
    __publicField(this, "onDistanceComputed", new Event());
    /**
     * Objects that won't be taken into account in the distance check.
     */
    __publicField(this, "excludedObjects", /* @__PURE__ */ new Set());
    /**
     * Whether this renderer is active or not. If not, it won't render anything.
     */
    __publicField(this, "enabled", true);
    /**
     * Render the internal scene used to determine the object visibility. Used
     * for debugging purposes.
     */
    __publicField(this, "renderDebugFrame", false);
    /** The components instance to which this renderer belongs. */
    __publicField(this, "components");
    /**
     * The scene where the distance is computed.
     */
    __publicField(this, "scene", new THREE$1.Scene());
    /**
     * The camera used to compute the distance.
     */
    __publicField(this, "camera", new THREE$1.OrthographicCamera(-1, 1, 1, -1, 0, 1));
    /**
     * The material used to compute the distance.
     */
    __publicField(this, "depthMaterial");
    /** The world instance to which this renderer belongs. */
    __publicField(this, "world");
    __publicField(this, "worker");
    __publicField(this, "_width", 512);
    __publicField(this, "_height", 512);
    __publicField(this, "_postQuad");
    __publicField(this, "tempRT");
    __publicField(this, "resultRT");
    __publicField(this, "bufferSize");
    __publicField(this, "_buffer");
    // Prevents worker being fired multiple times
    __publicField(this, "_isWorkerBusy", false);
    /**
     * The function that the culler uses to reprocess the scene. Generally it's
     * better to call needsUpdate, but you can also call this to force it.
     * @param force if true, it will refresh the scene even if needsUpdate is
     * not true.
     */
    __publicField(this, "compute", async () => {
      if (!this.enabled || this.world.isDisposing) {
        return;
      }
      if (this._isWorkerBusy) {
        return;
      }
      this._isWorkerBusy = true;
      this.world.camera.three.updateMatrix();
      const renderer = this.world.renderer.three;
      renderer.setRenderTarget(this.tempRT);
      const tempVariableName = "visibilityBeforeDistanceCheck";
      for (const object of this.excludedObjects) {
        object.userData[tempVariableName] = object.visible;
        object.visible = false;
      }
      renderer.render(this.world.scene.three, this.world.camera.three);
      for (const object of this.excludedObjects) {
        if (object.userData[tempVariableName] !== void 0) {
          object.visible = object.userData[tempVariableName];
        }
      }
      this.depthMaterial.uniforms.tDiffuse.value = this.tempRT.texture;
      this.depthMaterial.uniforms.tDepth.value = this.tempRT.depthTexture;
      renderer.setRenderTarget(this.resultRT);
      renderer.render(this.scene, this.camera);
      const context = renderer.getContext();
      try {
        await readPixelsAsync(
          context,
          0,
          0,
          this._width,
          this._height,
          context.RGBA,
          context.UNSIGNED_BYTE,
          this._buffer
        );
      } catch (e) {
        renderer.setRenderTarget(null);
        this._isWorkerBusy = false;
        return;
      }
      renderer.setRenderTarget(null);
      if (this.renderDebugFrame) {
        renderer.render(this.scene, this.camera);
      }
      this.worker.postMessage({
        buffer: this._buffer
      });
    });
    __publicField(this, "handleWorkerMessage", (event) => {
      if (!this.enabled || this.world.isDisposing) {
        return;
      }
      const colors = event.data.colors;
      let min = Number.MAX_VALUE;
      for (const value of colors) {
        if (value === 0) {
          continue;
        }
        if (value < min) {
          min = value;
        }
      }
      const camera = this.world.camera.three || THREE$1.OrthographicCamera;
      const normalized = min / 255;
      const maxFoundDistance = (normalized - 1) * -1 * (camera.far - camera.near);
      const maxValidDistance = Math.min(maxFoundDistance, camera.far);
      this.onDistanceComputed.trigger(maxValidDistance);
      this._isWorkerBusy = false;
    });
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    this.components = components;
    this.world = world;
    const camera = world.camera.three;
    this.tempRT = new THREE$1.WebGLRenderTarget(this._width, this._height);
    this.bufferSize = this._width * this._height * 4;
    this._buffer = new Uint8Array(this.bufferSize);
    this.tempRT.texture.minFilter = THREE$1.NearestFilter;
    this.tempRT.texture.magFilter = THREE$1.NearestFilter;
    this.tempRT.stencilBuffer = false;
    this.tempRT.samples = 0;
    this.tempRT.depthTexture = new THREE$1.DepthTexture(
      this._width,
      this._height
    );
    this.tempRT.depthTexture.format = THREE$1.DepthFormat;
    this.tempRT.depthTexture.type = THREE$1.UnsignedShortType;
    this.resultRT = new THREE$1.WebGLRenderTarget(this._width, this._height);
    this.depthMaterial = new THREE$1.ShaderMaterial({
      vertexShader: `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
    `,
      fragmentShader: `
#include <packing>

varying vec2 vUv;
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
uniform float cameraNear;
uniform float cameraFar;


float readDepth( sampler2D depthSampler, vec2 coord ) {
  float fragCoordZ = texture2D( depthSampler, coord ).x;
  float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
  return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
}

void main() {
  //vec3 diffuse = texture2D( tDiffuse, vUv ).rgb;
  float depth = readDepth( tDepth, vUv );

  gl_FragColor.rgb = 1.0 - vec3( depth );
  gl_FragColor.a = 1.0;
}
    `,
      uniforms: {
        cameraNear: { value: camera.near },
        cameraFar: { value: camera.far },
        tDiffuse: { value: null },
        tDepth: { value: null }
      }
    });
    const postPlane = new THREE$1.PlaneGeometry(2, 2);
    this._postQuad = new THREE$1.Mesh(postPlane, this.depthMaterial);
    this.scene.add(this._postQuad);
    const code = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Set();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          colors.add(r);
        }
        postMessage({ colors });
      });
    `;
    const blob = new Blob([code], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(blob));
    this.worker.addEventListener("message", this.handleWorkerMessage);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.onDistanceComputed.reset();
    this.worker.terminate();
    this.tempRT.dispose();
    this.resultRT.dispose();
    const children = [...this.scene.children];
    this.excludedObjects.clear();
    for (const child of children) {
      child.removeFromParent();
    }
    this._postQuad.geometry.dispose();
    this._postQuad.removeFromParent();
    this._buffer = null;
    this.onDisposed.reset();
  }
}
class ShadowedScene extends SimpleScene {
  constructor() {
    super(...arguments);
    __publicField(this, "_distanceRenderer");
    /**
     * Whether the bias property should be set automatically depending on the shadow distance.
     */
    __publicField(this, "autoBias", true);
    __publicField(this, "_defaultShadowConfig", {
      cascade: 1,
      resolution: 512
    });
    __publicField(this, "_lightsWithShadow", /* @__PURE__ */ new Map());
    __publicField(this, "_isComputingShadows", false);
    __publicField(this, "_shadowsEnabled", true);
    __publicField(this, "_bias", 0);
    __publicField(this, "recomputeShadows", (farthestDistance) => {
      if (!this._shadowsEnabled) {
        return;
      }
      if (this.autoBias) {
        this.bias = -5e-3;
      }
      const factor = 1.5;
      farthestDistance *= factor;
      if (!this.currentWorld) {
        throw new Error(
          "A world needs to be assigned to the scene before computing shadows!"
        );
      }
      if (!this._lightsWithShadow.size) {
        throw new Error("No shadows found!");
      }
      const camera = this.currentWorld.camera.three;
      if (!(camera instanceof THREE$1.PerspectiveCamera) && !(camera instanceof THREE$1.OrthographicCamera)) {
        throw new Error("Invalid camera type!");
      }
      const camDirection = new THREE$1.Vector3();
      camera.getWorldDirection(camDirection);
      let currentDistance = farthestDistance;
      const lightDirection = new THREE$1.Vector3();
      lightDirection.copy(this.config.directionalLight.position);
      lightDirection.normalize();
      for (const [index, id] of this._lightsWithShadow) {
        const light = this.directionalLights.get(id);
        if (!light) {
          throw new Error("Light not found.");
        }
        const shadowCenter = new THREE$1.Vector3();
        shadowCenter.copy(camDirection);
        const isLastShadow = index === this._lightsWithShadow.size - 1;
        const shadowOffset = isLastShadow ? currentDistance / 2 : currentDistance * 2 / 3;
        shadowCenter.multiplyScalar(shadowOffset);
        shadowCenter.add(camera.position);
        const shadowRadius = currentDistance - shadowOffset;
        const lightOffset = new THREE$1.Vector3();
        lightOffset.copy(lightDirection);
        lightOffset.multiplyScalar(shadowRadius);
        light.target.position.copy(shadowCenter);
        light.position.copy(shadowCenter);
        light.position.add(lightOffset);
        light.shadow.camera.right = shadowRadius;
        light.shadow.camera.left = -shadowRadius;
        light.shadow.camera.top = shadowRadius;
        light.shadow.camera.bottom = -shadowRadius;
        light.shadow.camera.far = shadowRadius * 2;
        light.shadow.camera.updateProjectionMatrix();
        light.shadow.camera.updateMatrix();
        if (!isLastShadow) {
          currentDistance /= 3;
        }
      }
      this._isComputingShadows = false;
    });
  }
  /**
   * The getter for the bias to prevent artifacts (stripes). It usually ranges between 0 and -0.005.
   */
  get bias() {
    return this._bias;
  }
  /**
   * The setter for the bias to prevent artifacts (stripes). It usually ranges between 0 and -0.005.
   */
  set bias(value) {
    this._bias = value;
    for (const [, id] of this._lightsWithShadow) {
      const light = this.directionalLights.get(id);
      if (light) {
        light.shadow.bias = value;
      }
    }
  }
  /**
   * Getter to see whether the shadows are enabled or not in this scene instance.
   */
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
  /**
   * Setter to control whether the shadows are enabled or not in this scene instance.
   */
  set shadowsEnabled(value) {
    this._shadowsEnabled = value;
    for (const [, light] of this.directionalLights) {
      light.castShadow = value;
    }
  }
  /**
   * Getter to get the renderer used to determine the farthest distance from the camera.
   */
  get distanceRenderer() {
    if (!this._distanceRenderer) {
      throw new Error(
        "You must set up this component before accessing the distance renderer!"
      );
    }
    return this._distanceRenderer;
  }
  /** {@link Configurable.setup} */
  setup(config) {
    super.setup(config);
    const fullConfig = {
      ...this._defaultConfig,
      ...this._defaultShadowConfig,
      ...config
    };
    if (fullConfig.cascade <= 0) {
      throw new Error(
        "Config.shadows.cascade must be a natural number greater than 0!"
      );
    }
    if (fullConfig.cascade > 1) {
      throw new Error("Multiple shadows not supported yet!");
    }
    if (!this.currentWorld) {
      throw new Error(
        "A world needs to be assigned to the scene before setting it up!"
      );
    }
    for (const [, light] of this.directionalLights) {
      light.target.removeFromParent();
      light.removeFromParent();
      light.dispose();
    }
    this.directionalLights.clear();
    if (!this._distanceRenderer) {
      this._distanceRenderer = new DistanceRenderer(
        this.components,
        this.currentWorld
      );
      this._distanceRenderer.onDistanceComputed.add(this.recomputeShadows);
    }
    this._lightsWithShadow.clear();
    for (let i = 0; i < fullConfig.cascade; i++) {
      const light = new THREE$1.DirectionalLight();
      light.intensity = this.config.directionalLight.intensity;
      light.color = this.config.directionalLight.color;
      light.position.copy(this.config.directionalLight.position);
      light.shadow.mapSize.width = fullConfig.resolution;
      light.shadow.mapSize.height = fullConfig.resolution;
      this.three.add(light, light.target);
      this.directionalLights.set(light.uuid, light);
      this._lightsWithShadow.set(i, light.uuid);
      light.castShadow = true;
      light.shadow.bias = this._bias;
    }
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose();
    if (this._distanceRenderer) {
      this._distanceRenderer.dispose();
    }
    this._lightsWithShadow.clear();
  }
  /** Update all the shadows of the scene. */
  async updateShadows() {
    if (this._isComputingShadows || !this._shadowsEnabled) {
      return;
    }
    this._isComputingShadows = true;
    await this.distanceRenderer.compute();
  }
}
class IDSFacet {
  constructor(_components) {
    // Used when the facet is a requirement
    // On IDSEntity is always required
    __publicField(this, "cardinality", "required");
    // When using this facet as a requirement, instructions can be given for the authors of the IFC.
    __publicField(this, "instructions");
    __publicField(this, "evalRequirement", (value, facetParameter, parameter, checks) => {
      const checkLog = {
        parameter,
        currentValue: value,
        requiredValue: facetParameter,
        pass: false
      };
      if (checks)
        this.addCheckResult(checkLog, checks);
      let pass = false;
      if (facetParameter.type === "simple") {
        pass = value === facetParameter.parameter;
      }
      if (facetParameter.type === "enumeration") {
        pass = facetParameter.parameter.includes(value);
      }
      if (facetParameter.type === "pattern") {
        const regex = new RegExp(facetParameter.parameter);
        pass = regex.test(String(value));
      }
      if (facetParameter.type === "length") {
        const { min, length, max } = facetParameter.parameter;
        if (length !== void 0) {
          pass = String(value).length === length;
        }
        if (min !== void 0) {
          pass = String(value).length >= min;
        }
        if (max !== void 0) {
          pass = String(value).length <= max;
        }
      }
      if (facetParameter.type === "bounds" && typeof value === "number") {
        const { min, minInclusive, max, maxInclusive } = facetParameter.parameter;
        let minPass = true;
        let maxPass = true;
        if (min !== void 0) {
          minPass = minInclusive ? value >= min : value > min;
        }
        if (max !== void 0) {
          maxPass = maxInclusive ? value <= max : value < max;
        }
        pass = minPass && maxPass;
      }
      if (this.cardinality === "prohibited")
        pass = !pass;
      if (this.cardinality === "optional")
        pass = true;
      checkLog.pass = pass;
      return checkLog.pass;
    });
    this._components = _components;
  }
  addCheckResult(check, checks) {
    const index = checks.findIndex(
      ({ parameter }) => parameter === check.parameter
    );
    if (index !== -1) {
      checks[index] = check;
    } else {
      checks.push(check);
    }
  }
  getItemChecks(collector, modelId, item, skipIfFails) {
    if (!("value" in item._localId && typeof item._localId.value === "number")) {
      return null;
    }
    let modelItemResults = collector.get(modelId);
    if (!modelItemResults) {
      modelItemResults = new FRAGS.DataMap();
      collector.set(modelId, modelItemResults);
    }
    let result = modelItemResults.get(item._localId.value);
    if (result && skipIfFails && !result.pass) {
      return null;
    }
    if (!result) {
      const checks2 = [];
      result = {
        guid: Array.isArray(item._guid) ? void 0 : item._guid.value,
        pass: false,
        checks: checks2
      };
      Object.defineProperty(result, "pass", {
        get: () => checks2.every(({ pass }) => pass)
      });
      modelItemResults.set(item._localId.value, result);
    }
    const checks = [];
    const check = {
      facetType: this.facetType,
      cardinality: this.cardinality,
      checks,
      pass: false
    };
    Object.defineProperty(check, "pass", {
      get: () => checks.every(({ pass }) => pass)
    });
    result.checks.push(check);
    return check.checks;
  }
}
const getParameterXML = (name, parameter) => {
  let parameterXML = "";
  if (!parameter)
    return parameterXML;
  if (parameter.type === "simple") {
    parameterXML = `<simpleValue>${parameter.parameter}</simpleValue>`;
  }
  if (parameter.type === "enumeration") {
    const value = parameter.parameter;
    parameterXML = `<xs:restriction base="xs:string">
    ${value.map((v) => `<xs:enumeration value="${v}" />`).join("\n")}
    </xs:restriction>`;
  }
  if (parameter.type === "pattern") {
    const value = parameter.parameter;
    parameterXML = `<xs:restriction base="xs:string">
      <xs:pattern value="${value}" />
    </xs:restriction>`;
  }
  if (parameter.type === "bounds") {
    const { min, minInclusive, max, maxInclusive } = parameter.parameter;
    let minTag = "";
    if (min !== void 0) {
      minTag = `<xs:min${minInclusive ? "Inclusive" : "Exclusive"} value="${min}">`;
    }
    let maxTag = "";
    if (max !== void 0) {
      maxTag = `<xs:max${maxInclusive ? "Inclusive" : "Exclusive"} value="${max}">`;
    }
    parameterXML = `<xs:restriction base="xs:double">
      ${minTag}
      ${maxTag}
    </xs:restriction>`;
  }
  if (parameter.type === "length") {
    const { length, min, max } = parameter.parameter;
    let lengthTag = "";
    if (length !== void 0 && min === void 0 && max === void 0) {
      lengthTag = `<xs:length value="${length}" />`;
    }
    let minTag = "";
    if (min !== void 0 && length === void 0) {
      minTag = `<xs:minLength value="${min}" />`;
    }
    let maxTag = "";
    if (max !== void 0 && length === void 0) {
      maxTag = `<xs:maxLength value="${max}" />`;
    }
    parameterXML = `<xs:restriction base="xs:string">
      ${lengthTag}
      ${minTag}
      ${maxTag}
    </xs:restriction>`;
  }
  const xml = `<${name[0].toLowerCase() + name.slice(1)}>
    ${parameterXML}
  </${name[0].toLowerCase() + name.slice(1)}>`;
  return xml;
};
class IDSAttribute extends IDSFacet {
  constructor(components, name) {
    super(components);
    __publicField(this, "facetType", "Attribute");
    __publicField(this, "name");
    __publicField(this, "value");
    this.name = name;
  }
  serialize(type) {
    const nameXML = getParameterXML("Name", this.name);
    const valueXML = getParameterXML("Value", this.value);
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<attribute ${attributes}>
  ${nameXML}
  ${valueXML}
</attribute>`;
  }
  // This can be very ineficcient as we do not have an easy way to get an entity based on an attribute
  // Right now, all entities must be iterated.
  // When the new IfcEntitiesFinder comes, this can become easier.
  // This may be greatly increase in performance if the applicability has any of the other facets and this is applied the latest
  async getEntities() {
  }
  // async getEntities(
  //   model: FRAGS.FragmentsGroup,
  //   collector: FRAGS.IfcProperties = {},
  // ) {
  //   return [];
  //   // for (const expressID in model) {
  //   //   if (collector[expressID]) continue;
  //   //   const entity = model[expressID];
  //   //   // Check if the attribute exists
  //   //   const attribute = entity[this.name];
  //   //   const attributeExists = !!attribute;
  //   //   // Check if the attribute value matches
  //   //   let valueMatches = true;
  //   //   if (attributeExists && this.value && this.value.value) {
  //   //     if (this.value.type === "simpleValue") {
  //   //       valueMatches = attribute.value === this.value.value;
  //   //     }
  //   //     if (this.value.type === "restriction") {
  //   //       const regex = new RegExp(this.value.value);
  //   //       valueMatches = regex.test(attribute.value);
  //   //     }
  //   //   }
  //   //   if (attributeExists && valueMatches) {
  //   //     collector[entity.expressID] = entity;
  //   //   }
  //   // }
  // }
  // https://github.com/buildingSMART/IDS/tree/development/Documentation/ImplementersDocumentation/TestCases/attribute
  // Test cases from buildingSMART repo have been tested and they all match with the expected result
  // All invalid cases have been treated as failures
  // FragmentsGroup do not hold some of the entities used in the tests
  async test(items, collector, config = { skipIfFails: true }) {
    const fragments = this._components.get(FragmentsManager);
    for (const [modelId, localIds] of Object.entries(items)) {
      const model = fragments.list.get(modelId);
      if (!model)
        continue;
      const data = await model.getItemsData([...localIds]);
      for (const item of data) {
        const checks = this.getItemChecks(
          collector,
          modelId,
          item,
          config.skipIfFails
        );
        if (!checks)
          continue;
        const attrNames = Object.keys(item);
        const matchingAttributes = attrNames.filter((name) => {
          const nameMatches = this.evalRequirement(name, this.name, "Name");
          if (!nameMatches)
            return false;
          const attribute = item[name];
          if (Array.isArray(attribute))
            return true;
          if (attribute === null || attribute.value === null) {
            if (this.cardinality === "optional" || this.cardinality === "prohibited") {
              return true;
            }
            return false;
          }
          if (Array.isArray(attribute.value) && attribute.value.length === 0) {
            return false;
          }
          if (typeof attribute.value === "string" && attribute.value.trim() === "") {
            return false;
          }
          return nameMatches;
        });
        const attributeMatches = matchingAttributes.length > 0;
        checks.push({
          parameter: "Name",
          currentValue: attributeMatches ? matchingAttributes[0] : null,
          requiredValue: this.name,
          pass: this.cardinality === "prohibited" ? !attributeMatches : attributeMatches
        });
        if (this.value) {
          if (matchingAttributes[0]) {
            const attribute = item[matchingAttributes[0]];
            if (Array.isArray(attribute)) {
              checks.push({
                parameter: "Value",
                currentValue: null,
                requiredValue: this.value,
                pass: this.cardinality === "prohibited"
              });
            } else {
              const isRef = Array.isArray(attribute.value);
              if (isRef) {
                checks.push({
                  parameter: "Value",
                  currentValue: null,
                  requiredValue: this.value,
                  pass: this.cardinality === "prohibited"
                });
              } else {
                this.evalRequirement(
                  attribute.value,
                  this.value,
                  "Value",
                  checks
                );
              }
            }
          } else {
            checks.push({
              parameter: "Value",
              currentValue: null,
              requiredValue: this.value,
              pass: this.cardinality === "prohibited"
            });
          }
        }
      }
    }
  }
}
class IDSClassification extends IDSFacet {
  constructor(components, system) {
    super(components);
    __publicField(this, "facetType", "Classification");
    __publicField(this, "system");
    __publicField(this, "value");
    __publicField(this, "uri");
    this.system = system;
  }
  serialize(type) {
    const systemXML = getParameterXML("System", this.system);
    const valueXML = getParameterXML("Value", this.value);
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.uri ? `uri=${this.uri}` : "";
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<classification ${attributes}>
  ${systemXML}
  ${valueXML}
</classification>`;
  }
  async getEntities(_modelIds, _collector) {
  }
  async test(_items, _collector) {
  }
  // private async processReferencedSource(
  //   model: FRAGS.FragmentsGroup,
  //   attrs: Record<string, any>,
  // ) {
  //   const sourceID = attrs.ReferencedSource?.value;
  //   if (!sourceID) return null;
  //   const sourceAttrs = await model.getProperties(sourceID);
  //   if (!sourceAttrs) return null;
  //   if (sourceAttrs.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //     sourceAttrs.ReferencedSource = await this.processReferencedSource(
  //       model,
  //       sourceAttrs,
  //     );
  //   }
  //   return sourceAttrs;
  // }
  // private async getSystems(model: FRAGS.FragmentsGroup, expressID: number) {
  //   const result: Record<string, any>[] = [];
  //   const indexer = this._components.get(IfcRelationsIndexer);
  //   const ocurrenceAssociations = indexer.getEntityRelations(
  //     model,
  //     expressID,
  //     "HasAssociations",
  //   );
  //   if (ocurrenceAssociations) {
  //     for (const id of ocurrenceAssociations) {
  //       const attrs = await model.getProperties(id);
  //       if (!attrs) continue;
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATION) {
  //         result.push(attrs);
  //       }
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //         attrs.ReferencedSource = await this.processReferencedSource(
  //           model,
  //           attrs,
  //         );
  //         if (attrs.ReferencedSource) result.push(attrs);
  //       }
  //     }
  //   }
  //   // As occurence classifications prevail over type clasifications
  //   // the classification systems used by the occurrence are get
  //   // so type classifications are not included
  //   const occurrenceSystems = result
  //     .map((attrs) => {
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATION) {
  //         return attrs.Name?.value;
  //       }
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //         return attrs.ReferencedSource?.Name?.value;
  //       }
  //       return null;
  //     })
  //     .filter((name) => name);
  //   const types = indexer.getEntityRelations(model, expressID, "IsTypedBy");
  //   if (!(types && types[0])) return result;
  //   const type = types[0];
  //   const typeAssociations = indexer.getEntityRelations(
  //     model,
  //     type,
  //     "HasAssociations",
  //   );
  //   if (typeAssociations) {
  //     for (const id of typeAssociations) {
  //       const attrs = await model.getProperties(id);
  //       if (!attrs) continue;
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATION) {
  //         if (occurrenceSystems.includes(attrs.Name?.value)) continue;
  //         result.push(attrs);
  //       }
  //       if (attrs.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //         attrs.ReferencedSource = await this.processReferencedSource(
  //           model,
  //           attrs,
  //         );
  //         if (attrs.ReferencedSource) result.push(attrs);
  //       }
  //     }
  //   }
  //   return result;
  // }
  // private getSystemName(attrs: Record<string, any>): string | null {
  //   if (attrs.type === WEBIFC.IFCCLASSIFICATION) {
  //     return attrs.Name?.value;
  //   }
  //   if (attrs.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //     if (attrs.ReferencedSource?.type === WEBIFC.IFCCLASSIFICATIONREFERENCE) {
  //       return this.getSystemName(attrs.ReferencedSource);
  //     }
  //     if (attrs.ReferencedSource?.type === WEBIFC.IFCCLASSIFICATION) {
  //       return attrs.ReferencedSource.Name?.value;
  //     }
  //   }
  //   return null;
  // }
  // private getAllReferenceIdentifications(attrs: Record<string, any>) {
  //   if (attrs.type !== WEBIFC.IFCCLASSIFICATIONREFERENCE) return null;
  //   const identifications: string[] = [];
  //   if (attrs.Identification) identifications.push(attrs.Identification.value);
  //   if (attrs.ReferencedSource) {
  //     const identification = this.getAllReferenceIdentifications(
  //       attrs.ReferencedSource,
  //     );
  //     if (identification) identifications.push(...identification);
  //   }
  //   return identifications;
  // }
  // private evalSystem(attrs: Record<string, any>, checks?: IDSCheck[]) {
  //   const name = this.getSystemName(attrs);
  //   return this.evalRequirement(name, this.system, "System", checks);
  // }
  // private evalValue(attrs: any, checks?: IDSCheck[]) {
  //   if (!this.value) return true;
  //   const identifications = this.getAllReferenceIdentifications(attrs);
  //   if (!identifications) return false;
  //   const identifier = identifications.find((id) => {
  //     if (!this.value) return false;
  //     return this.evalRequirement(id, this.value, "Value");
  //   });
  //   if (checks) {
  //     this.addCheckResult(
  //       {
  //         parameter: "Value",
  //         currentValue: identifier ?? null,
  //         requiredValue: this.value,
  //         pass: !!identifier,
  //       },
  //       checks,
  //     );
  //   }
  //   return !!identifier;
  // }
  // private evalURI(attrs: any, checks?: IDSCheck[]) {
  //   if (!this.uri) return true;
  //   const result = this.evalRequirement(
  //     attrs.Location?.value,
  //     {
  //       type: "simple",
  //       parameter: this.uri,
  //     },
  //     "URI",
  //     checks,
  //   );
  //   return result;
  // }
}
class IDSEntity extends IDSFacet {
  constructor(components, name) {
    super(components);
    __publicField(this, "facetType", "Entity");
    __publicField(this, "name");
    __publicField(this, "predefinedType");
    this.name = name;
  }
  serialize(type) {
    const nameXML = getParameterXML("Name", this.name);
    const predefinedTypeXML = getParameterXML("Name", this.predefinedType);
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<entity ${attributes}>
  ${nameXML}
  ${predefinedTypeXML}
</entity>`;
  }
  async getEntities(modelIds, collector) {
    const fragments = this._components.get(FragmentsManager);
    const modelCategories = /* @__PURE__ */ new Map();
    for (const [modelId, model] of fragments.list) {
      const isValidModel = modelIds.find((regex) => regex.test(modelId));
      if (!isValidModel)
        continue;
      const categories = await model.getCategories();
      for (const category of categories) {
        const isValidCategory = await this.evalName(category);
        if (!isValidCategory)
          continue;
        let validCategories = modelCategories.get(modelId);
        if (!validCategories) {
          validCategories = [];
          modelCategories.set(modelId, validCategories);
        }
        validCategories.push(category);
      }
    }
    const items = {};
    await Promise.all(
      Array.from(modelCategories.entries()).map(
        async ([modelId, categories]) => {
          const model = fragments.list.get(modelId);
          if (!model)
            return;
          const regexCategories = categories.map(
            (cat) => new RegExp(`^${cat}$`)
          );
          const categoryItemIds = await model.getItemsOfCategories(regexCategories);
          const localIds = Object.values(categoryItemIds).flat();
          items[modelId] = new Set(localIds);
        }
      )
    );
    if (!this.predefinedType) {
      ModelIdMapUtils.add(collector, items);
      return;
    }
    for (const [modelId, localIds] of Object.entries(items)) {
      const model = fragments.list.get(modelId);
      if (!model)
        continue;
      const itemsData = await model.getItemsData([...localIds]);
      for (const attribute of itemsData) {
        if (!("value" in attribute._localId))
          continue;
        const isValidPredefinedType = await this.evalPredefinedType(
          modelId,
          attribute
        );
        if (isValidPredefinedType) {
          ModelIdMapUtils.append(collector, modelId, attribute._localId.value);
        }
      }
    }
  }
  async test(items, collector, config) {
    const fragments = this._components.get(FragmentsManager);
    for (const [modelId, localIds] of Object.entries(items)) {
      const model = fragments.list.get(modelId);
      if (!model)
        continue;
      const data = await model.getItemsData([...localIds]);
      for (const item of data) {
        if (!("value" in item._category))
          continue;
        const checks = this.getItemChecks(
          collector,
          modelId,
          item,
          config.skipIfFails
        );
        if (!checks)
          continue;
        await this.evalName(item._category.value, checks);
        await this.evalPredefinedType(modelId, item, checks);
      }
    }
  }
  async evalName(category, checks) {
    const result = this.evalRequirement(category, this.name, "Name", checks);
    return result;
  }
  async evalPredefinedType(modelId, itemData, checks) {
    if (!this.predefinedType)
      return null;
    if (!("value" in itemData.PredefinedType))
      return null;
    const isRequirementUserDefined = typeof this.predefinedType.parameter === "string" && this.predefinedType.parameter === "USERDEFINED";
    let value = itemData.PredefinedType.value;
    if (value === "USERDEFINED" && !isRequirementUserDefined) {
      const attrNames = Object.keys(itemData);
      const key = attrNames.find((str) => /^((?!Predefined).)*Type$/.test(str));
      if (key) {
        const keyValue = itemData[key];
        if ("value" in keyValue)
          value = keyValue.value;
      } else {
        value = "USERDEFINED";
      }
    }
    if (!value) {
      const fragments = this._components.get(FragmentsManager);
      const model = fragments.list.get(modelId);
      if (model && "value" in itemData._localId) {
        const [data] = await model.getItemsData([itemData._localId.value], {
          relations: { IsTypedBy: { attributes: true, relations: false } }
        });
        if (Array.isArray(data.IsTypedBy)) {
          const typeAttrs = data.IsTypedBy[0];
          if (typeAttrs && "value" in typeAttrs.PredefinedType) {
            value = typeAttrs.PredefinedType.value;
            if (value === "USERDEFINED" && !isRequirementUserDefined) {
              const attrNames = Object.keys(typeAttrs);
              const key = attrNames.find(
                (str) => /^((?!Predefined).)*Type$/.test(str)
              );
              if (key) {
                const keyValue = typeAttrs[key];
                if ("value" in keyValue)
                  value = keyValue.value;
              } else {
                value = "USERDEFINED";
              }
            }
          }
        }
      }
    }
    const result = this.evalRequirement(
      value,
      this.predefinedType,
      "PredefinedType",
      checks
    );
    return result;
  }
}
class IDSProperty extends IDSFacet {
  constructor(components, propertySet, baseName) {
    super(components);
    __publicField(this, "facetType", "Property");
    __publicField(this, "propertySet");
    __publicField(this, "baseName");
    __publicField(this, "value");
    __publicField(this, "dataType");
    __publicField(this, "uri");
    // These are defined by the IDS specification
    __publicField(this, "_unsupportedTypes", [
      "IFCCOMPLEXPROPERTY",
      "IFCPHYSICALCOMPLEXQUANTITY"
    ]);
    this.propertySet = propertySet;
    this.baseName = baseName;
  }
  serialize(type) {
    const propertySetXML = getParameterXML("PropertySet", this.propertySet);
    const baseNameXML = getParameterXML("BaseName", this.baseName);
    const valueXML = getParameterXML("Value", this.value);
    const dataTypeXML = this.dataType ? `dataType=${this.dataType}` : "";
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.uri ? `uri=${this.uri}` : "";
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<property ${dataTypeXML} ${attributes}>
  ${propertySetXML}
  ${baseNameXML}
  ${valueXML}
</property>`;
  }
  async getEntities(modelIds, collector) {
    const fragments = this._components.get(FragmentsManager);
    for (const [modelId, model] of fragments.list) {
      const isValidModel = modelIds.find((regex) => regex.test(modelId));
      if (!isValidModel)
        continue;
      const items = await model.getItemsOfCategories([
        /PROPERTYSET/,
        /ELEMENTQUANTITY/
      ]);
      const localIds = Object.values(items).flat();
      if (localIds.length === 0)
        continue;
      const data = await model.getItemsData(localIds, {
        relations: {
          HasProperties: { attributes: true, relations: false },
          DefinesOcurrence: { attributes: true, relations: false }
        }
      });
      for (const set of data) {
        if (!("value" in set._localId && "value" in set._category && "value" in set.Name && Array.isArray(set.DefinesOcurrence))) {
          continue;
        }
        const nameMatches = this.evalRequirement(
          set.Name.value,
          this.propertySet,
          "PropertySet"
        );
        if (!nameMatches)
          continue;
        let propsListName;
        if (set._category.value === "IFCPROPERTYSET")
          propsListName = "HasProperties";
        if (set._category.value === "IFCELEMENTQUANTITY")
          propsListName = "Quantities";
        if (!propsListName)
          continue;
        const props = set[propsListName];
        if (!Array.isArray(props))
          continue;
        for (const prop of props) {
          const keys = Object.keys(prop);
          const nameKey = keys.find((key) => /Name/.test(key));
          if (!(nameKey && "value" in prop[nameKey]))
            continue;
          const attribute = prop[nameKey];
          if (!("value" in attribute))
            continue;
          const propNameMatches = this.evalRequirement(
            attribute.value,
            this.baseName,
            "BaseName"
          );
          if (!propNameMatches)
            continue;
          if (this.value) {
            const valueKey = keys.find((key) => /Value/.test(key));
            if (!valueKey)
              continue;
            const attribute2 = prop[valueKey];
            if (!("value" in attribute2))
              continue;
            const valueMatches = this.evalRequirement(
              attribute2.value,
              this.value,
              "Value"
            );
            if (!valueMatches)
              continue;
          }
          const items2 = set.DefinesOcurrence.map((ocurrence) => {
            if (!("value" in ocurrence._localId && typeof ocurrence._localId.value === "number")) {
              return null;
            }
            return ocurrence._localId.value;
          }).filter((id) => id !== null);
          ModelIdMapUtils.append(collector, modelId, ...items2);
        }
      }
    }
  }
  async test(items, collector, config = { skipIfFails: true }) {
    const fragments = this._components.get(FragmentsManager);
    for (const [modelId, localIds] of Object.entries(items)) {
      const model = fragments.list.get(modelId);
      if (!model)
        continue;
      const data = await model.getItemsData([...localIds], {
        relations: {
          IsDefinedBy: { attributes: true, relations: true },
          IsTypedBy: { attributes: true, relations: false },
          HasPropertySets: { attributes: true, relations: true },
          DefinesOcurrence: { attributes: false, relations: false }
        }
      });
      for (const item of data) {
        const checks = this.getItemChecks(
          collector,
          modelId,
          item,
          config.skipIfFails
        );
        if (!checks)
          continue;
        const sets = await this.getPsets(item);
        const matchingSets = sets.filter((set) => {
          if (!("value" in set.Name))
            return false;
          const result = this.evalRequirement(
            set.Name.value,
            this.propertySet,
            "PropertySet"
          );
          if (!result)
            return false;
          checks.push({
            currentValue: set.Name.value,
            parameter: "PropertySet",
            pass: true,
            requiredValue: this.propertySet
          });
          return true;
        });
        if (matchingSets.length === 0) {
          checks.push({
            currentValue: null,
            parameter: "PropertySet",
            pass: false,
            requiredValue: this.propertySet
          });
          continue;
        }
        for (const set of matchingSets) {
          const propsListName = this.getPropertyListName(set);
          if (!propsListName)
            continue;
          const props = set[propsListName];
          if (!Array.isArray(props)) {
            checks.push({
              currentValue: null,
              parameter: "BaseName",
              pass: false,
              requiredValue: this.baseName
            });
            continue;
          }
          const matchingProps = props.filter((item2) => {
            if (!("value" in item2._category && "value" in item2.Name))
              return false;
            if (this._unsupportedTypes.includes(item2._category.value)) {
              return false;
            }
            const result = this.evalRequirement(
              item2.Name.value,
              this.baseName,
              "BaseName"
            );
            if (!result)
              return false;
            checks.push({
              currentValue: item2.Name.value,
              parameter: "BaseName",
              pass: true,
              requiredValue: this.baseName
            });
            return true;
          });
          if (matchingProps.length === 0) {
            checks.push({
              currentValue: null,
              parameter: "BaseName",
              pass: false,
              requiredValue: this.baseName
            });
            continue;
          }
          for (const item2 of matchingProps) {
            this.evalValue(item2, checks);
            this.evalDataType(item2, checks);
            this.evalURI();
          }
        }
      }
    }
  }
  getPropertyListName(item) {
    let propsListName;
    if (!("value" in item._category))
      return propsListName;
    if (item._category.value === "IFCPROPERTYSET")
      propsListName = "HasProperties";
    if (item._category.value === "IFCELEMENTQUANTITY")
      propsListName = "Quantities";
    return propsListName;
  }
  getValueKey(item) {
    return Object.keys(item).find(
      (name) => /Value/.test(name) || /Values/.test(name)
    );
  }
  getTypePsets(item) {
    if (!Array.isArray(item.IsTypedBy))
      return [];
    const [type] = item.IsTypedBy;
    if (!(type && Array.isArray(type.HasPropertySets))) {
      return [];
    }
    return type.HasPropertySets;
  }
  async getPsets(item) {
    const typeSets = this.getTypePsets(item);
    if (!Array.isArray(item.IsDefinedBy))
      return typeSets;
    const sets = [];
    for (const definition of item.IsDefinedBy) {
      if (!("value" in definition.Name))
        continue;
      const definitionName = definition.Name.value;
      const propsListName = this.getPropertyListName(definition);
      if (!(definitionName && propsListName))
        continue;
      const typeSet = typeSets.find((set) => {
        if (!("value" in set.Name))
          return false;
        return set.Name.value === definitionName;
      });
      if (typeSet && Array.isArray(typeSet.HasProperties) && Array.isArray(definition.HasProperties)) {
        for (const prop of typeSet.HasProperties) {
          if (!("value" in prop.Name))
            continue;
          const name = prop.Name.value;
          const existingProp = definition.HasProperties.find((p) => {
            if (!("value" in p.Name))
              return false;
            return p.Name.value === name;
          });
          if (!existingProp)
            definition.HasProperties.push(prop);
        }
      }
      sets.push(definition);
    }
    return sets;
  }
  // IFCPROPERTYBOUNDEDVALUE are not supported yet
  // IFCPROPERTYTABLEVALUE are not supported yet
  // TODO: Work must to be done to convert numerical value units to IDS-nominated standard units https://github.com/buildingSMART/IDS/blob/development/Documentation/UserManual/units.md
  evalValue(item, checks) {
    const valueKey = this.getValueKey(item);
    const valueAttr = item[valueKey];
    if (!("value" in valueAttr))
      return false;
    if (this.value) {
      if (!valueKey) {
        checks == null ? void 0 : checks.push({
          parameter: "Value",
          currentValue: null,
          pass: false,
          requiredValue: this.value
        });
        return false;
      }
      const facetValue = structuredClone(this.value);
      if (valueAttr.type === "IFCLABEL" && facetValue.type === "simple") {
        facetValue.parameter = String(facetValue.parameter);
      }
      const result = this.evalRequirement(
        valueAttr.value,
        facetValue,
        "Value",
        checks
      );
      return result;
    }
    if (!valueKey)
      return true;
    if (typeof valueAttr.value === "string" && valueAttr.value.trim() === "") {
      checks == null ? void 0 : checks.push({
        parameter: "Value",
        currentValue: "",
        pass: false,
        requiredValue: this.value
      });
      return false;
    }
    return true;
  }
  evalDataType(item, checks) {
    if (!this.dataType)
      return true;
    const valueKey = this.getValueKey(item);
    if (!(valueKey && "value" in item[valueKey])) {
      checks == null ? void 0 : checks.push({
        parameter: "DataType",
        currentValue: null,
        pass: false,
        requiredValue: this.dataType
      });
      return false;
    }
    const valueAttr = item[valueKey];
    const result = this.evalRequirement(
      valueAttr.type ?? null,
      {
        type: "simple",
        parameter: this.dataType
      },
      "DataType",
      checks
    );
    return result;
  }
  evalURI() {
    return true;
  }
}
class IDSMaterial extends IDSFacet {
  constructor() {
    super(...arguments);
    __publicField(this, "_ifcMaterialEntities", [
      /^IFCMATERIALLAYERSETUSAGE$/,
      /^IFCMATERIALCONSTITUENTSET$/,
      /^IFCMATERIAL$/,
      /^IFCMATERIALLIST$/
    ]);
    __publicField(this, "facetType", "Material");
    __publicField(this, "value");
    __publicField(this, "uri");
  }
  serialize(type) {
    if (!(this.value && this.uri))
      return "<material />";
    const valueXML = getParameterXML("Value", this.value);
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.uri ? `uri=${this.uri}` : "";
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<material ${attributes}>
  ${valueXML}
</material>`;
  }
  async getEntities(modelIds, collector) {
    const fragments = this._components.get(FragmentsManager);
    for (const [modelId, model] of fragments.list) {
      const isValidModel = modelIds.find((regex) => regex.test(modelId));
      if (!isValidModel)
        continue;
      const items = await model.getItemsOfCategories(this._ifcMaterialEntities);
      const localIds = Object.values(items).flat();
      if (localIds.length === 0)
        continue;
      const data = await model.getItemsData(localIds, {
        relations: {
          AssociatedTo: { attributes: true, relations: false },
          MaterialConstituents: { attributes: true, relations: true },
          ForLayerSet: { attributes: true, relations: true },
          MaterialLayers: { attributes: true, relations: true },
          Materials: { attributes: true, relations: false }
        }
      });
      for (const item of data) {
        if (!("value" in item._localId && "value" in item._category && Array.isArray(item.AssociatedTo))) {
          continue;
        }
        const isValid = this.hasValidMaterial(item);
        if (!isValid)
          continue;
        const relations = item.AssociatedTo.map((relation) => {
          if (!("value" in relation._localId && relation._localId.value))
            return null;
          return relation._localId.value;
        }).filter((value) => value !== null);
        ModelIdMapUtils.append(collector, modelId, ...relations);
      }
    }
  }
  async test(items, collector, config = { skipIfFails: true }) {
    const fragments = this._components.get(FragmentsManager);
    for (const [modelId, localIds] of Object.entries(items)) {
      const model = fragments.list.get(modelId);
      if (!model)
        continue;
      const data = await model.getItemsData([[...localIds][0]], {
        relations: {
          AssociatedTo: { attributes: false, relations: false },
          HasAssociations: { attributes: true, relations: true },
          MaterialConstituents: { attributes: true, relations: true },
          ForLayerSet: { attributes: true, relations: true },
          MaterialLayers: { attributes: true, relations: true },
          Materials: { attributes: true, relations: false }
        }
      });
      for (const item of data) {
        const checks = this.getItemChecks(
          collector,
          modelId,
          item,
          config.skipIfFails
        );
        if (!checks)
          continue;
        if (!Array.isArray(item.HasAssociations)) {
          checks.push({
            parameter: null,
            currentValue: null,
            requiredValue: this.value,
            pass: false
          });
          continue;
        }
        for (const association of item.HasAssociations) {
          if (!this._ifcMaterialEntities.some((parent) => {
            if (!("value" in association._category))
              return false;
            return parent.test(association._category.value);
          })) {
            continue;
          }
          const isValid = this.hasValidMaterial(association, checks);
          if (isValid)
            break;
        }
      }
    }
  }
  hasValidMaterial(item, checks) {
    let isValid = false;
    if ("value" in item._category && item._category.value === "IFCMATERIAL") {
      const result = this.evalValue(item, checks);
      if (result)
        isValid = true;
    } else {
      for (const [name, attribute] of Object.entries(item)) {
        if (![
          "ForLayerSet",
          "MaterialLayers",
          "Material",
          "MaterialConstituents",
          "Materials"
        ].includes(name))
          continue;
        if (!Array.isArray(attribute))
          continue;
        for (const item2 of attribute) {
          const isMaterial = "value" in item2._category && item2._category.value === "IFCMATERIAL";
          if (isMaterial) {
            const result = this.evalValue(item2, checks);
            if (result) {
              isValid = true;
              break;
            }
          } else {
            const result = this.hasValidMaterial(item2);
            if (result) {
              isValid = true;
              break;
            }
          }
        }
      }
    }
    return isValid;
  }
  evalValue(item, checks) {
    if (!this.value) {
      checks == null ? void 0 : checks.push({
        parameter: null,
        currentValue: item.Name && "value" in item.Name ? item.Name.value : null,
        pass: true
      });
      return true;
    }
    if (!("value" in item._category && item._category.value === "IFCMATERIAL")) {
      return null;
    }
    let result = false;
    if (item.Name && "value" in item.Name) {
      result = this.evalRequirement(
        item.Name.value,
        this.value,
        "Value",
        checks
      );
    }
    if (result)
      return result;
    if (item.Category && "value" in item.Category) {
      result = this.evalRequirement(
        item.Category.value,
        this.value,
        "Value",
        checks
      );
    }
    return result;
  }
}
class IDSPartOf extends IDSFacet {
  constructor(components, entity) {
    super(components);
    __publicField(this, "facetType", "PartOf");
    __publicField(this, "_entityFacet");
    __publicField(this, "_entity");
    __publicField(this, "relation");
    __publicField(this, "cardinality", "required");
    this._entity = entity;
    this._entityFacet = new IDSEntity(components, entity.name);
    this._entityFacet.predefinedType = entity.predefinedType;
  }
  set entity(value) {
    this._entity = value;
    const { name, predefinedType } = value;
    this._entityFacet = new IDSEntity(this._components, name);
    this._entityFacet.predefinedType = predefinedType;
  }
  get entity() {
    return this._entity;
  }
  serialize() {
    return "";
  }
  async getEntities(_modelIds, _collector) {
  }
  async test(_items) {
  }
}
class IDSSpecification {
  constructor(components, name, ifcVersion) {
    __publicField(this, "name");
    __publicField(this, "ifcVersion", /* @__PURE__ */ new Set());
    __publicField(this, "identifier", UUID.create());
    __publicField(this, "description");
    __publicField(this, "instructions");
    __publicField(this, "requirementsDescription");
    __publicField(this, "applicability", new FRAGS.DataSet());
    __publicField(this, "requirements", new FRAGS.DataSet());
    __publicField(this, "components");
    this.components = components;
    this.name = name;
    for (const version of ifcVersion) {
      this.ifcVersion.add(version);
    }
  }
  set(data) {
    const _data = data;
    const _this = this;
    for (const key in data) {
      if (key === "identifier")
        continue;
      const value = _data[key];
      if (key in this)
        _this[key] = value;
    }
    const manager = this.components.get(IDSSpecifications);
    manager.list.set(this.identifier, this);
    return this;
  }
  /**
   * Tests the model to test against the specification's requirements.
   *
   * @param modelId - The modelId of the model to be tested.
   * @returns An array representing the test results.
   * If no requirements are defined for the specification, an empty array is returned.
   */
  async test(modelIds, config = { skipIfFails: true }) {
    const result = new FRAGS.DataMap();
    if (this.requirements.size === 0)
      return result;
    const entities = {};
    const applicabilityPromises = [];
    for (const facet of this.applicability) {
      applicabilityPromises.push(facet.getEntities(modelIds, entities));
    }
    await Promise.all(applicabilityPromises);
    const requirementPromises = [];
    for (const requirement of this.requirements) {
      requirementPromises.push(requirement.test(entities, result, config));
    }
    await Promise.all(requirementPromises);
    return result;
  }
  /**
   * Serializes the IDSSpecification instance into XML format.
   *
   * @remarks This method is not meant to be used directly. It is used by the IDSSpecifications component.
   *
   * @returns The XML representation of the IDSSpecification.
   */
  serialize() {
    const name = `name="${this.name}"`;
    const identifier = this.identifier ? `identifier="${this.identifier}"` : "";
    const description = this.description ? `description="${this.description}"` : "";
    const instructions = this.instructions ? `instructions="${this.instructions}"` : "";
    const xml = `<specification ifcVersion="${[...this.ifcVersion].join(" ")}" ${name} ${identifier} ${description} ${instructions}>
      <applicability minOccurs="1" maxOccurs="unbounded">
        ${[...this.applicability].map((facet) => facet.serialize("applicability")).join("\n")}
      </applicability>
      <requirements>
        ${[...this.requirements].map((facet) => facet.serialize("requirement")).join("\n")}
      </requirements>
    </specification>`;
    return xml;
  }
}
const getParameterValue = (property) => {
  if (!property)
    return void 0;
  const result = {};
  if ("simpleValue" in property) {
    result.type = "simple";
    result.parameter = property.simpleValue;
  }
  if ("restriction" in property) {
    const restriction = property.restriction;
    const keys = Object.keys(restriction);
    if ("pattern" in restriction) {
      result.type = "pattern";
      result.parameter = restriction.pattern.value;
    }
    if ("enumeration" in restriction) {
      result.type = "enumeration";
      const enumeration = restriction.enumeration.map(
        ({ value }) => {
          if (restriction.base.includes("string"))
            return String(value);
          if (restriction.base.includes("integer") || restriction.base.includes("double"))
            return Number(value);
          return value;
        }
      );
      result.parameter = enumeration;
    }
    if (keys.some(
      (key) => [
        "minInclusive",
        "minExclusive",
        "maxInclusive",
        "maxExclusive"
      ].includes(key)
    )) {
      result.type = "bounds";
      const parameter = {};
      const minKey = keys.find((key) => key.includes("min"));
      const maxKey = keys.find((key) => key.includes("max"));
      if (minKey) {
        parameter.minInclusive = minKey === "minInclusive";
        parameter.min = restriction[minKey].value;
      }
      if (maxKey) {
        parameter.maxInclusive = maxKey === "maxInclusive";
        parameter.max = restriction[maxKey].value;
      }
      result.parameter = parameter;
    }
    if (keys.some((key) => ["minLength", "length", "maxLength"].includes(key))) {
      result.type = "length";
      const parameter = {};
      if (restriction.length !== void 0) {
        parameter.length = restriction.length.value;
      }
      if (restriction.minLength !== void 0) {
        parameter.min = restriction.minLength.value;
      }
      if (restriction.maxLength !== void 0) {
        parameter.max = restriction.maxLength.value;
      }
      result.parameter = parameter;
    }
  }
  if (result.parameter === void 0)
    return void 0;
  return result;
};
const createEntityFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const nameParameter = element.name;
    const name = getParameterValue(nameParameter);
    if (!name)
      continue;
    const facet = new IDSEntity(components, name);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    facet.predefinedType = getParameterValue(element.predefinedType);
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
const createAttributeFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const nameParameter = element.name;
    const name = getParameterValue(nameParameter);
    if (!name)
      continue;
    const facet = new IDSAttribute(components, name);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    facet.value = getParameterValue(element.value);
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
const createMaterialFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const facet = new IDSMaterial(components);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    const value = getParameterValue(element.value);
    if ((value == null ? void 0 : value.type) === "enumeration" && Array.isArray(value.parameter)) {
      value.parameter = value.parameter.map(String);
    }
    facet.value = value;
    facet.uri = element.uri;
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
const createPropertyFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const psetParameter = element.propertySet;
    const baseNameParameter = element.baseName;
    const pset = getParameterValue(psetParameter);
    const baseName = getParameterValue(baseNameParameter);
    if (!(baseName && pset))
      continue;
    const facet = new IDSProperty(components, pset, baseName);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    const value = getParameterValue(element.value);
    facet.value = value;
    facet.dataType = element.dataType;
    facet.uri = element.uri;
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
const createClassificationFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const systemParameter = element.system;
    const system = getParameterValue(systemParameter);
    if (!system)
      continue;
    const facet = new IDSClassification(components, system);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    const value = getParameterValue(element.value);
    if ((value == null ? void 0 : value.type) === "simple") {
      value.parameter = String(value.parameter);
    }
    if ((value == null ? void 0 : value.type) === "enumeration" && Array.isArray(value.parameter)) {
      value.parameter = value.parameter.map(String);
    }
    facet.value = value;
    facet.uri = element.uri;
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
const createPartOfFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const entityName2 = getParameterValue(element.entity.name);
    if (!entityName2)
      continue;
    const entityPredefinedType = getParameterValue(
      element.entity.predefinedType
    );
    const facet = new IDSPartOf(components, {
      name: entityName2,
      predefinedType: entityPredefinedType
    });
    facet.relation = element.relation;
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
const _IDSSpecifications = class _IDSSpecifications extends Component {
  constructor(components) {
    super(components);
    __publicField(this, "enabled", true);
    __publicField(this, "IDSInfo");
    __publicField(this, "list", new DataMap$1());
    components.add(_IDSSpecifications.uuid, this);
  }
  /**
   * Processes the results of an IDS check and categorizes the items into passing and failing.
   *
   * @param result - An `IDSCheckResult` object containing the check results for various model IDs.
   * @returns An object containing two `ModelIdMap` objects:
   *          - `pass`: A ModelIdMap representing items that passed the check.
   *          - `fail`: A ModelIdMap representing items that failed the check.
   */
  getModelIdMap(result) {
    const pass = {};
    const fail = {};
    for (const [modelId, items] of result) {
      const passingResults = [...items].filter(([, result2]) => result2.pass);
      const passingIds = passingResults.map(([localId]) => localId);
      ModelIdMapUtils.append(pass, modelId, ...passingIds);
      const failingResults = [...items].filter(([, result2]) => !result2.pass);
      const failingIds = failingResults.map(([localId]) => localId);
      ModelIdMapUtils.append(fail, modelId, ...failingIds);
    }
    return { pass, fail };
  }
  /**
   * Creates a new IDSSpecification instance and adds it to the list.
   *
   * @param name - The name of the IDSSpecification.
   * @param ifcVersion - An array of IfcVersion values that the specification supports.
   *
   * @returns The newly created IDSSpecification instance.
   */
  create(name, ifcVersion, identifier) {
    const specification = new IDSSpecification(
      this.components,
      name,
      ifcVersion
    );
    if (identifier)
      specification.identifier = identifier;
    this.list.set(specification.identifier, specification);
    return specification;
  }
  /**
   * Parses and processes an XML string containing Information Delivery Specification (IDS) data.
   * It creates IDSSpecification instances based on the parsed data and returns them in an array.
   * Also, the instances are added to the list array.
   *
   * @param data - The XML string to parse.
   *
   * @returns An array of IDSSpecification instances created from the parsed data.
   */
  load(data) {
    const result = [];
    const ids = _IDSSpecifications.xmlParser.parse(data).ids;
    const { specifications, info } = ids;
    this.IDSInfo = { ...info };
    if (specifications && specifications.specification) {
      const specs = Array.isArray(specifications.specification) ? specifications.specification : [specifications.specification];
      for (const spec of specs) {
        const { name, ifcVersion, description, instructions, identifier } = spec;
        if (!(name && ifcVersion))
          continue;
        const applicabilities = [];
        const reqs = [];
        const { applicability, requirements } = spec;
        if (applicability) {
          const { maxOccurs, ...rest } = applicability;
          const facets = Array.isArray(rest) ? rest : [rest];
          for (const facet of facets) {
            for (const facetName in facet) {
              const elements = Array.isArray(facet[facetName]) ? facet[facetName] : [facet[facetName]];
              if (facetName === "entity") {
                const facets2 = createEntityFacets(this.components, elements);
                applicabilities.push(...facets2);
              }
              if (facetName === "attribute") {
                const facets2 = createAttributeFacets(this.components, elements);
                applicabilities.push(...facets2);
              }
              if (facetName === "material") {
                const facets2 = createMaterialFacets(this.components, elements);
                applicabilities.push(...facets2);
              }
              if (facetName === "classification") {
                const facets2 = createClassificationFacets(
                  this.components,
                  elements
                );
                applicabilities.push(...facets2);
              }
              if (facetName === "property") {
                const facets2 = createPropertyFacets(this.components, elements);
                applicabilities.push(...facets2);
              }
              if (facetName === "partOf") {
                const facets2 = createPartOfFacets(this.components, elements);
                applicabilities.push(...facets2);
              }
            }
          }
        }
        let requirementsDescription;
        if (requirements) {
          const { maxOccurs, ...rest } = requirements;
          requirementsDescription = requirements.description;
          const facets = Array.isArray(rest) ? rest : [rest];
          for (const facet of facets) {
            for (const facetName in facet) {
              const elements = Array.isArray(facet[facetName]) ? facet[facetName] : [facet[facetName]];
              if (facetName === "entity") {
                const facets2 = createEntityFacets(this.components, elements);
                reqs.push(...facets2);
              }
              if (facetName === "attribute") {
                const facets2 = createAttributeFacets(this.components, elements);
                reqs.push(...facets2);
              }
              if (facetName === "material") {
                const facets2 = createMaterialFacets(this.components, elements);
                reqs.push(...facets2);
              }
              if (facetName === "classification") {
                const facets2 = createClassificationFacets(
                  this.components,
                  elements
                );
                reqs.push(...facets2);
              }
              if (facetName === "property") {
                const facets2 = createPropertyFacets(this.components, elements);
                reqs.push(...facets2);
              }
              if (facetName === "partOf") {
                const facets2 = createPartOfFacets(this.components, elements);
                reqs.push(...facets2);
              }
            }
          }
        }
        const specification = this.create(
          name,
          ifcVersion.split(/\s+/),
          identifier
        );
        specification.description = description;
        specification.instructions = instructions;
        specification.requirementsDescription = requirementsDescription;
        specification.applicability.add(...applicabilities);
        specification.requirements.add(...reqs);
        result.push(specification);
      }
    }
    return result;
  }
  /**
   * Exports the IDSSpecifications data into an XML string.
   *
   * @param info - The metadata information for the exported XML.
   * @param specifications - An optional iterable of IDSSpecification instances to export.
   * If not provided, all specifications in the list will be exported.
   *
   * @returns A string containing the exported IDSSpecifications data in XML format.
   */
  export(info, specifications = this.list.values()) {
    const _specifications = specifications ?? this.list;
    const xml = `<ids xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://standards.buildingsmart.org/IDS http://standards.buildingsmart.org/IDS/1.0/ids.xsd" xmlns:ids="http://standards.buildingsmart.org/IDS">
  <!-- Made with That Open Engine ${Components.release} (https://github.com/thatopen/engine_components) -->
  <info>
    <title>${info.title}</title>
    ${info.copyright ? `<copyright>${info.copyright}</copyright>` : ""}
    ${info.version ? `<version>${info.version}</version>` : ""}
    ${info.description ? `<description>${info.description}</description>` : ""}
    ${info.author ? `<author>${info.author}</author>` : ""}
    ${info.date ? `<date>${info.date.toISOString().split("T")[0]}</date>` : ""}
    ${info.purpose ? `<purpose>${info.purpose}</purpose>` : ""}
    ${info.milestone ? `<milestone>${info.milestone}</milestone>` : ""}
  </info>
  <specifications>
    ${[..._specifications].map((spec) => spec.serialize()).join("\n")}
  </specifications>
</ids>`;
    return xml;
  }
};
__publicField(_IDSSpecifications, "uuid", "9f0b9f78-9b2e-481a-b766-2fbfd01f342c");
__publicField(_IDSSpecifications, "xmlParser", new fxp.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
let IDSSpecifications = _IDSSpecifications;
const _MeasurementUtils = class _MeasurementUtils extends Component {
  constructor(components) {
    super(components);
    /** {@link Component.enabled} */
    __publicField(this, "enabled", true);
    components.add(_MeasurementUtils.uuid, this);
  }
  /**
   * Utility method to calculate the distance from a point to a line segment.
   *
   * @param point - The point from which to calculate the distance.
   * @param lineStart - The start point of the line segment.
   * @param lineEnd - The end point of the line segment.
   * @param clamp - If true, the distance will be clamped to the line segment's length.
   * @returns The distance from the point to the line segment.
   */
  static distanceFromPointToLine(point, lineStart, lineEnd, clamp2 = false) {
    const tempLine = new THREE$1.Line3();
    const tempPoint = new THREE$1.Vector3();
    tempLine.set(lineStart, lineEnd);
    tempLine.closestPointToPoint(point, clamp2, tempPoint);
    return tempPoint.distanceTo(point);
  }
  // /**
  //  * Method to get the face of a mesh that contains a given triangle index.
  //  * It also returns the edges of the found face and their indices.
  //  *
  //  * @param mesh - The mesh to get the face from. It must be indexed.
  //  * @param triangleIndex - The index of the triangle within the mesh.
  //  * @param instance - The instance of the mesh (optional).
  //  * @returns An object containing the edges of the found face and their indices, or null if no face was found.
  //  */
  // getFace(
  //   mesh: THREE.InstancedMesh | THREE.Mesh,
  //   triangleIndex: number,
  //   instance?: number,
  // ) {
  //   if (!mesh.geometry.index) {
  //     throw new Error("Geometry must be indexed!");
  //   }
  //   const allEdges = new Map<string, MeasureEdge>();
  //   const indices = mesh.geometry.index.array;
  //   // Find out the raycasted face plane
  //   const { plane: targetPlane } = this.getFaceData(
  //     triangleIndex,
  //     instance,
  //     mesh,
  //   );
  //   // Get the face where the given triangle belongs
  //   const coplanarFacesIndices: {
  //     index: number;
  //     edges: { id: string; distance: number; points: THREE.Vector3[] }[];
  //   }[] = [];
  //   for (let faceIndex = 0; faceIndex < indices.length / 3; faceIndex++) {
  //     const { plane, edges } = this.getFaceData(faceIndex, instance, mesh);
  //     if (plane.equals(targetPlane)) {
  //       coplanarFacesIndices.push({ index: faceIndex, edges });
  //       for (const { id, points, distance } of edges) {
  //         allEdges.set(id, { points, distance });
  //       }
  //     }
  //   }
  //   // Now, let's get all faces (groups of adjacent triangles)
  //   // To visualize this, draw all possible cases on paper, it's easy
  //   let nextFaceID = 0;
  //   const edgeFaceMap = new Map<string, number>();
  //   const faceEdgesMap = new Map<
  //     number,
  //     { edges: Set<string>; indices: Set<number> }
  //   >();
  //   for (const { index, edges } of coplanarFacesIndices) {
  //     const commonEdgesFaces = new Map<string, number>();
  //     for (const { id: edge } of edges) {
  //       if (edgeFaceMap.has(edge)) {
  //         const commonFace = edgeFaceMap.get(edge) as number;
  //         commonEdgesFaces.set(edge, commonFace);
  //       }
  //     }
  //     const edgesIDs = edges.map((edge) => edge.id);
  //     // Triangle is isolated, just create a new face
  //     if (!commonEdgesFaces.size) {
  //       const faceID = nextFaceID++;
  //       for (const { id: edge } of edges) {
  //         edgeFaceMap.set(edge, faceID);
  //       }
  //       faceEdgesMap.set(faceID, {
  //         edges: new Set(edgesIDs),
  //         indices: new Set([index]),
  //       });
  //       continue;
  //     }
  //     // Triangle has common edges with existing faces
  //     let firstFaceID: number | null = null;
  //     const otherFaces = new Set<number>();
  //     const edgesToAdd = new Set(edgesIDs);
  //     // First, remove all common edges
  //     for (const [edge, faceID] of commonEdgesFaces) {
  //       if (firstFaceID === null) {
  //         firstFaceID = faceID;
  //       } else if (faceID !== firstFaceID) {
  //         otherFaces.add(faceID);
  //       }
  //       edgeFaceMap.delete(edge);
  //       const { edges: foundFaceEdges } = faceEdgesMap.get(faceID)!;
  //       foundFaceEdges.delete(edge);
  //       edgesToAdd.delete(edge);
  //     }
  //     // If we hadn't found a face, we wouldn't be here
  //     if (firstFaceID === null) {
  //       throw new Error("Error computing face!");
  //     }
  //     // Now, let's merge this triangle with the first face
  //     const firstFace = faceEdgesMap.get(firstFaceID)!;
  //     const { indices: firstFaceIndices } = firstFace;
  //     firstFaceIndices.add(index);
  //     for (const edge of edgesToAdd) {
  //       edgeFaceMap.set(edge, firstFaceID);
  //       const { edges: firstFaceEdges } = firstFace;
  //       firstFaceEdges.add(edge);
  //     }
  //     // Finally, if there were other faces in common
  //     // merge them with the first one
  //     for (const faceID of otherFaces) {
  //       const otherFace = faceEdgesMap.get(faceID)!;
  //       const { edges: otherEdges, indices: otherIndices } = otherFace;
  //       const firstFace = faceEdgesMap.get(firstFaceID)!;
  //       const { edges: firstEdges, indices: firstIndices } = firstFace;
  //       for (const edge of otherEdges) {
  //         firstEdges.add(edge);
  //         edgeFaceMap.set(edge, firstFaceID);
  //       }
  //       for (const index of otherIndices) {
  //         firstIndices.add(index);
  //       }
  //       faceEdgesMap.delete(faceID);
  //     }
  //   }
  //   for (const [_faceID, { indices, edges }] of faceEdgesMap) {
  //     if (indices.has(triangleIndex)) {
  //       const foundEdges: MeasureEdge[] = [];
  //       for (const edgeID of edges) {
  //         const foundEdge = allEdges.get(edgeID)!;
  //         foundEdges.push(foundEdge);
  //       }
  //       return { edges: foundEdges, indices };
  //     }
  //   }
  //   return null;
  // }
  // /**
  //  * Method to get the vertices and normal of a mesh face at a given index.
  //  * It also applies instance transformation if provided.
  //  *
  //  * @param mesh - The mesh to get the face from. It must be indexed.
  //  * @param faceIndex - The index of the face within the mesh.
  //  * @param instance - The instance of the mesh (optional).
  //  * @returns An object containing the vertices and normal of the face.
  //  * @throws Will throw an error if the geometry is not indexed.
  //  */
  // getVerticesAndNormal(
  //   mesh: THREE.Mesh | THREE.InstancedMesh,
  //   faceIndex: number,
  //   instance: number | undefined,
  // ) {
  //   if (!mesh.geometry.index) {
  //     throw new Error("Geometry must be indexed!");
  //   }
  //   const indices = mesh.geometry.index.array;
  //   const pos = mesh.geometry.attributes.position.array;
  //   const nor = mesh.geometry.attributes.normal.array;
  //   const i1 = indices[faceIndex * 3] * 3;
  //   const i2 = indices[faceIndex * 3 + 1] * 3;
  //   const i3 = indices[faceIndex * 3 + 2] * 3;
  //   const p1 = new THREE.Vector3(pos[i1], pos[i1 + 1], pos[i1 + 2]);
  //   const p2 = new THREE.Vector3(pos[i2], pos[i2 + 1], pos[i2 + 2]);
  //   const p3 = new THREE.Vector3(pos[i3], pos[i3 + 1], pos[i3 + 2]);
  //   const n1 = new THREE.Vector3(nor[i1], nor[i1 + 1], nor[i1 + 2]);
  //   const n2 = new THREE.Vector3(nor[i2], nor[i2 + 1], nor[i2 + 2]);
  //   const n3 = new THREE.Vector3(nor[i3], nor[i3 + 1], nor[i3 + 2]);
  //   const averageNx = (n1.x + n2.x + n3.x) / 3;
  //   const averageNy = (n1.y + n2.y + n3.y) / 3;
  //   const averageNz = (n1.z + n2.z + n3.z) / 3;
  //   const faceNormal = new THREE.Vector3(averageNx, averageNy, averageNz);
  //   // Apply instance transformation to vertex and normal
  //   if (instance !== undefined && mesh instanceof THREE.InstancedMesh) {
  //     const transform = new THREE.Matrix4();
  //     mesh.getMatrixAt(instance, transform);
  //     const rotation = new THREE.Matrix4();
  //     rotation.extractRotation(transform);
  //     faceNormal.applyMatrix4(rotation);
  //     p1.applyMatrix4(transform);
  //     p2.applyMatrix4(transform);
  //     p3.applyMatrix4(transform);
  //   }
  //   return { p1, p2, p3, faceNormal };
  // }
  /**
   * Method to round the vector's components to a specified number of decimal places.
   * This is used to ensure numerical precision in edge detection.
   *
   * @param vector - The vector to round.
   * @returns The vector with rounded components.
   */
  round(vector) {
    const factor = 1e3;
    vector.x = Math.trunc(vector.x * factor) / factor;
    vector.y = Math.trunc(vector.y * factor) / factor;
    vector.z = Math.trunc(vector.z * factor) / factor;
  }
  /**
   * @deprecated Use {@link getItemsVolume} instead.
   *
   * Calculates the volume of a set of items.
   */
  async getVolumeFromFragments(modelIdMap) {
    console.warn(
      "getVolumeFromFragments is deprecated. Use getItemsVolume instead."
    );
    return this.getItemsVolume(modelIdMap);
  }
  /**
   * Calculates the total volume of items for a given map of model IDs to local IDs.
   * @param modelIdMap A map where the key is the model ID and the value is an array of local IDs.
   * @returns A promise that resolves to the total volume of the specified items.
   */
  async getItemsVolume(modelIdMap) {
    let volume = 0;
    const fragments = this.components.get(FragmentsManager);
    for (const [modelId, localIds] of Object.entries(modelIdMap)) {
      const model = fragments.list.get(modelId);
      if (!model)
        continue;
      volume += await model.getItemsVolume([...localIds]);
    }
    return volume;
  }
  // private getFaceData(
  //   faceIndex: number,
  //   instance: number | undefined,
  //   mesh: THREE.Mesh | THREE.InstancedMesh,
  // ) {
  //   const found = this.getVerticesAndNormal(mesh, faceIndex, instance);
  //   const { p1, p2, p3, faceNormal } = found;
  //   // Round numbers to make sure numerical precision
  //   // doesn't affect edge detection
  //   this.round(p1);
  //   this.round(p2);
  //   this.round(p3);
  //   this.round(faceNormal);
  //   // To make sure the edge AB === the edge BA
  //   const vertices = [
  //     { id: `${p1.x}|${p1.y}|${p1.z}`, value: p1 },
  //     { id: `${p2.x}|${p2.y}|${p2.z}`, value: p2 },
  //     { id: `${p3.x}|${p3.y}|${p3.z}`, value: p3 },
  //   ];
  //   vertices.sort((a, b) => {
  //     if (a.id < b.id) {
  //       return -1;
  //     }
  //     if (a.id > b.id) {
  //       return 1;
  //     }
  //     return 0;
  //   });
  //   const [
  //     { id: id1, value: v1 },
  //     { id: id2, value: v2 },
  //     { id: id3, value: v3 },
  //   ] = vertices;
  //   // Create IDs to identify the edges
  //   const edges = [
  //     {
  //       id: `${id1}|${id2}`,
  //       distance: v1.distanceTo(v2),
  //       points: [v1, v2],
  //     },
  //     {
  //       id: `${id2}|${id3}`,
  //       distance: v2.distanceTo(v3),
  //       points: [v2, v3],
  //     },
  //     {
  //       id: `${id1}|${id3}`,
  //       distance: v1.distanceTo(v3),
  //       points: [v1, v3],
  //     },
  //   ];
  //   const plane = new THREE.Plane();
  //   plane.setFromNormalAndCoplanarPoint(faceNormal, p1);
  //   plane.constant = Math.round(plane.constant * 10) / 10;
  //   return { plane, edges };
  // }
  /**
   * Converts a value from one unit to another for length, area, or volume without using external libraries.
   *
   * @param value - The value to convert.
   * @param fromUnit - The unit of the input value (e.g., "m", "cm", "mm" for lengths; "m2", "cm2" for areas; "m3", "cm3" for volumes).
   * @param toUnit - The unit to convert to (e.g., "cm", "mm", "m" for lengths; "cm2", "m2" for areas; "cm3", "m3" for volumes).
   * @param precision - The number of decimal places to round the result to, as number between 0 and 5. (default is 2).
   * @throws {Error} If the rounding value is not a valid integer or is out of range (0-5).
   * @returns The converted value rounded to the specified precision.
   */
  static convertUnits(value, fromUnit, toUnit, precision = 2) {
    const unitFactors = {
      // Length
      m: 1,
      cm: 0.01,
      mm: 1e-3,
      km: 1e3,
      // Area
      m2: 1,
      cm2: 1e-4,
      mm2: 1e-6,
      km2: 1e6,
      // Volume
      m3: 1,
      cm3: 1e-6,
      mm3: 1e-9,
      km3: 1e9
    };
    if (!unitFactors[fromUnit] || !unitFactors[toUnit]) {
      throw new Error("Invalid units provided for conversion.");
    }
    if (!Number.isInteger(precision) || precision < 0 || precision > 5) {
      throw new Error("Precision must be an integer between 0 and 5.");
    }
    let factor = unitFactors[fromUnit] / unitFactors[toUnit];
    const convertedValue = value * factor;
    const roundingFactor = 10 ** precision;
    return Math.round(convertedValue * roundingFactor) / roundingFactor;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
__publicField(_MeasurementUtils, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
let MeasurementUtils = _MeasurementUtils;
export {
  AsyncEvent,
  BCFTopics,
  BCFTopicsConfigManager,
  Base,
  BaseCamera,
  BaseRenderer,
  BaseScene,
  BaseWorldItem,
  BoundingBoxer,
  Classifier,
  Clipper,
  Comment,
  Component,
  Components,
  ConfigManager,
  Configurator,
  ControlsUtils,
  DataMap,
  DataSet,
  Disposer,
  Event,
  EventManager,
  FastModelPicker,
  FastModelPickers,
  FinderQuery,
  FirstPersonMode,
  FragmentsManager,
  Grids,
  Hider,
  IDSAttribute,
  IDSClassification,
  IDSEntity,
  IDSFacet,
  IDSMaterial,
  IDSPartOf,
  IDSProperty,
  IDSSpecification,
  IDSSpecifications,
  IfcFragmentSettings,
  IfcLoader,
  ItemsFinder,
  MeasurementUtils,
  ModelIdMapUtils,
  Mouse,
  OrbitMode,
  OrthoPerspectiveCamera,
  PlanMode,
  ProjectionManager,
  Raycasters,
  RendererMode,
  ShadowedScene,
  SimpleCamera,
  SimpleGrid,
  SimpleGridConfigManager,
  SimplePlane,
  SimpleRaycaster,
  SimpleRenderer,
  SimpleScene,
  SimpleSceneConfigManager,
  SimpleWorld,
  Topic,
  UUID,
  VertexPicker,
  View,
  Viewpoint,
  Viewpoints,
  Views,
  Worlds,
  XML,
  extensionsImporter
};
