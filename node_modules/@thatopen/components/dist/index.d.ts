import CameraControls from 'camera-controls';
import { DataMap as DataMap_2 } from '@thatopen/fragments';
import { DataSet as DataSet_2 } from '@thatopen/fragments';
import * as FRAGS from '@thatopen/fragments';
import * as THREE from 'three';
import { TransformControls } from 'three/examples/jsm/controls/TransformControls.js';
import { Vector2 } from 'three';
import * as WEBIFC from 'web-ifc';
import { XMLBuilder } from 'fast-xml-parser';
import { XMLParser } from 'fast-xml-parser';

/**
 * Configuration options for adding a classification.
 */
export declare interface AddClassificationConfig {
    /**
     * Optional name of the classification to be added.
     */
    classificationName?: string;
    /**
     * Optional array of regular expressions representing model IDs.
     */
    modelIds?: RegExp[];
}

declare class AmbientLightConfig {
    private _list;
    private _scene;
    constructor(list: SimpleSceneConfigType, scene: SimpleScene);
    get color(): THREE.Color;
    set color(value: THREE.Color);
    get intensity(): number;
    set intensity(value: number);
}

/**
 * Simple event handler by [Jason Kleban](https://gist.github.com/JasonKleban/50cee44960c225ac1993c922563aa540). Keep in mind that if you want to remove it later, you might want to declare the callback as an object. If you want to maintain the reference to `this`, you will need to declare the callback as an arrow function.
 */
export declare class AsyncEvent<T> {
    /**
     * Whether this event is active or not. If not, it won't trigger.
     */
    enabled: boolean;
    /**
     * Add a callback to this event instance.
     * @param handler - the callback to be added to this event.
     */
    add(handler: T extends void ? {
        (): Promise<void>;
    } : {
        (data: T): Promise<void>;
    }): void;
    /**
     * Removes a callback from this event instance.
     * @param handler - the callback to be removed from this event.
     */
    remove(handler: T extends void ? {
        (): Promise<void>;
    } : {
        (data: T): Promise<void>;
    }): void;
    /** Triggers all the callbacks assigned to this event. */
    trigger: (data?: T) => Promise<void>;
    /** Gets rid of all the suscribed events. */
    reset(): void;
    private handlers;
}

/**
 * Base class of the library. Useful for finding out the interfaces something implements.
 */
export declare abstract class Base {
    components: Components;
    constructor(components: Components);
    /** Whether is component is {@link Disposable}. */
    isDisposeable: () => this is Disposable_2;
    /** Whether is component is {@link Resizeable}. */
    isResizeable: () => this is Resizeable;
    /** Whether is component is {@link Updateable}. */
    isUpdateable: () => this is Updateable;
    /** Whether is component is {@link Hideable}. */
    isHideable: () => this is Hideable;
    /** Whether is component is {@link Configurable}. */
    isConfigurable: () => this is Configurable<any, any>;
    /** Whether is component is {@link Serializable}. */
    isSerializable: () => this is Serializable<any, Record<string, any>>;
}

/**
 * Abstract class representing a camera in a 3D world. All cameras should use this class as a base.
 */
export declare abstract class BaseCamera extends BaseWorldItem {
    /**
     * Whether the camera is enabled or not.
     */
    abstract enabled: boolean;
    /**
     * The Three.js camera instance.
     */
    abstract three: THREE.Camera;
    /**
     * Optional CameraControls instance for controlling the camera.
     * This property is only available if the camera is controllable.
     */
    abstract controls?: CameraControls;
    /**
     * Checks whether the instance is {@link CameraControllable}.
     *
     * @returns True if the instance is controllable, false otherwise.
     */
    hasCameraControls: () => this is CameraControllable;
}

/**
 * Abstract class representing a renderer for a 3D world. All renderers should use this class as a base.
 */
export declare abstract class BaseRenderer extends BaseWorldItem implements Updateable, Disposable_2, Resizeable {
    /**
     * The three.js WebGLRenderer instance associated with this renderer.
     *
     * @abstract
     * @type {THREE.WebGLRenderer}
     */
    abstract three: THREE.WebGLRenderer;
    /** {@link Updateable.onBeforeUpdate} */
    onAfterUpdate: Event_2<unknown>;
    /** {@link Updateable.onAfterUpdate} */
    onBeforeUpdate: Event_2<unknown>;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<undefined>;
    /** {@link Resizeable.onResize} */
    readonly onResize: Event_2<THREE.Vector2>;
    /**
     * Event that fires when there has been a change to the list of clipping
     * planes used by the active renderer.
     */
    readonly onClippingPlanesUpdated: Event_2<unknown>;
    /** {@link Updateable.update} */
    abstract update(delta?: number): void | Promise<void>;
    /** {@link Disposable.dispose} */
    abstract dispose(): void;
    /** {@link Resizeable.getSize} */
    abstract getSize(): Vector2;
    /** {@link Resizeable.resize} */
    abstract resize(size: Vector2 | undefined): void;
    /**
     * The list of [clipping planes](https://threejs.org/docs/#api/en/renderers/WebGLRenderer.clippingPlanes) used by this instance of the renderer.
     */
    clippingPlanes: THREE.Plane[];
    /**
     * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
     *
     * @remarks
     * This method is typically called when there is a change to the list of clipping planes
     * used by the active renderer.
     */
    updateClippingPlanes(): void;
    /**
     * Sets or removes a clipping plane from the renderer.
     *
     * @param active - A boolean indicating whether the clipping plane should be active or not.
     * @param plane - The clipping plane to be added or removed.
     * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
     *
     * @remarks
     * This method adds or removes a clipping plane from the `clippingPlanes` array.
     * If `active` is `true` and the plane is not already in the array, it is added.
     * If `active` is `false` and the plane is in the array, it is removed.
     * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
     * excluding any planes marked as local.
     */
    setPlane(active: boolean, plane: THREE.Plane, isLocal?: boolean): void;
}

/**
 * Abstract class representing a base scene in the application. All scenes should use this class as a base.
 */
export declare abstract class BaseScene extends BaseWorldItem implements Disposable_2 {
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /**
     * Abstract property representing the three.js object associated with this scene.
     * It should be implemented by subclasses.
     */
    abstract three: THREE.Object3D;
    /** The set of directional lights managed by this scene component. */
    directionalLights: Map<string, THREE.DirectionalLight>;
    /** The set of ambient lights managed by this scene component. */
    ambientLights: Map<string, THREE.AmbientLight>;
    protected constructor(components: Components);
    /** {@link Disposable.dispose} */
    dispose(): void;
    deleteAllLights(): void;
}

/**
 * One of the elements that make a world. It can be either a scene, a camera or a renderer.
 */
export declare abstract class BaseWorldItem extends Base {
    readonly worlds: DataMap_2<string, World>;
    /**
     * Event that is triggered when a world is added or removed from the `worlds` map.
     * The event payload contains the world instance and the action ("added" or "removed").
     */
    readonly onWorldChanged: Event_2<{
        world: World;
        action: "added" | "removed";
    }>;
    protected _currentWorld: World | null;
    /**
     * The current world this item is associated with. It can be null if no world is currently active.
     */
    set currentWorld(value: World | null);
    get currentWorld(): World | null;
    protected constructor(components: Components);
}

export declare interface BCFApiComment {
    guid: string;
    date: string;
    author: string;
    comment: string;
    topic_guid?: string;
    viewpoint_guid?: string;
    modified_date?: string;
    modified_author?: string;
}

export declare interface BCFApiTopic {
    guid: string;
    server_assigned_id?: string;
    topic_type?: string;
    topic_status?: string;
    reference_links?: string[];
    title: string;
    priority?: string;
    index?: number;
    labels?: string[];
    creation_date: string;
    creation_author: string;
    modified_date?: string;
    modified_author?: string;
    assigned_to?: string;
    stage?: string;
    description?: string;
    bim_snippet?: {
        snippet_type: string;
        is_external: boolean;
        reference: string;
        reference_schema: string;
    };
    due_date?: string;
    comments?: BCFApiComment[];
    viewpoints?: BCFViewpoint[];
    relatedTopics?: {
        related_topic_guid: string;
    }[];
    document_references?: {
        guid: string;
        document_guid?: string;
        url?: string;
        description?: string;
    }[];
}

export declare interface BCFTopic {
    guid: string;
    serverAssignedId?: string;
    type: string;
    status: string;
    title: string;
    priority?: string;
    index?: number;
    labels: Set<string>;
    creationDate: Date;
    creationAuthor: string;
    modifiedDate?: Date;
    modifiedAuthor?: string;
    dueDate?: Date;
    assignedTo?: string;
    description?: string;
    stage?: string;
}

/**
 * BCFTopics manages Building Collaboration Format (BCF) data the engine. It provides functionality for importing, exporting, and manipulating BCF data. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/BCFTopics). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/BCFTopics).
 */
export declare class BCFTopics extends Component implements Disposable_2, Configurable<BCFTopicsConfigManager, BCFTopicsConfig> {
    static uuid: "de977976-e4f6-4e4f-a01a-204727839802";
    enabled: boolean;
    static xmlParser: XMLParser;
    protected _defaultConfig: Required<BCFTopicsConfig>;
    config: BCFTopicsConfigManager;
    readonly list: DataMap_2<string, Topic>;
    readonly documents: DataMap_2<string, InternalDocumentReference | ExternalDocumentReference>;
    readonly onSetup: Event_2<unknown>;
    isSetup: boolean;
    setup(config?: Partial<BCFTopicsConfig>): void;
    readonly onBCFImported: Event_2<Topic[]>;
    /**
     * Creates a new BCFTopic instance and adds it to the list.
     *
     * @param data - Optional partial BCFTopic object to initialize the new topic with.
     * If not provided, default values will be used.
     * @returns The newly created BCFTopic instance.
     */
    create(data?: Partial<BCFTopic>): Topic;
    readonly onDisposed: Event_2<unknown>;
    /**
     * Disposes of the BCFTopics component and triggers the onDisposed event.
     *
     * @remarks
     * This method clears the list of topics and triggers the onDisposed event.
     * It also resets the onDisposed event listener.
     */
    dispose(): void;
    /**
     * Retrieves the unique set of topic types used across all topics.
     *
     * @returns A Set containing the unique topic types.
     */
    get usedTypes(): Set<string>;
    /**
     * Retrieves the unique set of topic statuses used across all topics.
     *
     * @returns A Set containing the unique topic statuses.
     */
    get usedStatuses(): Set<string>;
    /**
     * Retrieves the unique set of topic priorities used across all topics.
     *
     * @returns A Set containing the unique topic priorities.
     * Note: This method filters out any null or undefined priorities.
     */
    get usedPriorities(): Set<string | undefined>;
    /**
     * Retrieves the unique set of topic stages used across all topics.
     *
     * @returns A Set containing the unique topic stages.
     * Note: This method filters out any null or undefined stages.
     */
    get usedStages(): Set<string | undefined>;
    /**
     * Retrieves the unique set of users associated with topics.
     *
     * @returns A Set containing the unique users.
     * Note: This method collects users from the creation author, assigned to, modified author, and comment authors.
     */
    get usedUsers(): Set<string>;
    /**
     * Retrieves the unique set of labels used across all topics.
     *
     * @returns A Set containing the unique labels.
     */
    get usedLabels(): Set<string>;
    /**
     * Updates the set of extensions (types, statuses, priorities, labels, stages, users) based on the current topics.
     * This method iterates through each topic in the list and adds its properties to the corresponding sets in the config.
     */
    updateExtensions(): void;
    /**
     * Updates the references to viewpoints in the topics.
     * This function iterates through each topic and checks if the viewpoints exist in the viewpoints list.
     * If a viewpoint does not exist, it is removed from the topic's viewpoints.
     */
    updateViewpointReferences(): void;
    /**
     * Exports the given topics to a BCF (Building Collaboration Format) zip file.
     *
     * @param topics - The topics to export. Defaults to all topics in the list.
     * @returns A promise that resolves to a Blob containing the exported BCF zip file.
     */
    export(topics?: Iterable<Topic>): Promise<Blob>;
    private serializeExtensions;
    private processMarkupComment;
    private getMarkupComments;
    private getMarkupLabels;
    private getMarkupViewpoints;
    private getMarkupRelatedTopics;
    private getMarkupDocumentReferences;
    /**
     * Loads BCF (Building Collaboration Format) data into the engine.
     *
     * @param world - The default world where the viewpoints are going to be created.
     * @param data - The BCF data to load.
     *
     * @returns A promise that resolves to an object containing the created viewpoints and topics.
     *
     * @throws An error if the BCF version is not supported.
     */
    load(data: Uint8Array): Promise<{
        viewpoints: Viewpoint[];
        topics: Topic[];
    }>;
}

/**
 * Configuration settings for managing BCF topics. This interface defines the properties and their meanings used to control the behavior of exporting and importing BCF topics.
 */
export declare interface BCFTopicsConfig {
    /**
     * The BCF version used during export.
     */
    version: BCFVersion;
    /**
     * The email of the user creating topics using this component.
     */
    author: string;
    /**
     * The set of allowed topic types. This is exported inside the
     * [bcf.extensions](https://github.com/buildingSMART/BCF-XML/tree/release_3_0/Documentation#bcf-file-structure).
     */
    types: Set<string>;
    /**
     * The set of allowed topic statuses. This is exported inside the
     * [bcf.extensions](https://github.com/buildingSMART/BCF-XML/tree/release_3_0/Documentation#bcf-file-structure).
     */
    statuses: Set<string>;
    /**
     * The set of allowed topic priorities. This is exported inside the
     * [bcf.extensions](https://github.com/buildingSMART/BCF-XML/tree/release_3_0/Documentation#bcf-file-structure).
     */
    priorities: Set<string>;
    /**
     * The set of allowed topic labels. This is exported inside the
     * [bcf.extensions](https://github.com/buildingSMART/BCF-XML/tree/release_3_0/Documentation#bcf-file-structure).
     */
    labels: Set<string>;
    /**
     * The set of allowed topic stages. This is exported inside the
     * [bcf.extensions](https://github.com/buildingSMART/BCF-XML/tree/release_3_0/Documentation#bcf-file-structure).
     */
    stages: Set<string>;
    /**
     * The set of allowed topic users. This is exported inside the
     * [bcf.extensions](https://github.com/buildingSMART/BCF-XML/tree/release_3_0/Documentation#bcf-file-structure).
     */
    users: Set<string>;
    /**
     * Whether or not to include the AuthoringSoftwareId in the viewpoint components during export.
     */
    includeSelectionTag: boolean;
    /**
     * Updates the types, statuses, users, etc., after importing an external BCF.
     */
    updateExtensionsOnImport: boolean;
    /**
     * Only allow to use the extensions (types, statuses, etc.) defined in the config when setting the corresponding data in a topic.
     */
    strict: boolean;
    /**
     * If true, export the extensions (types, status, etc.) based on topics data. This doesn't update the extensions in the config.
     * If false, only export the extensions defined in each collection of possibilities set in the config.
     * In all cases, all the values from each collection of extensions defined in the config are going to be exported.
     */
    includeAllExtensionsOnExport: boolean;
    /**
     * Version to be used when importing if no bcf.version file is present in the incoming data.
     * When null, the importer will throw an error if the version is missing or is not supported.
     */
    fallbackVersionOnImport: BCFVersion | null;
    /**
     * If true, do not import a topic with missing information (guid, type, status, title, creationDate or creationAuthor).
     * If false, use default values for missing data.
     */
    ignoreIncompleteTopicsOnImport: boolean;
    exportCustomDataAsLabels: boolean;
}

export declare class BCFTopicsConfigManager extends Configurator<BCFTopics, BCFTopicsConfigType> {
    protected _config: BCFTopicsConfigType;
    get version(): string;
    set version(value: string);
    get author(): string;
    set author(value: string);
    get types(): Set<string>;
    set types(value: Set<string>);
    get statuses(): Set<string>;
    set statuses(value: Set<string>);
    get priorities(): Set<string>;
    set priorities(value: Set<string>);
    get labels(): Set<string>;
    set labels(value: Set<string>);
    get stages(): Set<string>;
    set stages(value: Set<string>);
    get users(): Set<string>;
    set users(value: Set<string>);
    get includeSelectionTag(): boolean;
    set includeSelectionTag(value: boolean);
    get updateExtensionsOnImport(): boolean;
    set updateExtensionsOnImport(value: boolean);
    get strict(): boolean;
    set strict(value: boolean);
    get includeAllExtensionsOnExport(): boolean;
    set includeAllExtensionsOnExport(value: boolean);
    get fallbackVersionOnImport(): string;
    set fallbackVersionOnImport(value: string);
    get ignoreIncompleteTopicsOnImport(): boolean;
    set ignoreIncompleteTopicsOnImport(value: boolean);
    get exportCustomDataAsLabels(): boolean;
    set exportCustomDataAsLabels(value: boolean);
}

declare type BCFTopicsConfigType = {
    version: SelectSettingControl;
    author: TextSettingsControl;
    types: TextSetSettingControl;
    statuses: TextSetSettingControl;
    priorities: TextSetSettingControl;
    labels: TextSetSettingControl;
    stages: TextSetSettingControl;
    users: TextSetSettingControl;
    includeSelectionTag: BooleanSettingsControl;
    updateExtensionsOnImport: BooleanSettingsControl;
    strict: BooleanSettingsControl;
    includeAllExtensionsOnExport: BooleanSettingsControl;
    fallbackVersionOnImport: SelectSettingControl;
    ignoreIncompleteTopicsOnImport: BooleanSettingsControl;
    exportCustomDataAsLabels: BooleanSettingsControl;
};

export declare type BCFVersion = "2.1" | "3";

/**
 * Represents a Building Collaboration Format (BCF) viewpoint. This interface is compliant with the BCF API specifications.
 */
export declare interface BCFViewpoint {
    /**
     * Optional title of the viewpoint.
     */
    title?: string;
    /**
     * Optional index of the viewpoint.
     */
    index?: number;
    /**
     * Unique identifier for the viewpoint.
     */
    guid: string;
    /**
     * Optional perspective camera settings for the viewpoint.
     */
    perspective_camera?: ViewpointPerspectiveCamera;
    /**
     * Optional orthogonal camera settings for the viewpoint.
     */
    orthogonal_camera?: ViewpointOrthogonalCamera;
    /**
     * Optional components associated with the viewpoint.
     */
    components?: ViewpointComponents;
    /**
     * Optional snapshot image of the viewpoint.
     */
    snapshot?: ViewpointSnapshot;
    /**
     * Optional array of lines associated with the viewpoint.
     */
    lines?: ViewpointLine[];
    /**
     * Optional array of clipping planes associated with the viewpoint.
     */
    clipping_planes?: ViewpointClippingPlane[];
    /**
     * Optional array of bitmaps associated with the viewpoint.
     */
    bitmaps?: ViewpointBitmap[];
}

export declare interface BooleanSettingsControl {
    type: "Boolean";
    value: boolean;
}

/**
 * An implementation of bounding box utilities that works for fragments. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/BoundingBoxer). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/BoundingBoxer).
 */
export declare class BoundingBoxer extends Component implements Disposable_2 {
    static readonly uuid: "d1444724-dba6-4cdd-a0c7-68ee1450d166";
    /** {@link Component.enabled} */
    enabled: boolean;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /**
     * A readonly dataset containing instances of THREE.Box3.
     */
    readonly list: FRAGS.DataSet<THREE.Box3>;
    constructor(components: Components);
    /** {@link Disposable.dispose} */
    dispose(full?: boolean): void;
    /**
     * Combines all bounding boxes in the `list` property into a single bounding box.
     *
     * @returns A `THREE.Box3` instance representing the union of all bounding boxes in the `list`.
     */
    get(): THREE.Box3;
    /**
     * Asynchronously adds bounding boxes to the list by merging boxes from models
     * specified in the provided `ModelIdMap`.
     *
     * @param items - A map where keys are model IDs and values are arrays of local IDs
     *                representing specific parts of the models to include in the bounding box.
     */
    addFromModelIdMap(items: ModelIdMap): Promise<void>;
    /**
     * Adds bounding boxes from models to the current list based on optional filtering criteria.
     *
     * @param modelIds - An optional array of regular expressions used to filter models by their IDs.
     *                   If provided, only models whose IDs match at least one of the regular expressions
     *                   will have their bounding boxes added to the list. If not, all models will be used.
     */
    addFromModels(modelIds?: RegExp[]): void;
    /**
     * Calculates and returns the center point of the bounding box derived from the provided model ID map.
     *
     * @param modelIdMap - A mapping of model IDs and localIds used to generate the bounding box.
     * @returns A `THREE.Vector3` object representing the center point of the bounding box.
     */
    getCenter(modelIdMap: ModelIdMap): Promise<THREE.Vector3>;
    /**
     * Calculates the camera orientation and position based on the specified orientation
     * and an optional offset factor.
     *
     * @param orientation - Specifies the direction of the camera relative to the bounding box.
     * @param offsetFactor - A multiplier applied to the distance between the camera and the bounding box.
     *                       Defaults to `1`.
     * @returns An object containing:
     *          - `position`: A `THREE.Vector3` representing the calculated camera position.
     *          - `target`: A `THREE.Vector3` representing the center of the bounding box, which the camera should target.
     */
    getCameraOrientation(orientation: "front" | "back" | "left" | "right" | "top" | "bottom", offsetFactor?: number): Promise<{
        position: THREE.Vector3;
        target: THREE.Vector3;
    }>;
}

/**
 * Whether a camera uses the Camera Controls library.
 */
export declare interface CameraControllable {
    /**
     * An instance of CameraControls that provides camera control functionalities.
     * This instance is used to manipulate the camera.
     */
    controls: CameraControls;
}

/**
 * The projection system of the camera.
 */
export declare type CameraProjection = "Perspective" | "Orthographic";

/**
 * Represents the data structure for a classification group.
 */
export declare interface ClassificationGroupData {
    /**
     * The ModelIdMap that represents the static collection of items within the group.
     */
    map: ModelIdMap;
    /**
     * Optional query used to dynamically find items using the ItemsFinder. Some groups may only rely on static items.
     */
    query?: ClassificationGroupQuery;
    /**
     * Asynchronously retrieves the combined map of static and dynamically found items.
     */
    get(): Promise<ModelIdMap>;
}

/**
 * Represents a query for a classification group.
 */
export declare interface ClassificationGroupQuery {
    /**
     * The name of the query from the finder to use in the group.
     */
    name: string;
    /**
     * Optional configuration for the query.
     */
    config?: QueryTestConfig;
}

/**
 * The Classifier component is responsible for grouping items from different models based on criteria. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/Classifier). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/Classifier).
 */
export declare class Classifier extends Component implements Disposable_2 {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7";
    /** {@link Component.enabled} */
    enabled: boolean;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /**
     * A nested data map that organizes classification groups.
     * The outer map uses strings as keys, and the inner map contains ClassificationGroupData, also keyed by strings.
     */
    readonly list: FRAGS.DataMap<string, FRAGS.DataMap<string, ClassificationGroupData>>;
    constructor(components: Components);
    private setupEvents;
    private getClassificationGroups;
    private getModelItems;
    /**
     * Retrieves data associated with a specific group within a classification.
     * If the group data does not exist, it creates a new entry.
     *
     * @param classification - The classification string.
     * @param group - The group string within the classification.
     * @returns The data object associated with the group, containing a map and a `get` method.
     */
    getGroupData(classification: string, group: string): ClassificationGroupData;
    /**
     * The default save function used by the classifier.
     * It extracts the 'value' property from the item's Name and returns it as a string.
     * If the 'value' property does not exist, it returns null.
     *
     * @param item - The item data to extract the value from.
     * @returns The extracted value as a string, or null if the value does not exist.
     */
    defaultSaveFunction: (item: FRAGS.ItemData) => string | null;
    /**
     * Aggregates items based on a classification and query, applying a provided function to each item.
     *
     * @param classification - The classification string used to categorize the items.
     * @param query - The query parameters used to find items.
     * @param config - Optional configuration for data and item processing.
     * @param config.data - Optional data configuration to pass to the item retrieval.
     * @param config.aggregationCallback - Optional function to apply to each item; defaults to `this.defaultSaveFunction` if not provided.
     *                       This function receives the item data and a register function to associate item local IDs with names.
     *                       If no function is provided, the default save function is used.
     *
     * @remarks
     * The `register` function within the `config.func` allows associating item local IDs with a given name under the specified classification.
     * It is used to keep track of which items belong to which classification.
     */
    aggregateItems(classification: string, query: FRAGS.ItemsQueryParams, config?: {
        modelIds?: RegExp[];
        data?: Partial<FRAGS.ItemsDataConfig>;
        aggregationCallback?: (item: FRAGS.ItemData, register: (name: string, ...localIds: number[]) => void) => void;
    }): Promise<void>;
    /**
     * Adds items to a specific group within a classification.
     *
     * @param classification - The classification to which the group belongs.
     * @param group - The group to which the items will be added.
     * @param items - A map of model IDs to add to the group.
     */
    addGroupItems(classification: string, group: string, items: ModelIdMap): void;
    /**
     * Sets the query for a specific group within a classification.
     *
     * @param classification - The classification to target.
     * @param group - The group within the classification to target.
     * @param query - The query to set for the group.
     */
    setGroupQuery(classification: string, group: string, query: ClassificationGroupQuery): void;
    /**
     * Asynchronously finds a set of ModelIdMaps based on the provided classification data.
     * @param data An object with classifications as keys and an array of groups as values.
     * @returns A promise that resolves to a ModelIdMap representing the intersection of all ModelIdMaps found.
     */
    find(data: ClassifierIntersectionInput): Promise<ModelIdMap>;
    /**
     * From the items passing the query, use the specified relation to create groupings
     * This method retrieves and processes related items, applying a custom aggregation callback to register
     * relations between items based on their attributes and local IDs.
     *
     * @param classification - The classification type used to filter items.
     * @param query - Query parameters for filtering items, defined by `FRAGS.ItemsQueryParams`.
     * @param relation - The type of relation to aggregate (e.g., "ContainedInStructure", "HasAssociations").
     * @param config - Optional configuration for the aggregation process.
     * @returns A promise that resolves when the aggregation process is complete.
     * @remarks
     * - The `aggregationCallback` function processes each item and registers relations based on the item's
     *   attribute value and the local ID of its relations.
     * - Items without the specified attribute or relations are ignored during aggregation.
     */
    aggregateItemRelations(classification: string, query: FRAGS.ItemsQueryParams, relation: string, config?: ClassifyItemRelationsConfig): Promise<void>;
    /**
     * Asynchronously processes and adds classifications by IfcBuildingStorey.
     * @param config - Optional configuration for adding classifications.
     * @returns A promise that resolves once the storeys have been processed and added.
     */
    byIfcBuildingStorey(config?: AddClassificationConfig): Promise<void>;
    /**
     * Asynchronously processes and adds classifications by category.
     * @param config - Optional configuration for adding classifications.
     * @returns A promise that resolves once the categories have been processed and added.
     */
    byCategory(config?: AddClassificationConfig): Promise<void>;
    private onBeforeFragmentsDispose;
    /** {@link Disposable.dispose} */
    dispose(): void;
    /**
     * Removes items from the classifier based on the provided model ID map and configuration.
     *
     * @param modelIdMap - A map containing model IDs to be removed.
     * @param config - Optional configuration for removing items.s.
     * @remarks If no configuration is provided, items will be removed from all classifications
     */
    removeItems(modelIdMap: ModelIdMap, config?: RemoveClassifierItemsConfig): void;
    /**
     * Asynchronously processes models based on the provided configuration and updates classification groups.
     *
     * @param config - Optional configuration for adding classifications. Contains the following properties.
     * @returns A promise that resolves when the processing is complete.
     */
    byModel(config?: AddClassificationConfig): Promise<void>;
}

/**
 * Represents the input structure for a classifier intersection operation. Defines a record where the keys are classification names and the values are arrays of group names within those classifications.
 */
export declare type ClassifierIntersectionInput = Record<string, string[]>;

/**
 * Configuration interface for classifying item by relation values.
 */
export declare interface ClassifyItemRelationsConfig {
    /**
     * The attribute whose value will be used to create the group.
     */
    attribute?: string;
    /**
     * An array of regular expressions representing model IDs to be used in the aggregation process.
     */
    modelIds?: RegExp[];
}

/**
 * A lightweight component to easily create, delete and handle [clipping planes](https://threejs.org/docs/#api/en/materials/Material.clippingPlanes). ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/Clipper). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/Clipper).
 */
export declare class Clipper extends Component implements Createable, Disposable_2, Hideable, Configurable<ClipperConfigManager, ClipperConfig> {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "66290bc5-18c4-4cd1-9379-2e17a0617611";
    /** {@link Configurable.onSetup} */
    readonly onSetup: Event_2<unknown>;
    /** Event that fires when the user starts dragging a clipping plane. */
    readonly onBeforeDrag: Event_2<void>;
    /** Event that fires when the user stops dragging a clipping plane. */
    readonly onAfterDrag: Event_2<void>;
    /**
     * Event that fires when the user starts creating a clipping plane.
     */
    readonly onBeforeCreate: Event_2<unknown>;
    /**
     * Event that fires when the user cancels the creation of a clipping plane.
     */
    readonly onBeforeCancel: Event_2<unknown>;
    /**
     * Event that fires after the user cancels the creation of a clipping plane.
     */
    readonly onAfterCancel: Event_2<unknown>;
    /**
     * Event that fires when the user starts deleting a clipping plane.
     */
    readonly onBeforeDelete: Event_2<unknown>;
    /**
     * Event that fires after a clipping plane has been created.
     * @param plane - The newly created clipping plane.
     */
    readonly onAfterCreate: Event_2<SimplePlane>;
    /**
     * Event that fires after a clipping plane has been deleted.
     * @param plane - The deleted clipping plane.
     */
    readonly onAfterDelete: Event_2<SimplePlane>;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<string>;
    /** {@link Configurable.isSetup} */
    isSetup: boolean;
    /**
     * Whether to force the clipping plane to be orthogonal in the Y direction
     * (up). This is desirable when clipping a building horizontally and a
     * clipping plane is created in its roof, which might have a slight
     * slope for draining purposes.
     */
    orthogonalY: boolean;
    /**
     * The tolerance that determines whether an almost-horizontal clipping plane
     * will be forced to be orthogonal to the Y direction. {@link orthogonalY}
     * has to be `true` for this to apply.
     */
    toleranceOrthogonalY: number;
    /**
     * The type of clipping plane to be created.
     * Default is {@link SimplePlane}.
     */
    Type: new (...args: any) => SimplePlane;
    /**
     * A list of all the clipping planes created by this component.
     */
    readonly list: FRAGS.DataMap<string, SimplePlane>;
    /** {@link Configurable.config} */
    config: ClipperConfigManager;
    protected _defaultConfig: ClipperConfig;
    /** The material used in all the clipping planes. */
    private _material;
    private _size;
    private _enabled;
    private _visible;
    readonly onStateChanged: Event_2<("material" | "enabled" | "size" | "visibility")[]>;
    /** {@link Component.enabled} */
    get enabled(): boolean;
    /** {@link Component.enabled} */
    set enabled(state: boolean);
    /** {@link Hideable.visible } */
    get visible(): boolean;
    /** {@link Hideable.visible } */
    set visible(state: boolean);
    /** The material of the clipping plane representation. */
    get material(): THREE.MeshBasicMaterial;
    /** The material of the clipping plane representation. */
    set material(material: THREE.MeshBasicMaterial);
    /** The size of the geometric representation of the clippings planes. */
    get size(): number;
    /** The size of the geometric representation of the clippings planes. */
    set size(size: number);
    constructor(components: Components);
    private setEvents;
    /** {@link Disposable.dispose} */
    dispose(): void;
    /** {@link Createable.create} */
    create(world: World): Promise<SimplePlane | null>;
    /**
     * Creates a plane in a certain place and with a certain orientation,
     * without the need of the mouse.
     *
     * @param world - the world where this plane should be created.
     * @param normal - the orientation of the clipping plane.
     * @param point - the position of the clipping plane.
     * navigation.
     */
    createFromNormalAndCoplanarPoint(world: World, normal: THREE.Vector3, point: THREE.Vector3): string;
    /**
     * {@link Createable.delete}
     *
     * @param world - the world where the plane to delete is.
     * @param planeId - the plane to delete. If undefined, the first plane
     * found under the cursor will be deleted.
     */
    delete(world: World, planeId?: string): Promise<void>;
    /**
     * Deletes all the existing clipping planes.
     *
     * @param types - the types of planes to be deleted. If not provided, all planes will be deleted.
     */
    deleteAll(types?: Set<string>): void;
    /** {@link Configurable.setup} */
    setup(config?: Partial<ClipperConfig>): void;
    private pickPlane;
    private getAllPlaneMeshes;
    private createPlaneFromIntersection;
    private getWorldNormal;
    private normalizePlaneDirectionY;
    private newPlane;
    private updateMaterialsAndPlanes;
    private _onStartDragging;
    private _onEndDragging;
}

/**
 * Configuration interface for the {@link Clipper}.
 */
declare interface ClipperConfig {
    color: THREE.Color;
    opacity: number;
    size: number;
}

declare class ClipperConfigManager extends Configurator<Clipper, ClipperConfigType> {
    protected _config: ClipperConfigType;
    get enabled(): boolean;
    set enabled(value: boolean);
    get visible(): boolean;
    set visible(value: boolean);
    get color(): THREE.Color;
    set color(value: THREE.Color);
    get opacity(): number;
    set opacity(value: number);
    get size(): number;
    set size(value: number);
}

declare type ClipperConfigType = {
    enabled: BooleanSettingsControl;
    visible: BooleanSettingsControl;
    color: ColorSettingsControl;
    opacity: NumberSettingControl;
    size: NumberSettingControl;
};

export declare interface ColorSettingsControl {
    type: "Color";
    value: THREE.Color;
}

/**
 * Represents a comment in a BCF Topic.
 */
declare class Comment_2 {
    date: Date;
    author: string;
    guid: string;
    viewpoint?: string;
    modifiedAuthor?: string;
    modifiedDate?: Date;
    topic?: Topic;
    private _components;
    private _comment;
    /**
     * Sets the comment text and updates the modified date and author.
     * The author will be the one defined in BCFTopics.config.author
     * @param value - The new comment text.
     */
    set comment(value: string);
    /**
     * Gets the comment text.
     * @returns The comment text.
     */
    get comment(): string;
    /**
     * Constructs a new BCF Topic Comment instance.
     * @param components - The Components instance.
     * @param text - The initial comment text.
     */
    constructor(components: Components, text: string);
    toJSON(): BCFApiComment;
}
export { Comment_2 as Comment }

/**
 * Components are the building blocks of this library. Components are singleton elements that contain specific functionality. For instance, the Clipper Component can create, delete and handle 3D clipping planes. Components must be unique (they can't be instanced more than once per Components instance), and have a static UUID that identifies them uniquely. The can be accessed globally using the {@link Components} instance.
 */
export declare abstract class Component extends Base {
    /**
     * Whether this component is active or not. The behaviour can vary depending
     * on the type of component. E.g. a disabled dimension tool will stop creating
     * dimensions, while a disabled camera will stop moving. A disabled component
     * will not be updated automatically each frame.
     */
    abstract enabled: boolean;
}

/**
 * The entry point of the Components library. It can create, delete and access all the components of the library globally, update all the updatable components automatically and dispose all the components, preventing memory leaks.
 */
export declare class Components implements Disposable_2 {
    /**
     * The version of the @thatopen/components library.
     */
    static readonly release = "2.4.3";
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<void>;
    /**
     * The list of components created in this app.
     * The keys are UUIDs and the values are instances of the components.
     */
    readonly list: DataMap_2<string, Component>;
    /**
     * If disabled, the animation loop will be stopped.
     * Default value is false.
     */
    enabled: boolean;
    private _clock;
    /**
     * Event that triggers the Components instance is initialized.
     *
     * @remarks
     * This event is triggered once when the {@link Components.init} method has been called and finish processing.
     * This is useful to set configuration placeholders that need to be executed when the components instance is initialized.
     * For example, enabling and configuring custom effects in a post-production renderer.
     *
     * @example
     * ```typescript
     * const components = new Components();
     * components.onInit.add(() => {
     *   // Enable custom effects in the post-production renderer
     *   // or any other operation dependant on the component initialization
     * });
     * components.init();
     * ```
     */
    readonly onInit: Event_2<undefined>;
    /**
     * Adds a component to the list of components.
     * Throws an error if a component with the same UUID already exists.
     *
     * @param uuid - The unique identifier of the component.
     * @param instance - The instance of the component to be added.
     *
     * @throws Will throw an error if a component with the same UUID already exists.
     */
    add(uuid: string, instance: Component): void;
    /**
     * Retrieves a component instance by its constructor function.
     * If the component does not exist in the list, it will be created and added.
     *
     * @template U - The type of the component to retrieve.
     * @param Component - The constructor function of the component to retrieve.
     *
     * @returns The instance of the requested component.
     *
     * @throws Will throw an error if a component with the same UUID already exists.
     */
    get<U extends Component>(Component: new (components: Components) => U): U;
    constructor();
    /**
     * Initializes the Components instance.
     * This method starts the animation loop, sets the enabled flag to true,
     * and calls the update method.
     */
    init(): void;
    /**
     * Disposes the memory of all the components and tools of this instance of
     * the library. A memory leak will be created if:
     *
     * - An instance of the library ends up out of scope and this function isn't
     * called. This is especially relevant in Single Page Applications (React,
     * Angular, Vue, etc).
     *
     * - Any of the objects of this instance (meshes, geometries,materials, etc) is
     * referenced by a reference type (object or array).
     *
     * You can learn more about how Three.js handles memory leaks
     * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
     *
     */
    dispose(): void;
    private update;
    private static setupBVH;
}

/**
 * A tool to manage all the configuration from the app centrally. ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/ConfigManager).
 */
export declare class ConfigManager extends Component {
    /**
     * The list of all configurations of this app.
     */
    list: DataMap_2<string, Configurator<any, any>>;
    /** {@link Component.enabled} */
    enabled: boolean;
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "b8c764e0-6b24-4e77-9a32-35fa728ee5b4";
    constructor(components: Components);
}

/**
 * Whether this component supports to be configured.
 */
export declare interface Configurable<T, U> {
    /** Wether this components has been already configured. */
    isSetup: boolean;
    /** Use the provided configuration to set up the tool. */
    setup: (config?: Partial<U>) => void | Promise<void>;
    /** Fired after successfully calling {@link Configurable.setup()}  */
    readonly onSetup: Event_2<any>;
    /** Object holding the tool configuration. You can edit this directly to change the object.
     */
    config: Required<T>;
}

export declare abstract class Configurator<T = any, U extends ControlsSchema = ControlsSchema> {
    protected abstract _config: U;
    protected _component: T;
    name: string;
    uuid: string;
    get controls(): U;
    constructor(component: T, components: Components, name: string, uuid?: string);
    set(data: Partial<U>): void;
    export(controls?: ControlsSchema, exported?: any): any;
    import(exported: any, imported?: any, first?: boolean): void;
}

export declare type ControlEntry = BooleanSettingsControl | ColorSettingsControl | TextSettingsControl | NumberSettingControl | SelectSettingControl | Vector3SettingControl | TextSetSettingControl | NoControl;

export declare interface ControlsSchema {
    [name: string]: ControlEntry | ControlsSchema;
}

export declare class ControlsUtils {
    static isEntry(item: any): boolean;
    static copySchema<T extends ControlsSchema = ControlsSchema>(schema: T, copy?: ControlsSchema): T;
    static copyEntry(controlEntry: ControlEntry): ControlEntry;
}

/**
 * Whether this component supports create and destroy operations. This generally applies for components that work with instances, such as clipping planes or dimensions.
 */
export declare interface Createable {
    /** Creates a new instance of an element (e.g. a new Dimension). */
    create: (data: any) => void;
    /**
     * Finish the creation process of the component, successfully creating an
     * instance of whatever the component creates.
     */
    endCreation?: (data: any) => void;
    /**
     * Cancels the creation process of the component, going back to the state
     * before starting to create.
     */
    cancelCreation?: (data: any) => void;
    /** Deletes an existing instance of an element (e.g. a Dimension). */
    delete: (data: any) => void;
}

/**
 * Configuration options for creating views from bounding boxes.
 */
export declare interface CreateElevationViewsConfig {
    /**
     * Determines whether to combine all models into a single bounding box. If `true`, a single bounding box will be created from all models. If `false`, each model will be treated separately. Defaults to `false`.
     */
    combine?: boolean;
    /**
     * An optional array of regular expressions to match model IDs. If not provided, all models will be used.
     */
    modelIds?: RegExp[];
    /**
     * Optional world instance to use when creating the view. If not set, the component's default world will be used.
     */
    world?: World;
    /**
     * A callback function to generate names for the views based on the model ID. Defaults to a function that generates names in the format: `<modelId>: Front`, `<modelId>: Back`, `<modelId>: Left`, `<modelId>: Right`.
     */
    namingCallback?: (modelId: string) => {
        front: string;
        back: string;
        left: string;
        right: string;
    };
}

/**
 * Configuration options for creating views from a plane.
 */
export declare interface CreateViewConfig {
    /**
     * Optional identifier for the view. If not provided, a random ID will be generated.
     */
    id?: string;
    /**
     * Optional world instance to use when creating the view. If not set, the component's default world will be used.
     */
    world?: World;
}

/**
 * Configuration options for creating a view from IFC storeys.
 */
export declare interface CreateViewFromIfcStoreysConfig {
    /**
     * An optional array of regular expressions to match model IDs. If not provided, all models will be used.
     */
    modelIds?: RegExp[];
    /**
     * An optional array of regular expressions to match storey names. If not provided, all storeys will be used.
     */
    storeyNames?: RegExp[];
    /**
     * An optional offset value to displace the storey plane upward. Defaults to `0.25`.
     */
    offset?: number;
    /**
     * Optional world instance to use when creating the view. If not set, the component's default world will be used.
     */
    world?: World;
}

/**
 * A class that extends the built-in Map class and provides additional events for item set, update, delete, and clear operations.
 *
 * @template K - The type of keys in the map.
 * @template V - The type of values in the map.
 */
export declare class DataMap<K, V> extends Map<K, V> {
    /**
     * An event triggered when a new item is set in the map.
     */
    readonly onItemSet: Event_2<{
        key: K;
        value: V;
    }>;
    /**
     * An event triggered when an existing item in the map is updated.
     */
    readonly onItemUpdated: Event_2<{
        key: K;
        value: V;
    }>;
    /**
     * An event triggered when an item is deleted from the map.
     */
    readonly onItemDeleted: Event_2<K>;
    /**
     * An event triggered when the map is cleared.
     */
    readonly onCleared: Event_2<unknown>;
    /**
     * Constructs a new DataMap instance.
     *
     * @param iterable - An iterable object containing key-value pairs to populate the map.
     */
    constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);
    /**
     * Clears the map and triggers the onCleared event.
     */
    clear(): void;
    /**
     * Sets the value for the specified key in the map.
     * If the item is new, then onItemSet is triggered.
     * If the item is already in the map, then onItemUpdated is triggered.
     *
     * @param key - The key of the item to set.
     * @param value - The value of the item to set.
     * @returns The DataMap instance.
     */
    set(key: K, value: V): this;
    /**
     * Sets the value in the map with a randomly generated uuidv4 key.
     * Only use this if your keys are strings
     *
     * @param value - The value of the item to set.
     * @returns The key used.
     */
    add(value: V): K;
    /**
     * A function that acts as a guard for adding items to the set.
     * It determines whether a given value should be allowed to be added to the set.
     *
     * @param key - The key of the entry to be checked against the guard.
     * @param value - The value of the entry to be checked against the guard.
     * @returns A boolean indicating whether the value should be allowed to be added to the set.
     *          By default, this function always returns true, allowing all values to be added.
     *          You can override this behavior by providing a custom implementation.
     */
    guard: (key: K, value: V) => boolean;
    /**
     * Deletes the specified key from the map and triggers the onItemDeleted event if the key was found.
     *
     * @param key - The key of the item to delete.
     * @returns True if the key was found and deleted; otherwise, false.
     */
    delete(key: K): boolean;
    /**
     * Clears the map and resets the events.
     */
    dispose(): void;
}

/**
 * A class that extends the built-in Set class and provides additional functionality. It triggers events when items are added, deleted, or the set is cleared.
 *
 * @template T - The type of elements in the set.
 */
export declare class DataSet<T> extends Set<T> {
    /**
     * An event that is triggered when a new item is added to the set.
     */
    readonly onItemAdded: Event_2<T>;
    /**
     * An event that is triggered when an item is deleted from the set.
     */
    readonly onItemDeleted: Event_2<unknown>;
    /**
     * An event that is triggered when the set is cleared.
     */
    readonly onCleared: Event_2<unknown>;
    /**
     * Constructs a new instance of the DataSet class.
     *
     * @param iterable - An optional iterable object to initialize the set with.
     */
    constructor(iterable?: Iterable<T> | null);
    /**
     * Clears the set and triggers the onCleared event.
     */
    clear(): void;
    /**
     * Adds one or multiple values to the set and triggers the onItemAdded event per each.
     *
     * @param value - The value to add to the set.
     * @returns - The set instance.
     */
    add(...value: T[]): this;
    /**
     * A function that acts as a guard for adding items to the set.
     * It determines whether a given value should be allowed to be added to the set.
     *
     * @param value - The value to be checked against the guard.
     * @returns A boolean indicating whether the value should be allowed to be added to the set.
     *          By default, this function always returns true, allowing all values to be added.
     *          You can override this behavior by providing a custom implementation.
     */
    guard: (value: T) => boolean;
    /**
     * Deletes a value from the set and triggers the onItemDeleted event.
     *
     * @param value - The value to delete from the set.
     * @returns - True if the value was successfully deleted, false otherwise.
     */
    delete(value: T): boolean;
    /**
     * Clears the set and resets the onItemAdded, onItemDeleted, and onCleared events.
     */
    dispose(): void;
}

declare class DirectionalLightConfig {
    private _list;
    private _scene;
    constructor(list: SimpleSceneConfigType, scene: SimpleScene);
    get color(): THREE.Color;
    set color(value: THREE.Color);
    get intensity(): number;
    set intensity(value: number);
    get position(): THREE.Vector3;
    set position(value: THREE.Vector3);
}

/**
 * Whether this component has to be manually destroyed once you are done with it to prevent [memory leaks](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects). This also ensures that the DOM events created by that component will be cleaned up.
 */
declare interface Disposable_2 {
    /**
     * Destroys the object from memory to prevent a
     * [memory leak](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
     */
    dispose: () => void | Promise<void>;
    /** Fired after the tool has been disposed.  */
    readonly onDisposed: Event_2<any>;
}
export { Disposable_2 as Disposable }

/**
 * A tool to safely remove meshes, geometries, materials and other items from memory to [prevent memory leaks](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/Disposer).
 */
export declare class Disposer extends Component {
    private _disposedComponents;
    /** {@link Component.enabled} */
    enabled: boolean;
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe";
    constructor(components: Components);
    /**
     * Return the UUIDs of all disposed components.
     */
    get(): Set<string>;
    /**
     * Removes a mesh, its geometry and its materials from memory. If you are
     * using any of these in other parts of the application, make sure that you
     * remove them from the mesh before disposing it.
     *
     * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
     * to remove.
     *
     * @param materials - whether to dispose the materials of the mesh.
     *
     * @param recursive - whether to recursively dispose the children of the mesh.
     */
    destroy(object: THREE.Object3D, materials?: boolean, recursive?: boolean): void;
    /**
     * Disposes a geometry from memory.
     *
     * @param geometry - the
     * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
     * to remove.
     */
    disposeGeometry(geometry: THREE.BufferGeometry): void;
    private disposeGeometryAndMaterials;
    private disposeChildren;
    private static disposeMaterial;
}

/**
 * A base renderer to determine visibility on screen.
 */
declare class DistanceRenderer {
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<string>;
    /**
     * Fires after making the visibility check to the meshes. It lists the
     * meshes that are currently visible, and the ones that were visible
     * just before but not anymore.
     */
    readonly onDistanceComputed: Event_2<number>;
    /**
     * Objects that won't be taken into account in the distance check.
     */
    excludedObjects: Set<THREE.Object3D<THREE.Object3DEventMap>>;
    /**
     * Whether this renderer is active or not. If not, it won't render anything.
     */
    enabled: boolean;
    /**
     * Render the internal scene used to determine the object visibility. Used
     * for debugging purposes.
     */
    renderDebugFrame: boolean;
    /** The components instance to which this renderer belongs. */
    components: Components;
    /**
     * The scene where the distance is computed.
     */
    scene: THREE.Scene;
    /**
     * The camera used to compute the distance.
     */
    camera: THREE.OrthographicCamera;
    /**
     * The material used to compute the distance.
     */
    depthMaterial: THREE.ShaderMaterial;
    /** The world instance to which this renderer belongs. */
    readonly world: World;
    protected readonly worker: Worker;
    private _width;
    private _height;
    private readonly _postQuad;
    private readonly tempRT;
    private readonly resultRT;
    private readonly bufferSize;
    private readonly _buffer;
    protected _isWorkerBusy: boolean;
    constructor(components: Components, world: World);
    /** {@link Disposable.dispose} */
    dispose(): void;
    /**
     * The function that the culler uses to reprocess the scene. Generally it's
     * better to call needsUpdate, but you can also call this to force it.
     * @param force if true, it will refresh the scene even if needsUpdate is
     * not true.
     */
    compute: () => Promise<void>;
    private handleWorkerMessage;
}

export declare interface DocumentReference {
    type: "internal" | "external";
    description?: string;
}

/**
 * Simple event handler by [Jason Kleban](https://gist.github.com/JasonKleban/50cee44960c225ac1993c922563aa540). Keep in mind that if you want to remove it later, you might want to declare the callback as an object. If you want to maintain the reference to `this`, you will need to declare the callback as an arrow function.
 */
declare class Event_2<T> {
    /**
     * Whether this event is active or not. If not, it won't trigger.
     */
    enabled: boolean;
    /**
     * Add a callback to this event instance.
     * @param handler - the callback to be added to this event.
     */
    add(handler: T extends void ? {
        (): void;
    } : {
        (data: T): void;
    }): void;
    /**
     * Removes a callback from this event instance.
     * @param handler - the callback to be removed from this event.
     */
    remove(handler: T extends void ? {
        (): void;
    } : {
        (data: T): void;
    }): void;
    /** Triggers all the callbacks assigned to this event. */
    trigger: (data?: T) => void;
    /** Gets rid of all the suscribed events. */
    reset(): void;
    private handlers;
}
export { Event_2 as Event }

/**
 * Whether it has events or not.
 */
export declare interface Eventable {
    /**
     * The object in charge of managing all the events.
     */
    eventManager: EventManager;
}

/**
 * Simple class to easily toggle and reset event lists.
 */
export declare class EventManager {
    /**
     * The list of events managed by this instance.
     */
    list: Set<Event_2<any> | AsyncEvent<any>>;
    /**
     * Adds events to this manager.
     * @param events the events to add.
     */
    add(events: Iterable<Event_2<any> | AsyncEvent<any>>): void;
    /**
     * Removes events from this manager.
     * @param events the events to remove.
     */
    remove(events: Iterable<Event_2<any> | AsyncEvent<any>>): void;
    /**
     * Sets all the events managed by this instance as enabled or disabled.
     * @param active whether to turn on or off the events.
     */
    set(active: boolean): void;
    /**
     * Resets all the events managed by this instance.
     */
    reset(): void;
}

export declare const extensionsImporter: (manager: BCFTopics, extensionsXML: string) => void;

export declare interface ExternalDocumentReference extends DocumentReference {
    type: "external";
    url: string;
}

/**
 * A fast model picker that uses color coding to identify fragment models under the mouse cursor.
 * This is much faster than raycasting for simple model identification.
 */
export declare class FastModelPicker implements Disposable_2 {
    /** {@link Component.enabled} */
    enabled: boolean;
    /** The components instance to which this FastModelPicker belongs. */
    components: Components;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /** The position of the mouse in the screen. */
    readonly mouse: Mouse;
    /**
     * A reference to the world instance to which this FastModelPicker belongs.
     * This is used to access the camera and scene.
     */
    world: World;
    /**
     * Whether debug mode is enabled. When enabled, shows the color-coded canvas.
     */
    debugMode: boolean;
    /**
     * Map from color (as RGB number) to model ID.
     * Color is encoded as: (r << 16) | (g << 8) | b
     */
    private colorToModelId;
    /**
     * Map from model ID to color.
     */
    private modelIdToColor;
    /**
     * Render target for the color-coded scene.
     */
    private renderTarget?;
    /**
     * Size of the render target (stored separately since getSize doesn't exist).
     */
    private renderTargetSize;
    /**
     * Debug canvas element (shown when debugMode is true).
     */
    private debugCanvas?;
    /**
     * Debug container element.
     */
    private debugContainer?;
    /**
     * Material used for color-coding models.
     */
    private colorMaterials;
    /**
     * Original materials cache (to restore after picking).
     */
    private originalMaterials;
    private originalLodColors;
    /**
     * Whether colors need to be reassigned (when models change).
     */
    private colorsNeedUpdate;
    constructor(components: Components, world: World);
    /**
     * Sets up listeners for fragment model changes.
     */
    private setupFragmentListeners;
    /**
     * Sets up the render target for color-coded picking.
     */
    private setupRenderTarget;
    /**
     * Sets up the debug canvas for visualization.
     */
    private setupDebugCanvas;
    /**
     * Generates a deterministic color for a model based on its ID.
     * This ensures the same model always gets the same color.
     */
    private generateColorForModel;
    /**
     * Converts a color to a numeric ID.
     */
    private colorToId;
    /**
     * Assigns unique colors to all fragment models.
     * Colors are deterministic based on model ID, so the same model always gets the same color.
     */
    private assignColors;
    /**
     * Applies color materials to fragment models.
     */
    private applyColorMaterials;
    /**
     * Restores original materials to fragment models.
     */
    private restoreOriginalMaterials;
    /**
     * Renders the scene with color-coded models.
     */
    private renderColorCoded;
    /**
     * Updates the debug canvas with the color-coded render.
     */
    private updateDebugCanvas;
    /**
     * Gets the model ID at the given screen position.
     *
     * @param position - Optional screen position. If not provided, uses current mouse position.
     * @returns The model ID at the position, or null if no model is found.
     */
    getModelAt(position?: THREE.Vector2): Promise<string | null>;
    /**
     * Enables or disables debug mode.
     * When enabled, shows a canvas with the color-coded render.
     */
    setDebugMode(enabled: boolean): void;
    /**
     * Removes the debug canvas.
     */
    private removeDebugCanvas;
    /** {@link Disposable.dispose} */
    dispose(): void;
}

/**
 * A component that manages a FastModelPicker for each world and automatically disposes it when its corresponding world is disposed.
 */
export declare class FastModelPickers extends Component implements Disposable_2 {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "4a82430c-7ff2-49ea-9401-60807502dad6";
    /** {@link Component.enabled} */
    enabled: boolean;
    /**
     * A Map that stores FastModelPicker instances for each world.
     * The key is the world's UUID, and the value is the corresponding FastModelPicker instance.
     */
    list: Map<string, FastModelPicker>;
    /** {@link Disposable.onDisposed} */
    onDisposed: Event_2<unknown>;
    constructor(components: Components);
    /**
     * Retrieves a FastModelPicker instance for the given world.
     * If a FastModelPicker instance already exists for the world, it will be returned.
     * Otherwise, a new FastModelPicker instance will be created and added to the list.
     *
     * @param world - The world for which to retrieve or create a FastModelPicker instance.
     * @returns The FastModelPicker instance for the given world.
     */
    get(world: World): FastModelPicker;
    /**
     * Deletes the FastModelPicker instance associated with the given world.
     * If a FastModelPicker instance exists for the given world, it will be disposed and removed from the list.
     *
     * @param world - The world for which to delete the FastModelPicker instance.
     * @returns {void}
     */
    delete(world: World): void;
    /** {@link Disposable.dispose} */
    dispose(): void;
}

/**
 * Represents a finder query for retrieving items based on specified parameters. This class encapsulates the query logic, caching mechanism, and result management.
 */
export declare class FinderQuery {
    name: string;
    customData: Record<string, any>;
    private _components;
    private _queries;
    /**
     * The query parameters used to find items.
     */
    set queries(value: FRAGS.ItemsQueryParams[]);
    get queries(): FRAGS.ItemsQueryParams[];
    private _aggregation;
    /**
     * Sets the aggregation value (AND/OR) for the query and resets the cache if the new value differs.
     */
    set aggregation(value: QueryResultAggregation);
    get aggregation(): QueryResultAggregation;
    /**
     * The result of the query, a map of modelIds to localIds.
     * Null if the query has not been executed or has not been cached.
     */
    readonly result: ModelIdMap | null;
    /**
     * Determines whether the query results should be cached.
     */
    cache: boolean;
    constructor(components: Components, queries: FRAGS.ItemsQueryParams[]);
    /**
     * Executes the finder query to retrieve items based on the configured query and optional model IDs.
     *
     * @param config - Optional configuration object.
     * @param config.modelIds - Optional array of model IDs to filter the search.
     * @param config.force - Optional boolean to force a new search, bypassing the cache. Defaults to `false`.
     * @returns A promise that resolves to a `ModelIdMap` containing the search results.
     */
    test(config?: QueryTestConfig): Promise<ModelIdMap>;
    /**
     * Clears the cached result of the query, forcing a re-evaluation on the next access.
     */
    clearCache(): void;
    private serializeAttributeQuery;
    private serializeQueryParameters;
    /**
     * Serializes the finder query into a JSON-compatible format.
     * Converts regular expressions to strings.
     *
     * @returns A `SerializedFinderQuery` object representing the serialized query.
     */
    toJSON(): SerializedFinderQuery;
    private deserializeAttributeQuery;
    private deserializeQueryParameters;
    /**
     * Deserializes a JSON object into a `FinderQuery` instance.
     *
     * @param data - A `SerializedFinderQuery` object representing the serialized query.
     * @returns A `FinderQuery` instance.
     */
    fromJSON(data: SerializedFinderQuery): this;
}

/**
 * A {@link NavigationMode} that allows first person navigation, simulating FPS video games.
 */
export declare class FirstPersonMode implements NavigationMode {
    private camera;
    /** {@link NavigationMode.enabled} */
    enabled: boolean;
    /** {@link NavigationMode.id} */
    readonly id = "FirstPerson";
    constructor(camera: OrthoPerspectiveCamera);
    /** {@link NavigationMode.set} */
    set(active: boolean): void;
    private setupFirstPersonCamera;
}

/**
 * Component to load, delete and manage [fragments](https://github.com/ThatOpen/engine_fragment) efficiently. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/FragmentsManager). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/FragmentsManager).
 */
export declare class FragmentsManager extends Component implements Disposable_2 {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "fef46874-46a3-461b-8c44-2922ab77c806";
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<undefined>;
    readonly onBeforeDispose: Event_2<undefined>;
    /**
     * Event triggered when fragments are loaded.
     */
    readonly onFragmentsLoaded: Event_2<any>;
    baseCoordinationModel: string;
    baseCoordinationMatrix: THREE.Matrix4;
    /** {@link Component.enabled} */
    enabled: boolean;
    get initialized(): boolean;
    private _core?;
    /**
     * Map containing all loaded fragment models.
     * The key is the group's unique identifier, and the value is the model itself.
     */
    get list(): FRAGS.DataMap<string, FRAGS.FragmentsModel>;
    get core(): FRAGS.FragmentsModels;
    private get _hasCoordinationModel();
    constructor(components: Components);
    /** {@link Disposable.dispose} */
    dispose(): void;
    init(workerURL: string): void;
    raycast(data: {
        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;
        mouse: THREE.Vector2;
        dom: HTMLCanvasElement;
        snappingClasses?: FRAGS.SnappingClass[];
    }): Promise<FRAGS.RaycastResult | undefined>;
    getPositions(items: ModelIdMap): Promise<THREE.Vector3[]>;
    getBBoxes(items: ModelIdMap): Promise<THREE.Box3[]>;
    highlight(style: FRAGS.MaterialDefinition, items?: ModelIdMap): Promise<void>;
    /**
     * Retrieves data for specified items from multiple models.
     *
     * @param items A map of model IDs to an array of local IDs, specifying which items to retrieve data for.
     * @param config Optional configuration for data retrieval.
     * @returns A record mapping model IDs to an array of item data.
     */
    getData(items: ModelIdMap, config?: Partial<FRAGS.ItemsDataConfig>): Promise<Record<string, FRAGS.ItemData[]>>;
    resetHighlight(items?: ModelIdMap): Promise<void>;
    private forEachModel;
    /**
     * Converts a collection of IFC GUIDs to a fragmentIdMap.
     *
     * @param guids - An iterable collection of global IDs to be converted to a fragment ID map.
     *
     * @returns A fragment ID map, where the keys are fragment IDs and the values are the corresponding express IDs.
     */
    guidsToModelIdMap(guids: Iterable<string>): Promise<ModelIdMap>;
    /**
     * Converts a fragment ID map to a collection of GUIDs.
     *
     * @param modelIdMap - A ModelIdMap to be converted to a collection of GUIDs.
     *
     * @returns An array of GUIDs.
     */
    modelIdMapToGuids(modelIdMap: ModelIdMap): Promise<string[]>;
    /**
     * Applies the base coordinate system to the provided object.
     *
     * This function takes an object and its original coordinate system as input.
     * It then inverts the original coordinate system and applies the base coordinate system
     * to the object. This ensures that the object's position, rotation, and scale are
     * transformed to match the base coordinate system (which is taken from the first model loaded).
     *
     * @param object - The object to which the base coordinate system will be applied.
     * This should be an instance of THREE.Object3D.
     *
     * @param originalCoordinateSystem - The original coordinate system of the object.
     * This should be a THREE.Matrix4 representing the object's transformation matrix.
     */
    applyBaseCoordinateSystem(object: THREE.Object3D | THREE.Vector3, originalCoordinateSystem?: THREE.Matrix4): THREE.Matrix4;
}

/**
 * A component that manages grid instances. Each grid is associated with a unique world. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/Grids). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/Grids).
 */
export declare class Grids extends Component implements Disposable_2 {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "d1e814d5-b81c-4452-87a2-f039375e0489";
    /**
     * A map of world UUIDs to their corresponding grid instances.
     */
    list: Map<string, SimpleGrid>;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /** {@link Component.enabled} */
    enabled: boolean;
    constructor(components: Components);
    /**
     * Creates a new grid for the given world.
     * Throws an error if a grid already exists for the world.
     *
     * @param world - The world to create the grid for.
     * @returns The newly created grid.
     *
     * @throws Will throw an error if a grid already exists for the given world.
     */
    create(world: World): SimpleGrid;
    /**
     * Deletes the grid associated with the given world.
     * If a grid does not exist for the given world, this method does nothing.
     *
     * @param world - The world for which to delete the grid.
     *
     * @remarks
     * This method will dispose of the grid and remove it from the internal list.
     * If the world is disposed before calling this method, the grid will be automatically deleted.
     */
    delete(world: World): void;
    /** {@link Disposable.dispose} */
    dispose(): void;
}

/**
 * Whether the geometric representation of this component can be hidden or shown in the [Three.js scene](https://threejs.org/docs/#api/en/scenes/Scene).
 */
export declare interface Hideable {
    /**
     * Whether the geometric representation of this component is
     * currently visible or not in the
     * [Three.js scene](https://threejs.org/docs/#api/en/scenes/Scene).
     */
    visible: boolean;
}

/**
 * A component that manages visibility of fragments within a 3D scene. It extends the base Component class and provides methods to control fragment visibility and isolation. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/Hider). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/Hider).
 */
export declare class Hider extends Component {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "dd9ccf2d-8a21-4821-b7f6-2949add16a29";
    /** {@link Component.enabled} */
    enabled: boolean;
    constructor(components: Components);
    /**
     * Sets the visibility of fragment items within the 3D scene.
     * If no `modelIdMap` parameter is provided, all fragments will be set to the specified visibility.
     * If it is provided, only the specified fragment items will be affected.
     *
     * @param visible - The visibility state to set for the items.
     * @param modelIdMap - An optional map of modelIds and their corresponding itemIds to be affected.
     * If not provided, all fragment items will be affected.
     */
    set(visible: boolean, modelIdMap?: ModelIdMap): Promise<void>;
    /**
     * Isolates fragments within the 3D scene by hiding all other fragments and showing only the specified ones.
     * It calls the `set` method twice: first to hide all fragments, and then to show only the specified ones.
     *
     * @param modelIdMap - A map of model IDs and their corresponding itemIds to be isolated.
     */
    isolate(modelIdMap: ModelIdMap): Promise<void>;
    /**
     * Toggles the visibility of specified items in the fragments.
     *
     * @param modelIdMap - An object where the keys are model IDs and the values are arrays of local IDs representing the fragments to be toggled.
     * @returns A promise that resolves when all visibility toggles and the core update are complete.
     */
    toggle(modelIdMap: ModelIdMap): Promise<void>;
    /**
     * Asynchronously retrieves a map of model IDs to their corresponding item IDs based on visibility state.
     *
     * @param state - The visibility state to filter items by.
     * @param modelIds - Optional array of model IDs to filter the items. If not provided, all models will be considered.
     * @returns A promise that resolves to a ModelIdMap record where the keys are model IDs and the values are arrays of item IDs that match the visibility state.
     */
    getVisibilityMap(state: boolean, modelIds?: string[]): Promise<Record<string, number[]>>;
}

export declare class IDSAttribute extends IDSFacet {
    facetType: "Attribute";
    name: IDSFacetParameter;
    value?: IDSFacetParameter;
    constructor(components: Components, name: IDSFacetParameter);
    serialize(type: "applicability" | "requirement"): string;
    getEntities(): Promise<void>;
    test(items: ModelIdMap, collector: ModelIdDataMap<IDSItemCheckResult>, config?: {
        skipIfFails: boolean;
    }): Promise<void>;
}

export declare interface IDSBoundsParameter {
    type: "bounds";
    parameter: {
        min?: number;
        minInclusive?: boolean;
        max?: number;
        maxInclusive?: boolean;
    };
}

export declare interface IDSCheck {
    parameter: IDSFacetParameterName | null;
    currentValue: any;
    requiredValue?: IDSFacetParameter | string;
    pass: boolean;
}

/**
 * The result of a check performed by an IDSFacet test.
 */
export declare type IDSCheckResult = ModelIdDataMap<IDSItemCheckResult>;

export declare class IDSClassification extends IDSFacet {
    facetType: "Classification";
    system: IDSFacetParameter;
    value?: IDSFacetParameter;
    uri?: string;
    constructor(components: Components, system: IDSFacetParameter);
    serialize(type: "applicability" | "requirement"): string;
    getEntities(_modelIds: RegExp[], _collector: ModelIdMap): Promise<void>;
    test(_items: ModelIdMap, _collector: ModelIdDataMap<IDSItemCheckResult>): Promise<void>;
}

export declare type IDSConditionalCardinaltiy = IDSSimpleCardinality | "optional";

export declare class IDSEntity extends IDSFacet {
    facetType: "Entity";
    name: IDSFacetParameter;
    predefinedType?: IDSFacetParameter;
    constructor(components: Components, name: IDSFacetParameter);
    serialize(type: "applicability" | "requirement"): string;
    getEntities(modelIds: RegExp[], collector: ModelIdMap): Promise<void>;
    test(items: ModelIdMap, collector: ModelIdDataMap<IDSItemCheckResult>, config: {
        skipIfFails: boolean;
    }): Promise<void>;
    protected evalName(category: string, checks?: IDSCheck[]): Promise<boolean>;
    protected evalPredefinedType(modelId: string, itemData: FRAGS.ItemData, checks?: IDSCheck[]): Promise<boolean | null>;
}

export declare interface IDSEnumerationParameter {
    type: "enumeration";
    parameter: string[] | number[] | boolean[];
}

export declare abstract class IDSFacet {
    protected _components: Components;
    abstract facetType: IDSFacetType;
    cardinality: IDSSimpleCardinality | IDSConditionalCardinaltiy;
    instructions?: string;
    constructor(_components: Components);
    protected addCheckResult(check: IDSCheck, checks: IDSCheck[]): void;
    protected evalRequirement: (value: string | number | boolean | null, facetParameter: IDSFacetParameter, parameter: IDSFacetParameterName, checks?: IDSCheck[]) => boolean;
    protected getItemChecks(collector: ModelIdDataMap<IDSItemCheckResult>, modelId: string, item: FRAGS.ItemData, skipIfFails: boolean): IDSCheck[] | null;
    /**
     * Returns the list of expressIDs that pass the criteria of this facet.
     * @param model - The IFC model to retrieve entities from.
     * @param collector - An optional object to collect the retrieved entities.
     * @remarks
     * If the collector already includes the entity, it won't get processed any further.
     *
     * @returns An array of express IDs of the retrieved entities.
     */
    abstract getEntities(modelIds: RegExp[], collector: ModelIdMap): Promise<void>;
    abstract test(items: ModelIdMap, collector: ModelIdDataMap<IDSItemCheckResult>, config: {
        skipIfFails: boolean;
    }): Promise<void>;
    abstract serialize(type: "applicability" | "requirement"): string;
}

export declare type IDSFacetParameter = IDSSimpleParameter | IDSRestrictionParameter;

export declare type IDSFacetParameterName = "Name" | "PredefinedType" | "Value" | "System" | "URI" | "PropertySet" | "BaseName" | "DataType" | "Value" | "Entity" | "Relation";

export declare type IDSFacetType = "Entity" | "Attribute" | "Property" | "Classification" | "Material" | "PartOf";

export declare interface IDSInfo {
    title: string;
    description?: string;
    copyright?: string;
    version?: string;
    author?: string;
    date?: Date;
    purpose?: string;
    milestone?: string;
}

export declare interface IDSItemCheckResult {
    guid?: string;
    pass: boolean;
    checks: IDSItemFacetCheck[];
}

export declare interface IDSItemFacetCheck {
    facetType: IDSFacetType;
    cardinality: IDSConditionalCardinaltiy;
    checks: IDSCheck[];
    pass: boolean;
}

export declare interface IDSLengthParameter {
    type: "length";
    parameter: {
        min?: number;
        length?: number;
        max?: number;
    };
}

export declare class IDSMaterial extends IDSFacet {
    private _ifcMaterialEntities;
    facetType: "Material";
    value?: IDSFacetParameter;
    uri?: string;
    serialize(type: "applicability" | "requirement"): string;
    getEntities(modelIds: RegExp[], collector: ModelIdMap): Promise<void>;
    test(items: ModelIdMap, collector: ModelIdDataMap<IDSItemCheckResult>, config?: {
        skipIfFails: boolean;
    }): Promise<void>;
    private hasValidMaterial;
    private evalValue;
}

export declare class IDSPartOf extends IDSFacet {
    facetType: "PartOf";
    private _entityFacet;
    private _entity;
    set entity(value: {
        name: IDSFacetParameter;
        predefinedType?: IDSFacetParameter;
    });
    get entity(): {
        name: IDSFacetParameter;
        predefinedType?: IDSFacetParameter;
    };
    relation?: IDSPartOfRelations;
    cardinality: IDSSimpleCardinality;
    constructor(components: Components, entity: {
        name: IDSFacetParameter;
        predefinedType?: IDSFacetParameter;
    });
    serialize(): string;
    getEntities(_modelIds: RegExp[], _collector: ModelIdMap): Promise<void>;
    test(_items: ModelIdMap): Promise<void>;
}

export declare type IDSPartOfRelations = "IFCRELAGGREGATES" | "IFCRELASSIGNSTOGROUP" | "IFCRELCONTAINEDINSPATIALSTRUCTURE" | "IFCRELNESTS" | "IFCRELVOIDSELEMENT" | "IFCRELFILLSELEMENT";

export declare interface IDSPatternParameter {
    type: "pattern";
    parameter: string;
}

export declare class IDSProperty extends IDSFacet {
    facetType: "Property";
    propertySet: IDSFacetParameter;
    baseName: IDSFacetParameter;
    value?: IDSFacetParameter;
    dataType?: string;
    uri?: string;
    private _unsupportedTypes;
    constructor(components: Components, propertySet: IDSFacetParameter, baseName: IDSFacetParameter);
    serialize(type: "applicability" | "requirement"): string;
    getEntities(modelIds: RegExp[], collector: ModelIdMap): Promise<void>;
    test(items: ModelIdMap, collector: ModelIdDataMap<IDSItemCheckResult>, config?: {
        skipIfFails: boolean;
    }): Promise<void>;
    private getPropertyListName;
    private getValueKey;
    private getTypePsets;
    private getPsets;
    private evalValue;
    private evalDataType;
    private evalURI;
}

export declare type IDSRestrictionParameter = IDSEnumerationParameter | IDSPatternParameter | IDSBoundsParameter | IDSLengthParameter;

export declare type IDSSimpleCardinality = "required" | "prohibited";

export declare interface IDSSimpleParameter {
    type: "simple";
    parameter: string | number | boolean;
}

/**
 * Represents a single specification from the Information Delivery Specification (IDS) standard.
 *
 * @remarks This class provides methods for testing a model against the specification,
 * as well as serializing the specification into XML format.
 */
export declare class IDSSpecification implements IDSSpecificationData {
    name: string;
    ifcVersion: Set<IfcVersion>;
    readonly identifier: string;
    description?: string;
    instructions?: string;
    requirementsDescription?: string;
    applicability: FRAGS.DataSet<IDSFacet>;
    requirements: FRAGS.DataSet<IDSFacet>;
    protected components: Components;
    constructor(components: Components, name: string, ifcVersion: IfcVersion[]);
    set(data: Partial<IDSSpecificationData>): this;
    /**
     * Tests the model to test against the specification's requirements.
     *
     * @param modelId - The modelId of the model to be tested.
     * @returns An array representing the test results.
     * If no requirements are defined for the specification, an empty array is returned.
     */
    test(modelIds: RegExp[], config?: {
        skipIfFails: boolean;
    }): Promise<IDSCheckResult>;
    /**
     * Serializes the IDSSpecification instance into XML format.
     *
     * @remarks This method is not meant to be used directly. It is used by the IDSSpecifications component.
     *
     * @returns The XML representation of the IDSSpecification.
     */
    serialize(): string;
}

export declare interface IDSSpecificationData {
    name: string;
    ifcVersion: Set<IfcVersion>;
    identifier: string;
    description?: string;
    instructions?: string;
    requirementsDescription?: string;
}

/**
 * Component that manages Information Delivery Specification (IDS) data. It provides functionality for importing, exporting, and manipulating IDS data. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/IDSSpecifications). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/IDSSpecifications).
 */
export declare class IDSSpecifications extends Component {
    static uuid: "9f0b9f78-9b2e-481a-b766-2fbfd01f342c";
    enabled: boolean;
    static xmlParser: XMLParser;
    IDSInfo?: IDSInfo;
    constructor(components: Components);
    readonly list: DataMap_2<string, IDSSpecification>;
    /**
     * Processes the results of an IDS check and categorizes the items into passing and failing.
     *
     * @param result - An `IDSCheckResult` object containing the check results for various model IDs.
     * @returns An object containing two `ModelIdMap` objects:
     *          - `pass`: A ModelIdMap representing items that passed the check.
     *          - `fail`: A ModelIdMap representing items that failed the check.
     */
    getModelIdMap(result: IDSCheckResult): {
        pass: ModelIdMap;
        fail: ModelIdMap;
    };
    /**
     * Creates a new IDSSpecification instance and adds it to the list.
     *
     * @param name - The name of the IDSSpecification.
     * @param ifcVersion - An array of IfcVersion values that the specification supports.
     *
     * @returns The newly created IDSSpecification instance.
     */
    create(name: string, ifcVersion: IfcVersion[], identifier?: string): IDSSpecification;
    /**
     * Parses and processes an XML string containing Information Delivery Specification (IDS) data.
     * It creates IDSSpecification instances based on the parsed data and returns them in an array.
     * Also, the instances are added to the list array.
     *
     * @param data - The XML string to parse.
     *
     * @returns An array of IDSSpecification instances created from the parsed data.
     */
    load(data: string): IDSSpecification[];
    /**
     * Exports the IDSSpecifications data into an XML string.
     *
     * @param info - The metadata information for the exported XML.
     * @param specifications - An optional iterable of IDSSpecification instances to export.
     * If not provided, all specifications in the list will be exported.
     *
     * @returns A string containing the exported IDSSpecifications data in XML format.
     */
    export(info: IDSInfo, specifications?: Iterable<IDSSpecification>): string;
}

/** Configuration of the IFC-fragment conversion. */
export declare class IfcFragmentSettings {
    /** Path of the WASM for [web-ifc](https://github.com/ThatOpen/engine_web-ifc). */
    wasm: {
        path: string;
        absolute: boolean;
        logLevel?: WEBIFC.LogLevel;
    };
    /** Loader settings for [web-ifc](https://github.com/ThatOpen/engine_web-ifc). */
    webIfc: WEBIFC.LoaderSettings;
    /**
     * Whether to automatically set the path to the WASM file for [web-ifc](https://github.com/ThatOpen/engine_web-ifc).
     * If set to true, the path will be set to the default path of the WASM file.
     * If set to false, the path must be provided manually in the `wasm.path` property.
     * Default value is true.
     */
    autoSetWasm: boolean;
    /**
     * Custom function to handle the file location for [web-ifc](https://github.com/ThatOpen/engine_web-ifc).
     * This function will be called when [web-ifc](https://github.com/ThatOpen/engine_web-ifc) needs to locate a file.
     * If set to null, the default file location handler will be used.
     *
     * @param url - The URL of the file to locate.
     * @returns The absolute path of the file.
     */
    customLocateFileHandler: WEBIFC.LocateFileHandlerFn | null;
}

/**
 * The IfcLoader component is responsible of converting IFC files into Fragments. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/IfcLoader). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/IfcLoader).
 */
export declare class IfcLoader extends Component implements Disposable_2 {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "a659add7-1418-4771-a0d6-7d4d438e4624";
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<string>;
    /**
     * An event triggered when the IFC file starts loading.
     */
    readonly onIfcStartedLoading: Event_2<void>;
    /**
     * An event triggered when the IFC importer is initialized.
     */
    readonly onIfcImporterInitialized: Event_2<FRAGS.IfcImporter>;
    /**
     * An event triggered when the setup process is completed.
     */
    readonly onSetup: Event_2<void>;
    /**
     * The settings for the IfcLoader.
     * It includes options for excluding categories, setting WASM paths, and more.
     */
    settings: IfcFragmentSettings;
    /**
     * The instance of the Web-IFC library used for handling IFC data.
     */
    webIfc: WEBIFC.IfcAPI;
    /** {@link Component.enabled} */
    enabled: boolean;
    constructor(components: Components);
    /** {@link Disposable.dispose} */
    dispose(): void;
    /**
     * Sets up the IfcLoader component with the provided configuration.
     *
     * @param config - Optional configuration settings for the IfcLoader.
     * If not provided, the existing settings will be used.
     *
     * @returns A Promise that resolves when the setup process is completed.
     *
     * @remarks
     * If the `autoSetWasm` option is enabled in the configuration,
     * the method will automatically set the WASM paths for the Web-IFC library.
     *
     * @example
     * ```typescript
     * const ifcLoader = new IfcLoader(components);
     * await ifcLoader.setup({ autoSetWasm: true });
     * ```
     */
    setup(config?: Partial<IfcFragmentSettings>): Promise<void>;
    /**
     * Loads an IFC file and processes it for 3D visualization.
     *
     * @param data - The Uint8Array containing the IFC file data.
     * @param coordinate - Boolean indicating whether to coordinate the loaded IFC data. Default is true.
     * @param name - Name for the fragments model.
     * @param config - Optional extra data for loading the IFC.
     *
     * @returns A Promise that resolves to the FragmentsModel containing the loaded and processed IFC data.
     *
     * @example
     * ```typescript
     * const ifcLoader = components.get(IfcLoader);
     * const model = await ifcLoader.load(ifcData);
     * ```
     */
    load(data: Uint8Array, coordinate: boolean, name: string, config?: {
        userData?: Record<string, any>;
        processData?: Omit<FRAGS.ProcessData, "bytes">;
        instanceCallback?: (importer: FRAGS.IfcImporter) => void;
    }): Promise<FRAGS.FragmentsModel>;
    /**
     * Reads an IFC file and initializes the Web-IFC library.
     *
     * @param data - The Uint8Array containing the IFC file data.
     *
     * @returns A Promise that resolves when the IFC file is opened and initialized.
     *
     * @remarks
     * This method sets the WASM path and initializes the Web-IFC library based on the provided settings.
     * It also opens the IFC model using the provided data and settings.
     *
     * @example
     * ```typescript
     * const ifcLoader = components.get(IfcLoader);
     * await ifcLoader.readIfcFile(ifcData);
     * ```
     */
    readIfcFile(data: Uint8Array): Promise<number>;
    /**
     * Cleans up the IfcLoader component by resetting the Web-IFC library,
     * clearing the visited fragments and fragment instances maps, and creating a new instance of the Web-IFC library.
     *
     * @remarks
     * This method is called automatically after using the .load() method, so usually you don't need to use it manually.
     *
     * @example
     * ```typescript
     * const ifcLoader = components.get(IfcLoader);
     * ifcLoader.cleanUp();
     * ```
     */
    cleanUp(): void;
    private autoSetWasm;
}

export declare type IfcVersion = "IFC2X3" | "IFC4" | "IFC4X3_ADD2";

export declare interface InternalDocumentReference extends DocumentReference {
    type: "internal";
    fileName: string;
    data: Uint8Array;
}

/**
 * Manages and executes queries to find items within models based on specified criteria. This class provides functionalities to create, store, and execute FinderQuery instances, allowing for efficient retrieval of items that match given query parameters. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/ItemsFinder). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/ItemsFinder).
 */
export declare class ItemsFinder extends Component implements Serializable<SerializedFinderQuery> {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "0da7ad77-f734-42ca-942f-a074adfd1e3a";
    /** {@link Component.enabled} */
    enabled: boolean;
    /**
     * A map of FinderQuery objects, indexed by a string key.
     */
    readonly list: FRAGS.DataMap<string, FinderQuery>;
    constructor(components: Components);
    /**
     * Retrieves items from specified models based on a query.
     *
     * @param queries - The query parameters to filter items.
     * @param modelIds - Optional array of model IDs to include in the search. If not provided, all models are searched.
     * @returns A map of model IDs to sets of item IDs that match the query.
     */
    getItems(queries: FRAGS.ItemsQueryParams[], config?: {
        modelIds?: RegExp[];
        aggregation?: QueryResultAggregation;
        items?: ModelIdMap;
    }): Promise<ModelIdMap>;
    /**
     * Creates a new FinderQuery instance and adds it to the list of queries.
     *
     * @param name - The name of the query.
     * @param queries - The queries to use.
     * @returns The newly created FinderQuery instance.
     */
    create(name: string, queries: FRAGS.ItemsQueryParams[]): FinderQuery;
    /**
     * Adds queries based on categories from items that have geometry.
     *
     * @param modelIds - An optional array of model IDs to filter fragments. If not provided, all fragments are processed.
     * @returns An array with the categories used to create the queries
     */
    addFromCategories(modelIds?: RegExp[]): Promise<string[]>;
    /**
     * Imports a list of `FinderQuery` instances from a `SerializationResult` containing serialized finder query data.
     *
     * @param result - The `SerializationResult` containing the serialized `SerializedFinderQuery` data.
     * @returns An array of `FinderQuery` instances created from the serialized data. Returns an empty array if the input data is null or undefined.
     */
    import(result: SerializationResult<SerializedFinderQuery>): FinderQuery[];
    /**
     * Serializes the ItemsFinder's data into a format suitable for export.
     *
     * @returns An object containing an array of serialized finder queries.
     */
    export(): {
        data: SerializedFinderQuery[];
    };
}

/**
 * Represents an edge measurement result.
 */
export declare interface MeasureEdge {
    /**
     * The distance between the two points of the edge.
     */
    distance: number;
    /**
     * The two points that define the edge.
     */
    points: THREE.Vector3[];
}

/**
 * Utility component for performing measurements on 3D meshes by providing methods for measuring distances between edges and faces. ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/MeasurementUtils).
 */
export declare class MeasurementUtils extends Component {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static uuid: string;
    /** {@link Component.enabled} */
    enabled: boolean;
    constructor(components: Components);
    /**
     * Utility method to calculate the distance from a point to a line segment.
     *
     * @param point - The point from which to calculate the distance.
     * @param lineStart - The start point of the line segment.
     * @param lineEnd - The end point of the line segment.
     * @param clamp - If true, the distance will be clamped to the line segment's length.
     * @returns The distance from the point to the line segment.
     */
    static distanceFromPointToLine(point: THREE.Vector3, lineStart: THREE.Vector3, lineEnd: THREE.Vector3, clamp?: boolean): number;
    /**
     * Method to round the vector's components to a specified number of decimal places.
     * This is used to ensure numerical precision in edge detection.
     *
     * @param vector - The vector to round.
     * @returns The vector with rounded components.
     */
    round(vector: THREE.Vector3): void;
    /**
     * @deprecated Use {@link getItemsVolume} instead.
     *
     * Calculates the volume of a set of items.
     */
    getVolumeFromFragments(modelIdMap: ModelIdMap): Promise<number>;
    /**
     * Calculates the total volume of items for a given map of model IDs to local IDs.
     * @param modelIdMap A map where the key is the model ID and the value is an array of local IDs.
     * @returns A promise that resolves to the total volume of the specified items.
     */
    getItemsVolume(modelIdMap: ModelIdMap): Promise<number>;
    /**
     * Converts a value from one unit to another for length, area, or volume without using external libraries.
     *
     * @param value - The value to convert.
     * @param fromUnit - The unit of the input value (e.g., "m", "cm", "mm" for lengths; "m2", "cm2" for areas; "m3", "cm3" for volumes).
     * @param toUnit - The unit to convert to (e.g., "cm", "mm", "m" for lengths; "cm2", "m2" for areas; "cm3", "m3" for volumes).
     * @param precision - The number of decimal places to round the result to, as number between 0 and 5. (default is 2).
     * @throws {Error} If the rounding value is not a valid integer or is out of range (0-5).
     * @returns The converted value rounded to the specified precision.
     */
    static convertUnits(value: number, fromUnit: string, toUnit: string, precision?: number): number;
}

export declare type ModelIdDataMap<T> = FRAGS.DataMap<string, FRAGS.DataMap<number, T>>;

/**
 * Mapping of model identifiers to a collection of numbers representing localIds.
 */
export declare type ModelIdMap = Record<string, Set<number>>;

/**
 * Utility class for manipulating and managing `ModelIdMap` objects. A `ModelIdMap` is a mapping of model identifiers (strings) to sets of local IDs (numbers). This class provides methods for joining, intersecting, cloning, adding, removing, and comparing `ModelIdMap` objects, as well as converting between `ModelIdMap` and plain JavaScript objects.
 */
export declare class ModelIdMapUtils {
    /**
     * Creates a new ModelIdMap from the union of multiple ModelIdMaps.
     * @param maps - An array of ModelIdMaps to join.
     * @returns A new ModelIdMap containing all model identifiers and localIds from all input maps.
     */
    static join(maps: ModelIdMap[]): ModelIdMap;
    /**
     * Creates a new ModelIdMap from the intersection of multiple ModelIdMaps.
     * @param maps - An array of ModelIdMaps.
     * @returns A new ModelIdMap containing only model identifiers and localIds present in all input maps.
     */
    static intersect(maps: ModelIdMap[]): ModelIdMap;
    /**
     * Creates a deep clone of a ModelIdMap.
     * @param source - The ModelIdMap to clone.
     * @returns A new ModelIdMap with the same model identifiers and localIds as the original.
     */
    static clone(source: ModelIdMap): ModelIdMap;
    /**
     * Remove all entries from one ModelIdMap to another.
     * @param target - The ModelIdMap to subtract from.
     * @param source - The ModelIdMap to subtract.
     */
    static remove(target: ModelIdMap, source: ModelIdMap, clone?: boolean): void;
    /**
     * Adds all entries from one ModelIdMap to another.
     * @param target - The ModelIdMap to add to.
     * @param source - The ModelIdMap to add from.
     */
    static add(target: ModelIdMap, source: ModelIdMap, clone?: boolean): void;
    static append(target: ModelIdMap, modelId: string, ...localIds: number[]): void;
    /**
     * Checks if two ModelIdMaps are equal.
     * @param a - The first ModelIdMap.
     * @param b - The second ModelIdMap.
     * @returns True if the ModelIdMaps are equal, false otherwise.
     */
    static isEqual(a: ModelIdMap, b: ModelIdMap): boolean;
    /**
     * Checks if a ModelIdMap is empty.
     * @param map - The ModelIdMap to check.
     * @returns True if the ModelIdMap is empty, false otherwise.
     */
    static isEmpty(map: ModelIdMap): boolean;
    /**
     * Converts a ModelIdMap into a plain JavaScript object with array values.
     * @param map - The ModelIdMap to convert.
     * @returns A plain JavaScript object where each key (model ID) maps to an array of local IDs.
     */
    static toRaw(map: ModelIdMap): {
        [modelID: string]: number[];
    };
    /**
     * Creates a ModelIdMap from a plain JavaScript object with array values.
     * @param raw - A plain JavaScript object where each key (model ID) maps to an array of local IDs.
     * @returns A ModelIdMap.
     */
    static fromRaw(raw: {
        [modelID: string]: number[];
    }): ModelIdMap;
}

/**
 * A helper to easily get the real position of the mouse in the Three.js canvas to work with tools like the [raycaster](https://threejs.org/docs/#api/en/core/Raycaster), even if it has been transformed through CSS or doesn't occupy the whole screen.
 */
export declare class Mouse implements Disposable_2 {
    dom: HTMLCanvasElement;
    private _event?;
    private _position;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    constructor(dom: HTMLCanvasElement);
    /**
     * The real position of the mouse or touch of the Three.js canvas.
     */
    get position(): THREE.Vector2;
    /**
     * The raw position of the mouse or touch of the Three.js canvas.
     */
    get rawPosition(): THREE.Vector2;
    /** {@link Disposable.dispose} */
    dispose(): void;
    private updatePosition;
    private getPositionY;
    private getPositionX;
    private updateMouseInfo;
    private getDataObject;
    private setupEvents;
}

/**
 * An object that determines the behavior of the camera controls and the user input (e.g. 2D floor plan mode, first person mode, etc).
 */
export declare interface NavigationMode {
    /** The unique ID of this navigation mode. */
    id: NavModeID;
    /**
     * Enable or disable this navigation mode.
     * When a new navigation mode is enabled, the previous navigation mode
     * must be disabled.
     *
     * @param active - whether to enable or disable this mode.
     * @param options - any additional data required to enable or disable it.
     * */
    set: (active: boolean, options?: any) => void;
    /** Whether this navigation mode is active or not. */
    enabled: boolean;
}

/**
 * The extensible list of supported navigation modes.
 */
export declare type NavModeID = "Orbit" | "FirstPerson" | "Plan";

export declare interface NoControl {
    type: "None";
    value: any;
}

export declare interface NumberSettingControl {
    type: "Number";
    interpolable: boolean;
    min?: number;
    max?: number;
    value: number;
}

/**
 * A {@link NavigationMode} that allows 3D navigation and panning like in many 3D and CAD softwares.
 */
export declare class OrbitMode implements NavigationMode {
    camera: OrthoPerspectiveCamera;
    /** {@link NavigationMode.enabled} */
    enabled: boolean;
    /** {@link NavigationMode.id} */
    readonly id = "Orbit";
    constructor(camera: OrthoPerspectiveCamera);
    /** {@link NavigationMode.set} */
    set(active: boolean): void;
    private activateOrbitControls;
}

/**
 * A flexible camera that uses [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls) to control the camera in 2D and 3D. It supports multiple navigation modes, such as 2D floor plan navigation, first person and 3D orbit. This class extends the SimpleCamera class and adds additional functionality for managing different camera projections and navigation modes. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/OrthoPerspectiveCamera). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/OrthoPerspectiveCamera).
 */
export declare class OrthoPerspectiveCamera extends SimpleCamera {
    /**
     * A ProjectionManager instance that manages the projection modes of the camera.
     */
    readonly projection: ProjectionManager;
    /**
     * A THREE.OrthographicCamera instance that represents the orthographic camera.
     * This camera is used when the projection mode is set to orthographic.
     */
    readonly threeOrtho: THREE.OrthographicCamera;
    /**
     * A THREE.PerspectiveCamera instance that represents the perspective camera.
     * This camera is used when the projection mode is set to perspective.
     */
    readonly threePersp: THREE.PerspectiveCamera;
    protected readonly _userInputButtons: any;
    protected readonly _frustumSize = 50;
    protected readonly _navigationModes: Map<string, NavigationMode>;
    protected _mode: NavigationMode | null;
    private previousSize;
    /**
     * Getter for the current navigation mode.
     * Throws an error if the mode is not found or the camera is not initialized.
     *
     * @returns {NavigationMode} The current navigation mode.
     *
     * @throws {Error} Throws an error if the mode is not found or the camera is not initialized.
     */
    get mode(): NavigationMode;
    constructor(components: Components);
    /** {@link Disposable.dispose} */
    dispose(): void;
    /**
     * Sets a new {@link NavigationMode} and disables the previous one.
     *
     * @param mode - The {@link NavigationMode} to set.
     */
    set(mode: string): void;
    /**
     * Make the camera view fit all the specified meshes.
     *
     * @param meshes the meshes to fit. If it is not defined, it will
     * evaluate {@link Components.meshes}.
     * @param offset the distance to the fit object
     */
    fit(meshes: Iterable<THREE.Mesh>, offset?: number): Promise<void>;
    /**
     * Allows or prevents all user input.
     *
     * @param active - whether to enable or disable user inputs.
     */
    setUserInput(active: boolean): void;
    /**
     * Adds a custom {@link NavigationMode} to the camera that can be used using the {@link OrthoPerspectiveCamera.set} method.
     *
     * @param mode - The custom {@link NavigationMode} to add.
     */
    addCustomNavigationMode(mode: NavigationMode): void;
    private disableUserInput;
    private enableUserInput;
    private newOrthoCamera;
    private setOrthoPerspCameraAspect;
}

/**
 * A {@link NavigationMode} that allows to navigate floorplans in 2D, like many BIM tools.
 */
export declare class PlanMode implements NavigationMode {
    private camera;
    /** {@link NavigationMode.enabled} */
    enabled: boolean;
    /** {@link NavigationMode.id} */
    readonly id = "Plan";
    private mouseAction1?;
    private mouseAction2?;
    private mouseInitialized;
    private readonly defaultAzimuthSpeed;
    private readonly defaultPolarSpeed;
    constructor(camera: OrthoPerspectiveCamera);
    /** {@link NavigationMode.set} */
    set(active: boolean): void;
}

/** Basic type to describe the progress of any kind of process. */
export declare interface Progress {
    /** The amount of things that have been done already. */
    current: number;
    /** The total amount of things to be done by the process. */
    total: number;
}

/**
 * Object to control the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
 */
export declare class ProjectionManager {
    /**
     * Event that fires when the {@link CameraProjection} changes.
     */
    readonly onChanged: Event_2<THREE.PerspectiveCamera | THREE.OrthographicCamera>;
    /**
     * Current projection mode of the camera.
     * Default is "Perspective".
     */
    current: CameraProjection;
    /**
     * The camera controlled by this ProjectionManager.
     * It can be either a PerspectiveCamera or an OrthographicCamera.
     */
    camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;
    /** Match Ortho zoom with Perspective distance when changing projection mode */
    matchOrthoDistanceEnabled: boolean;
    private _component;
    private _previousDistance;
    constructor(camera: OrthoPerspectiveCamera);
    /**
     * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
     *
     * @param projection - the new projection to set. If it is the current projection,
     * it will have no effect.
     */
    set(projection: CameraProjection): Promise<void>;
    /**
     * Changes the current {@link CameraProjection} from Ortographic to Perspective
     * and vice versa.
     */
    toggle(): Promise<void>;
    private setOrthoCamera;
    private getPerspectiveDims;
    private setupOrthoCamera;
    private getDistance;
    private setPerspectiveCamera;
}

/**
 * Represents the type of aggregation used in a query result. `inclusive`: Equivalent to OR. `exclusive`: Equivalent to AND.
 */
export declare type QueryResultAggregation = "inclusive" | "exclusive";

/**
 * Configuration for testing queries.
 */
export declare interface QueryTestConfig {
    /**
     * An optional array of regular expressions used to know the models to be tested.
     */
    modelIds?: RegExp[];
    /**
     * An optional boolean indicating whether to force the query execution no matter if there is a cached result already.
     */
    force?: boolean;
}

/**
 * A component that manages a raycaster for each world and automatically disposes it when its corresponding world is disposed. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/Raycasters). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/Raycasters).
 */
export declare class Raycasters extends Component implements Disposable_2 {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "d5d8bdf0-db25-4952-b951-b643af207ace";
    /** {@link Component.enabled} */
    enabled: boolean;
    /**
     * A Map that stores raycasters for each world.
     * The key is the world's UUID, and the value is the corresponding SimpleRaycaster instance.
     */
    list: Map<string, SimpleRaycaster>;
    /** {@link Disposable.onDisposed} */
    onDisposed: Event_2<unknown>;
    constructor(components: Components);
    /**
     * Retrieves a SimpleRaycaster instance for the given world.
     * If a SimpleRaycaster instance already exists for the world, it will be returned.
     * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
     *
     * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
     * @returns The SimpleRaycaster instance for the given world.
     */
    get(world: World): SimpleRaycaster;
    /**
     * Deletes the SimpleRaycaster instance associated with the given world.
     * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
     *
     * @param world - The world for which to delete the SimpleRaycaster instance.
     * @returns {void}
     */
    delete(world: World): void;
    /** {@link Disposable.dispose} */
    dispose(): void;
}

/**
 * Configuration options for removing items from a classifier.
 */
export declare interface RemoveClassifierItemsConfig {
    /**
     * The name of the classification from which items should be removed.
     */
    classificationName?: string;
    /**
     * The name of the group within the classification from which items should be removed.
     */
    groupName?: string;
}

/**
 * The mode of the renderer. If MANUAL, the renderer will be updated on command. If AUTO, the renderer will render on every update tick.
 */
export declare enum RendererMode {
    MANUAL = 0,
    AUTO = 1
}

/**
 * Whether this component can be resized. The meaning of this can vary depending on the component: resizing a [Renderer](https://threejs.org/docs/#api/en/renderers/WebGLRenderer) component could mean changing its resolution, whereas resizing a [Mesh](https://threejs.org/docs/#api/en/objects/Mesh) would change its scale.
 */
export declare interface Resizeable {
    /**
     * Sets size of this component (e.g. the resolution of a
     * [Renderer](https://threejs.org/docs/#api/en/renderers/WebGLRenderer)
     * component.
     */
    resize: (size?: THREE.Vector2) => void;
    /** Event that fires when the component has been resized. */
    onResize: Event_2<THREE.Vector2>;
    /**
     * Gets the current size of this component (e.g. the resolution of a
     * [Renderer](https://threejs.org/docs/#api/en/renderers/WebGLRenderer)
     * component.
     */
    getSize: () => THREE.Vector2;
}

export declare interface SelectSettingControl {
    type: "Select";
    multiple: boolean;
    options: Set<string>;
    value: string;
}

export declare interface Serializable<D extends Record<string, any> = Record<string, any>, S extends Record<string, any> = Record<string, any>> {
    import: (result: SerializationResult<D, S>, ...args: any) => any;
    export: (...args: any) => SerializationResult<D, S>;
}

export declare interface SerializationResult<D extends Record<string, any> = Record<string, any>, S extends Record<string, any> = Record<string, any>> {
    data?: D[];
    settings?: S;
}

/**
 * Represents a serialized query for an item finder.
 */
export declare interface SerializedFinderQuery {
    /**
     * The ID of the query.
     */
    guid: string;
    /**
     * The name of the query.
     */
    name: string;
    /**
     * An object to define custom data.
     */
    customData: Record<string, any>;
    /**
     * An array of serialized query parameters.
     */
    queries: SerializedQueryParameters[];
    /**
     * The type of aggregation applied to the query results.
     */
    aggregation: QueryResultAggregation;
    /**
     * Indicates whether the query results should be cached.
     */
    cache: boolean;
}

export declare interface SerializedQueryAttribute {
    /**
     * The name of the attribute.
     */
    name: string;
    /**
     * The value of the attribute, which can be a string, an array of strings, a number, or a boolean. Optional.
     */
    value?: string | string[] | number | boolean;
    /**
     * The type of the attribute, typically used to define the data type or category. Optional.
     */
    type?: string;
    /**
     * Indicates whether the query should negate this attribute. Optional.
     */
    negate?: boolean;
    /**
     * An array of item IDs associated with this attribute. Optional.
     */
    itemIds?: number[];
}

/**
 * Represents the serialized query parameters used for item finding.
 */
export declare interface SerializedQueryParameters {
    /**
     * An optional array of category strings to filter items.
     */
    categories?: string[];
    /**
     * An optional object containing attribute-based queries.
     */
    attributes?: {
        /**
         * Specifies the aggregation type for attributes, either "exclusive" or "inclusive".
         */
        aggregation?: "exclusive" | "inclusive";
        /**
         * An array of serialized query attributes used for filtering.
         */
        queries: SerializedQueryAttribute[];
    };
    /**
     * An optional object defining a relational query.
     */
    relation?: {
        /**
         * The name of the relation.
         */
        name: string;
        /**
         * An optional nested query of type SerializedQueryParameters.
         */
        query?: SerializedQueryParameters;
    };
}

/**
 * A scene that supports efficient cast shadows. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/ShadowedScene). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/ShadowedScene).
 */
export declare class ShadowedScene extends SimpleScene implements Disposable_2, Configurable<SimpleSceneConfigManager, ShadowedSceneConfig> {
    private _distanceRenderer?;
    /**
     * Whether the bias property should be set automatically depending on the shadow distance.
     */
    autoBias: boolean;
    protected _defaultShadowConfig: {
        cascade: number;
        resolution: number;
    };
    private _lightsWithShadow;
    private _isComputingShadows;
    private _shadowsEnabled;
    private _bias;
    /**
     * The getter for the bias to prevent artifacts (stripes). It usually ranges between 0 and -0.005.
     */
    get bias(): number;
    /**
     * The setter for the bias to prevent artifacts (stripes). It usually ranges between 0 and -0.005.
     */
    set bias(value: number);
    /**
     * Getter to see whether the shadows are enabled or not in this scene instance.
     */
    get shadowsEnabled(): boolean;
    /**
     * Setter to control whether the shadows are enabled or not in this scene instance.
     */
    set shadowsEnabled(value: boolean);
    /**
     * Getter to get the renderer used to determine the farthest distance from the camera.
     */
    get distanceRenderer(): DistanceRenderer;
    /** {@link Configurable.setup} */
    setup(config?: Partial<ShadowedSceneConfig>): void;
    /** {@link Disposable.dispose} */
    dispose(): void;
    /** Update all the shadows of the scene. */
    updateShadows(): Promise<void>;
    private recomputeShadows;
}

/**
 * Configuration interface for the {@link ShadowedScene}. Defines properties for directional and ambient lights, as well as shadows.
 */
export declare interface ShadowedSceneConfig extends SimpleSceneConfig {
    shadows: {
        cascade: number;
        resolution: number;
    };
}

/**
 * A basic camera that uses [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls) to control the camera in 2D and 3D. Check out it's API to find out what features it offers.
 */
export declare class SimpleCamera extends BaseCamera implements Updateable, Disposable_2 {
    /** {@link Updateable.onBeforeUpdate} */
    readonly onBeforeUpdate: Event_2<SimpleCamera>;
    /** {@link Updateable.onAfterUpdate} */
    readonly onAfterUpdate: Event_2<SimpleCamera>;
    /**
     * Event that is triggered when the aspect of the camera has been updated.
     * This event is useful when you need to perform actions after the aspect of the camera has been changed.
     */
    readonly onAspectUpdated: Event_2<unknown>;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<string>;
    /**
     * A three.js PerspectiveCamera or OrthographicCamera instance.
     * This camera is used for rendering the scene.
     */
    three: THREE.PerspectiveCamera | THREE.OrthographicCamera;
    private _allControls;
    /**
     * The object that controls the camera. An instance of
     * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
     * Transforming the camera directly will have no effect: you need to use this
     * object to move, rotate, look at objects, etc.
     */
    get controls(): CameraControls;
    /**
     * Getter for the enabled state of the camera controls.
     * If the current world is null, it returns false.
     * Otherwise, it returns the enabled state of the camera controls.
     *
     * @returns {boolean} The enabled state of the camera controls.
     */
    get enabled(): boolean;
    /**
     * Setter for the enabled state of the camera controls.
     * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
     *
     * @param {boolean} enabled - The new enabled state of the camera controls.
     */
    set enabled(enabled: boolean);
    set currentWorld(value: World | null);
    get currentWorld(): World | null;
    constructor(components: Components);
    /** {@link Disposable.dispose} */
    dispose(): void;
    fitToItems(items?: ModelIdMap): Promise<void>;
    setOrbitToItems(items?: ModelIdMap): Promise<void>;
    /** {@link Updateable.update} */
    update(_delta: number): void;
    /**
     * Updates the aspect of the camera to match the size of the
     * {@link Components.renderer}.
     */
    updateAspect: () => void;
    private getItemsBounding;
    private setupCamera;
    private newCameraControls;
    private setupEvents;
    private static getSubsetOfThree;
}

/**
 * An infinite grid. Created by [fyrestar](https://github.com/Fyrestar/THREE.InfiniteGridHelper) and translated to typescript by [dkaraush](https://github.com/dkaraush/THREE.InfiniteGridHelper/blob/master/InfiniteGridHelper.ts).
 */
export declare class SimpleGrid implements Hideable, Disposable_2, Configurable<SimpleGridConfigManager, SimpleGridConfig> {
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /** {@link Configurable.onSetup} */
    readonly onSetup: Event_2<unknown>;
    /** {@link Configurable.isSetup} */
    isSetup: boolean;
    /** The world instance to which this Raycaster belongs. */
    world: World;
    /** The components instance to which this grid belongs. */
    components: Components;
    /** {@link Configurable.config} */
    config: SimpleGridConfigManager;
    protected _defaultConfig: SimpleGridConfig;
    /** {@link Hideable.visible} */
    get visible(): boolean;
    /** {@link Hideable.visible} */
    set visible(visible: boolean);
    /** The material of the grid. */
    get material(): THREE.ShaderMaterial;
    /**
     * Whether the grid should fade away with distance. Recommended to be true for
     * perspective cameras and false for orthographic cameras.
     */
    get fade(): boolean;
    /**
     * Whether the grid should fade away with distance. Recommended to be true for
     * perspective cameras and false for orthographic cameras.
     */
    set fade(active: boolean);
    /** The Three.js mesh that contains the infinite grid. */
    readonly three: THREE.Mesh;
    private _fade;
    constructor(components: Components, world: World);
    /** {@link Configurable.setup} */
    setup(config?: Partial<SimpleGridConfig>): void;
    /** {@link Disposable.dispose} */
    dispose(): void;
    private setupEvents;
    private updateZoom;
}

/**
 * Configuration interface for the {@link SimpleGrid}.
 */
export declare interface SimpleGridConfig {
    /**
     * Whether the grid is visible or not.
     */
    visible: boolean;
    /**
     * The color of the grid lines.
     */
    color: THREE.Color;
    /**
     * The size of the primary grid lines.
     */
    primarySize: number;
    /**
     * The size of the secondary grid lines.
     */
    secondarySize: number;
    /**
     * The distance at which the grid lines start to fade away.
     */
    distance: number;
}

export declare class SimpleGridConfigManager extends Configurator<SimpleGrid, SimpleGridConfigType> {
    protected _config: SimpleGridConfigType;
    /**
     * Whether the grid is visible or not.
     */
    get visible(): boolean;
    /**
     * Whether the grid is visible or not.
     */
    set visible(value: boolean);
    /**
     * The color of the grid lines.
     */
    get color(): THREE.Color;
    /**
     * The color of the grid lines.
     */
    set color(value: THREE.Color);
    /**
     * The size of the primary grid lines.
     */
    get primarySize(): number;
    /**
     * The size of the primary grid lines.
     */
    set primarySize(value: number);
    /**
     * The size of the secondary grid lines.
     */
    get secondarySize(): number;
    /**
     * The size of the secondary grid lines.
     */
    set secondarySize(value: number);
    /**
     * The distance at which the grid lines start to fade away.
     */
    get distance(): number;
    /**
     * The distance at which the grid lines start to fade away.
     */
    set distance(value: number);
}

declare type SimpleGridConfigType = {
    visible: BooleanSettingsControl;
    color: ColorSettingsControl;
    primarySize: NumberSettingControl;
    secondarySize: NumberSettingControl;
    distance: NumberSettingControl;
};

/**
 * Each of the clipping planes created by the clipper.
 */
export declare class SimplePlane implements Disposable_2, Hideable {
    /** Event that fires when the user starts dragging a clipping plane. */
    readonly onDraggingStarted: Event_2<unknown>;
    /** Event that fires when the user stops dragging a clipping plane. */
    readonly onDraggingEnded: Event_2<unknown>;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /**
     * The normal vector of the clipping plane.
     */
    readonly normal: THREE.Vector3;
    /**
     * The origin point of the clipping plane.
     */
    readonly origin: THREE.Vector3;
    /**
     * The THREE.js Plane object representing the clipping plane.
     */
    readonly three: THREE.Plane;
    /** The components instance to which this plane belongs. */
    components: Components;
    /** The world instance to which this plane belongs. */
    world: World;
    /** A custom string to identify what this plane is used for. */
    type: string;
    private _title;
    set title(value: string);
    get title(): string;
    protected readonly _helper: THREE.Object3D;
    protected _visible: boolean;
    protected _enabled: boolean;
    private _controlsActive;
    private readonly _arrowBoundBox;
    private readonly _planeMesh;
    private readonly _controls;
    private readonly _hiddenMaterial;
    /**
     * Getter for the enabled state of the clipping plane.
     * @returns {boolean} The current enabled state.
     */
    get enabled(): boolean;
    /**
     * Setter for the enabled state of the clipping plane.
     * Updates the clipping plane state in the renderer and throws an error if no renderer is found.
     * @param {boolean} state - The new enabled state.
     */
    set enabled(state: boolean);
    private _visibilityBeforeDisabled;
    /** {@link Hideable.visible } */
    get visible(): boolean;
    /** {@link Hideable.visible } */
    set visible(state: boolean);
    /** The meshes used for raycasting */
    get meshes(): THREE.Mesh[];
    /** The material of the clipping plane representation. */
    get planeMaterial(): THREE.Material | THREE.Material[];
    /** The material of the clipping plane representation. */
    set planeMaterial(material: THREE.Material | THREE.Material[]);
    /** The size of the clipping plane representation. */
    get size(): number;
    /** Sets the size of the clipping plane representation. */
    set size(size: number);
    /**
     * Getter for the helper object of the clipping plane.
     * The helper object is a THREE.Object3D that contains the clipping plane mesh and other related objects.
     * It is used for positioning, rotating, and scaling the clipping plane in the 3D scene.
     *
     * @returns {THREE.Object3D} The helper object of the clipping plane.
     */
    get helper(): THREE.Object3D<THREE.Object3DEventMap>;
    /**
     * Getter for the transform controls of the clipping plane.
     * The controls allow interactive manipulation (translation, rotation, etc.) of the clipping plane.
     *
     * @returns {TransformControls} The transform controls of the clipping plane.
     */
    get controls(): TransformControls;
    constructor(components: Components, world: World, origin: THREE.Vector3, normal: THREE.Vector3, material: THREE.Material, size?: number, activateControls?: boolean);
    private notifyManager;
    /**
     * Sets the clipping plane's normal and origin from the given normal and point.
     * This method resets the clipping plane's state, updates the normal and origin,
     * and positions the helper object accordingly.
     *
     * @param normal - The new normal vector for the clipping plane.
     * @param point - The new origin point for the clipping plane.
     *
     * @returns {void}
     */
    setFromNormalAndCoplanarPoint(normal: THREE.Vector3, point: THREE.Vector3): void;
    /** {@link Updateable.update} */
    update: () => void;
    /** {@link Disposable.dispose} */
    dispose(): void;
    private reset;
    protected toggleControls(state: boolean): void;
    private newTransformControls;
    private initializeControls;
    private createArrowBoundingBox;
    private changeDrag;
    private notifyDraggingChanged;
    private preventCameraMovement;
    private newHelper;
    private static newPlaneMesh;
}

/**
 * A simple [raycaster](https://threejs.org/docs/#api/en/core/Raycaster) that allows to easily get items from the scene using the mouse and touch events.
 */
export declare class SimpleRaycaster implements Disposable_2 {
    /** {@link Component.enabled} */
    enabled: boolean;
    /** The components instance to which this Raycaster belongs. */
    components: Components;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /** The position of the mouse in the screen. */
    readonly mouse: Mouse;
    /**
     * A reference to the Three.js Raycaster instance.
     * This is used for raycasting operations.
     */
    readonly three: THREE.Raycaster;
    /**
     * A reference to the world instance to which this Raycaster belongs.
     * This is used to access the camera and meshes.
     */
    world: World;
    /**
     * Whether to use fast model picking to optimize raycasting.
     * When enabled, the raycaster will first use FastModelPicker to identify
     * which model is under the mouse, then only raycast that specific model.
     * This can significantly improve performance when there are many models.
     */
    useFastModelPicking: boolean;
    constructor(components: Components, world: World);
    /** {@link Disposable.dispose} */
    dispose(): void;
    castRayToObjects(items?: THREE.Object3D[], position?: THREE.Vector2): THREE.Intersection | null;
    /**
     * Throws a ray from the camera to the mouse or touch event point and returns
     * the first item found. This also takes into account the clipping planes
     * used by the renderer.
     *
     * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
     * to query. If not provided, it will query all the meshes stored in
     * {@link Components.meshes}.
     * @param position - the screen position to use for raycasting. If not provided,
     * the last pointer (mouse/touch) position will be used.
     */
    castRay(data?: {
        snappingClasses?: FRAGS.SnappingClass[];
        items?: THREE.Object3D[];
        position?: THREE.Vector2;
    }): Promise<THREE.Intersection | null>;
    /**
     * Casts a ray from a given origin in a given direction and returns the first item found.
     * This method also takes into account the clipping planes used by the renderer.
     *
     * @param origin - The origin of the ray.
     * @param direction - The direction of the ray.
     * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
     * @returns The first intersection found or `null` if no intersection was found.
     */
    castRayFromVector(origin: THREE.Vector3, direction: THREE.Vector3, items?: THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[], THREE.Object3DEventMap>[]): THREE.Intersection<THREE.Object3D<THREE.Object3DEventMap>> | null;
    private intersect;
    private filterClippingPlanes;
}

/**
 * A basic renderer capable of rendering [Objec3Ds](https://threejs.org/docs/#api/en/core/Object3D).
 */
export declare class SimpleRenderer extends BaseRenderer {
    /**
     * Indicates whether the renderer is enabled. If it's not, it won't be updated.
     * Default is `true`.
     */
    enabled: boolean;
    /**
     * The HTML container of the THREE.js canvas where the scene is rendered.
     */
    container: HTMLElement;
    /**
     * The THREE.js WebGLRenderer instance.
     */
    three: THREE.WebGLRenderer;
    /**
     * The mode of the renderer. If MANUAL, the renderer will be updated manually. If AUTO, the renderer will render on every update tick.
     */
    mode: RendererMode;
    /**
     * Whether the renderer needs to be updated. If true, the renderer will be updated on the next frame.
     */
    needsUpdate: boolean;
    protected _canvas: HTMLCanvasElement;
    protected _parameters?: Partial<THREE.WebGLRendererParameters>;
    protected _resizeObserver: ResizeObserver | null;
    protected onContainerUpdated: Event_2<unknown>;
    private _resizing;
    /**
     * Constructor for the SimpleRenderer class.
     *
     * @param components - The components instance.
     * @param container - The HTML container where the THREE.js canvas will be rendered.
     * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
     */
    constructor(components: Components, container: HTMLElement, parameters?: Partial<THREE.WebGLRendererParameters>);
    /** {@link Updateable.update} */
    update(): void;
    /** {@link Disposable.dispose} */
    dispose(): void;
    /** {@link Resizeable.getSize}. */
    getSize(): THREE.Vector2;
    /** {@link Resizeable.resize} */
    resize: (size?: THREE.Vector2) => void;
    /**
     * Sets up and manages the event listeners for the renderer.
     *
     * @param active - A boolean indicating whether to activate or deactivate the event listeners.
     *
     * @throws Will throw an error if the renderer does not have an HTML container.
     */
    setupEvents(active: boolean): void;
    private resizeEvent;
    private setupRenderer;
    private onContextLost;
    private onContextBack;
}

/**
 * A basic 3D [scene](https://threejs.org/docs/#api/en/scenes/Scene) to add objects hierarchically, and easily dispose them when you are finished with it.
 */
export declare class SimpleScene extends BaseScene implements Configurable<SimpleSceneConfigManager, SimpleSceneConfig> {
    /** {@link Configurable.onSetup} */
    readonly onSetup: Event_2<unknown>;
    /** {@link Configurable.isSetup} */
    isSetup: boolean;
    /**
     * The underlying Three.js scene object.
     * It is used to define the 3D space containing objects, lights, and cameras.
     */
    three: THREE.Scene;
    /** {@link Configurable.config} */
    config: SimpleSceneConfigManager;
    protected _defaultConfig: SimpleSceneConfig;
    constructor(components: Components);
    /** {@link Configurable.setup} */
    setup(config?: Partial<SimpleSceneConfig>): void;
    dispose(): void;
}

/**
 * Configuration interface for the {@link SimpleScene}.
 */
export declare interface SimpleSceneConfig {
    backgroundColor: THREE.Color;
    directionalLight: {
        color: THREE.Color;
        intensity: number;
        position: THREE.Vector3;
    };
    ambientLight: {
        color: THREE.Color;
        intensity: number;
    };
}

export declare class SimpleSceneConfigManager extends Configurator<SimpleScene, SimpleSceneConfigType> {
    protected _config: SimpleSceneConfigType;
    ambientLight: AmbientLightConfig;
    directionalLight: DirectionalLightConfig;
    get backgroundColor(): THREE.Color;
    set backgroundColor(value: THREE.Color);
}

declare type SimpleSceneConfigType = {
    backgroundColor: ColorSettingsControl;
    ambientLight: {
        color: ColorSettingsControl;
        intensity: NumberSettingControl;
    };
    directionalLight: {
        color: ColorSettingsControl;
        intensity: NumberSettingControl;
        position: Vector3SettingControl;
    };
};

/**
 * A class representing a simple world in a 3D environment. It extends the Base class and implements the World interface.
 *
 * @template T - The type of the scene. Default is BaseScene.
 * @template U - The type of the camera. Default is BaseCamera.
 * @template S - The type of the renderer. Default is BaseRenderer.
 */
export declare class SimpleWorld<T extends BaseScene = BaseScene, U extends BaseCamera = BaseCamera, S extends BaseRenderer = BaseRenderer> extends Base implements World, Disposable_2, Updateable {
    readonly onCameraChanged: Event_2<U>;
    /**
     * All the loaded [meshes](https://threejs.org/docs/#api/en/objects/Mesh). These meshes will be taken into account in operations like raycasting.
     */
    readonly meshes: Set<THREE.Mesh<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.Material | THREE.Material[], THREE.Object3DEventMap>>;
    /** {@link Updateable.onAfterUpdate} */
    readonly onAfterUpdate: Event_2<unknown>;
    /** {@link Updateable.onBeforeUpdate} */
    readonly onBeforeUpdate: Event_2<unknown>;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /**
     * Indicates whether the world is currently being disposed. This is useful to prevent trying to access world's elements when it's being disposed, which could cause errors when you dispose a world.
     */
    isDisposing: boolean;
    /**
     * Indicates whether the world is currently enabled.
     * When disabled, the world will not be updated.
     */
    enabled: boolean;
    private _dynamicAnchor;
    set dynamicAnchor(value: boolean);
    get dynamicAnchor(): boolean;
    /**
     * A unique identifier for the world. Is not meant to be changed at any moment.
     */
    readonly uuid: string;
    /**
     * An optional name for the world.
     */
    name?: string;
    private _scene?;
    private _camera?;
    private _renderer;
    private onPointerDown;
    private _defaultCamera?;
    get defaultCamera(): U;
    set defaultCamera(value: U);
    /**
     * Getter for the scene. If no scene is initialized, it throws an error.
     * @returns The current scene.
     */
    get scene(): T;
    /**
     * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
     * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
     * @param scene - The new scene to be set.
     */
    set scene(scene: T);
    /**
     * Getter for the camera. If no camera is initialized, it throws an error.
     * @returns The current camera.
     */
    get camera(): U;
    /**
     * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
     * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
     * @param camera - The new camera to be set.
     */
    set camera(camera: U);
    /**
     * Getter for the renderer.
     * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
     */
    get renderer(): S | null;
    /**
     * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
     * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
     * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
     * @param renderer - The new renderer to be set or null to remove the current renderer.
     */
    set renderer(renderer: S | null);
    useDefaultCamera(): void;
    /** {@link Updateable.update} */
    update(delta?: number): void;
    /** {@link Disposable.dispose} */
    dispose(disposeResources?: boolean): void;
}

export declare interface TextSetSettingControl {
    type: "TextSet";
    value: Set<string>;
}

export declare interface TextSettingsControl {
    type: "Text";
    value: string;
}

export declare class Topic implements BCFTopic {
    /**
     * Default values for a BCF Topic, excluding `guid`, `creationDate`, and `creationAuthor`.
     */
    static default: Omit<Partial<BCFTopic> & {
        title: string;
        type: string;
        status: string;
    }, "guid" | "creationDate" | "creationAuthor">;
    /**
     * A unique identifier for the topic.
     *
     * @remarks
     * The `guid` is automatically generated upon topic creation and by no means it should change.
     */
    guid: string;
    title: string;
    creationDate: Date;
    creationAuthor: string;
    readonly viewpoints: DataSet_2<string>;
    readonly relatedTopics: DataSet_2<string>;
    readonly comments: DataMap_2<string, Comment_2>;
    readonly documentReferences: DataSet_2<string>;
    customData: Record<string, any>;
    description?: string;
    serverAssignedId?: string;
    dueDate?: Date;
    modifiedAuthor?: string;
    modifiedDate?: Date;
    index?: number;
    private _type;
    set type(value: string);
    get type(): string;
    private _status;
    set status(value: string);
    get status(): string;
    private _priority?;
    set priority(value: string | undefined);
    get priority(): string | undefined;
    private _stage?;
    set stage(value: string | undefined);
    get stage(): string | undefined;
    private _assignedTo?;
    set assignedTo(value: string | undefined);
    get assignedTo(): string | undefined;
    private _labels;
    set labels(value: Set<string>);
    get labels(): Set<string>;
    private _components;
    private get _managerVersion();
    /**
     * Initializes a new instance of the `Topic` class representing a BCF (BIM Collaboration Format) topic.
     * It provides methods and properties to manage and serialize BCF topics.
     *
     * @remarks
     * The default creationUser is the one set in BCFTopics.config.author
     * It should not be created manually. Better use BCFTopics.create().
     *
     * @param components - The `Components` instance that provides access to other components and services.
     */
    constructor(components: Components);
    /**
     * Sets properties of the BCF Topic based on the provided data.
     *
     * @remarks
     * This method iterates over the provided `data` object and updates the corresponding properties of the BCF Topic.
     * It skips the `guid` property as it should not be modified.
     *
     * @param data - An object containing the properties to be updated.
     * @returns The topic
     *
     * @example
     * ```typescript
     * const topic = new Topic(components);
     * topic.set({
     *   title: "New BCF Topic Title",
     *   description: "This is a new description.",
     *   status: "Resolved",
     * });
     * ```
     */
    set(data: Partial<BCFTopic>): this;
    /**
     * Creates a new comment associated with the current topic.
     *
     * @param text - The text content of the comment.
     * @param viewpoint - (Optional) The viewpoint associated with the comment.
     *
     * @returns The newly created comment.
     *
     * @example
     * ```typescript
     * const viewpoint = viewpoints.create(world); // Created with an instance of Viewpoints
     * const topic = topics.create(); // Created with an instance of BCFTopics
     * topic.viewpoints.add(viewpoint);
     * const comment = topic.createComment("This is a new comment", viewpoint);
     * ```
     */
    createComment(text: string, viewpoint?: string): Comment_2;
    private createLabelTags;
    private createCommentTags;
    private createViewpointTags;
    private createRelatedTopicTags;
    private createDocumentReferencesTag;
    toJSON(): BCFApiTopic;
    /**
     * Serializes the BCF Topic instance into an XML string representation based on the official schema.
     *
     * @remarks
     * This method constructs an XML string based on the properties of the BCF Topic instance.
     * It includes the topic's guid, type, status, creation date, creation author, priority, index,
     * modified date, modified author, due date, assigned to, description, stage, labels, related topics,
     * comments, and viewpoints.
     *
     * @returns A string representing the XML serialization of the BCF Topic.
     *
     * @example
     * ```typescript
     * const topic = bcfTopics.create(); // Created with an instance of BCFTopics
     * const xml = topic.serialize();
     * console.log(xml);
     * ```
     */
    serialize(): string;
}

/** Whether this component should be updated each frame. */
export declare interface Updateable {
    /** Actions that should be executed after updating the component. */
    onAfterUpdate: Event_2<any>;
    /** Actions that should be executed before updating the component. */
    onBeforeUpdate: Event_2<any>;
    /**
     * Function used to update the state of this component each frame. For
     * instance, a renderer component will make a render each frame.
     */
    update(delta?: number): void;
}

export declare class UUID {
    private static _pattern;
    private static _lut;
    static create(): string;
    static validate(uuid: string): void;
}

export declare interface Vector3SettingControl {
    type: "Vector3";
    value: THREE.Vector3;
}

/**
 * A class that provides functionality for picking vertices in a 3D scene.
 */
export declare class VertexPicker extends Component implements Disposable_2 {
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /**
     * An event that is triggered when a vertex is found.
     * The event passes a THREE.Vector3 representing the position of the found vertex.
     */
    readonly onVertexFound: Event_2<THREE.Vector3>;
    /**
     * An event that is triggered when a vertex is lost.
     * The event passes a THREE.Vector3 representing the position of the lost vertex.
     */
    readonly onVertexLost: Event_2<THREE.Vector3>;
    /**
     * An event that is triggered when the picker is enabled or disabled
     */
    readonly onEnabled: Event_2<boolean>;
    /**
     * A reference to the Components instance associated with this VertexPicker.
     */
    components: Components;
    /**
     * A reference to the working plane used for vertex picking.
     * This plane is used to determine which vertices are considered valid for picking.
     * If this value is null, all vertices are considered valid.
     */
    workingPlane: THREE.Plane | null;
    private _pickedPoint;
    private _config;
    private _enabled;
    /**
     * Sets the enabled state of the VertexPicker.
     * When enabled, the VertexPicker will actively search for vertices in the 3D scene.
     * When disabled, the VertexPicker will stop searching for vertices and reset the picked point.
     *
     * @param value - The new enabled state.
     */
    set enabled(value: boolean);
    /**
     * Gets the current enabled state of the VertexPicker.
     *
     * @returns The current enabled state.
     */
    get enabled(): boolean;
    /**
     * Sets the configuration for the VertexPicker component.
     *
     * @param value - A Partial object containing the configuration properties to update.
     * The properties not provided in the value object will retain their current values.
     *
     * @example
     * ```typescript
     * vertexPicker.config = {
     *   snapDistance: 0.5,
     *   showOnlyVertex: true,
     * };
     * ```
     */
    set config(value: Partial<VertexPickerConfig>);
    /**
     * Gets the current configuration for the VertexPicker component.
     *
     * @returns A copy of the current VertexPickerConfig object.
     *
     * @example
     * ```typescript
     * const currentConfig = vertexPicker.config;
     * console.log(currentConfig.snapDistance); // Output: 0.25
     * ```
     */
    get config(): Partial<VertexPickerConfig>;
    constructor(components: Components, config?: Partial<VertexPickerConfig>);
    /** {@link Disposable.dispose} */
    dispose(): void;
    /**
     * Performs the vertex picking operation based on the current state of the VertexPicker.
     *
     * @param world - The World instance to use for raycasting.
     *
     * @returns The current picked point, or null if no point is picked.
     *
     * @remarks
     * This method checks if the VertexPicker is enabled. If not, it returns the current picked point.
     * If enabled, it performs raycasting to find the closest intersecting object.
     * It then determines the closest vertex or point on the face, based on the configuration settings.
     * If the picked point is on the working plane (if defined), it triggers the `onVertexFound` event and updates the `pickedPoint`.
     * If the picked point is not on the working plane, it resets the `pickedPoint`.
     * If no intersecting object is found, it triggers the `onVertexLost` event and resets the `pickedPoint`.
     */
    get(world: World): Promise<THREE.Vector3 | null>;
}

/**
 * Configuration interface for the VertexPicker component.
 */
export declare interface VertexPickerConfig {
    /**
     * If true, only vertices will be picked, not the closest point on the face.
     */
    showOnlyVertex: boolean;
    /**
     * The maximum distance for snapping to a vertex.
     */
    snapDistance: number;
    /**
     * The HTML element to use for previewing the picked vertex.
     */
    previewElement: HTMLElement;
}

export declare class View implements Disposable_2 {
    private _components;
    private _cameraOffset;
    private _planeHelper;
    private _farPlaneHelper;
    private _cameraHelper;
    private get _planeNormalOpposite();
    private get _planePosition();
    private get _cameraPosition();
    readonly onStateChanged: Event_2<string[]>;
    readonly onUpdated: Event_2<undefined>;
    readonly onDisposed: Event_2<undefined>;
    readonly camera: OrthoPerspectiveCamera;
    readonly plane: THREE.Plane;
    readonly farPlane: THREE.Plane;
    readonly id: string;
    private _open;
    set open(value: boolean);
    get open(): boolean;
    set planeHelperColor(value: THREE.Color);
    set farPlaneHelperColor(value: THREE.Color);
    private _range;
    set range(value: number);
    get range(): number;
    set distance(value: number);
    get distance(): number;
    private _world;
    set world(value: World | null);
    get world(): World | null;
    private _helpersVisible;
    set helpersVisible(value: boolean);
    get helpersVisible(): boolean;
    private _planesEnabled;
    set planesEnabled(value: boolean);
    get planesEnabled(): boolean;
    constructor(components: Components, config?: {
        id?: string;
        normal?: THREE.Vector3;
        point?: THREE.Vector3;
    });
    dispose(): void;
    update(): void;
    flip(): void;
}

/**
 * Represents a BCF compliant viewpoint from BuildingSMART. The Viewpoint class provides methods for managing and interacting with viewpoints. It includes functionality for setting viewpoint properties, updating the camera, applying color to components, and serializing the viewpoint for export.
 */
export declare class Viewpoint {
    title?: string;
    readonly guid: string;
    /**
     * ClippingPlanes can be used to define a subsection of a building model that is related to the topic.
     * Each clipping plane is defined by Location and Direction.
     * The Direction vector points in the invisible direction meaning the half-space that is clipped.
     */
    readonly clippingPlanes: FRAGS.DataSet<string>;
    camera: ViewpointPerspectiveCamera | ViewpointOrthogonalCamera;
    customData: Record<string, any>;
    /**
     * A list of components GUIDs to hide when defaultVisibility = true or to show when defaultVisibility = false
     */
    readonly exceptionComponents: FRAGS.DataSet<string>;
    /**
     * A list of components GUIDs that should be selected (highlighted) when displaying a viewpoint.
     */
    readonly selectionComponents: FRAGS.DataSet<string>;
    /**
     * A map of colors and components GUIDs that should be colorized when displaying a viewpoint.
     * For this to work, call viewpoint.colorize()
     */
    readonly componentColors: FRAGS.DataMap<string, string[]>;
    /**
     * Boolean flags to allow fine control over the visibility of spaces.
     * A typical use of these flags is when DefaultVisibility=true but spaces should remain hidden.
     * @default false
     */
    spacesVisible: boolean;
    /**
     * Boolean flags to allow fine control over the visibility of space boundaries.
     * A typical use of these flags is when DefaultVisibility=true but space boundaries should remain hidden.
     * @default false
     */
    spaceBoundariesVisible: boolean;
    /**
     * Boolean flags to allow fine control over the visibility of openings.
     * A typical use of these flags is when DefaultVisibility=true but openings should remain hidden.
     * @default false
     */
    openingsVisible: boolean;
    /**
     * When true, all components should be visible unless listed in the exceptions
     * When false all components should be invisible unless listed in the exceptions
     */
    defaultVisibility: boolean;
    /**
     * The snapshotID that will be used for this viewpoint when exported.
     */
    snapshot: string;
    getSelectionMap(): Promise<ModelIdMap>;
    getExceptionMap(): Promise<ModelIdMap>;
    /**
     * Retrieves the projection type of the viewpoint's camera.
     *
     * @returns A string representing the projection type of the viewpoint's camera.
     *          It can be either 'Perspective' or 'Orthographic'.
     */
    get projection(): CameraProjection;
    /**
     * Retrieves the position vector of the viewpoint's camera.
     *
     * @returns A THREE.Vector3 representing the position of the viewpoint's camera.
     */
    get position(): THREE.Vector3;
    /**
     * Sets the position of the viewpoint's camera.
     * @param value - The new position for the viewpoint's camera.
     */
    set position(value: THREE.Vector3);
    /**
     * Retrieves the direction vector of the viewpoint's camera.
     * @returns A THREE.Vector3 representing the direction of the viewpoint's camera.
     */
    get direction(): THREE.Vector3;
    private _components;
    private _world;
    /**
     * Represents the world in which the viewpoint will take effect.
     */
    set world(value: World | null);
    get world(): World | null;
    private get _managerVersion();
    /**
     * Retrieves the list of BCF topics associated with the current viewpoint.
     *
     * @remarks
     * This function retrieves the BCFTopics manager from the components,
     * then filters the list of topics to find those associated with the current viewpoint.
     *
     * @returns An array of BCF topics associated with the current viewpoint.
     */
    get topics(): Topic[];
    constructor(components: Components, data?: Partial<BCFViewpoint & {
        title: string;
    }>);
    private notifyUpdate;
    private setEvents;
    /**
     * Fully replace the properties of the viewpoint with the provided data.
     * The properties not included will remain unchanged.
     *
     * @remarks The guid will be ommited as it shouldn't change after it has been initially set.
     *
     * @param data - An object containing the properties to be set.
     */
    set(data: Partial<BCFViewpoint>): void;
    /**
     * Sets the viewpoint of the camera in the world.
     *
     * @remarks
     * This function calculates the target position based on the viewpoint information.
     * It sets the visibility of the viewpoint components and then applies the viewpoint using the camera's controls.
     *
     * @param transition - Indicates whether the camera movement should have a transition effect.
     *                      Default value is `true`.
     *
     * @throws An error if the world's camera does not have camera controls.
     *
     * @returns A Promise that resolves when the camera has been set.
     */
    go(_config?: {
        transition?: boolean;
        applyClippings?: boolean;
        clippingsVisibility?: boolean;
        applyVisibility?: boolean;
    }): Promise<void>;
    /**
     * Updates the camera settings of the viewpoint based on the current world's camera and renderer.
     * @returns A boolean indicating if the camera data was updated or not.
     */
    updateCamera(takeSnapshot?: boolean): Promise<boolean>;
    /**
     * Captures a snapshot of the current viewpoint and stores it in the snapshots manager.
     */
    takeSnapshot(): Promise<boolean>;
    /**
     * Updates the collection of clipping planes by clearing the current set and adding enabled planes
     * from the associated `Clipper` component.
     */
    updateClippingPlanes(): void;
    /**
     * Applies visibility settings to components based on default visibility, exceptions, and selections.
     *
     * This method adjusts the visibility of components using the `Hider` instance. It ensures that:
     * - The default visibility is applied to all components.
     * - Exceptions are handled to override the default visibility.
     * - Selected components are always visible.
     */
    applyVisibility(): Promise<void>;
    /**
     * Asynchronously sets the colorization state for the viewpoint's components.
     * When the state is true, it applies the defined component colors to the corresponding fragments.
     * When the state is false, it resets the highlight for the corresponding fragments.
     *
     * @param state - A boolean indicating whether to apply or reset the colorization.
     *                If true, the components will be colorized. If false, the colorization will be reset.
     * @returns A Promise that resolves when all colorization or reset operations are complete.
     * @remarks Be careful when using this method along with the Highlighter as it can cause unwanted results
     */
    setColorizationState(state: boolean): Promise<void>;
    /**
     * Sets the enabled state of all clipping planes associated with this viewpoint.
     * @param state A boolean indicating whether the clipping planes should be enabled or disabled.
     */
    setClippingState(state: boolean): void;
    /**
     * Sets the visibility of all clipping planes associated with this viewpoint.
     *
     * @param visibility - A boolean indicating whether the clipping planes should be visible (`true`) or hidden (`false`).
     */
    setClippingVisibility(visibility: boolean): void;
    private createComponentTags;
    private createColorTags;
    /**
     * Converts the current viewpoint instance into a JSON representation compliant with the BCFViewpoint format.
     *
     * @returns A BCF API JSON complaint object representing the viewpoint, including its GUID, components,
     * visibility settings, clipping planes, camera configuration, and snapshot data.
     */
    toJSON(): BCFViewpoint;
    /**
     * Serializes the viewpoint into a buildingSMART compliant XML string for export.
     *
     * @param version - The version of the BCF Manager to use for serialization.
     *                   If not provided, the current version of the manager will be used.
     *
     * @returns A Promise that resolves to an XML string representing the viewpoint.
     *          The XML string follows the BCF VisualizationInfo schema.
     *
     * @throws An error if the world's camera does not have camera controls.
     * @throws An error if the world's renderer is not available.
     */
    serialize(version?: string): Promise<string>;
}

/**
 *  Represents a bitmap image associated with a viewpoint. This interface is compliant with the BCF API specifications.
 */
export declare interface ViewpointBitmap {
    /**
     * The type of the bitmap image, either "png" or "jpg".
     */
    bitmap_type: "png" | "jpg";
    /**
     * The base64-encoded string representing the bitmap image data.
     */
    bitmap_data: string;
    /**
     * The 3D vector specifying the location of the bitmap in space.
     */
    location: ViewpointVector;
    /**
     * The 3D vector specifying the normal direction of the bitmap.
     */
    normal: ViewpointVector;
    /**
     * The 3D vector specifying the upward direction of the bitmap.
     */
    up: ViewpointVector;
    /**
     * The height of the bitmap in units.
     */
    height: number;
}

/**
 * Represents the properties of a camera viewpoint in a 3D space. This interface is compliant with the BCF API specifications.
 */
export declare interface ViewpointCamera {
    /**
     * The position of the camera in 3D space, defined by x, y, and z coordinates.
     */
    camera_view_point: {
        x: number;
        y: number;
        z: number;
    };
    /**
     * The direction the camera is pointing towards, represented by x, y, and z components.
     */
    camera_direction: {
        x: number;
        y: number;
        z: number;
    };
    /**
     * The upward direction vector of the camera, used to define the camera's orientation, represented by x, y, and z components.
     */
    camera_up_vector: {
        x: number;
        y: number;
        z: number;
    };
    /**
     * The aspect ratio of the camera's view, typically defined as the ratio of width to height.
     */
    aspect_ratio: number;
}

/**
 * Represents a clipping plane in a viewpoint, defined by its location and direction. This interface is compliant with the BCF API specifications.
 */
export declare interface ViewpointClippingPlane {
    /**
     * The position vector of the clipping plane.
     */
    location: ViewpointVector;
    /**
     * The direction vector indicating the orientation of the clipping plane.
     */
    direction: ViewpointVector;
}

/**
 * Represents the coloring information for a viewpoint, including the color and associated components. This interface is compliant with the BCF API specifications.
 */
export declare interface ViewpointColoring {
    /**
     * The color associated with the viewpoint, represented as a string (e.g., a hex code or color name).
     */
    color: string;
    /**
     * An array of components that are associated with the specified color in the viewpoint.
     */
    components: ViewpointComponent[];
}

/**
 * Represents a component within a viewpoint, typically used in Building Information Modeling (BIM) workflows. This interface is compliant with the BCF API specifications.
 */
export declare interface ViewpointComponent {
    /**
     * The unique identifier for the component in the IFC format. Can be `null` if not applicable.
     */
    ifc_guid: string | null;
    /**
     * The identifier of the component as defined by the authoring tool. Can be `null` if not applicable.
     */
    authoring_tool_id: string | null;
    /**
     * (Optional) The name of the system or application that originated the component.
     */
    originating_system?: string;
}

/**
 * Represents the components of a viewpoint in the BCF API. This interface is compliant with the BCF API specifications.
 */
export declare interface ViewpointComponents {
    /**
     * An array of viewpoint components representing the selection.
     */
    selection: ViewpointComponent[];
    /**
     * An array of viewpoint coloring definitions.
     */
    coloring: ViewpointColoring[];
    /**
     * Defines the visibility settings for the viewpoint.
     */
    visibility: ViewpointVisibility;
}

/**
 * Represents a line defined by a start and end point in a viewpoint. This interface is compliant with the BCF API specifications.
 */
export declare interface ViewpointLine {
    /**
     * The starting point of the line, represented as a `ViewpointVector`.
     */
    start_point: ViewpointVector;
    /**
     * The ending point of the line, represented as a `ViewpointVector`.
     */
    end_point: ViewpointVector;
}

/**
 * Represents an orthogonal camera viewpoint, extending the base `ViewpointCamera` type. This interface is compliant with the BCF API specifications.
 */
export declare type ViewpointOrthogonalCamera = ViewpointCamera & {
    /**
     * Defines the scale factor between the view space and the world space.
     */
    view_to_world_scale: number;
};

/**
 * Represents a perspective camera viewpoint compliant with the BCF API specifications. Extends the `ViewpointCamera` type and includes additional properties specific to perspective cameras.
 */
export declare type ViewpointPerspectiveCamera = ViewpointCamera & {
    /**
     * The field of view of the perspective camera, expressed in degrees.
     */
    field_of_view: number;
};

export declare class Viewpoints extends Component implements Disposable_2, Configurable<ViewpointsConfigManager, ViewpointsConfig> {
    static readonly uuid: "ee867824-a796-408d-8aa0-4e5962a83c66";
    enabled: boolean;
    /**
     * Represents the default world where all viewpoints will be created.
     * A viewpoint can specify a different world if necessary.
     */
    world: World | null;
    /**
     * A DataMap that stores Viewpoint instances, indexed by their unique identifiers (guid).
     * This map is used to manage and retrieve Viewpoint instances within the Viewpoints component.
     */
    readonly list: DataMap_2<string, Viewpoint>;
    /**
     * A collection of snapshots represented as a mapping between string keys and their corresponding binary data.
     */
    readonly snapshots: DataMap_2<string, Uint8Array>;
    /**
     * Creates a new Viewpoint instance and adds it to the list.
     *
     * @param data - Optional partial data for the Viewpoint. If not provided, default data will be used.
     *
     * @returns The newly created Viewpoint instance.
     */
    create(data?: Partial<BCFViewpoint>): Viewpoint;
    constructor(components: Components);
    /**
     * Determines the file extension of a snapshot based on its header bytes.
     *
     * @param name - The name of the snapshot from the list to retrieve its extension.
     * @returns The file extension as a string. Defaults to "jpeg" if the snapshot
     *          does not exist or the header bytes do not match known formats.
     */
    getSnapshotExtension(name: string): string;
    isSetup: boolean;
    setup(): void;
    onSetup: Event_2<unknown>;
    config: ViewpointsConfigManager;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /**
     * Disposes of the Viewpoints component and its associated resources.
     *
     * This method is responsible for cleaning up any resources held by the Viewpoints component,
     * such as disposing of the DataMap of Viewpoint instances and triggering and resetting the
     * onDisposed event.
     */
    dispose(): void;
}

/**
 * Configuration interface for the Viewpoints general behavior.
 */
declare interface ViewpointsConfig {
    /**
     * Indicates whether to overwrite the fragments colors when applying viewpoints.
     * @remarks BCF Viewpoints comes with information to indicate the colors to be applied to components, if any.
     * @default false
     */
    overwriteColors: boolean;
}

declare class ViewpointsConfigManager extends Configurator<Viewpoints, ViewpointsConfigType> {
    protected _config: ViewpointsConfigType;
    get overwriteColors(): boolean;
    set overwriteColors(value: boolean);
}

declare type ViewpointsConfigType = {
    overwriteColors: BooleanSettingsControl;
};

/**
 * Represents a snapshot of a viewpoint, including its type and data. This interface is compliant with the BCF API specifications.
 */
export declare interface ViewpointSnapshot {
    /**
     * The type of the snapshot, either "png" or "jpg".
     */
    snapshot_type: "png" | "jpg";
    /**
     * The base64-encoded string representing the snapshot data.
     */
    snapshot_data: string;
}

/**
 * Represents a 3D vector with x, y, and z coordinates.
 */
export declare interface ViewpointVector {
    x: number;
    y: number;
    z: number;
}

/**
 * Represents the visibility settings for a viewpoint. This interface is compliant with the BCF API specifications.
 */
export declare interface ViewpointVisibility {
    /**
     * Indicates whether the default visibility is enabled.
     */
    default_visibility: boolean;
    /**
     * A list of viewpoint components that are exceptions to the default visibility.
     */
    exceptions: ViewpointComponent[];
    /**
     * Configuration hints for the viewpoint setup.
     */
    view_setup_hints: {
        /**
         * Specifies whether spaces are visible.
         */
        spaces_visible: boolean;
        /**
         * Specifies whether space boundaries are visible.
         */
        space_boundaries_visible: boolean;
        /**
         * Specifies whether openings are visible.
         */
        openings_visible: boolean;
    };
}

/**
 * The `Views` class is responsible for managing and interacting with a collection of 2D sections. It provides methods for creating, opening, closing, and managing views, as well as generating views from specific configurations such as IFC storeys or bounding boxes. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/Views). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/Views).
 */
export declare class Views extends Component {
    static uuid: "fb22f1f5-6598-4664-a11d-de8963ae420f";
    /**
     * The default range value used by the Views component.
     * This represents the standard range setting applied unless explicitly overridden.
     */
    static defaultRange: number;
    /**
     * A readonly map that associates string keys with `View` instances.
     * This map is used to store and manage a collection of views.
     */
    readonly list: DataMap_2<string, View>;
    enabled: boolean;
    /**
     * The default world to be used when creating views.
     *
     * - If `world` is set to `null`, views can still specify another world directly in their instance.
     * - This property allows views to inherit a default world context unless explicitly overridden.
     */
    world: World | null;
    private _fragmentsUpdateEvent;
    /**
     * Determines whether there are any open views in this component's list.
     */
    get hasOpenViews(): boolean;
    constructor(components: Components);
    private setupEvents;
    /**
     * Creates a new view with the specified normal vector, point, and optional configuration.
     *
     * @param normal - The normal vector defining the orientation of the view.
     * @param point - The point in space where the view is centered.
     * @param config - Optional configuration for the view creation.
     * @returns The newly created `View` instance.
     * @remarks The created view will be added to the component's list data map.
     */
    create(normal: THREE.Vector3, point: THREE.Vector3, config?: CreateViewConfig): View;
    /**
     * Creates a new view from the specified plane and optional configuration.
     *
     * @param plane - The `THREE.Plane` object representing the plane to create the view from.
     * @param config - Optional configuration for creating the view.
     * @returns The newly created `View` instance.
     * @remarks The created view will be added to the component's list data map.
     */
    createFromPlane(plane: THREE.Plane, config?: CreateViewConfig): View;
    /**
     * Creates views from IFC storeys based on the provided configuration.
     * This method iterates through the fragments of the model, filters storeys
     * based on the configuration, and generates views for each storey.
     *
     * @param config - Optional configuration for creating views from IFC storeys.
     * @returns A promise that resolves to an array of `View` objects created from the IFC storeys.
     *
     * @remarks Each IfcBuilsingStorey is represented as a plane in 3D space, with its elevation adjusted by the `offset`. The created views will be added to the component's list data map.
     */
    createFromIfcStoreys(config?: CreateViewFromIfcStoreysConfig): Promise<View[]>;
    /**
     * Creates views representing the front, back, left, and right sides of bounding boxes for specified models or a combined bounding box of all models.
     *
     * @param config - Optional configuration object for creating bounding views.
     * @returns A promise that resolves to an array of `View` objects created from the boundings.
     * @remarks The method calculates bounding boxes for the specified models, optionally combines them into a single bounding box, and creates views for the planes representing the bounding box sides.
     */
    createElevations(config?: {
        combine?: boolean;
        modelIds?: RegExp[];
        world?: World;
        namingCallback?: (modelId: string) => {
            front: string;
            back: string;
            left: string;
            right: string;
        };
    }): View[];
    /**
     * Opens a view by its unique identifier. Ensures that no more than one view
     * is opened in the same world at a time. If the view is already open, the method
     * returns without performing any action.
     *
     * @param id - The unique identifier of the view to open.
     * @remarks This method changes world camera to use the view's.
     */
    open(id: string): void;
    /**
     * Closes a view by its unique identifier and performs necessary cleanup operations.
     *
     * @param id - The unique identifier of the view to be closed. If not provided, all opened views across worlds will be closed.
     * @remarks This method resets the world to use its default camera.
     */
    close(id?: string): void;
}

/**
 * Whether it has a UI or not.
 */
export declare interface WithUi {
    /**
     * The UI of the component.
     */
    ui: {
        [key: string]: () => HTMLElement;
    };
}

/**
 * Represents a 3D world with meshes, scene, camera, renderer, and other properties.
 */
export declare interface World extends Disposable_2, Updateable {
    /**
     * A set of meshes present in the world. This is taken into account for operations like raycasting.
     */
    meshes: Set<THREE.Mesh>;
    /**
     * The base scene of the world.
     */
    scene: BaseScene;
    /**
     * The default camera of the world.
     */
    defaultCamera: BaseCamera;
    /**
     * The base camera of the world.
     */
    camera: BaseCamera;
    onCameraChanged: Event_2<any>;
    useDefaultCamera: () => void;
    /**
     * The base renderer of the world. Can be null if this world doesn't use a renderer (e.g. in a backend environment).
     */
    renderer: BaseRenderer | null;
    /**
     * A unique identifier for the world.
     */
    uuid: string;
    /**
     * Indicates whether the world is currently disposing. This is useful for cancelling logic that access the elements of a world (which are also disposed).
     */
    isDisposing: boolean;
}

/**
 * A class representing a collection of worlds within a game engine. It manages the creation, deletion, and update of worlds. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Core/Worlds). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components/classes/Worlds).
 */
export declare class Worlds extends Component implements Updateable, Disposable_2 {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "fdb61dc4-2ec1-4966-b83d-54ea795fad4a";
    /** {@link Updateable.onAfterUpdate} */
    readonly onAfterUpdate: Event_2<unknown>;
    /** {@link Updateable.onBeforeUpdate} */
    readonly onBeforeUpdate: Event_2<unknown>;
    /** {@link Disposable.onDisposed} */
    readonly onDisposed: Event_2<unknown>;
    /**
     * A collection of worlds managed by this component.
     * The key is the unique identifier (UUID) of the world, and the value is the World instance.
     */
    list: DataMap_2<string, World>;
    /** {@link Component.enabled} */
    enabled: boolean;
    constructor(components: Components);
    /**
     * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
     *
     * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
     * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
     * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
     *
     * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
     */
    create<T extends BaseScene = BaseScene, U extends BaseCamera = BaseCamera, S extends BaseRenderer = BaseRenderer>(): SimpleWorld<T, U, S>;
    /**
     * Deletes a world from the list of worlds.
     *
     * @param {World} world - The world to be deleted.
     *
     * @throws {Error} - Throws an error if the provided world is not found in the list.
     */
    delete(world: World): void;
    /**
     * Disposes of the Worlds component and all its managed worlds.
     * This method sets the enabled flag to false, disposes of all worlds, clears the list,
     * and triggers the onDisposed event.
     */
    dispose(): void;
    /** {@link Updateable.update} */
    update(delta?: number): void | Promise<void>;
}

export declare class XML {
    static parser: XMLParser;
    static builder: XMLBuilder;
}

export { }
