var t,e,s,i,r,n,o,a,l,c,h,d,u,f,p,I,m,E,_,g,C,T,b,R,A,y,S,F,w,L,O,x,N,v,P,M,D,U,V,B,z,G,H,k,Y,W,q,j,X,Z,$,Q,K,J,tt,et,st,it,rt,nt=Object.defineProperty,ot=(t,e,s)=>(((t,e,s)=>{e in t?nt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s})(t,"symbol"!=typeof e?e+"":e,s),s),at=(t,e,s)=>{if(!e.has(t))throw TypeError("Cannot "+s)},lt=(t,e,s)=>(at(t,e,"read from private field"),s?s.call(t):e.get(t)),ct=(t,e,s)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,s)},ht=(t,e,s,i)=>(at(t,e,"write to private field"),i?i.call(t,s):e.set(t,s),s),dt=(t,e,s,i)=>({set _(i){ht(t,e,i,s)},get _(){return lt(t,e,i)}}),ut=(t,e,s)=>(at(t,e,"access private method"),s);import*as ft from"three";import{MathUtils as pt,InstancedBufferGeometry as It,Float32BufferAttribute as mt,InstancedInterleavedBuffer as Et,InterleavedBufferAttribute as _t,WireframeGeometry as gt,Box3 as Ct,Sphere as Tt,Vector3 as bt,ShaderMaterial as Rt,ShaderLib as At,UniformsUtils as yt,Vector2 as St,UniformsLib as Ft,Mesh as wt,Vector4 as Lt,Line3 as Ot,Matrix4 as xt,BufferAttribute as Nt,Plane as vt,Triangle as Pt,BackSide as Mt,DoubleSide as Dt,FrontSide as Ut,Ray as Vt}from"three";import*as Bt from"web-ifc";function zt(t,e){const s=Object.getPrototypeOf(t),i=Object.getOwnPropertyNames(s);for(const r of i){if("constructor"===r||"__init"===r)continue;if(r.includes("mutate_"))continue;if(r.match(/.*Array$/))continue;const i=s[r];if("function"==typeof i){const s=void 0!==t[`${r}Length`]&&void 0!==t[`${r}Array`];if(2===i.length||s){const s=t[`${r}Length`](),i=[];e[r]=i;for(let e=0;e<s;e++){const s=t[r](e);if("object"==typeof s&&null!==s&&"bb"in s){const t={};zt(s,t),i.push(t)}else i.push(s)}continue}const n=t[r]();if("object"!=typeof n||null===n){e[r]=n;continue}e[r]={},zt(n,e[r])}else e[r]=i}}const Gt={950732822:"IFCURIREFERENCE",4075327185:"IFCTIME",1209108979:"IFCTEMPERATURERATEOFCHANGEMEASURE",3457685358:"IFCSOUNDPRESSURELEVELMEASURE",4157543285:"IFCSOUNDPOWERLEVELMEASURE",2798247006:"IFCPROPERTYSETDEFINITIONSET",1790229001:"IFCPOSITIVEINTEGER",525895558:"IFCNONNEGATIVELENGTHMEASURE",1774176899:"IFCLINEINDEX",1275358634:"IFCLANGUAGEID",2541165894:"IFCDURATION",3701338814:"IFCDAYINWEEKNUMBER",2195413836:"IFCDATETIME",937566702:"IFCDATE",1683019596:"IFCCARDINALPOINTREFERENCE",2314439260:"IFCBINARY",1500781891:"IFCAREADENSITYMEASURE",3683503648:"IFCARCINDEX",4065007721:"IFCYEARNUMBER",1718600412:"IFCWARPINGMOMENTMEASURE",51269191:"IFCWARPINGCONSTANTMEASURE",2593997549:"IFCVOLUMETRICFLOWRATEMEASURE",3458127941:"IFCVOLUMEMEASURE",3345633955:"IFCVAPORPERMEABILITYMEASURE",1278329552:"IFCTORQUEMEASURE",2591213694:"IFCTIMESTAMP",2726807636:"IFCTIMEMEASURE",743184107:"IFCTHERMODYNAMICTEMPERATUREMEASURE",2016195849:"IFCTHERMALTRANSMITTANCEMEASURE",857959152:"IFCTHERMALRESISTANCEMEASURE",2281867870:"IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",2645777649:"IFCTHERMALCONDUCTIVITYMEASURE",232962298:"IFCTHERMALADMITTANCEMEASURE",296282323:"IFCTEXTTRANSFORMATION",603696268:"IFCTEXTFONTNAME",3490877962:"IFCTEXTDECORATION",1460886941:"IFCTEXTALIGNMENT",2801250643:"IFCTEXT",58845555:"IFCTEMPERATUREGRADIENTMEASURE",361837227:"IFCSPECULARROUGHNESS",2757832317:"IFCSPECULAREXPONENT",3477203348:"IFCSPECIFICHEATCAPACITYMEASURE",993287707:"IFCSOUNDPRESSUREMEASURE",846465480:"IFCSOUNDPOWERMEASURE",3471399674:"IFCSOLIDANGLEMEASURE",408310005:"IFCSHEARMODULUSMEASURE",2190458107:"IFCSECTIONALAREAINTEGRALMEASURE",3467162246:"IFCSECTIONMODULUSMEASURE",2766185779:"IFCSECONDINMINUTE",3211557302:"IFCROTATIONALSTIFFNESSMEASURE",1755127002:"IFCROTATIONALMASSMEASURE",2133746277:"IFCROTATIONALFREQUENCYMEASURE",200335297:"IFCREAL",96294661:"IFCRATIOMEASURE",3972513137:"IFCRADIOACTIVITYMEASURE",3665567075:"IFCPRESSUREMEASURE",2169031380:"IFCPRESENTABLETEXT",1364037233:"IFCPOWERMEASURE",1245737093:"IFCPOSITIVERATIOMEASURE",3054510233:"IFCPOSITIVEPLANEANGLEMEASURE",2815919920:"IFCPOSITIVELENGTHMEASURE",4042175685:"IFCPLANEANGLEMEASURE",2642773653:"IFCPLANARFORCEMEASURE",2260317790:"IFCPARAMETERVALUE",929793134:"IFCPHMEASURE",2395907400:"IFCNUMERICMEASURE",2095195183:"IFCNORMALISEDRATIOMEASURE",765770214:"IFCMONTHINYEARNUMBER",2615040989:"IFCMONETARYMEASURE",3114022597:"IFCMOMENTOFINERTIAMEASURE",1648970520:"IFCMOLECULARWEIGHTMEASURE",3177669450:"IFCMOISTUREDIFFUSIVITYMEASURE",1753493141:"IFCMODULUSOFSUBGRADEREACTIONMEASURE",1052454078:"IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",2173214787:"IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",3341486342:"IFCMODULUSOFELASTICITYMEASURE",102610177:"IFCMINUTEINHOUR",3531705166:"IFCMASSPERLENGTHMEASURE",3124614049:"IFCMASSMEASURE",4017473158:"IFCMASSFLOWRATEMEASURE",1477762836:"IFCMASSDENSITYMEASURE",2486716878:"IFCMAGNETICFLUXMEASURE",286949696:"IFCMAGNETICFLUXDENSITYMEASURE",151039812:"IFCLUMINOUSINTENSITYMEASURE",2755797622:"IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",2095003142:"IFCLUMINOUSFLUXMEASURE",503418787:"IFCLOGICAL",3086160713:"IFCLINEARVELOCITYMEASURE",1307019551:"IFCLINEARSTIFFNESSMEASURE",2128979029:"IFCLINEARMOMENTMEASURE",191860431:"IFCLINEARFORCEMEASURE",1243674935:"IFCLENGTHMEASURE",3258342251:"IFCLABEL",2054016361:"IFCKINEMATICVISCOSITYMEASURE",3192672207:"IFCISOTHERMALMOISTURECAPACITYMEASURE",3686016028:"IFCIONCONCENTRATIONMEASURE",3809634241:"IFCINTEGERCOUNTRATEMEASURE",1939436016:"IFCINTEGER",2679005408:"IFCINDUCTANCEMEASURE",3358199106:"IFCILLUMINANCEMEASURE",983778844:"IFCIDENTIFIER",2589826445:"IFCHOURINDAY",1158859006:"IFCHEATINGVALUEMEASURE",3113092358:"IFCHEATFLUXDENSITYMEASURE",3064340077:"IFCGLOBALLYUNIQUEID",3044325142:"IFCFREQUENCYMEASURE",1361398929:"IFCFORCEMEASURE",2590844177:"IFCFONTWEIGHT",2715512545:"IFCFONTVARIANT",1102727119:"IFCFONTSTYLE",2078135608:"IFCENERGYMEASURE",2506197118:"IFCELECTRICVOLTAGEMEASURE",2951915441:"IFCELECTRICRESISTANCEMEASURE",3790457270:"IFCELECTRICCURRENTMEASURE",2093906313:"IFCELECTRICCONDUCTANCEMEASURE",3818826038:"IFCELECTRICCHARGEMEASURE",1827137117:"IFCELECTRICCAPACITANCEMEASURE",69416015:"IFCDYNAMICVISCOSITYMEASURE",524656162:"IFCDOSEEQUIVALENTMEASURE",4134073009:"IFCDIMENSIONCOUNT",1514641115:"IFCDESCRIPTIVEMEASURE",300323983:"IFCDAYLIGHTSAVINGHOUR",86635668:"IFCDAYINMONTHNUMBER",94842927:"IFCCURVATUREMEASURE",1778710042:"IFCCOUNTMEASURE",3238673880:"IFCCONTEXTDEPENDENTMEASURE",3812528620:"IFCCOMPOUNDPLANEANGLEMEASURE",2991860651:"IFCCOMPLEXNUMBER",1867003952:"IFCBOXALIGNMENT",2735952531:"IFCBOOLEAN",2650437152:"IFCAREAMEASURE",632304761:"IFCANGULARVELOCITYMEASURE",360377573:"IFCAMOUNTOFSUBSTANCEMEASURE",4182062534:"IFCACCELERATIONMEASURE",3699917729:"IFCABSORBEDDOSEMEASURE",1971632696:"IFCGEOSLICE",2680139844:"IFCGEOMODEL",24726584:"IFCELECTRICFLOWTREATMENTDEVICE",3693000487:"IFCDISTRIBUTIONBOARD",3460952963:"IFCCONVEYORSEGMENT",3999819293:"IFCCAISSONFOUNDATION",3314249567:"IFCBOREHOLE",4196446775:"IFCBEARING",325726236:"IFCALIGNMENT",3425753595:"IFCTRACKELEMENT",991950508:"IFCSIGNAL",3798194928:"IFCREINFORCEDSOIL",3290496277:"IFCRAIL",1383356374:"IFCPAVEMENT",2182337498:"IFCNAVIGATIONELEMENT",234836483:"IFCMOORINGDEVICE",2078563270:"IFCMOBILETELECOMMUNICATIONSAPPLIANCE",1638804497:"IFCLIQUIDTERMINAL",1154579445:"IFCLINEARPOSITIONINGELEMENT",2696325953:"IFCKERB",2713699986:"IFCGEOTECHNICALASSEMBLY",2142170206:"IFCELECTRICFLOWTREATMENTDEVICETYPE",3376911765:"IFCEARTHWORKSFILL",1077100507:"IFCEARTHWORKSELEMENT",3071239417:"IFCEARTHWORKSCUT",479945903:"IFCDISTRIBUTIONBOARDTYPE",3426335179:"IFCDEEPFOUNDATION",1502416096:"IFCCOURSE",2940368186:"IFCCONVEYORSEGMENTTYPE",3203706013:"IFCCAISSONFOUNDATIONTYPE",3862327254:"IFCBUILTSYSTEM",1876633798:"IFCBUILTELEMENT",963979645:"IFCBRIDGEPART",644574406:"IFCBRIDGE",3649138523:"IFCBEARINGTYPE",1662888072:"IFCALIGNMENTVERTICAL",317615605:"IFCALIGNMENTSEGMENT",1545765605:"IFCALIGNMENTHORIZONTAL",4266260250:"IFCALIGNMENTCANT",3956297820:"IFCVIBRATIONDAMPERTYPE",1530820697:"IFCVIBRATIONDAMPER",840318589:"IFCVEHICLE",1953115116:"IFCTRANSPORTATIONDEVICE",618700268:"IFCTRACKELEMENTTYPE",2281632017:"IFCTENDONCONDUITTYPE",3663046924:"IFCTENDONCONDUIT",42703149:"IFCSINESPIRAL",1894708472:"IFCSIGNALTYPE",3599934289:"IFCSIGNTYPE",33720170:"IFCSIGN",1027922057:"IFCSEVENTHORDERPOLYNOMIALSPIRAL",544395925:"IFCSEGMENTEDREFERENCECURVE",3649235739:"IFCSECONDORDERPOLYNOMIALSPIRAL",550521510:"IFCROADPART",146592293:"IFCROAD",3818125796:"IFCRELADHERESTOELEMENT",4021432810:"IFCREFERENT",1891881377:"IFCRAILWAYPART",3992365140:"IFCRAILWAY",1763565496:"IFCRAILTYPE",1946335990:"IFCPOSITIONINGELEMENT",514975943:"IFCPAVEMENTTYPE",506776471:"IFCNAVIGATIONELEMENTTYPE",710110818:"IFCMOORINGDEVICETYPE",1950438474:"IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",976884017:"IFCMARINEPART",525669439:"IFCMARINEFACILITY",1770583370:"IFCLIQUIDTERMINALTYPE",2176059722:"IFCLINEARELEMENT",679976338:"IFCKERBTYPE",3948183225:"IFCIMPACTPROTECTIONDEVICETYPE",2568555532:"IFCIMPACTPROTECTIONDEVICE",2898700619:"IFCGRADIENTCURVE",1594536857:"IFCGEOTECHNICALSTRATUM",4230923436:"IFCGEOTECHNICALELEMENT",4228831410:"IFCFACILITYPARTCOMMON",1310830890:"IFCFACILITYPART",24185140:"IFCFACILITY",4234616927:"IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",1306400036:"IFCDEEPFOUNDATIONTYPE",4189326743:"IFCCOURSETYPE",2000195564:"IFCCOSINESPIRAL",3497074424:"IFCCLOTHOID",1626504194:"IFCBUILTELEMENTTYPE",3651464721:"IFCVEHICLETYPE",1229763772:"IFCTRIANGULATEDIRREGULARNETWORK",3665877780:"IFCTRANSPORTATIONDEVICETYPE",782932809:"IFCTHIRDORDERPOLYNOMIALSPIRAL",2735484536:"IFCSPIRAL",1356537516:"IFCSECTIONEDSURFACE",1290935644:"IFCSECTIONEDSOLIDHORIZONTAL",1862484736:"IFCSECTIONEDSOLID",1441486842:"IFCRELPOSITIONS",1033248425:"IFCRELASSOCIATESPROFILEDEF",3381221214:"IFCPOLYNOMIALCURVE",2485787929:"IFCOFFSETCURVEBYDISTANCES",590820931:"IFCOFFSETCURVE",3465909080:"IFCINDEXEDPOLYGONALTEXTUREMAP",593015953:"IFCDIRECTRIXCURVESWEPTAREASOLID",4212018352:"IFCCURVESEGMENT",3425423356:"IFCAXIS2PLACEMENTLINEAR",823603102:"IFCSEGMENT",2165702409:"IFCPOINTBYDISTANCEEXPRESSION",182550632:"IFCOPENCROSSPROFILEDEF",388784114:"IFCLINEARPLACEMENT",536804194:"IFCALIGNMENTHORIZONTALSEGMENT",3752311538:"IFCALIGNMENTCANTSEGMENT",1010789467:"IFCTEXTURECOORDINATEINDICESWITHVOIDS",222769930:"IFCTEXTURECOORDINATEINDICES",2691318326:"IFCQUANTITYNUMBER",3633395639:"IFCALIGNMENTVERTICALSEGMENT",2879124712:"IFCALIGNMENTPARAMETERSEGMENT",25142252:"IFCCONTROLLER",3087945054:"IFCALARM",4288193352:"IFCACTUATOR",630975310:"IFCUNITARYCONTROLELEMENT",4086658281:"IFCSENSOR",2295281155:"IFCPROTECTIVEDEVICETRIPPINGUNIT",182646315:"IFCFLOWINSTRUMENT",1426591983:"IFCFIRESUPPRESSIONTERMINAL",819412036:"IFCFILTER",3415622556:"IFCFAN",1003880860:"IFCELECTRICTIMECONTROL",402227799:"IFCELECTRICMOTOR",264262732:"IFCELECTRICGENERATOR",3310460725:"IFCELECTRICFLOWSTORAGEDEVICE",862014818:"IFCELECTRICDISTRIBUTIONBOARD",1904799276:"IFCELECTRICAPPLIANCE",1360408905:"IFCDUCTSILENCER",3518393246:"IFCDUCTSEGMENT",342316401:"IFCDUCTFITTING",562808652:"IFCDISTRIBUTIONCIRCUIT",4074379575:"IFCDAMPER",3640358203:"IFCCOOLINGTOWER",4136498852:"IFCCOOLEDBEAM",2272882330:"IFCCONDENSER",3571504051:"IFCCOMPRESSOR",3221913625:"IFCCOMMUNICATIONSAPPLIANCE",639361253:"IFCCOIL",3902619387:"IFCCHILLER",4217484030:"IFCCABLESEGMENT",1051757585:"IFCCABLEFITTING",3758799889:"IFCCABLECARRIERSEGMENT",635142910:"IFCCABLECARRIERFITTING",2938176219:"IFCBURNER",32344328:"IFCBOILER",2906023776:"IFCBEAMSTANDARDCASE",277319702:"IFCAUDIOVISUALAPPLIANCE",2056796094:"IFCAIRTOAIRHEATRECOVERY",177149247:"IFCAIRTERMINALBOX",1634111441:"IFCAIRTERMINAL",486154966:"IFCWINDOWSTANDARDCASE",4237592921:"IFCWASTETERMINAL",4156078855:"IFCWALLELEMENTEDCASE",4207607924:"IFCVALVE",4292641817:"IFCUNITARYEQUIPMENT",3179687236:"IFCUNITARYCONTROLELEMENTTYPE",3026737570:"IFCTUBEBUNDLE",3825984169:"IFCTRANSFORMER",812556717:"IFCTANK",1162798199:"IFCSWITCHINGDEVICE",385403989:"IFCSTRUCTURALLOADCASE",1404847402:"IFCSTACKTERMINAL",1999602285:"IFCSPACEHEATER",3420628829:"IFCSOLARDEVICE",3027962421:"IFCSLABSTANDARDCASE",3127900445:"IFCSLABELEMENTEDCASE",1329646415:"IFCSHADINGDEVICE",3053780830:"IFCSANITARYTERMINAL",2572171363:"IFCREINFORCINGBARTYPE",1232101972:"IFCRATIONALBSPLINECURVEWITHKNOTS",90941305:"IFCPUMP",655969474:"IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",738039164:"IFCPROTECTIVEDEVICE",1156407060:"IFCPLATESTANDARDCASE",3612865200:"IFCPIPESEGMENT",310824031:"IFCPIPEFITTING",3694346114:"IFCOUTLET",144952367:"IFCOUTERBOUNDARYCURVE",2474470126:"IFCMOTORCONNECTION",1911478936:"IFCMEMBERSTANDARDCASE",1437502449:"IFCMEDICALDEVICE",629592764:"IFCLIGHTFIXTURE",76236018:"IFCLAMP",2176052936:"IFCJUNCTIONBOX",4175244083:"IFCINTERCEPTOR",2068733104:"IFCHUMIDIFIER",3319311131:"IFCHEATEXCHANGER",2188021234:"IFCFLOWMETER",1209101575:"IFCEXTERNALSPATIALELEMENT",484807127:"IFCEVAPORATOR",3747195512:"IFCEVAPORATIVECOOLER",2814081492:"IFCENGINE",2417008758:"IFCELECTRICDISTRIBUTIONBOARDTYPE",3242481149:"IFCDOORSTANDARDCASE",3205830791:"IFCDISTRIBUTIONSYSTEM",400855858:"IFCCOMMUNICATIONSAPPLIANCETYPE",905975707:"IFCCOLUMNSTANDARDCASE",1677625105:"IFCCIVILELEMENT",3296154744:"IFCCHIMNEY",2674252688:"IFCCABLEFITTINGTYPE",2188180465:"IFCBURNERTYPE",1177604601:"IFCBUILDINGSYSTEM",39481116:"IFCBUILDINGELEMENTPARTTYPE",1136057603:"IFCBOUNDARYCURVE",2461110595:"IFCBSPLINECURVEWITHKNOTS",1532957894:"IFCAUDIOVISUALAPPLIANCETYPE",4088093105:"IFCWORKCALENDAR",4009809668:"IFCWINDOWTYPE",926996030:"IFCVOIDINGFEATURE",2391383451:"IFCVIBRATIONISOLATOR",2415094496:"IFCTENDONTYPE",3081323446:"IFCTENDONANCHORTYPE",413509423:"IFCSYSTEMFURNITUREELEMENT",3101698114:"IFCSURFACEFEATURE",3657597509:"IFCSTRUCTURALSURFACEACTION",2757150158:"IFCSTRUCTURALCURVEREACTION",1004757350:"IFCSTRUCTURALCURVEACTION",338393293:"IFCSTAIRTYPE",1072016465:"IFCSOLARDEVICETYPE",4074543187:"IFCSHADINGDEVICETYPE",2157484638:"IFCSEAMCURVE",2781568857:"IFCROOFTYPE",2310774935:"IFCREINFORCINGMESHTYPE",964333572:"IFCREINFORCINGELEMENTTYPE",683857671:"IFCRATIONALBSPLINESURFACEWITHKNOTS",1469900589:"IFCRAMPTYPE",2839578677:"IFCPOLYGONALFACESET",1158309216:"IFCPILETYPE",3079942009:"IFCOPENINGSTANDARDCASE",1114901282:"IFCMEDICALDEVICETYPE",3113134337:"IFCINTERSECTIONCURVE",3946677679:"IFCINTERCEPTORTYPE",2571569899:"IFCINDEXEDPOLYCURVE",3493046030:"IFCGEOGRAPHICELEMENT",1509553395:"IFCFURNITURE",1893162501:"IFCFOOTINGTYPE",2853485674:"IFCEXTERNALSPATIALSTRUCTUREELEMENT",4148101412:"IFCEVENT",132023988:"IFCENGINETYPE",2397081782:"IFCELEMENTASSEMBLYTYPE",2323601079:"IFCDOORTYPE",1213902940:"IFCCYLINDRICALSURFACE",1525564444:"IFCCONSTRUCTIONPRODUCTRESOURCETYPE",4105962743:"IFCCONSTRUCTIONMATERIALRESOURCETYPE",2185764099:"IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",15328376:"IFCCOMPOSITECURVEONSURFACE",3875453745:"IFCCOMPLEXPROPERTYTEMPLATE",3893394355:"IFCCIVILELEMENTTYPE",2197970202:"IFCCHIMNEYTYPE",167062518:"IFCBSPLINESURFACEWITHKNOTS",2887950389:"IFCBSPLINESURFACE",2603310189:"IFCADVANCEDBREPWITHVOIDS",1635779807:"IFCADVANCEDBREP",2916149573:"IFCTRIANGULATEDFACESET",1935646853:"IFCTOROIDALSURFACE",2387106220:"IFCTESSELLATEDFACESET",3206491090:"IFCTASKTYPE",699246055:"IFCSURFACECURVE",4095615324:"IFCSUBCONTRACTRESOURCETYPE",603775116:"IFCSTRUCTURALSURFACEREACTION",4015995234:"IFCSPHERICALSURFACE",2481509218:"IFCSPATIALZONETYPE",463610769:"IFCSPATIALZONE",710998568:"IFCSPATIALELEMENTTYPE",1412071761:"IFCSPATIALELEMENT",3663146110:"IFCSIMPLEPROPERTYTEMPLATE",3243963512:"IFCREVOLVEDAREASOLIDTAPERED",816062949:"IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",1521410863:"IFCRELSPACEBOUNDARY2NDLEVEL",3523091289:"IFCRELSPACEBOUNDARY1STLEVEL",427948657:"IFCRELINTERFERESELEMENTS",307848117:"IFCRELDEFINESBYTEMPLATE",1462361463:"IFCRELDEFINESBYOBJECT",2565941209:"IFCRELDECLARES",1027710054:"IFCRELASSIGNSTOGROUPBYFACTOR",3521284610:"IFCPROPERTYTEMPLATE",492091185:"IFCPROPERTYSETTEMPLATE",653396225:"IFCPROJECTLIBRARY",569719735:"IFCPROCEDURETYPE",3967405729:"IFCPREDEFINEDPROPERTYSET",1682466193:"IFCPCURVE",428585644:"IFCLABORRESOURCETYPE",2294589976:"IFCINDEXEDPOLYGONALFACEWITHVOIDS",178912537:"IFCINDEXEDPOLYGONALFACE",4095422895:"IFCGEOGRAPHICELEMENTTYPE",2652556860:"IFCFIXEDREFERENCESWEPTAREASOLID",2804161546:"IFCEXTRUDEDAREASOLIDTAPERED",4024345920:"IFCEVENTTYPE",2629017746:"IFCCURVEBOUNDEDSURFACE",1815067380:"IFCCREWRESOURCETYPE",3419103109:"IFCCONTEXT",2574617495:"IFCCONSTRUCTIONRESOURCETYPE",2059837836:"IFCCARTESIANPOINTLIST3D",1675464909:"IFCCARTESIANPOINTLIST2D",574549367:"IFCCARTESIANPOINTLIST",3406155212:"IFCADVANCEDFACE",3698973494:"IFCTYPERESOURCE",3736923433:"IFCTYPEPROCESS",901063453:"IFCTESSELLATEDITEM",1096409881:"IFCSWEPTDISKSOLIDPOLYGONAL",1042787934:"IFCRESOURCETIME",1608871552:"IFCRESOURCECONSTRAINTRELATIONSHIP",2943643501:"IFCRESOURCEAPPROVALRELATIONSHIP",2090586900:"IFCQUANTITYSET",1482703590:"IFCPROPERTYTEMPLATEDEFINITION",3778827333:"IFCPREDEFINEDPROPERTIES",2998442950:"IFCMIRROREDPROFILEDEF",853536259:"IFCMATERIALRELATIONSHIP",3404854881:"IFCMATERIALPROFILESETUSAGETAPERING",3079605661:"IFCMATERIALPROFILESETUSAGE",2852063980:"IFCMATERIALCONSTITUENTSET",3708119e3:"IFCMATERIALCONSTITUENT",1585845231:"IFCLAGTIME",2133299955:"IFCINDEXEDTRIANGLETEXTUREMAP",1437953363:"IFCINDEXEDTEXTUREMAP",3570813810:"IFCINDEXEDCOLOURMAP",1437805879:"IFCEXTERNALREFERENCERELATIONSHIP",297599258:"IFCEXTENDEDPROPERTIES",211053100:"IFCEVENTTIME",2713554722:"IFCCONVERSIONBASEDUNITWITHOFFSET",3285139300:"IFCCOLOURRGBLIST",1236880293:"IFCWORKTIME",1199560280:"IFCTIMEPERIOD",3611470254:"IFCTEXTUREVERTEXLIST",2771591690:"IFCTASKTIMERECURRING",1549132990:"IFCTASKTIME",2043862942:"IFCTABLECOLUMN",2934153892:"IFCSURFACEREINFORCEMENTAREA",609421318:"IFCSTRUCTURALLOADORRESULT",3478079324:"IFCSTRUCTURALLOADCONFIGURATION",1054537805:"IFCSCHEDULINGTIME",2439245199:"IFCRESOURCELEVELRELATIONSHIP",2433181523:"IFCREFERENCE",3915482550:"IFCRECURRENCEPATTERN",986844984:"IFCPROPERTYABSTRACTION",3843373140:"IFCPROJECTEDCRS",677532197:"IFCPRESENTATIONITEM",1507914824:"IFCMATERIALUSAGEDEFINITION",552965576:"IFCMATERIALPROFILEWITHOFFSETS",164193824:"IFCMATERIALPROFILESET",2235152071:"IFCMATERIALPROFILE",1847252529:"IFCMATERIALLAYERWITHOFFSETS",760658860:"IFCMATERIALDEFINITION",3057273783:"IFCMAPCONVERSION",4294318154:"IFCEXTERNALINFORMATION",1466758467:"IFCCOORDINATEREFERENCESYSTEM",1785450214:"IFCCOORDINATEOPERATION",775493141:"IFCCONNECTIONVOLUMEGEOMETRY",979691226:"IFCREINFORCINGBAR",3700593921:"IFCELECTRICDISTRIBUTIONPOINT",1062813311:"IFCDISTRIBUTIONCONTROLELEMENT",1052013943:"IFCDISTRIBUTIONCHAMBERELEMENT",578613899:"IFCCONTROLLERTYPE",2454782716:"IFCCHAMFEREDGEFEATURE",753842376:"IFCBEAM",3001207471:"IFCALARMTYPE",2874132201:"IFCACTUATORTYPE",3304561284:"IFCWINDOW",3512223829:"IFCWALLSTANDARDCASE",2391406946:"IFCWALL",3313531582:"IFCVIBRATIONISOLATORTYPE",2347447852:"IFCTENDONANCHOR",3824725483:"IFCTENDON",2515109513:"IFCSTRUCTURALANALYSISMODEL",4252922144:"IFCSTAIRFLIGHT",331165859:"IFCSTAIR",1529196076:"IFCSLAB",1783015770:"IFCSENSORTYPE",1376911519:"IFCROUNDEDEDGEFEATURE",2016517767:"IFCROOF",2320036040:"IFCREINFORCINGMESH",3027567501:"IFCREINFORCINGELEMENT",3055160366:"IFCRATIONALBEZIERCURVE",3283111854:"IFCRAMPFLIGHT",3024970846:"IFCRAMP",2262370178:"IFCRAILING",3171933400:"IFCPLATE",1687234759:"IFCPILE",1073191201:"IFCMEMBER",900683007:"IFCFOOTING",3508470533:"IFCFLOWTREATMENTDEVICE",2223149337:"IFCFLOWTERMINAL",707683696:"IFCFLOWSTORAGEDEVICE",987401354:"IFCFLOWSEGMENT",3132237377:"IFCFLOWMOVINGDEVICE",4037862832:"IFCFLOWINSTRUMENTTYPE",4278956645:"IFCFLOWFITTING",2058353004:"IFCFLOWCONTROLLER",4222183408:"IFCFIRESUPPRESSIONTERMINALTYPE",1810631287:"IFCFILTERTYPE",346874300:"IFCFANTYPE",1658829314:"IFCENERGYCONVERSIONDEVICE",857184966:"IFCELECTRICALELEMENT",1634875225:"IFCELECTRICALCIRCUIT",712377611:"IFCELECTRICTIMECONTROLTYPE",1217240411:"IFCELECTRICMOTORTYPE",1365060375:"IFCELECTRICHEATERTYPE",1534661035:"IFCELECTRICGENERATORTYPE",3277789161:"IFCELECTRICFLOWSTORAGEDEVICETYPE",663422040:"IFCELECTRICAPPLIANCETYPE",855621170:"IFCEDGEFEATURE",2030761528:"IFCDUCTSILENCERTYPE",3760055223:"IFCDUCTSEGMENTTYPE",869906466:"IFCDUCTFITTINGTYPE",395920057:"IFCDOOR",3041715199:"IFCDISTRIBUTIONPORT",3040386961:"IFCDISTRIBUTIONFLOWELEMENT",1945004755:"IFCDISTRIBUTIONELEMENT",2063403501:"IFCDISTRIBUTIONCONTROLELEMENTTYPE",1599208980:"IFCDISTRIBUTIONCHAMBERELEMENTTYPE",2635815018:"IFCDISCRETEACCESSORYTYPE",1335981549:"IFCDISCRETEACCESSORY",4147604152:"IFCDIAMETERDIMENSION",3961806047:"IFCDAMPERTYPE",3495092785:"IFCCURTAINWALL",1973544240:"IFCCOVERING",2954562838:"IFCCOOLINGTOWERTYPE",335055490:"IFCCOOLEDBEAMTYPE",488727124:"IFCCONSTRUCTIONPRODUCTRESOURCE",1060000209:"IFCCONSTRUCTIONMATERIALRESOURCE",3898045240:"IFCCONSTRUCTIONEQUIPMENTRESOURCE",1163958913:"IFCCONDITIONCRITERION",2188551683:"IFCCONDITION",2816379211:"IFCCONDENSERTYPE",3850581409:"IFCCOMPRESSORTYPE",843113511:"IFCCOLUMN",2301859152:"IFCCOILTYPE",2611217952:"IFCCIRCLE",2951183804:"IFCCHILLERTYPE",1285652485:"IFCCABLESEGMENTTYPE",3293546465:"IFCCABLECARRIERSEGMENTTYPE",395041908:"IFCCABLECARRIERFITTINGTYPE",1909888760:"IFCBUILDINGELEMENTPROXYTYPE",1095909175:"IFCBUILDINGELEMENTPROXY",2979338954:"IFCBUILDINGELEMENTPART",52481810:"IFCBUILDINGELEMENTCOMPONENT",3299480353:"IFCBUILDINGELEMENT",231477066:"IFCBOILERTYPE",1916977116:"IFCBEZIERCURVE",819618141:"IFCBEAMTYPE",1967976161:"IFCBSPLINECURVE",3460190687:"IFCASSET",2470393545:"IFCANGULARDIMENSION",1871374353:"IFCAIRTOAIRHEATRECOVERYTYPE",3352864051:"IFCAIRTERMINALTYPE",1411407467:"IFCAIRTERMINALBOXTYPE",3821786052:"IFCACTIONREQUEST",1213861670:"IFC2DCOMPOSITECURVE",1033361043:"IFCZONE",3342526732:"IFCWORKSCHEDULE",4218914973:"IFCWORKPLAN",1028945134:"IFCWORKCONTROL",1133259667:"IFCWASTETERMINALTYPE",1898987631:"IFCWALLTYPE",2769231204:"IFCVIRTUALELEMENT",728799441:"IFCVALVETYPE",1911125066:"IFCUNITARYEQUIPMENTTYPE",1600972822:"IFCTUBEBUNDLETYPE",3593883385:"IFCTRIMMEDCURVE",1620046519:"IFCTRANSPORTELEMENT",1692211062:"IFCTRANSFORMERTYPE",1637806684:"IFCTIMESERIESSCHEDULE",5716631:"IFCTANKTYPE",2254336722:"IFCSYSTEM",2315554128:"IFCSWITCHINGDEVICETYPE",148013059:"IFCSUBCONTRACTRESOURCE",1975003073:"IFCSTRUCTURALSURFACECONNECTION",2986769608:"IFCSTRUCTURALRESULTGROUP",1235345126:"IFCSTRUCTURALPOINTREACTION",734778138:"IFCSTRUCTURALPOINTCONNECTION",2082059205:"IFCSTRUCTURALPOINTACTION",3987759626:"IFCSTRUCTURALPLANARACTIONVARYING",1621171031:"IFCSTRUCTURALPLANARACTION",1252848954:"IFCSTRUCTURALLOADGROUP",1721250024:"IFCSTRUCTURALLINEARACTIONVARYING",1807405624:"IFCSTRUCTURALLINEARACTION",2445595289:"IFCSTRUCTURALCURVEMEMBERVARYING",214636428:"IFCSTRUCTURALCURVEMEMBER",4243806635:"IFCSTRUCTURALCURVECONNECTION",1179482911:"IFCSTRUCTURALCONNECTION",682877961:"IFCSTRUCTURALACTION",1039846685:"IFCSTAIRFLIGHTTYPE",3112655638:"IFCSTACKTERMINALTYPE",3812236995:"IFCSPACETYPE",652456506:"IFCSPACEPROGRAM",1305183839:"IFCSPACEHEATERTYPE",3856911033:"IFCSPACE",2533589738:"IFCSLABTYPE",4097777520:"IFCSITE",4105383287:"IFCSERVICELIFE",3517283431:"IFCSCHEDULETIMECONTROL",1768891740:"IFCSANITARYTERMINALTYPE",2863920197:"IFCRELASSIGNSTASKS",160246688:"IFCRELAGGREGATES",2324767716:"IFCRAMPFLIGHTTYPE",2893384427:"IFCRAILINGTYPE",3248260540:"IFCRADIUSDIMENSION",2250791053:"IFCPUMPTYPE",1842657554:"IFCPROTECTIVEDEVICETYPE",3651124850:"IFCPROJECTIONELEMENT",3642467123:"IFCPROJECTORDERRECORD",2904328755:"IFCPROJECTORDER",2744685151:"IFCPROCEDURE",3740093272:"IFCPORT",3724593414:"IFCPOLYLINE",4017108033:"IFCPLATETYPE",4231323485:"IFCPIPESEGMENTTYPE",804291784:"IFCPIPEFITTINGTYPE",3327091369:"IFCPERMIT",2382730787:"IFCPERFORMANCEHISTORY",2837617999:"IFCOUTLETTYPE",3425660407:"IFCORDERACTION",3588315303:"IFCOPENINGELEMENT",4143007308:"IFCOCCUPANT",1916936684:"IFCMOVE",977012517:"IFCMOTORCONNECTIONTYPE",3181161470:"IFCMEMBERTYPE",2108223431:"IFCMECHANICALFASTENERTYPE",377706215:"IFCMECHANICALFASTENER",2506943328:"IFCLINEARDIMENSION",1161773419:"IFCLIGHTFIXTURETYPE",1051575348:"IFCLAMPTYPE",3827777499:"IFCLABORRESOURCE",4288270099:"IFCJUNCTIONBOXTYPE",2391368822:"IFCINVENTORY",1806887404:"IFCHUMIDIFIERTYPE",1251058090:"IFCHEATEXCHANGERTYPE",2706460486:"IFCGROUP",3009204131:"IFCGRID",200128114:"IFCGASTERMINALTYPE",814719939:"IFCFURNITURESTANDARD",263784265:"IFCFURNISHINGELEMENT",3009222698:"IFCFLOWTREATMENTDEVICETYPE",2297155007:"IFCFLOWTERMINALTYPE",1339347760:"IFCFLOWSTORAGEDEVICETYPE",1834744321:"IFCFLOWSEGMENTTYPE",1482959167:"IFCFLOWMOVINGDEVICETYPE",3815607619:"IFCFLOWMETERTYPE",3198132628:"IFCFLOWFITTINGTYPE",3907093117:"IFCFLOWCONTROLLERTYPE",1287392070:"IFCFEATUREELEMENTSUBTRACTION",2143335405:"IFCFEATUREELEMENTADDITION",2827207264:"IFCFEATUREELEMENT",2489546625:"IFCFASTENERTYPE",647756555:"IFCFASTENER",3737207727:"IFCFACETEDBREPWITHVOIDS",807026263:"IFCFACETEDBREP",3390157468:"IFCEVAPORATORTYPE",3174744832:"IFCEVAPORATIVECOOLERTYPE",3272907226:"IFCEQUIPMENTSTANDARD",1962604670:"IFCEQUIPMENTELEMENT",2107101300:"IFCENERGYCONVERSIONDEVICETYPE",1704287377:"IFCELLIPSE",2590856083:"IFCELEMENTCOMPONENTTYPE",1623761950:"IFCELEMENTCOMPONENT",4123344466:"IFCELEMENTASSEMBLY",1758889154:"IFCELEMENT",360485395:"IFCELECTRICALBASEPROPERTIES",3849074793:"IFCDISTRIBUTIONFLOWELEMENTTYPE",3256556792:"IFCDISTRIBUTIONELEMENTTYPE",681481545:"IFCDIMENSIONCURVEDIRECTEDCALLOUT",1457835157:"IFCCURTAINWALLTYPE",3295246426:"IFCCREWRESOURCE",1916426348:"IFCCOVERINGTYPE",1419761937:"IFCCOSTSCHEDULE",3895139033:"IFCCOSTITEM",3293443760:"IFCCONTROL",2559216714:"IFCCONSTRUCTIONRESOURCE",2510884976:"IFCCONIC",3732776249:"IFCCOMPOSITECURVE",300633059:"IFCCOLUMNTYPE",2937912522:"IFCCIRCLEHOLLOWPROFILEDEF",3124254112:"IFCBUILDINGSTOREY",1950629157:"IFCBUILDINGELEMENTTYPE",4031249490:"IFCBUILDING",1260505505:"IFCBOUNDEDCURVE",3649129432:"IFCBOOLEANCLIPPINGRESULT",1334484129:"IFCBLOCK",3207858831:"IFCASYMMETRICISHAPEPROFILEDEF",1674181508:"IFCANNOTATION",2296667514:"IFCACTOR",2097647324:"IFCTRANSPORTELEMENTTYPE",3473067441:"IFCTASK",1580310250:"IFCSYSTEMFURNITUREELEMENTTYPE",4124788165:"IFCSURFACEOFREVOLUTION",2809605785:"IFCSURFACEOFLINEAREXTRUSION",2028607225:"IFCSURFACECURVESWEPTAREASOLID",4070609034:"IFCSTRUCTUREDDIMENSIONCALLOUT",2218152070:"IFCSTRUCTURALSURFACEMEMBERVARYING",3979015343:"IFCSTRUCTURALSURFACEMEMBER",3689010777:"IFCSTRUCTURALREACTION",530289379:"IFCSTRUCTURALMEMBER",3136571912:"IFCSTRUCTURALITEM",3544373492:"IFCSTRUCTURALACTIVITY",451544542:"IFCSPHERE",3893378262:"IFCSPATIALSTRUCTUREELEMENTTYPE",2706606064:"IFCSPATIALSTRUCTUREELEMENT",3626867408:"IFCRIGHTCIRCULARCYLINDER",4158566097:"IFCRIGHTCIRCULARCONE",1856042241:"IFCREVOLVEDAREASOLID",2914609552:"IFCRESOURCE",1401173127:"IFCRELVOIDSELEMENT",3451746338:"IFCRELSPACEBOUNDARY",366585022:"IFCRELSERVICESBUILDINGS",4122056220:"IFCRELSEQUENCE",1058617721:"IFCRELSCHEDULESCOSTITEMS",1245217292:"IFCRELREFERENCEDINSPATIALSTRUCTURE",750771296:"IFCRELPROJECTSELEMENT",202636808:"IFCRELOVERRIDESPROPERTIES",2051452291:"IFCRELOCCUPIESSPACES",3268803585:"IFCRELNESTS",4189434867:"IFCRELINTERACTIONREQUIREMENTS",279856033:"IFCRELFLOWCONTROLELEMENTS",3940055652:"IFCRELFILLSELEMENT",781010003:"IFCRELDEFINESBYTYPE",4186316022:"IFCRELDEFINESBYPROPERTIES",693640335:"IFCRELDEFINES",2551354335:"IFCRELDECOMPOSES",2802773753:"IFCRELCOVERSSPACES",886880790:"IFCRELCOVERSBLDGELEMENTS",3242617779:"IFCRELCONTAINEDINSPATIALSTRUCTURE",3678494232:"IFCRELCONNECTSWITHREALIZINGELEMENTS",504942748:"IFCRELCONNECTSWITHECCENTRICITY",1638771189:"IFCRELCONNECTSSTRUCTURALMEMBER",3912681535:"IFCRELCONNECTSSTRUCTURALELEMENT",2127690289:"IFCRELCONNECTSSTRUCTURALACTIVITY",3190031847:"IFCRELCONNECTSPORTS",4201705270:"IFCRELCONNECTSPORTTOELEMENT",3945020480:"IFCRELCONNECTSPATHELEMENTS",1204542856:"IFCRELCONNECTSELEMENTS",826625072:"IFCRELCONNECTS",2851387026:"IFCRELASSOCIATESPROFILEPROPERTIES",2655215786:"IFCRELASSOCIATESMATERIAL",3840914261:"IFCRELASSOCIATESLIBRARY",982818633:"IFCRELASSOCIATESDOCUMENT",2728634034:"IFCRELASSOCIATESCONSTRAINT",919958153:"IFCRELASSOCIATESCLASSIFICATION",4095574036:"IFCRELASSOCIATESAPPROVAL",1327628568:"IFCRELASSOCIATESAPPLIEDVALUE",1865459582:"IFCRELASSOCIATES",205026976:"IFCRELASSIGNSTORESOURCE",3372526763:"IFCRELASSIGNSTOPROJECTORDER",2857406711:"IFCRELASSIGNSTOPRODUCT",4278684876:"IFCRELASSIGNSTOPROCESS",1307041759:"IFCRELASSIGNSTOGROUP",2495723537:"IFCRELASSIGNSTOCONTROL",1683148259:"IFCRELASSIGNSTOACTOR",3939117080:"IFCRELASSIGNS",3454111270:"IFCRECTANGULARTRIMMEDSURFACE",2798486643:"IFCRECTANGULARPYRAMID",2770003689:"IFCRECTANGLEHOLLOWPROFILEDEF",3219374653:"IFCPROXY",1451395588:"IFCPROPERTYSET",4194566429:"IFCPROJECTIONCURVE",103090709:"IFCPROJECT",4208778838:"IFCPRODUCT",2945172077:"IFCPROCESS",220341763:"IFCPLANE",603570806:"IFCPLANARBOX",3566463478:"IFCPERMEABLECOVERINGPROPERTIES",3505215534:"IFCOFFSETCURVE3D",3388369263:"IFCOFFSETCURVE2D",3888040117:"IFCOBJECT",1425443689:"IFCMANIFOLDSOLIDBREP",1281925730:"IFCLINE",572779678:"IFCLSHAPEPROFILEDEF",1484403080:"IFCISHAPEPROFILEDEF",987898635:"IFCGEOMETRICCURVESET",1268542332:"IFCFURNITURETYPE",4238390223:"IFCFURNISHINGELEMENTTYPE",3455213021:"IFCFLUIDFLOWPROPERTIES",315944413:"IFCFILLAREASTYLETILES",4203026998:"IFCFILLAREASTYLETILESYMBOLWITHSTYLE",374418227:"IFCFILLAREASTYLEHATCHING",2047409740:"IFCFACEBASEDSURFACEMODEL",477187591:"IFCEXTRUDEDAREASOLID",80994333:"IFCENERGYPROPERTIES",2835456948:"IFCELLIPSEPROFILEDEF",2777663545:"IFCELEMENTARYSURFACE",339256511:"IFCELEMENTTYPE",1883228015:"IFCELEMENTQUANTITY",1472233963:"IFCEDGELOOP",4006246654:"IFCDRAUGHTINGPREDEFINEDCURVEFONT",445594917:"IFCDRAUGHTINGPREDEFINEDCOLOUR",3073041342:"IFCDRAUGHTINGCALLOUT",526551008:"IFCDOORSTYLE",1714330368:"IFCDOORPANELPROPERTIES",2963535650:"IFCDOORLININGPROPERTIES",32440307:"IFCDIRECTION",4054601972:"IFCDIMENSIONCURVETERMINATOR",606661476:"IFCDIMENSIONCURVE",693772133:"IFCDEFINEDSYMBOL",2827736869:"IFCCURVEBOUNDEDPLANE",2601014836:"IFCCURVE",2147822146:"IFCCSGSOLID",2506170314:"IFCCSGPRIMITIVE3D",194851669:"IFCCRANERAILFSHAPEPROFILEDEF",4133800736:"IFCCRANERAILASHAPEPROFILEDEF",2485617015:"IFCCOMPOSITECURVESEGMENT",2205249479:"IFCCLOSEDSHELL",1383045692:"IFCCIRCLEPROFILEDEF",1416205885:"IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",3331915920:"IFCCARTESIANTRANSFORMATIONOPERATOR3D",3486308946:"IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",3749851601:"IFCCARTESIANTRANSFORMATIONOPERATOR2D",59481748:"IFCCARTESIANTRANSFORMATIONOPERATOR",1123145078:"IFCCARTESIANPOINT",2898889636:"IFCCSHAPEPROFILEDEF",2713105998:"IFCBOXEDHALFSPACE",2581212453:"IFCBOUNDINGBOX",4182860854:"IFCBOUNDEDSURFACE",2736907675:"IFCBOOLEANRESULT",2740243338:"IFCAXIS2PLACEMENT3D",3125803723:"IFCAXIS2PLACEMENT2D",4261334040:"IFCAXIS1PLACEMENT",1302238472:"IFCANNOTATIONSURFACE",2265737646:"IFCANNOTATIONFILLAREAOCCURRENCE",669184980:"IFCANNOTATIONFILLAREA",3288037868:"IFCANNOTATIONCURVEOCCURRENCE",2543172580:"IFCZSHAPEPROFILEDEF",1299126871:"IFCWINDOWSTYLE",512836454:"IFCWINDOWPANELPROPERTIES",336235671:"IFCWINDOWLININGPROPERTIES",2759199220:"IFCVERTEXLOOP",1417489154:"IFCVECTOR",427810014:"IFCUSHAPEPROFILEDEF",2347495698:"IFCTYPEPRODUCT",1628702193:"IFCTYPEOBJECT",1345879162:"IFCTWODIRECTIONREPEATFACTOR",2715220739:"IFCTRAPEZIUMPROFILEDEF",3124975700:"IFCTEXTLITERALWITHEXTENT",4282788508:"IFCTEXTLITERAL",3028897424:"IFCTERMINATORSYMBOL",3071757647:"IFCTSHAPEPROFILEDEF",230924584:"IFCSWEPTSURFACE",1260650574:"IFCSWEPTDISKSOLID",2247615214:"IFCSWEPTAREASOLID",1878645084:"IFCSURFACESTYLERENDERING",2513912981:"IFCSURFACE",2233826070:"IFCSUBEDGE",3653947884:"IFCSTRUCTURALSTEELPROFILEPROPERTIES",3843319758:"IFCSTRUCTURALPROFILEPROPERTIES",1190533807:"IFCSTRUCTURALLOADSINGLEFORCEWARPING",1597423693:"IFCSTRUCTURALLOADSINGLEFORCE",1973038258:"IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",2473145415:"IFCSTRUCTURALLOADSINGLEDISPLACEMENT",2668620305:"IFCSTRUCTURALLOADPLANARFORCE",1595516126:"IFCSTRUCTURALLOADLINEARFORCE",390701378:"IFCSPACETHERMALLOADPROPERTIES",1202362311:"IFCSOUNDVALUE",2485662743:"IFCSOUNDPROPERTIES",723233188:"IFCSOLIDMODEL",2609359061:"IFCSLIPPAGECONNECTIONCONDITION",4124623270:"IFCSHELLBASEDSURFACEMODEL",2411513650:"IFCSERVICELIFEFACTOR",1509187699:"IFCSECTIONEDSPINE",2778083089:"IFCROUNDEDRECTANGLEPROFILEDEF",478536968:"IFCRELATIONSHIP",3765753017:"IFCREINFORCEMENTDEFINITIONPROPERTIES",3413951693:"IFCREGULARTIMESERIES",3615266464:"IFCRECTANGLEPROFILEDEF",110355661:"IFCPROPERTYTABLEVALUE",3650150729:"IFCPROPERTYSINGLEVALUE",3357820518:"IFCPROPERTYSETDEFINITION",941946838:"IFCPROPERTYREFERENCEVALUE",2752243245:"IFCPROPERTYLISTVALUE",4166981789:"IFCPROPERTYENUMERATEDVALUE",1680319473:"IFCPROPERTYDEFINITION",871118103:"IFCPROPERTYBOUNDEDVALUE",673634403:"IFCPRODUCTDEFINITIONSHAPE",179317114:"IFCPREDEFINEDPOINTMARKERSYMBOL",433424934:"IFCPREDEFINEDDIMENSIONSYMBOL",2559016684:"IFCPREDEFINEDCURVEFONT",759155922:"IFCPREDEFINEDCOLOUR",2775532180:"IFCPOLYGONALBOUNDEDHALFSPACE",2924175390:"IFCPOLYLOOP",1423911732:"IFCPOINTONSURFACE",4022376103:"IFCPOINTONCURVE",2067069095:"IFCPOINT",1663979128:"IFCPLANAREXTENT",2004835150:"IFCPLACEMENT",597895409:"IFCPIXELTEXTURE",3021840470:"IFCPHYSICALCOMPLEXQUANTITY",2519244187:"IFCPATH",2529465313:"IFCPARAMETERIZEDPROFILEDEF",1029017970:"IFCORIENTEDEDGE",2665983363:"IFCOPENSHELL",2833995503:"IFCONEDIRECTIONREPEATFACTOR",219451334:"IFCOBJECTDEFINITION",1430189142:"IFCMECHANICALCONCRETEMATERIALPROPERTIES",2022407955:"IFCMATERIALDEFINITIONREPRESENTATION",2347385850:"IFCMAPPEDITEM",1008929658:"IFCLOOP",2624227202:"IFCLOCALPLACEMENT",3422422726:"IFCLIGHTSOURCESPOT",1520743889:"IFCLIGHTSOURCEPOSITIONAL",4266656042:"IFCLIGHTSOURCEGONIOMETRIC",2604431987:"IFCLIGHTSOURCEDIRECTIONAL",125510826:"IFCLIGHTSOURCEAMBIENT",1402838566:"IFCLIGHTSOURCE",3741457305:"IFCIRREGULARTIMESERIES",3905492369:"IFCIMAGETEXTURE",2445078500:"IFCHYGROSCOPICMATERIALPROPERTIES",812098782:"IFCHALFSPACESOLID",178086475:"IFCGRIDPLACEMENT",3590301190:"IFCGEOMETRICSET",4142052618:"IFCGEOMETRICREPRESENTATIONSUBCONTEXT",2453401579:"IFCGEOMETRICREPRESENTATIONITEM",3448662350:"IFCGEOMETRICREPRESENTATIONCONTEXT",1446786286:"IFCGENERALPROFILEPROPERTIES",803998398:"IFCGENERALMATERIALPROPERTIES",3857492461:"IFCFUELPROPERTIES",738692330:"IFCFILLAREASTYLE",4219587988:"IFCFAILURECONNECTIONCONDITION",3008276851:"IFCFACESURFACE",803316827:"IFCFACEOUTERBOUND",1809719519:"IFCFACEBOUND",2556980723:"IFCFACE",1860660968:"IFCEXTENDEDMATERIALPROPERTIES",476780140:"IFCEDGECURVE",3900360178:"IFCEDGE",4170525392:"IFCDRAUGHTINGPREDEFINEDTEXTFONT",3732053477:"IFCDOCUMENTREFERENCE",1694125774:"IFCDIMENSIONPAIR",2273265877:"IFCDIMENSIONCALLOUTRELATIONSHIP",3632507154:"IFCDERIVEDPROFILEDEF",3800577675:"IFCCURVESTYLE",2889183280:"IFCCONVERSIONBASEDUNIT",3050246964:"IFCCONTEXTDEPENDENTUNIT",45288368:"IFCCONNECTIONPOINTECCENTRICITY",1981873012:"IFCCONNECTIONCURVEGEOMETRY",370225590:"IFCCONNECTEDFACESET",1485152156:"IFCCOMPOSITEPROFILEDEF",2542286263:"IFCCOMPLEXPROPERTY",776857604:"IFCCOLOURRGB",647927063:"IFCCLASSIFICATIONREFERENCE",3150382593:"IFCCENTERLINEPROFILEDEF",616511568:"IFCBLOBTEXTURE",2705031697:"IFCARBITRARYPROFILEDEFWITHVOIDS",1310608509:"IFCARBITRARYOPENPROFILEDEF",3798115385:"IFCARBITRARYCLOSEDPROFILEDEF",2297822566:"IFCANNOTATIONTEXTOCCURRENCE",3612888222:"IFCANNOTATIONSYMBOLOCCURRENCE",962685235:"IFCANNOTATIONSURFACEOCCURRENCE",2442683028:"IFCANNOTATIONOCCURRENCE",1065908215:"IFCWATERPROPERTIES",891718957:"IFCVIRTUALGRIDINTERSECTION",1907098498:"IFCVERTEXPOINT",3304826586:"IFCVERTEXBASEDTEXTUREMAP",2799835756:"IFCVERTEX",180925521:"IFCUNITASSIGNMENT",1735638870:"IFCTOPOLOGYREPRESENTATION",1377556343:"IFCTOPOLOGICALREPRESENTATIONITEM",581633288:"IFCTIMESERIESVALUE",1718945513:"IFCTIMESERIESREFERENCERELATIONSHIP",3101149627:"IFCTIMESERIES",3317419933:"IFCTHERMALMATERIALPROPERTIES",1210645708:"IFCTEXTUREVERTEX",2552916305:"IFCTEXTUREMAP",1742049831:"IFCTEXTURECOORDINATEGENERATOR",280115917:"IFCTEXTURECOORDINATE",1484833681:"IFCTEXTSTYLEWITHBOXCHARACTERISTICS",1640371178:"IFCTEXTSTYLETEXTMODEL",2636378356:"IFCTEXTSTYLEFORDEFINEDFONT",1983826977:"IFCTEXTSTYLEFONTMODEL",1447204868:"IFCTEXTSTYLE",912023232:"IFCTELECOMADDRESS",531007025:"IFCTABLEROW",985171141:"IFCTABLE",1290481447:"IFCSYMBOLSTYLE",626085974:"IFCSURFACETEXTURE",1351298697:"IFCSURFACESTYLEWITHTEXTURES",846575682:"IFCSURFACESTYLESHADING",1607154358:"IFCSURFACESTYLEREFRACTION",3303107099:"IFCSURFACESTYLELIGHTING",1300840506:"IFCSURFACESTYLE",3049322572:"IFCSTYLEDREPRESENTATION",3958052878:"IFCSTYLEDITEM",2830218821:"IFCSTYLEMODEL",3408363356:"IFCSTRUCTURALLOADTEMPERATURE",2525727697:"IFCSTRUCTURALLOADSTATIC",2162789131:"IFCSTRUCTURALLOAD",2273995522:"IFCSTRUCTURALCONNECTIONCONDITION",3692461612:"IFCSIMPLEPROPERTY",4240577450:"IFCSHAPEREPRESENTATION",3982875396:"IFCSHAPEMODEL",867548509:"IFCSHAPEASPECT",4165799628:"IFCSECTIONREINFORCEMENTPROPERTIES",2042790032:"IFCSECTIONPROPERTIES",448429030:"IFCSIUNIT",2341007311:"IFCROOT",3679540991:"IFCRIBPLATEPROFILEPROPERTIES",1660063152:"IFCREPRESENTATIONMAP",3008791417:"IFCREPRESENTATIONITEM",3377609919:"IFCREPRESENTATIONCONTEXT",1076942058:"IFCREPRESENTATION",1222501353:"IFCRELAXATION",1580146022:"IFCREINFORCEMENTBARPROPERTIES",2692823254:"IFCREFERENCESVALUEDOCUMENT",825690147:"IFCQUANTITYWEIGHT",2405470396:"IFCQUANTITYVOLUME",3252649465:"IFCQUANTITYTIME",931644368:"IFCQUANTITYLENGTH",2093928680:"IFCQUANTITYCOUNT",2044713172:"IFCQUANTITYAREA",3710013099:"IFCPROPERTYENUMERATION",148025276:"IFCPROPERTYDEPENDENCYRELATIONSHIP",3896028662:"IFCPROPERTYCONSTRAINTRELATIONSHIP",2598011224:"IFCPROPERTY",2802850158:"IFCPROFILEPROPERTIES",3958567839:"IFCPROFILEDEF",2267347899:"IFCPRODUCTSOFCOMBUSTIONPROPERTIES",2095639259:"IFCPRODUCTREPRESENTATION",2417041796:"IFCPRESENTATIONSTYLEASSIGNMENT",3119450353:"IFCPRESENTATIONSTYLE",1304840413:"IFCPRESENTATIONLAYERWITHSTYLE",2022622350:"IFCPRESENTATIONLAYERASSIGNMENT",1775413392:"IFCPREDEFINEDTEXTFONT",3213052703:"IFCPREDEFINEDTERMINATORSYMBOL",990879717:"IFCPREDEFINEDSYMBOL",3727388367:"IFCPREDEFINEDITEM",3355820592:"IFCPOSTALADDRESS",2226359599:"IFCPHYSICALSIMPLEQUANTITY",2483315170:"IFCPHYSICALQUANTITY",101040310:"IFCPERSONANDORGANIZATION",2077209135:"IFCPERSON",1207048766:"IFCOWNERHISTORY",1411181986:"IFCORGANIZATIONRELATIONSHIP",4251960020:"IFCORGANIZATION",1227763645:"IFCOPTICALMATERIALPROPERTIES",2251480897:"IFCOBJECTIVE",3701648758:"IFCOBJECTPLACEMENT",1918398963:"IFCNAMEDUNIT",2706619895:"IFCMONETARYUNIT",3368373690:"IFCMETRIC",677618848:"IFCMECHANICALSTEELMATERIALPROPERTIES",4256014907:"IFCMECHANICALMATERIALPROPERTIES",2597039031:"IFCMEASUREWITHUNIT",3265635763:"IFCMATERIALPROPERTIES",2199411900:"IFCMATERIALLIST",1303795690:"IFCMATERIALLAYERSETUSAGE",3303938423:"IFCMATERIALLAYERSET",248100487:"IFCMATERIALLAYER",1847130766:"IFCMATERIALCLASSIFICATIONRELATIONSHIP",1838606355:"IFCMATERIAL",30780891:"IFCLOCALTIME",1566485204:"IFCLIGHTINTENSITYDISTRIBUTION",4162380809:"IFCLIGHTDISTRIBUTIONDATA",3452421091:"IFCLIBRARYREFERENCE",2655187982:"IFCLIBRARYINFORMATION",3020489413:"IFCIRREGULARTIMESERIESVALUE",852622518:"IFCGRIDAXIS",3548104201:"IFCEXTERNALLYDEFINEDTEXTFONT",3207319532:"IFCEXTERNALLYDEFINEDSYMBOL",1040185647:"IFCEXTERNALLYDEFINEDSURFACESTYLE",2242383968:"IFCEXTERNALLYDEFINEDHATCHSTYLE",3200245327:"IFCEXTERNALREFERENCE",1648886627:"IFCENVIRONMENTALIMPACTVALUE",3796139169:"IFCDRAUGHTINGCALLOUTRELATIONSHIP",770865208:"IFCDOCUMENTINFORMATIONRELATIONSHIP",1154170062:"IFCDOCUMENTINFORMATION",1376555844:"IFCDOCUMENTELECTRONICFORMAT",2949456006:"IFCDIMENSIONALEXPONENTS",1045800335:"IFCDERIVEDUNITELEMENT",1765591967:"IFCDERIVEDUNIT",1072939445:"IFCDATEANDTIME",3510044353:"IFCCURVESTYLEFONTPATTERN",2367409068:"IFCCURVESTYLEFONTANDSCALING",1105321065:"IFCCURVESTYLEFONT",539742890:"IFCCURRENCYRELATIONSHIP",602808272:"IFCCOSTVALUE",1065062679:"IFCCOORDINATEDUNIVERSALTIMEOFFSET",347226245:"IFCCONSTRAINTRELATIONSHIP",613356794:"IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",1658513725:"IFCCONSTRAINTAGGREGATIONRELATIONSHIP",1959218052:"IFCCONSTRAINT",2732653382:"IFCCONNECTIONSURFACEGEOMETRY",4257277454:"IFCCONNECTIONPORTGEOMETRY",2614616156:"IFCCONNECTIONPOINTGEOMETRY",2859738748:"IFCCONNECTIONGEOMETRY",3264961684:"IFCCOLOURSPECIFICATION",3639012971:"IFCCLASSIFICATIONNOTATIONFACET",938368621:"IFCCLASSIFICATIONNOTATION",1098599126:"IFCCLASSIFICATIONITEMRELATIONSHIP",1767535486:"IFCCLASSIFICATIONITEM",747523909:"IFCCLASSIFICATION",622194075:"IFCCALENDARDATE",2069777674:"IFCBOUNDARYNODECONDITIONWARPING",1387855156:"IFCBOUNDARYNODECONDITION",3367102660:"IFCBOUNDARYFACECONDITION",1560379544:"IFCBOUNDARYEDGECONDITION",4037036970:"IFCBOUNDARYCONDITION",3869604511:"IFCAPPROVALRELATIONSHIP",390851274:"IFCAPPROVALPROPERTYRELATIONSHIP",2080292479:"IFCAPPROVALACTORRELATIONSHIP",130549933:"IFCAPPROVAL",1110488051:"IFCAPPLIEDVALUERELATIONSHIP",411424972:"IFCAPPLIEDVALUE",639542469:"IFCAPPLICATION",618182010:"IFCADDRESS",3630933823:"IFCACTORROLE",599546466:"FILE_DESCRIPTION",1390159747:"FILE_NAME",1109904537:"FILE_SCHEMA"};class Ht{constructor(){ot(this,"enabled",!0),ot(this,"trigger",(t=>{if(!this.enabled)return;const e=this.handlers.slice(0);for(const s of e)s(t)})),ot(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter((e=>e!==t))}reset(){this.handlers.length=0}}class kt{constructor(){ot(this,"enabled",!0),ot(this,"trigger",(async t=>{if(!this.enabled)return;const e=this.handlers.slice(0);for(const s of e)await s(t)})),ot(this,"handlers",[])}add(t){this.handlers.push(t)}remove(t){this.handlers=this.handlers.filter((e=>e!==t))}reset(){this.handlers.length=0}}class Yt extends Map{constructor(t){super(t),ot(this,"onBeforeSet",new Ht),ot(this,"onItemSet",new Ht),ot(this,"onItemUpdated",new Ht),ot(this,"onBeforeDelete",new Ht),ot(this,"onItemDeleted",new Ht),ot(this,"onCleared",new Ht),ot(this,"guard",(()=>!0)),ot(this,"deleteGuard",(()=>!0)),ot(this,"updateGuard",(()=>!0))}set eventsEnabled(t){this.onItemSet.enabled=t,this.onItemUpdated.enabled=t,this.onItemDeleted.enabled=t,this.onBeforeDelete.enabled=t,this.onCleared.enabled=t}clear(){for(const[t,e]of this)this.onBeforeDelete.trigger({key:t,value:e});super.clear(),this.onCleared.trigger()}set(t,e){const s=this.has(t);if(!(this.guard??(()=>!0))(t,e))return this;s||this.onBeforeSet.trigger({key:t,value:e});const i=super.set(t,e);return s?(this.onItemUpdated||(this.onItemUpdated=new Ht),this.onItemUpdated.trigger({key:t,value:e})):(this.onItemSet||(this.onItemSet=new Ht),this.onItemSet.trigger({key:t,value:e})),i}delete(t){const e=this.get(t);if(!e)return!1;if(!this.deleteGuard(t,e))return!1;this.onBeforeDelete.trigger({key:t,value:e});const s=super.delete(t);return s&&this.onItemDeleted.trigger(t),s}getKey(t){for(const[e,s]of this)if(s===t)return e}add(t){const e=pt.generateUUID().toLowerCase();return this.set(e,t),e}update(t){const e=this.getKey(t);e&&this.updateGuard(e,t)&&this.set(e,t)}deleteIf(t){for(const[e,s]of this)t(s,e)&&this.delete(e)}replaceKey(t,e,s=!1){const i=this.get(t);if(!i)return!1;return!(this.get(e)&&!s)&&(this.eventsEnabled=!1,this.delete(t),this.eventsEnabled=!0,this.set(e,i),!0)}dispose(){this.clear(),this.onItemSet.reset(),this.onItemDeleted.reset(),this.onItemUpdated.reset(),this.onCleared.reset(),this.onBeforeDelete.reset()}}class Wt extends Set{constructor(t){super(t),ot(this,"onUpdated",new Ht),ot(this,"onItemAdded",new Ht),ot(this,"onBeforeDelete",new Ht),ot(this,"onItemDeleted",new Ht),ot(this,"onCleared",new Ht),ot(this,"guard",(()=>!0)),ot(this,"deleteGuard",(()=>!0))}set eventsEnabled(t){this.onUpdated.enabled=t,this.onItemAdded.enabled=t,this.onItemDeleted.enabled=t,this.onBeforeDelete.enabled=t,this.onCleared.enabled=t}clear(){for(const t of this)this.onBeforeDelete.trigger(t);super.clear(),this.onCleared.trigger(),this.onUpdated.trigger()}add(...t){for(const e of t){if(this.has(e))continue;(this.guard??(()=>!0))(e)&&(super.add(e),this.onItemAdded||(this.onItemAdded=new Ht),this.onItemAdded.trigger(e))}return this.onUpdated||(this.onUpdated=new Ht),this.onUpdated.trigger(),this}delete(t){if(!this.has(t))return!1;if(!this.deleteGuard(t))return!1;this.onBeforeDelete.trigger(t);const e=super.delete(t);return e&&(this.onItemDeleted.trigger(),this.onUpdated.trigger()),e}deleteIf(t){for(const e of this)t(e)&&this.delete(e)}getIndex(t){let e=0;for(const s of this){if(s===t)return e;e++}return-1}dispose(){this.clear(),this.onItemAdded.reset(),this.onItemDeleted.reset(),this.onCleared.reset(),this.onBeforeDelete.reset(),this.onUpdated.reset()}}const qt=new Int32Array(2),jt=new Float32Array(qt.buffer),Xt=new Float64Array(qt.buffer),Zt=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0];var $t,Qt;(Qt=$t||($t={}))[Qt.UTF8_BYTES=1]="UTF8_BYTES",Qt[Qt.UTF16_STRING=2]="UTF16_STRING";class Kt{constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new Kt(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return qt[0]=this.readInt32(t),jt[0]}readFloat64(t){return qt[Zt?0:1]=this.readInt32(t),qt[Zt?1:0]=this.readInt32(t+4),Xt[0]}writeInt8(t,e){this.bytes_[t]=e}writeUint8(t,e){this.bytes_[t]=e}writeInt16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeUint16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeInt32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeUint32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeInt64(t,e){this.writeInt32(t,Number(BigInt.asIntN(32,e))),this.writeInt32(t+4,Number(BigInt.asIntN(32,e>>BigInt(32))))}writeUint64(t,e){this.writeUint32(t,Number(BigInt.asUintN(32,e))),this.writeUint32(t+4,Number(BigInt.asUintN(32,e>>BigInt(32))))}writeFloat32(t,e){jt[0]=e,this.writeInt32(t,qt[0])}writeFloat64(t,e){Xt[0]=e,this.writeInt32(t,qt[Zt?0:1]),this.writeInt32(t+4,qt[Zt?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+4+4)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let e=0;e<4;e++)t+=String.fromCharCode(this.readInt8(this.position_+4+e));return t}__offset(t,e){const s=t-this.readInt32(t);return e<this.readInt16(s)?this.readInt16(s+e):0}__union(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t}__string(t,e){t+=this.readInt32(t);const s=this.readInt32(t);t+=4;const i=this.bytes_.subarray(t,t+s);return e===$t.UTF8_BYTES?i:this.text_decoder_.decode(i)}__union_with_string(t,e){return"string"==typeof t?this.__string(e):this.__union(t,e)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+4}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(4!=t.length)throw new Error("FlatBuffers: file identifier must be length 4");for(let e=0;e<4;e++)if(t.charCodeAt(e)!=this.readInt8(this.position()+4+e))return!1;return!0}createScalarList(t,e){const s=[];for(let i=0;i<e;++i){const e=t(i);null!==e&&s.push(e)}return s}createObjList(t,e){const s=[];for(let i=0;i<e;++i){const e=t(i);null!==e&&s.push(e.unpack())}return s}}class Jt{constructor(t){let e;this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder,e=t||1024,this.bb=Kt.allocate(e),this.space=e}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,e){t>this.minalign&&(this.minalign=t);const s=1+~(this.bb.capacity()-this.space+e)&t-1;for(;this.space<s+t+e;){const t=this.bb.capacity();this.bb=Jt.growByteBuffer(this.bb),this.space+=this.bb.capacity()-t}this.pad(s)}pad(t){for(let e=0;e<t;e++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,e,s){(this.force_defaults||e!=s)&&(this.addInt8(e),this.slot(t))}addFieldInt16(t,e,s){(this.force_defaults||e!=s)&&(this.addInt16(e),this.slot(t))}addFieldInt32(t,e,s){(this.force_defaults||e!=s)&&(this.addInt32(e),this.slot(t))}addFieldInt64(t,e,s){(this.force_defaults||e!==s)&&(this.addInt64(e),this.slot(t))}addFieldFloat32(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat32(e),this.slot(t))}addFieldFloat64(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat64(e),this.slot(t))}addFieldOffset(t,e,s){(this.force_defaults||e!=s)&&(this.addOffset(e),this.slot(t))}addFieldStruct(t,e,s){e!=s&&(this.nested(e),this.slot(t))}nested(t){if(t!=this.offset())throw new TypeError("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new TypeError("FlatBuffers: object serialization must not be nested.")}slot(t){null!==this.vtable&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const e=t.capacity();if(3221225472&e)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const s=e<<1,i=Kt.allocate(s);return i.setPosition(s-e),i.bytes().set(t.bytes(),s-e),i}addOffset(t){this.prep(4,0),this.writeInt32(this.offset()-t+4)}startObject(t){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=t;for(let e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let e=this.vtable_in_use-1;for(;e>=0&&0==this.vtable[e];e--);const s=e+1;for(;e>=0;e--)this.addInt16(0!=this.vtable[e]?t-this.vtable[e]:0);this.addInt16(t-this.object_start);const i=2*(s+2);this.addInt16(i);let r=0;const n=this.space;t:for(e=0;e<this.vtables.length;e++){const t=this.bb.capacity()-this.vtables[e];if(i==this.bb.readInt16(t)){for(let e=2;e<i;e+=2)if(this.bb.readInt16(n+e)!=this.bb.readInt16(t+e))continue t;r=this.vtables[e];break}}return r?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,r-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,e,s){const i=s?4:0;if(e){const t=e;if(this.prep(this.minalign,8+i),4!=t.length)throw new TypeError("FlatBuffers: file identifier must be length 4");for(let e=3;e>=0;e--)this.writeInt8(t.charCodeAt(e))}this.prep(this.minalign,4+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,e){this.finish(t,e,!0)}requiredField(t,e){const s=this.bb.capacity()-t,i=s-this.bb.readInt32(s);if(!(e<this.bb.readInt16(i)&&0!=this.bb.readInt16(i+e)))throw new TypeError("FlatBuffers: field "+e+" must be set")}startVector(t,e,s){this.notNested(),this.vector_num_elems=e,this.prep(4,t*e),this.prep(s,t*e)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const e=this.createString(t);return this.string_maps.set(t,e),e}createString(t){if(null==t)return 0;let e;return e=t instanceof Uint8Array?t:this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length),this.bb.bytes().set(e,this.space),this.endVector()}createByteVector(t){return null==t?0:(this.startVector(1,t.length,1),this.bb.setPosition(this.space-=t.length),this.bb.bytes().set(t,this.space),this.endVector())}createObjectOffset(t){return null===t?0:"string"==typeof t?this.createString(t):t.pack(this)}createObjectOffsetList(t){const e=[];for(let s=0;s<t.length;++s){const i=t[s];if(null===i)throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");e.push(this.createObjectOffset(i))}return e}createStructOffsetList(t,e){return e(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */function te(t){let e=t.length;for(;--e>=0;)t[e]=0}const ee=256,se=286,ie=30,re=15,ne=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),oe=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),ae=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),le=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),ce=new Array(576);te(ce);const he=new Array(60);te(he);const de=new Array(512);te(de);const ue=new Array(256);te(ue);const fe=new Array(29);te(fe);const pe=new Array(ie);function Ie(t,e,s,i,r){this.static_tree=t,this.extra_bits=e,this.extra_base=s,this.elems=i,this.max_length=r,this.has_stree=t&&t.length}let me,Ee,_e;function ge(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}te(pe);const Ce=t=>t<256?de[t]:de[256+(t>>>7)],Te=(t,e)=>{t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},be=(t,e,s)=>{t.bi_valid>16-s?(t.bi_buf|=e<<t.bi_valid&65535,Te(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=s-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=s)},Re=(t,e,s)=>{be(t,s[2*e],s[2*e+1])},Ae=(t,e)=>{let s=0;do{s|=1&t,t>>>=1,s<<=1}while(--e>0);return s>>>1},ye=(t,e,s)=>{const i=new Array(16);let r,n,o=0;for(r=1;r<=re;r++)o=o+s[r-1]<<1,i[r]=o;for(n=0;n<=e;n++){let e=t[2*n+1];0!==e&&(t[2*n]=Ae(i[e]++,e))}},Se=t=>{let e;for(e=0;e<se;e++)t.dyn_ltree[2*e]=0;for(e=0;e<ie;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.sym_next=t.matches=0},Fe=t=>{t.bi_valid>8?Te(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},we=(t,e,s,i)=>{const r=2*e,n=2*s;return t[r]<t[n]||t[r]===t[n]&&i[e]<=i[s]},Le=(t,e,s)=>{const i=t.heap[s];let r=s<<1;for(;r<=t.heap_len&&(r<t.heap_len&&we(e,t.heap[r+1],t.heap[r],t.depth)&&r++,!we(e,i,t.heap[r],t.depth));)t.heap[s]=t.heap[r],s=r,r<<=1;t.heap[s]=i},Oe=(t,e,s)=>{let i,r,n,o,a=0;if(0!==t.sym_next)do{i=255&t.pending_buf[t.sym_buf+a++],i+=(255&t.pending_buf[t.sym_buf+a++])<<8,r=t.pending_buf[t.sym_buf+a++],0===i?Re(t,r,e):(n=ue[r],Re(t,n+ee+1,e),o=ne[n],0!==o&&(r-=fe[n],be(t,r,o)),i--,n=Ce(i),Re(t,n,s),o=oe[n],0!==o&&(i-=pe[n],be(t,i,o)))}while(a<t.sym_next);Re(t,256,e)},xe=(t,e)=>{const s=e.dyn_tree,i=e.stat_desc.static_tree,r=e.stat_desc.has_stree,n=e.stat_desc.elems;let o,a,l,c=-1;for(t.heap_len=0,t.heap_max=573,o=0;o<n;o++)0!==s[2*o]?(t.heap[++t.heap_len]=c=o,t.depth[o]=0):s[2*o+1]=0;for(;t.heap_len<2;)l=t.heap[++t.heap_len]=c<2?++c:0,s[2*l]=1,t.depth[l]=0,t.opt_len--,r&&(t.static_len-=i[2*l+1]);for(e.max_code=c,o=t.heap_len>>1;o>=1;o--)Le(t,s,o);l=n;do{o=t.heap[1],t.heap[1]=t.heap[t.heap_len--],Le(t,s,1),a=t.heap[1],t.heap[--t.heap_max]=o,t.heap[--t.heap_max]=a,s[2*l]=s[2*o]+s[2*a],t.depth[l]=(t.depth[o]>=t.depth[a]?t.depth[o]:t.depth[a])+1,s[2*o+1]=s[2*a+1]=l,t.heap[1]=l++,Le(t,s,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],((t,e)=>{const s=e.dyn_tree,i=e.max_code,r=e.stat_desc.static_tree,n=e.stat_desc.has_stree,o=e.stat_desc.extra_bits,a=e.stat_desc.extra_base,l=e.stat_desc.max_length;let c,h,d,u,f,p,I=0;for(u=0;u<=re;u++)t.bl_count[u]=0;for(s[2*t.heap[t.heap_max]+1]=0,c=t.heap_max+1;c<573;c++)h=t.heap[c],u=s[2*s[2*h+1]+1]+1,u>l&&(u=l,I++),s[2*h+1]=u,h>i||(t.bl_count[u]++,f=0,h>=a&&(f=o[h-a]),p=s[2*h],t.opt_len+=p*(u+f),n&&(t.static_len+=p*(r[2*h+1]+f)));if(0!==I){do{for(u=l-1;0===t.bl_count[u];)u--;t.bl_count[u]--,t.bl_count[u+1]+=2,t.bl_count[l]--,I-=2}while(I>0);for(u=l;0!==u;u--)for(h=t.bl_count[u];0!==h;)d=t.heap[--c],d>i||(s[2*d+1]!==u&&(t.opt_len+=(u-s[2*d+1])*s[2*d],s[2*d+1]=u),h--)}})(t,e),ye(s,c,t.bl_count)},Ne=(t,e,s)=>{let i,r,n=-1,o=e[1],a=0,l=7,c=4;for(0===o&&(l=138,c=3),e[2*(s+1)+1]=65535,i=0;i<=s;i++)r=o,o=e[2*(i+1)+1],++a<l&&r===o||(a<c?t.bl_tree[2*r]+=a:0!==r?(r!==n&&t.bl_tree[2*r]++,t.bl_tree[32]++):a<=10?t.bl_tree[34]++:t.bl_tree[36]++,a=0,n=r,0===o?(l=138,c=3):r===o?(l=6,c=3):(l=7,c=4))},ve=(t,e,s)=>{let i,r,n=-1,o=e[1],a=0,l=7,c=4;for(0===o&&(l=138,c=3),i=0;i<=s;i++)if(r=o,o=e[2*(i+1)+1],!(++a<l&&r===o)){if(a<c)do{Re(t,r,t.bl_tree)}while(0!=--a);else 0!==r?(r!==n&&(Re(t,r,t.bl_tree),a--),Re(t,16,t.bl_tree),be(t,a-3,2)):a<=10?(Re(t,17,t.bl_tree),be(t,a-3,3)):(Re(t,18,t.bl_tree),be(t,a-11,7));a=0,n=r,0===o?(l=138,c=3):r===o?(l=6,c=3):(l=7,c=4)}};let Pe=!1;const Me=(t,e,s,i)=>{be(t,0+(i?1:0),3),Fe(t),Te(t,s),Te(t,~s),s&&t.pending_buf.set(t.window.subarray(e,e+s),t.pending),t.pending+=s};var De={_tr_init:t=>{Pe||((()=>{let t,e,s,i,r;const n=new Array(16);for(s=0,i=0;i<28;i++)for(fe[i]=s,t=0;t<1<<ne[i];t++)ue[s++]=i;for(ue[s-1]=i,r=0,i=0;i<16;i++)for(pe[i]=r,t=0;t<1<<oe[i];t++)de[r++]=i;for(r>>=7;i<ie;i++)for(pe[i]=r<<7,t=0;t<1<<oe[i]-7;t++)de[256+r++]=i;for(e=0;e<=re;e++)n[e]=0;for(t=0;t<=143;)ce[2*t+1]=8,t++,n[8]++;for(;t<=255;)ce[2*t+1]=9,t++,n[9]++;for(;t<=279;)ce[2*t+1]=7,t++,n[7]++;for(;t<=287;)ce[2*t+1]=8,t++,n[8]++;for(ye(ce,287,n),t=0;t<ie;t++)he[2*t+1]=5,he[2*t]=Ae(t,5);me=new Ie(ce,ne,257,se,re),Ee=new Ie(he,oe,0,ie,re),_e=new Ie(new Array(0),ae,0,19,7)})(),Pe=!0),t.l_desc=new ge(t.dyn_ltree,me),t.d_desc=new ge(t.dyn_dtree,Ee),t.bl_desc=new ge(t.bl_tree,_e),t.bi_buf=0,t.bi_valid=0,Se(t)},_tr_stored_block:Me,_tr_flush_block:(t,e,s,i)=>{let r,n,o=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=(t=>{let e,s=4093624447;for(e=0;e<=31;e++,s>>>=1)if(1&s&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<ee;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0})(t)),xe(t,t.l_desc),xe(t,t.d_desc),o=(t=>{let e;for(Ne(t,t.dyn_ltree,t.l_desc.max_code),Ne(t,t.dyn_dtree,t.d_desc.max_code),xe(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*le[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e})(t),r=t.opt_len+3+7>>>3,n=t.static_len+3+7>>>3,n<=r&&(r=n)):r=n=s+5,s+4<=r&&-1!==e?Me(t,e,s,i):4===t.strategy||n===r?(be(t,2+(i?1:0),3),Oe(t,ce,he)):(be(t,4+(i?1:0),3),((t,e,s,i)=>{let r;for(be(t,e-257,5),be(t,s-1,5),be(t,i-4,4),r=0;r<i;r++)be(t,t.bl_tree[2*le[r]+1],3);ve(t,t.dyn_ltree,e-1),ve(t,t.dyn_dtree,s-1)})(t,t.l_desc.max_code+1,t.d_desc.max_code+1,o+1),Oe(t,t.dyn_ltree,t.dyn_dtree)),Se(t),i&&Fe(t)},_tr_tally:(t,e,s)=>(t.pending_buf[t.sym_buf+t.sym_next++]=e,t.pending_buf[t.sym_buf+t.sym_next++]=e>>8,t.pending_buf[t.sym_buf+t.sym_next++]=s,0===e?t.dyn_ltree[2*s]++:(t.matches++,e--,t.dyn_ltree[2*(ue[s]+ee+1)]++,t.dyn_dtree[2*Ce(e)]++),t.sym_next===t.sym_end),_tr_align:t=>{be(t,2,3),Re(t,256,ce),(t=>{16===t.bi_valid?(Te(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)})(t)}};var Ue=(t,e,s,i)=>{let r=65535&t,n=t>>>16&65535,o=0;for(;0!==s;){o=s>2e3?2e3:s,s-=o;do{r=r+e[i++]|0,n=n+r|0}while(--o);r%=65521,n%=65521}return r|n<<16};const Ve=new Uint32Array((()=>{let t,e=[];for(var s=0;s<256;s++){t=s;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[s]=t}return e})());var Be=(t,e,s,i)=>{const r=Ve,n=i+s;t^=-1;for(let s=i;s<n;s++)t=t>>>8^r[255&(t^e[s])];return~t},ze={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Ge={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:He,_tr_stored_block:ke,_tr_flush_block:Ye,_tr_tally:We,_tr_align:qe}=De,{Z_NO_FLUSH:je,Z_PARTIAL_FLUSH:Xe,Z_FULL_FLUSH:Ze,Z_FINISH:$e,Z_BLOCK:Qe,Z_OK:Ke,Z_STREAM_END:Je,Z_STREAM_ERROR:ts,Z_DATA_ERROR:es,Z_BUF_ERROR:ss,Z_DEFAULT_COMPRESSION:is,Z_FILTERED:rs,Z_HUFFMAN_ONLY:ns,Z_RLE:os,Z_FIXED:as,Z_DEFAULT_STRATEGY:ls,Z_UNKNOWN:cs,Z_DEFLATED:hs}=Ge,ds=258,us=262,fs=42,ps=113,Is=666,ms=(t,e)=>(t.msg=ze[e],e),Es=t=>2*t-(t>4?9:0),_s=t=>{let e=t.length;for(;--e>=0;)t[e]=0},gs=t=>{let e,s,i,r=t.w_size;e=t.hash_size,i=e;do{s=t.head[--i],t.head[i]=s>=r?s-r:0}while(--e);e=r,i=e;do{s=t.prev[--i],t.prev[i]=s>=r?s-r:0}while(--e)};let Cs=(t,e,s)=>(e<<t.hash_shift^s)&t.hash_mask;const Ts=t=>{const e=t.state;let s=e.pending;s>t.avail_out&&(s=t.avail_out),0!==s&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+s),t.next_out),t.next_out+=s,e.pending_out+=s,t.total_out+=s,t.avail_out-=s,e.pending-=s,0===e.pending&&(e.pending_out=0))},bs=(t,e)=>{Ye(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,Ts(t.strm)},Rs=(t,e)=>{t.pending_buf[t.pending++]=e},As=(t,e)=>{t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},ys=(t,e,s,i)=>{let r=t.avail_in;return r>i&&(r=i),0===r?0:(t.avail_in-=r,e.set(t.input.subarray(t.next_in,t.next_in+r),s),1===t.state.wrap?t.adler=Ue(t.adler,e,r,s):2===t.state.wrap&&(t.adler=Be(t.adler,e,r,s)),t.next_in+=r,t.total_in+=r,r)},Ss=(t,e)=>{let s,i,r=t.max_chain_length,n=t.strstart,o=t.prev_length,a=t.nice_match;const l=t.strstart>t.w_size-us?t.strstart-(t.w_size-us):0,c=t.window,h=t.w_mask,d=t.prev,u=t.strstart+ds;let f=c[n+o-1],p=c[n+o];t.prev_length>=t.good_match&&(r>>=2),a>t.lookahead&&(a=t.lookahead);do{if(s=e,c[s+o]===p&&c[s+o-1]===f&&c[s]===c[n]&&c[++s]===c[n+1]){n+=2,s++;do{}while(c[++n]===c[++s]&&c[++n]===c[++s]&&c[++n]===c[++s]&&c[++n]===c[++s]&&c[++n]===c[++s]&&c[++n]===c[++s]&&c[++n]===c[++s]&&c[++n]===c[++s]&&n<u);if(i=ds-(u-n),n=u-ds,i>o){if(t.match_start=e,o=i,i>=a)break;f=c[n+o-1],p=c[n+o]}}}while((e=d[e&h])>l&&0!=--r);return o<=t.lookahead?o:t.lookahead},Fs=t=>{const e=t.w_size;let s,i,r;do{if(i=t.window_size-t.lookahead-t.strstart,t.strstart>=e+(e-us)&&(t.window.set(t.window.subarray(e,e+e-i),0),t.match_start-=e,t.strstart-=e,t.block_start-=e,t.insert>t.strstart&&(t.insert=t.strstart),gs(t),i+=e),0===t.strm.avail_in)break;if(s=ys(t.strm,t.window,t.strstart+t.lookahead,i),t.lookahead+=s,t.lookahead+t.insert>=3)for(r=t.strstart-t.insert,t.ins_h=t.window[r],t.ins_h=Cs(t,t.ins_h,t.window[r+1]);t.insert&&(t.ins_h=Cs(t,t.ins_h,t.window[r+3-1]),t.prev[r&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=r,r++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<us&&0!==t.strm.avail_in)},ws=(t,e)=>{let s,i,r,n=t.pending_buf_size-5>t.w_size?t.w_size:t.pending_buf_size-5,o=0,a=t.strm.avail_in;do{if(s=65535,r=t.bi_valid+42>>3,t.strm.avail_out<r)break;if(r=t.strm.avail_out-r,i=t.strstart-t.block_start,s>i+t.strm.avail_in&&(s=i+t.strm.avail_in),s>r&&(s=r),s<n&&(0===s&&e!==$e||e===je||s!==i+t.strm.avail_in))break;o=e===$e&&s===i+t.strm.avail_in?1:0,ke(t,0,0,o),t.pending_buf[t.pending-4]=s,t.pending_buf[t.pending-3]=s>>8,t.pending_buf[t.pending-2]=~s,t.pending_buf[t.pending-1]=~s>>8,Ts(t.strm),i&&(i>s&&(i=s),t.strm.output.set(t.window.subarray(t.block_start,t.block_start+i),t.strm.next_out),t.strm.next_out+=i,t.strm.avail_out-=i,t.strm.total_out+=i,t.block_start+=i,s-=i),s&&(ys(t.strm,t.strm.output,t.strm.next_out,s),t.strm.next_out+=s,t.strm.avail_out-=s,t.strm.total_out+=s)}while(0===o);return a-=t.strm.avail_in,a&&(a>=t.w_size?(t.matches=2,t.window.set(t.strm.input.subarray(t.strm.next_in-t.w_size,t.strm.next_in),0),t.strstart=t.w_size,t.insert=t.strstart):(t.window_size-t.strstart<=a&&(t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,t.insert>t.strstart&&(t.insert=t.strstart)),t.window.set(t.strm.input.subarray(t.strm.next_in-a,t.strm.next_in),t.strstart),t.strstart+=a,t.insert+=a>t.w_size-t.insert?t.w_size-t.insert:a),t.block_start=t.strstart),t.high_water<t.strstart&&(t.high_water=t.strstart),o?4:e!==je&&e!==$e&&0===t.strm.avail_in&&t.strstart===t.block_start?2:(r=t.window_size-t.strstart,t.strm.avail_in>r&&t.block_start>=t.w_size&&(t.block_start-=t.w_size,t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,r+=t.w_size,t.insert>t.strstart&&(t.insert=t.strstart)),r>t.strm.avail_in&&(r=t.strm.avail_in),r&&(ys(t.strm,t.window,t.strstart,r),t.strstart+=r,t.insert+=r>t.w_size-t.insert?t.w_size-t.insert:r),t.high_water<t.strstart&&(t.high_water=t.strstart),r=t.bi_valid+42>>3,r=t.pending_buf_size-r>65535?65535:t.pending_buf_size-r,n=r>t.w_size?t.w_size:r,i=t.strstart-t.block_start,(i>=n||(i||e===$e)&&e!==je&&0===t.strm.avail_in&&i<=r)&&(s=i>r?r:i,o=e===$e&&0===t.strm.avail_in&&s===i?1:0,ke(t,t.block_start,s,o),t.block_start+=s,Ts(t.strm)),o?3:1)},Ls=(t,e)=>{let s,i;for(;;){if(t.lookahead<us){if(Fs(t),t.lookahead<us&&e===je)return 1;if(0===t.lookahead)break}if(s=0,t.lookahead>=3&&(t.ins_h=Cs(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==s&&t.strstart-s<=t.w_size-us&&(t.match_length=Ss(t,s)),t.match_length>=3)if(i=We(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=Cs(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=Cs(t,t.ins_h,t.window[t.strstart+1]);else i=We(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(bs(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,e===$e?(bs(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(bs(t,!1),0===t.strm.avail_out)?1:2},Os=(t,e)=>{let s,i,r;for(;;){if(t.lookahead<us){if(Fs(t),t.lookahead<us&&e===je)return 1;if(0===t.lookahead)break}if(s=0,t.lookahead>=3&&(t.ins_h=Cs(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==s&&t.prev_length<t.max_lazy_match&&t.strstart-s<=t.w_size-us&&(t.match_length=Ss(t,s),t.match_length<=5&&(t.strategy===rs||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){r=t.strstart+t.lookahead-3,i=We(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=r&&(t.ins_h=Cs(t,t.ins_h,t.window[t.strstart+3-1]),s=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,i&&(bs(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if(i=We(t,0,t.window[t.strstart-1]),i&&bs(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=We(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===$e?(bs(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(bs(t,!1),0===t.strm.avail_out)?1:2};function xs(t,e,s,i,r){this.good_length=t,this.max_lazy=e,this.nice_length=s,this.max_chain=i,this.func=r}const Ns=[new xs(0,0,0,0,ws),new xs(4,4,8,4,Ls),new xs(4,5,16,8,Ls),new xs(4,6,32,32,Ls),new xs(4,4,16,16,Os),new xs(8,16,32,32,Os),new xs(8,16,128,128,Os),new xs(8,32,128,256,Os),new xs(32,128,258,1024,Os),new xs(32,258,258,4096,Os)];function vs(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=hs,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),_s(this.dyn_ltree),_s(this.dyn_dtree),_s(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),_s(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),_s(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const Ps=t=>{if(!t)return 1;const e=t.state;return!e||e.strm!==t||e.status!==fs&&57!==e.status&&69!==e.status&&73!==e.status&&91!==e.status&&103!==e.status&&e.status!==ps&&e.status!==Is?1:0},Ms=t=>{if(Ps(t))return ms(t,ts);t.total_in=t.total_out=0,t.data_type=cs;const e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=2===e.wrap?57:e.wrap?fs:ps,t.adler=2===e.wrap?0:1,e.last_flush=-2,He(e),Ke},Ds=t=>{const e=Ms(t);var s;return e===Ke&&((s=t.state).window_size=2*s.w_size,_s(s.head),s.max_lazy_match=Ns[s.level].max_lazy,s.good_match=Ns[s.level].good_length,s.nice_match=Ns[s.level].nice_length,s.max_chain_length=Ns[s.level].max_chain,s.strstart=0,s.block_start=0,s.lookahead=0,s.insert=0,s.match_length=s.prev_length=2,s.match_available=0,s.ins_h=0),e},Us=(t,e,s,i,r,n)=>{if(!t)return ts;let o=1;if(e===is&&(e=6),i<0?(o=0,i=-i):i>15&&(o=2,i-=16),r<1||r>9||s!==hs||i<8||i>15||e<0||e>9||n<0||n>as||8===i&&1!==o)return ms(t,ts);8===i&&(i=9);const a=new vs;return t.state=a,a.strm=t,a.status=fs,a.wrap=o,a.gzhead=null,a.w_bits=i,a.w_size=1<<a.w_bits,a.w_mask=a.w_size-1,a.hash_bits=r+7,a.hash_size=1<<a.hash_bits,a.hash_mask=a.hash_size-1,a.hash_shift=~~((a.hash_bits+3-1)/3),a.window=new Uint8Array(2*a.w_size),a.head=new Uint16Array(a.hash_size),a.prev=new Uint16Array(a.w_size),a.lit_bufsize=1<<r+6,a.pending_buf_size=4*a.lit_bufsize,a.pending_buf=new Uint8Array(a.pending_buf_size),a.sym_buf=a.lit_bufsize,a.sym_end=3*(a.lit_bufsize-1),a.level=e,a.strategy=n,a.method=s,Ds(t)};var Vs={deflateInit:(t,e)=>Us(t,e,hs,15,8,ls),deflateInit2:Us,deflateReset:Ds,deflateResetKeep:Ms,deflateSetHeader:(t,e)=>Ps(t)||2!==t.state.wrap?ts:(t.state.gzhead=e,Ke),deflate:(t,e)=>{if(Ps(t)||e>Qe||e<0)return t?ms(t,ts):ts;const s=t.state;if(!t.output||0!==t.avail_in&&!t.input||s.status===Is&&e!==$e)return ms(t,0===t.avail_out?ss:ts);const i=s.last_flush;if(s.last_flush=e,0!==s.pending){if(Ts(t),0===t.avail_out)return s.last_flush=-1,Ke}else if(0===t.avail_in&&Es(e)<=Es(i)&&e!==$e)return ms(t,ss);if(s.status===Is&&0!==t.avail_in)return ms(t,ss);if(s.status===fs&&0===s.wrap&&(s.status=ps),s.status===fs){let e=hs+(s.w_bits-8<<4)<<8,i=-1;if(i=s.strategy>=ns||s.level<2?0:s.level<6?1:6===s.level?2:3,e|=i<<6,0!==s.strstart&&(e|=32),e+=31-e%31,As(s,e),0!==s.strstart&&(As(s,t.adler>>>16),As(s,65535&t.adler)),t.adler=1,s.status=ps,Ts(t),0!==s.pending)return s.last_flush=-1,Ke}if(57===s.status)if(t.adler=0,Rs(s,31),Rs(s,139),Rs(s,8),s.gzhead)Rs(s,(s.gzhead.text?1:0)+(s.gzhead.hcrc?2:0)+(s.gzhead.extra?4:0)+(s.gzhead.name?8:0)+(s.gzhead.comment?16:0)),Rs(s,255&s.gzhead.time),Rs(s,s.gzhead.time>>8&255),Rs(s,s.gzhead.time>>16&255),Rs(s,s.gzhead.time>>24&255),Rs(s,9===s.level?2:s.strategy>=ns||s.level<2?4:0),Rs(s,255&s.gzhead.os),s.gzhead.extra&&s.gzhead.extra.length&&(Rs(s,255&s.gzhead.extra.length),Rs(s,s.gzhead.extra.length>>8&255)),s.gzhead.hcrc&&(t.adler=Be(t.adler,s.pending_buf,s.pending,0)),s.gzindex=0,s.status=69;else if(Rs(s,0),Rs(s,0),Rs(s,0),Rs(s,0),Rs(s,0),Rs(s,9===s.level?2:s.strategy>=ns||s.level<2?4:0),Rs(s,3),s.status=ps,Ts(t),0!==s.pending)return s.last_flush=-1,Ke;if(69===s.status){if(s.gzhead.extra){let e=s.pending,i=(65535&s.gzhead.extra.length)-s.gzindex;for(;s.pending+i>s.pending_buf_size;){let r=s.pending_buf_size-s.pending;if(s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex,s.gzindex+r),s.pending),s.pending=s.pending_buf_size,s.gzhead.hcrc&&s.pending>e&&(t.adler=Be(t.adler,s.pending_buf,s.pending-e,e)),s.gzindex+=r,Ts(t),0!==s.pending)return s.last_flush=-1,Ke;e=0,i-=r}let r=new Uint8Array(s.gzhead.extra);s.pending_buf.set(r.subarray(s.gzindex,s.gzindex+i),s.pending),s.pending+=i,s.gzhead.hcrc&&s.pending>e&&(t.adler=Be(t.adler,s.pending_buf,s.pending-e,e)),s.gzindex=0}s.status=73}if(73===s.status){if(s.gzhead.name){let e,i=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>i&&(t.adler=Be(t.adler,s.pending_buf,s.pending-i,i)),Ts(t),0!==s.pending)return s.last_flush=-1,Ke;i=0}e=s.gzindex<s.gzhead.name.length?255&s.gzhead.name.charCodeAt(s.gzindex++):0,Rs(s,e)}while(0!==e);s.gzhead.hcrc&&s.pending>i&&(t.adler=Be(t.adler,s.pending_buf,s.pending-i,i)),s.gzindex=0}s.status=91}if(91===s.status){if(s.gzhead.comment){let e,i=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>i&&(t.adler=Be(t.adler,s.pending_buf,s.pending-i,i)),Ts(t),0!==s.pending)return s.last_flush=-1,Ke;i=0}e=s.gzindex<s.gzhead.comment.length?255&s.gzhead.comment.charCodeAt(s.gzindex++):0,Rs(s,e)}while(0!==e);s.gzhead.hcrc&&s.pending>i&&(t.adler=Be(t.adler,s.pending_buf,s.pending-i,i))}s.status=103}if(103===s.status){if(s.gzhead.hcrc){if(s.pending+2>s.pending_buf_size&&(Ts(t),0!==s.pending))return s.last_flush=-1,Ke;Rs(s,255&t.adler),Rs(s,t.adler>>8&255),t.adler=0}if(s.status=ps,Ts(t),0!==s.pending)return s.last_flush=-1,Ke}if(0!==t.avail_in||0!==s.lookahead||e!==je&&s.status!==Is){let i=0===s.level?ws(s,e):s.strategy===ns?((t,e)=>{let s;for(;;){if(0===t.lookahead&&(Fs(t),0===t.lookahead)){if(e===je)return 1;break}if(t.match_length=0,s=We(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,s&&(bs(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===$e?(bs(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(bs(t,!1),0===t.strm.avail_out)?1:2})(s,e):s.strategy===os?((t,e)=>{let s,i,r,n;const o=t.window;for(;;){if(t.lookahead<=ds){if(Fs(t),t.lookahead<=ds&&e===je)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(r=t.strstart-1,i=o[r],i===o[++r]&&i===o[++r]&&i===o[++r])){n=t.strstart+ds;do{}while(i===o[++r]&&i===o[++r]&&i===o[++r]&&i===o[++r]&&i===o[++r]&&i===o[++r]&&i===o[++r]&&i===o[++r]&&r<n);t.match_length=ds-(n-r),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(s=We(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(s=We(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),s&&(bs(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===$e?(bs(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(bs(t,!1),0===t.strm.avail_out)?1:2})(s,e):Ns[s.level].func(s,e);if(3!==i&&4!==i||(s.status=Is),1===i||3===i)return 0===t.avail_out&&(s.last_flush=-1),Ke;if(2===i&&(e===Xe?qe(s):e!==Qe&&(ke(s,0,0,!1),e===Ze&&(_s(s.head),0===s.lookahead&&(s.strstart=0,s.block_start=0,s.insert=0))),Ts(t),0===t.avail_out))return s.last_flush=-1,Ke}return e!==$e?Ke:s.wrap<=0?Je:(2===s.wrap?(Rs(s,255&t.adler),Rs(s,t.adler>>8&255),Rs(s,t.adler>>16&255),Rs(s,t.adler>>24&255),Rs(s,255&t.total_in),Rs(s,t.total_in>>8&255),Rs(s,t.total_in>>16&255),Rs(s,t.total_in>>24&255)):(As(s,t.adler>>>16),As(s,65535&t.adler)),Ts(t),s.wrap>0&&(s.wrap=-s.wrap),0!==s.pending?Ke:Je)},deflateEnd:t=>{if(Ps(t))return ts;const e=t.state.status;return t.state=null,e===ps?ms(t,es):Ke},deflateSetDictionary:(t,e)=>{let s=e.length;if(Ps(t))return ts;const i=t.state,r=i.wrap;if(2===r||1===r&&i.status!==fs||i.lookahead)return ts;if(1===r&&(t.adler=Ue(t.adler,e,s,0)),i.wrap=0,s>=i.w_size){0===r&&(_s(i.head),i.strstart=0,i.block_start=0,i.insert=0);let t=new Uint8Array(i.w_size);t.set(e.subarray(s-i.w_size,s),0),e=t,s=i.w_size}const n=t.avail_in,o=t.next_in,a=t.input;for(t.avail_in=s,t.next_in=0,t.input=e,Fs(i);i.lookahead>=3;){let t=i.strstart,e=i.lookahead-2;do{i.ins_h=Cs(i,i.ins_h,i.window[t+3-1]),i.prev[t&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=t,t++}while(--e);i.strstart=t,i.lookahead=2,Fs(i)}return i.strstart+=i.lookahead,i.block_start=i.strstart,i.insert=i.lookahead,i.lookahead=0,i.match_length=i.prev_length=2,i.match_available=0,t.next_in=o,t.input=a,t.avail_in=n,i.wrap=r,Ke},deflateInfo:"pako deflate (from Nodeca project)"};const Bs=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var zs=function(t){const e=Array.prototype.slice.call(arguments,1);for(;e.length;){const s=e.shift();if(s){if("object"!=typeof s)throw new TypeError(s+"must be non-object");for(const e in s)Bs(s,e)&&(t[e]=s[e])}}return t},Gs=t=>{let e=0;for(let s=0,i=t.length;s<i;s++)e+=t[s].length;const s=new Uint8Array(e);for(let e=0,i=0,r=t.length;e<r;e++){let r=t[e];s.set(r,i),i+=r.length}return s};let Hs=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){Hs=!1}const ks=new Uint8Array(256);for(let t=0;t<256;t++)ks[t]=t>=252?6:t>=248?5:t>=240?4:t>=224?3:t>=192?2:1;ks[254]=ks[254]=1;var Ys=t=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);let e,s,i,r,n,o=t.length,a=0;for(r=0;r<o;r++)s=t.charCodeAt(r),55296==(64512&s)&&r+1<o&&(i=t.charCodeAt(r+1),56320==(64512&i)&&(s=65536+(s-55296<<10)+(i-56320),r++)),a+=s<128?1:s<2048?2:s<65536?3:4;for(e=new Uint8Array(a),n=0,r=0;n<a;r++)s=t.charCodeAt(r),55296==(64512&s)&&r+1<o&&(i=t.charCodeAt(r+1),56320==(64512&i)&&(s=65536+(s-55296<<10)+(i-56320),r++)),s<128?e[n++]=s:s<2048?(e[n++]=192|s>>>6,e[n++]=128|63&s):s<65536?(e[n++]=224|s>>>12,e[n++]=128|s>>>6&63,e[n++]=128|63&s):(e[n++]=240|s>>>18,e[n++]=128|s>>>12&63,e[n++]=128|s>>>6&63,e[n++]=128|63&s);return e},Ws=(t,e)=>{const s=e||t.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(t.subarray(0,e));let i,r;const n=new Array(2*s);for(r=0,i=0;i<s;){let e=t[i++];if(e<128){n[r++]=e;continue}let o=ks[e];if(o>4)n[r++]=65533,i+=o-1;else{for(e&=2===o?31:3===o?15:7;o>1&&i<s;)e=e<<6|63&t[i++],o--;o>1?n[r++]=65533:e<65536?n[r++]=e:(e-=65536,n[r++]=55296|e>>10&1023,n[r++]=56320|1023&e)}}return((t,e)=>{if(e<65534&&t.subarray&&Hs)return String.fromCharCode.apply(null,t.length===e?t:t.subarray(0,e));let s="";for(let i=0;i<e;i++)s+=String.fromCharCode(t[i]);return s})(n,r)},qs=(t,e)=>{(e=e||t.length)>t.length&&(e=t.length);let s=e-1;for(;s>=0&&128==(192&t[s]);)s--;return s<0||0===s?e:s+ks[t[s]]>e?s:e};var js=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const Xs=Object.prototype.toString,{Z_NO_FLUSH:Zs,Z_SYNC_FLUSH:$s,Z_FULL_FLUSH:Qs,Z_FINISH:Ks,Z_OK:Js,Z_STREAM_END:ti,Z_DEFAULT_COMPRESSION:ei,Z_DEFAULT_STRATEGY:si,Z_DEFLATED:ii}=Ge;function ri(t){this.options=zs({level:ei,method:ii,chunkSize:16384,windowBits:15,memLevel:8,strategy:si},t||{});let e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new js,this.strm.avail_out=0;let s=Vs.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(s!==Js)throw new Error(ze[s]);if(e.header&&Vs.deflateSetHeader(this.strm,e.header),e.dictionary){let t;if(t="string"==typeof e.dictionary?Ys(e.dictionary):"[object ArrayBuffer]"===Xs.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,s=Vs.deflateSetDictionary(this.strm,t),s!==Js)throw new Error(ze[s]);this._dict_set=!0}}function ni(t,e){const s=new ri(e);if(s.push(t,!0),s.err)throw s.msg||ze[s.err];return s.result}ri.prototype.push=function(t,e){const s=this.strm,i=this.options.chunkSize;let r,n;if(this.ended)return!1;for(n=e===~~e?e:!0===e?Ks:Zs,"string"==typeof t?s.input=Ys(t):"[object ArrayBuffer]"===Xs.call(t)?s.input=new Uint8Array(t):s.input=t,s.next_in=0,s.avail_in=s.input.length;;)if(0===s.avail_out&&(s.output=new Uint8Array(i),s.next_out=0,s.avail_out=i),(n===$s||n===Qs)&&s.avail_out<=6)this.onData(s.output.subarray(0,s.next_out)),s.avail_out=0;else{if(r=Vs.deflate(s,n),r===ti)return s.next_out>0&&this.onData(s.output.subarray(0,s.next_out)),r=Vs.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===Js;if(0!==s.avail_out){if(n>0&&s.next_out>0)this.onData(s.output.subarray(0,s.next_out)),s.avail_out=0;else if(0===s.avail_in)break}else this.onData(s.output)}return!0},ri.prototype.onData=function(t){this.chunks.push(t)},ri.prototype.onEnd=function(t){t===Js&&(this.result=Gs(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};var oi={Deflate:ri,deflate:ni,deflateRaw:function(t,e){return(e=e||{}).raw=!0,ni(t,e)},gzip:function(t,e){return(e=e||{}).gzip=!0,ni(t,e)}};const ai=16209;var li=function(t,e){let s,i,r,n,o,a,l,c,h,d,u,f,p,I,m,E,_,g,C,T,b,R,A,y;const S=t.state;s=t.next_in,A=t.input,i=s+(t.avail_in-5),r=t.next_out,y=t.output,n=r-(e-t.avail_out),o=r+(t.avail_out-257),a=S.dmax,l=S.wsize,c=S.whave,h=S.wnext,d=S.window,u=S.hold,f=S.bits,p=S.lencode,I=S.distcode,m=(1<<S.lenbits)-1,E=(1<<S.distbits)-1;t:do{f<15&&(u+=A[s++]<<f,f+=8,u+=A[s++]<<f,f+=8),_=p[u&m];e:for(;;){if(g=_>>>24,u>>>=g,f-=g,g=_>>>16&255,0===g)y[r++]=65535&_;else{if(!(16&g)){if(64&g){if(32&g){S.mode=16191;break t}t.msg="invalid literal/length code",S.mode=ai;break t}_=p[(65535&_)+(u&(1<<g)-1)];continue e}for(C=65535&_,g&=15,g&&(f<g&&(u+=A[s++]<<f,f+=8),C+=u&(1<<g)-1,u>>>=g,f-=g),f<15&&(u+=A[s++]<<f,f+=8,u+=A[s++]<<f,f+=8),_=I[u&E];;){if(g=_>>>24,u>>>=g,f-=g,g=_>>>16&255,16&g){if(T=65535&_,g&=15,f<g&&(u+=A[s++]<<f,f+=8,f<g&&(u+=A[s++]<<f,f+=8)),T+=u&(1<<g)-1,T>a){t.msg="invalid distance too far back",S.mode=ai;break t}if(u>>>=g,f-=g,g=r-n,T>g){if(g=T-g,g>c&&S.sane){t.msg="invalid distance too far back",S.mode=ai;break t}if(b=0,R=d,0===h){if(b+=l-g,g<C){C-=g;do{y[r++]=d[b++]}while(--g);b=r-T,R=y}}else if(h<g){if(b+=l+h-g,g-=h,g<C){C-=g;do{y[r++]=d[b++]}while(--g);if(b=0,h<C){g=h,C-=g;do{y[r++]=d[b++]}while(--g);b=r-T,R=y}}}else if(b+=h-g,g<C){C-=g;do{y[r++]=d[b++]}while(--g);b=r-T,R=y}for(;C>2;)y[r++]=R[b++],y[r++]=R[b++],y[r++]=R[b++],C-=3;C&&(y[r++]=R[b++],C>1&&(y[r++]=R[b++]))}else{b=r-T;do{y[r++]=y[b++],y[r++]=y[b++],y[r++]=y[b++],C-=3}while(C>2);C&&(y[r++]=y[b++],C>1&&(y[r++]=y[b++]))}break}if(64&g){t.msg="invalid distance code",S.mode=ai;break t}_=I[(65535&_)+(u&(1<<g)-1)]}}break}}while(s<i&&r<o);C=f>>3,s-=C,f-=C<<3,u&=(1<<f)-1,t.next_in=s,t.next_out=r,t.avail_in=s<i?i-s+5:5-(s-i),t.avail_out=r<o?o-r+257:257-(r-o),S.hold=u,S.bits=f};const ci=15,hi=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),di=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),ui=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),fi=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var pi=(t,e,s,i,r,n,o,a)=>{const l=a.bits;let c,h,d,u,f,p,I=0,m=0,E=0,_=0,g=0,C=0,T=0,b=0,R=0,A=0,y=null;const S=new Uint16Array(16),F=new Uint16Array(16);let w,L,O,x=null;for(I=0;I<=ci;I++)S[I]=0;for(m=0;m<i;m++)S[e[s+m]]++;for(g=l,_=ci;_>=1&&0===S[_];_--);if(g>_&&(g=_),0===_)return r[n++]=20971520,r[n++]=20971520,a.bits=1,0;for(E=1;E<_&&0===S[E];E++);for(g<E&&(g=E),b=1,I=1;I<=ci;I++)if(b<<=1,b-=S[I],b<0)return-1;if(b>0&&(0===t||1!==_))return-1;for(F[1]=0,I=1;I<ci;I++)F[I+1]=F[I]+S[I];for(m=0;m<i;m++)0!==e[s+m]&&(o[F[e[s+m]]++]=m);if(0===t?(y=x=o,p=20):1===t?(y=hi,x=di,p=257):(y=ui,x=fi,p=0),A=0,m=0,I=E,f=n,C=g,T=0,d=-1,R=1<<g,u=R-1,1===t&&R>852||2===t&&R>592)return 1;for(;;){w=I-T,o[m]+1<p?(L=0,O=o[m]):o[m]>=p?(L=x[o[m]-p],O=y[o[m]-p]):(L=96,O=0),c=1<<I-T,h=1<<C,E=h;do{h-=c,r[f+(A>>T)+h]=w<<24|L<<16|O}while(0!==h);for(c=1<<I-1;A&c;)c>>=1;if(0!==c?(A&=c-1,A+=c):A=0,m++,0==--S[I]){if(I===_)break;I=e[s+o[m]]}if(I>g&&(A&u)!==d){for(0===T&&(T=g),f+=E,C=I-T,b=1<<C;C+T<_&&(b-=S[C+T],!(b<=0));)C++,b<<=1;if(R+=1<<C,1===t&&R>852||2===t&&R>592)return 1;d=A&u,r[d]=g<<24|C<<16|f-n}}return 0!==A&&(r[f+A]=I-T<<24|64<<16),a.bits=g,0};const{Z_FINISH:Ii,Z_BLOCK:mi,Z_TREES:Ei,Z_OK:_i,Z_STREAM_END:gi,Z_NEED_DICT:Ci,Z_STREAM_ERROR:Ti,Z_DATA_ERROR:bi,Z_MEM_ERROR:Ri,Z_BUF_ERROR:Ai,Z_DEFLATED:yi}=Ge,Si=16180,Fi=16190,wi=16191,Li=16192,Oi=16194,xi=16199,Ni=16200,vi=16206,Pi=16209,Mi=t=>(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24);function Di(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const Ui=t=>{if(!t)return 1;const e=t.state;return!e||e.strm!==t||e.mode<Si||e.mode>16211?1:0},Vi=t=>{if(Ui(t))return Ti;const e=t.state;return t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=Si,e.last=0,e.havedict=0,e.flags=-1,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,_i},Bi=t=>{if(Ui(t))return Ti;const e=t.state;return e.wsize=0,e.whave=0,e.wnext=0,Vi(t)},zi=(t,e)=>{let s;if(Ui(t))return Ti;const i=t.state;return e<0?(s=0,e=-e):(s=5+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?Ti:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=s,i.wbits=e,Bi(t))},Gi=(t,e)=>{if(!t)return Ti;const s=new Di;t.state=s,s.strm=t,s.window=null,s.mode=Si;const i=zi(t,e);return i!==_i&&(t.state=null),i};let Hi,ki,Yi=!0;const Wi=t=>{if(Yi){Hi=new Int32Array(512),ki=new Int32Array(32);let e=0;for(;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(pi(1,t.lens,0,288,Hi,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;pi(2,t.lens,0,32,ki,0,t.work,{bits:5}),Yi=!1}t.lencode=Hi,t.lenbits=9,t.distcode=ki,t.distbits=5},qi=(t,e,s,i)=>{let r;const n=t.state;return null===n.window&&(n.wsize=1<<n.wbits,n.wnext=0,n.whave=0,n.window=new Uint8Array(n.wsize)),i>=n.wsize?(n.window.set(e.subarray(s-n.wsize,s),0),n.wnext=0,n.whave=n.wsize):(r=n.wsize-n.wnext,r>i&&(r=i),n.window.set(e.subarray(s-i,s-i+r),n.wnext),(i-=r)?(n.window.set(e.subarray(s-i,s),0),n.wnext=i,n.whave=n.wsize):(n.wnext+=r,n.wnext===n.wsize&&(n.wnext=0),n.whave<n.wsize&&(n.whave+=r))),0};var ji={inflateReset:Bi,inflateReset2:zi,inflateResetKeep:Vi,inflateInit:t=>Gi(t,15),inflateInit2:Gi,inflate:(t,e)=>{let s,i,r,n,o,a,l,c,h,d,u,f,p,I,m,E,_,g,C,T,b,R,A=0;const y=new Uint8Array(4);let S,F;const w=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(Ui(t)||!t.output||!t.input&&0!==t.avail_in)return Ti;s=t.state,s.mode===wi&&(s.mode=Li),o=t.next_out,r=t.output,l=t.avail_out,n=t.next_in,i=t.input,a=t.avail_in,c=s.hold,h=s.bits,d=a,u=l,R=_i;t:for(;;)switch(s.mode){case Si:if(0===s.wrap){s.mode=Li;break}for(;h<16;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}if(2&s.wrap&&35615===c){0===s.wbits&&(s.wbits=15),s.check=0,y[0]=255&c,y[1]=c>>>8&255,s.check=Be(s.check,y,2,0),c=0,h=0,s.mode=16181;break}if(s.head&&(s.head.done=!1),!(1&s.wrap)||(((255&c)<<8)+(c>>8))%31){t.msg="incorrect header check",s.mode=Pi;break}if((15&c)!==yi){t.msg="unknown compression method",s.mode=Pi;break}if(c>>>=4,h-=4,b=8+(15&c),0===s.wbits&&(s.wbits=b),b>15||b>s.wbits){t.msg="invalid window size",s.mode=Pi;break}s.dmax=1<<s.wbits,s.flags=0,t.adler=s.check=1,s.mode=512&c?16189:wi,c=0,h=0;break;case 16181:for(;h<16;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}if(s.flags=c,(255&s.flags)!==yi){t.msg="unknown compression method",s.mode=Pi;break}if(57344&s.flags){t.msg="unknown header flags set",s.mode=Pi;break}s.head&&(s.head.text=c>>8&1),512&s.flags&&4&s.wrap&&(y[0]=255&c,y[1]=c>>>8&255,s.check=Be(s.check,y,2,0)),c=0,h=0,s.mode=16182;case 16182:for(;h<32;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}s.head&&(s.head.time=c),512&s.flags&&4&s.wrap&&(y[0]=255&c,y[1]=c>>>8&255,y[2]=c>>>16&255,y[3]=c>>>24&255,s.check=Be(s.check,y,4,0)),c=0,h=0,s.mode=16183;case 16183:for(;h<16;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}s.head&&(s.head.xflags=255&c,s.head.os=c>>8),512&s.flags&&4&s.wrap&&(y[0]=255&c,y[1]=c>>>8&255,s.check=Be(s.check,y,2,0)),c=0,h=0,s.mode=16184;case 16184:if(1024&s.flags){for(;h<16;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}s.length=c,s.head&&(s.head.extra_len=c),512&s.flags&&4&s.wrap&&(y[0]=255&c,y[1]=c>>>8&255,s.check=Be(s.check,y,2,0)),c=0,h=0}else s.head&&(s.head.extra=null);s.mode=16185;case 16185:if(1024&s.flags&&(f=s.length,f>a&&(f=a),f&&(s.head&&(b=s.head.extra_len-s.length,s.head.extra||(s.head.extra=new Uint8Array(s.head.extra_len)),s.head.extra.set(i.subarray(n,n+f),b)),512&s.flags&&4&s.wrap&&(s.check=Be(s.check,i,f,n)),a-=f,n+=f,s.length-=f),s.length))break t;s.length=0,s.mode=16186;case 16186:if(2048&s.flags){if(0===a)break t;f=0;do{b=i[n+f++],s.head&&b&&s.length<65536&&(s.head.name+=String.fromCharCode(b))}while(b&&f<a);if(512&s.flags&&4&s.wrap&&(s.check=Be(s.check,i,f,n)),a-=f,n+=f,b)break t}else s.head&&(s.head.name=null);s.length=0,s.mode=16187;case 16187:if(4096&s.flags){if(0===a)break t;f=0;do{b=i[n+f++],s.head&&b&&s.length<65536&&(s.head.comment+=String.fromCharCode(b))}while(b&&f<a);if(512&s.flags&&4&s.wrap&&(s.check=Be(s.check,i,f,n)),a-=f,n+=f,b)break t}else s.head&&(s.head.comment=null);s.mode=16188;case 16188:if(512&s.flags){for(;h<16;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}if(4&s.wrap&&c!==(65535&s.check)){t.msg="header crc mismatch",s.mode=Pi;break}c=0,h=0}s.head&&(s.head.hcrc=s.flags>>9&1,s.head.done=!0),t.adler=s.check=0,s.mode=wi;break;case 16189:for(;h<32;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}t.adler=s.check=Mi(c),c=0,h=0,s.mode=Fi;case Fi:if(0===s.havedict)return t.next_out=o,t.avail_out=l,t.next_in=n,t.avail_in=a,s.hold=c,s.bits=h,Ci;t.adler=s.check=1,s.mode=wi;case wi:if(e===mi||e===Ei)break t;case Li:if(s.last){c>>>=7&h,h-=7&h,s.mode=vi;break}for(;h<3;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}switch(s.last=1&c,c>>>=1,h-=1,3&c){case 0:s.mode=16193;break;case 1:if(Wi(s),s.mode=xi,e===Ei){c>>>=2,h-=2;break t}break;case 2:s.mode=16196;break;case 3:t.msg="invalid block type",s.mode=Pi}c>>>=2,h-=2;break;case 16193:for(c>>>=7&h,h-=7&h;h<32;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}if((65535&c)!=(c>>>16^65535)){t.msg="invalid stored block lengths",s.mode=Pi;break}if(s.length=65535&c,c=0,h=0,s.mode=Oi,e===Ei)break t;case Oi:s.mode=16195;case 16195:if(f=s.length,f){if(f>a&&(f=a),f>l&&(f=l),0===f)break t;r.set(i.subarray(n,n+f),o),a-=f,n+=f,l-=f,o+=f,s.length-=f;break}s.mode=wi;break;case 16196:for(;h<14;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}if(s.nlen=257+(31&c),c>>>=5,h-=5,s.ndist=1+(31&c),c>>>=5,h-=5,s.ncode=4+(15&c),c>>>=4,h-=4,s.nlen>286||s.ndist>30){t.msg="too many length or distance symbols",s.mode=Pi;break}s.have=0,s.mode=16197;case 16197:for(;s.have<s.ncode;){for(;h<3;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}s.lens[w[s.have++]]=7&c,c>>>=3,h-=3}for(;s.have<19;)s.lens[w[s.have++]]=0;if(s.lencode=s.lendyn,s.lenbits=7,S={bits:s.lenbits},R=pi(0,s.lens,0,19,s.lencode,0,s.work,S),s.lenbits=S.bits,R){t.msg="invalid code lengths set",s.mode=Pi;break}s.have=0,s.mode=16198;case 16198:for(;s.have<s.nlen+s.ndist;){for(;A=s.lencode[c&(1<<s.lenbits)-1],m=A>>>24,E=A>>>16&255,_=65535&A,!(m<=h);){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}if(_<16)c>>>=m,h-=m,s.lens[s.have++]=_;else{if(16===_){for(F=m+2;h<F;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}if(c>>>=m,h-=m,0===s.have){t.msg="invalid bit length repeat",s.mode=Pi;break}b=s.lens[s.have-1],f=3+(3&c),c>>>=2,h-=2}else if(17===_){for(F=m+3;h<F;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}c>>>=m,h-=m,b=0,f=3+(7&c),c>>>=3,h-=3}else{for(F=m+7;h<F;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}c>>>=m,h-=m,b=0,f=11+(127&c),c>>>=7,h-=7}if(s.have+f>s.nlen+s.ndist){t.msg="invalid bit length repeat",s.mode=Pi;break}for(;f--;)s.lens[s.have++]=b}}if(s.mode===Pi)break;if(0===s.lens[256]){t.msg="invalid code -- missing end-of-block",s.mode=Pi;break}if(s.lenbits=9,S={bits:s.lenbits},R=pi(1,s.lens,0,s.nlen,s.lencode,0,s.work,S),s.lenbits=S.bits,R){t.msg="invalid literal/lengths set",s.mode=Pi;break}if(s.distbits=6,s.distcode=s.distdyn,S={bits:s.distbits},R=pi(2,s.lens,s.nlen,s.ndist,s.distcode,0,s.work,S),s.distbits=S.bits,R){t.msg="invalid distances set",s.mode=Pi;break}if(s.mode=xi,e===Ei)break t;case xi:s.mode=Ni;case Ni:if(a>=6&&l>=258){t.next_out=o,t.avail_out=l,t.next_in=n,t.avail_in=a,s.hold=c,s.bits=h,li(t,u),o=t.next_out,r=t.output,l=t.avail_out,n=t.next_in,i=t.input,a=t.avail_in,c=s.hold,h=s.bits,s.mode===wi&&(s.back=-1);break}for(s.back=0;A=s.lencode[c&(1<<s.lenbits)-1],m=A>>>24,E=A>>>16&255,_=65535&A,!(m<=h);){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}if(E&&!(240&E)){for(g=m,C=E,T=_;A=s.lencode[T+((c&(1<<g+C)-1)>>g)],m=A>>>24,E=A>>>16&255,_=65535&A,!(g+m<=h);){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}c>>>=g,h-=g,s.back+=g}if(c>>>=m,h-=m,s.back+=m,s.length=_,0===E){s.mode=16205;break}if(32&E){s.back=-1,s.mode=wi;break}if(64&E){t.msg="invalid literal/length code",s.mode=Pi;break}s.extra=15&E,s.mode=16201;case 16201:if(s.extra){for(F=s.extra;h<F;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}s.length+=c&(1<<s.extra)-1,c>>>=s.extra,h-=s.extra,s.back+=s.extra}s.was=s.length,s.mode=16202;case 16202:for(;A=s.distcode[c&(1<<s.distbits)-1],m=A>>>24,E=A>>>16&255,_=65535&A,!(m<=h);){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}if(!(240&E)){for(g=m,C=E,T=_;A=s.distcode[T+((c&(1<<g+C)-1)>>g)],m=A>>>24,E=A>>>16&255,_=65535&A,!(g+m<=h);){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}c>>>=g,h-=g,s.back+=g}if(c>>>=m,h-=m,s.back+=m,64&E){t.msg="invalid distance code",s.mode=Pi;break}s.offset=_,s.extra=15&E,s.mode=16203;case 16203:if(s.extra){for(F=s.extra;h<F;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}s.offset+=c&(1<<s.extra)-1,c>>>=s.extra,h-=s.extra,s.back+=s.extra}if(s.offset>s.dmax){t.msg="invalid distance too far back",s.mode=Pi;break}s.mode=16204;case 16204:if(0===l)break t;if(f=u-l,s.offset>f){if(f=s.offset-f,f>s.whave&&s.sane){t.msg="invalid distance too far back",s.mode=Pi;break}f>s.wnext?(f-=s.wnext,p=s.wsize-f):p=s.wnext-f,f>s.length&&(f=s.length),I=s.window}else I=r,p=o-s.offset,f=s.length;f>l&&(f=l),l-=f,s.length-=f;do{r[o++]=I[p++]}while(--f);0===s.length&&(s.mode=Ni);break;case 16205:if(0===l)break t;r[o++]=s.length,l--,s.mode=Ni;break;case vi:if(s.wrap){for(;h<32;){if(0===a)break t;a--,c|=i[n++]<<h,h+=8}if(u-=l,t.total_out+=u,s.total+=u,4&s.wrap&&u&&(t.adler=s.check=s.flags?Be(s.check,r,u,o-u):Ue(s.check,r,u,o-u)),u=l,4&s.wrap&&(s.flags?c:Mi(c))!==s.check){t.msg="incorrect data check",s.mode=Pi;break}c=0,h=0}s.mode=16207;case 16207:if(s.wrap&&s.flags){for(;h<32;){if(0===a)break t;a--,c+=i[n++]<<h,h+=8}if(4&s.wrap&&c!==(4294967295&s.total)){t.msg="incorrect length check",s.mode=Pi;break}c=0,h=0}s.mode=16208;case 16208:R=gi;break t;case Pi:R=bi;break t;case 16210:return Ri;default:return Ti}return t.next_out=o,t.avail_out=l,t.next_in=n,t.avail_in=a,s.hold=c,s.bits=h,(s.wsize||u!==t.avail_out&&s.mode<Pi&&(s.mode<vi||e!==Ii))&&qi(t,t.output,t.next_out,u-t.avail_out),d-=t.avail_in,u-=t.avail_out,t.total_in+=d,t.total_out+=u,s.total+=u,4&s.wrap&&u&&(t.adler=s.check=s.flags?Be(s.check,r,u,t.next_out-u):Ue(s.check,r,u,t.next_out-u)),t.data_type=s.bits+(s.last?64:0)+(s.mode===wi?128:0)+(s.mode===xi||s.mode===Oi?256:0),(0===d&&0===u||e===Ii)&&R===_i&&(R=Ai),R},inflateEnd:t=>{if(Ui(t))return Ti;let e=t.state;return e.window&&(e.window=null),t.state=null,_i},inflateGetHeader:(t,e)=>{if(Ui(t))return Ti;const s=t.state;return 2&s.wrap?(s.head=e,e.done=!1,_i):Ti},inflateSetDictionary:(t,e)=>{const s=e.length;let i,r,n;return Ui(t)?Ti:(i=t.state,0!==i.wrap&&i.mode!==Fi?Ti:i.mode===Fi&&(r=1,r=Ue(r,e,s,0),r!==i.check)?bi:(n=qi(t,e,s,s),n?(i.mode=16210,Ri):(i.havedict=1,_i)))},inflateInfo:"pako inflate (from Nodeca project)"};var Xi=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const Zi=Object.prototype.toString,{Z_NO_FLUSH:$i,Z_FINISH:Qi,Z_OK:Ki,Z_STREAM_END:Ji,Z_NEED_DICT:tr,Z_STREAM_ERROR:er,Z_DATA_ERROR:sr,Z_MEM_ERROR:ir}=Ge;function rr(t){this.options=zs({chunkSize:65536,windowBits:15,to:""},t||{});const e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&(15&e.windowBits||(e.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new js,this.strm.avail_out=0;let s=ji.inflateInit2(this.strm,e.windowBits);if(s!==Ki)throw new Error(ze[s]);if(this.header=new Xi,ji.inflateGetHeader(this.strm,this.header),e.dictionary&&("string"==typeof e.dictionary?e.dictionary=Ys(e.dictionary):"[object ArrayBuffer]"===Zi.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(s=ji.inflateSetDictionary(this.strm,e.dictionary),s!==Ki)))throw new Error(ze[s])}function nr(t,e){const s=new rr(e);if(s.push(t),s.err)throw s.msg||ze[s.err];return s.result}rr.prototype.push=function(t,e){const s=this.strm,i=this.options.chunkSize,r=this.options.dictionary;let n,o,a;if(this.ended)return!1;for(o=e===~~e?e:!0===e?Qi:$i,"[object ArrayBuffer]"===Zi.call(t)?s.input=new Uint8Array(t):s.input=t,s.next_in=0,s.avail_in=s.input.length;;){for(0===s.avail_out&&(s.output=new Uint8Array(i),s.next_out=0,s.avail_out=i),n=ji.inflate(s,o),n===tr&&r&&(n=ji.inflateSetDictionary(s,r),n===Ki?n=ji.inflate(s,o):n===sr&&(n=tr));s.avail_in>0&&n===Ji&&s.state.wrap>0&&0!==t[s.next_in];)ji.inflateReset(s),n=ji.inflate(s,o);switch(n){case er:case sr:case tr:case ir:return this.onEnd(n),this.ended=!0,!1}if(a=s.avail_out,s.next_out&&(0===s.avail_out||n===Ji))if("string"===this.options.to){let t=qs(s.output,s.next_out),e=s.next_out-t,r=Ws(s.output,t);s.next_out=e,s.avail_out=i-e,e&&s.output.set(s.output.subarray(t,t+e),0),this.onData(r)}else this.onData(s.output.length===s.next_out?s.output:s.output.subarray(0,s.next_out));if(n!==Ki||0!==a){if(n===Ji)return n=ji.inflateEnd(this.strm),this.onEnd(n),this.ended=!0,!0;if(0===s.avail_in)break}}return!0},rr.prototype.onData=function(t){this.chunks.push(t)},rr.prototype.onEnd=function(t){t===Ki&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=Gs(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};var or={Inflate:rr,inflate:nr,inflateRaw:function(t,e){return(e=e||{}).raw=!0,nr(t,e)},ungzip:nr};const{Deflate:ar,deflate:lr,deflateRaw:cr,gzip:hr}=oi,{Inflate:dr,inflate:ur,inflateRaw:fr,ungzip:pr}=or;var Ir={Deflate:ar,deflate:lr,deflateRaw:cr,gzip:hr,Inflate:dr,inflate:ur,inflateRaw:fr,ungzip:pr,constants:Ge};class mr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAttribute(t,e){return(e||new mr).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAttribute(t,e){return t.setPosition(t.position()+4),(e||new mr).__init(t.readInt32(t.position())+t.position(),t)}data(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}dataLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAttribute(t){t.startObject(1)}static addData(t,e){t.addFieldOffset(0,e,0)}static createDataVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startDataVector(t,e){t.startVector(4,e,4)}static endAttribute(t){const e=t.endObject();return t.requiredField(e,4),e}static createAttribute(t,e){return mr.startAttribute(t),mr.addData(t,e),mr.endAttribute(t)}}class Er{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}x(){return this.bb.readFloat32(this.bb_pos)}mutate_x(t){return this.bb.writeFloat32(this.bb_pos+0,t),!0}y(){return this.bb.readFloat32(this.bb_pos+4)}mutate_y(t){return this.bb.writeFloat32(this.bb_pos+4,t),!0}z(){return this.bb.readFloat32(this.bb_pos+8)}mutate_z(t){return this.bb.writeFloat32(this.bb_pos+8,t),!0}static sizeOf(){return 12}static createFloatVector(t,e,s,i){return t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class _r{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}aperture(){return this.bb.readFloat32(this.bb_pos)}mutate_aperture(t){return this.bb.writeFloat32(this.bb_pos+0,t),!0}position(t){return(t||new Er).__init(this.bb_pos+4,this.bb)}radius(){return this.bb.readFloat32(this.bb_pos+16)}mutate_radius(t){return this.bb.writeFloat32(this.bb_pos+16,t),!0}xDirection(t){return(t||new Er).__init(this.bb_pos+20,this.bb)}yDirection(t){return(t||new Er).__init(this.bb_pos+32,this.bb)}static sizeOf(){return 44}static createCircleCurve(t,e,s,i,r,n,o,a,l,c,h,d){return t.prep(4,44),t.prep(4,12),t.writeFloat32(d),t.writeFloat32(h),t.writeFloat32(c),t.prep(4,12),t.writeFloat32(l),t.writeFloat32(a),t.writeFloat32(o),t.writeFloat32(n),t.prep(4,12),t.writeFloat32(r),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class gr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}p1(t){return(t||new Er).__init(this.bb_pos,this.bb)}p2(t){return(t||new Er).__init(this.bb_pos+12,this.bb)}static sizeOf(){return 24}static createWire(t,e,s,i,r,n,o){return t.prep(4,24),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(n),t.writeFloat32(r),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class Cr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsWireSet(t,e){return(e||new Cr).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsWireSet(t,e){return t.setPosition(t.position()+4),(e||new Cr).__init(t.readInt32(t.position())+t.position(),t)}ps(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Er).__init(this.bb.__vector(this.bb_pos+s)+12*t,this.bb):null}psLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startWireSet(t){t.startObject(1)}static addPs(t,e){t.addFieldOffset(0,e,0)}static startPsVector(t,e){t.startVector(12,e,4)}static endWireSet(t){return t.endObject()}static createWireSet(t,e){return Cr.startWireSet(t),Cr.addPs(t,e),Cr.endWireSet(t)}}class Tr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAxis(t,e){return(e||new Tr).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAxis(t,e){return t.setPosition(t.position()+4),(e||new Tr).__init(t.readInt32(t.position())+t.position(),t)}wires(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new gr).__init(this.bb.__vector(this.bb_pos+s)+24*t,this.bb):null}wiresLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}order(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}orderLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}orderArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}parts(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt8(this.bb.__vector(this.bb_pos+e)+t):0}partsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}partsArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Int8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}wireSets(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new Cr).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}wireSetsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}circleCurves(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new _r).__init(this.bb.__vector(this.bb_pos+s)+44*t,this.bb):null}circleCurvesLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAxis(t){t.startObject(5)}static addWires(t,e){t.addFieldOffset(0,e,0)}static startWiresVector(t,e){t.startVector(24,e,4)}static addOrder(t,e){t.addFieldOffset(1,e,0)}static createOrderVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOrderVector(t,e){t.startVector(4,e,4)}static addParts(t,e){t.addFieldOffset(2,e,0)}static createPartsVector(t,e){t.startVector(1,e.length,1);for(let s=e.length-1;s>=0;s--)t.addInt8(e[s]);return t.endVector()}static startPartsVector(t,e){t.startVector(1,e,1)}static addWireSets(t,e){t.addFieldOffset(3,e,0)}static createWireSetsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startWireSetsVector(t,e){t.startVector(4,e,4)}static addCircleCurves(t,e){t.addFieldOffset(4,e,0)}static startCircleCurvesVector(t,e){t.startVector(44,e,4)}static endAxis(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),e}static createAxis(t,e,s,i,r,n){return Tr.startAxis(t),Tr.addWires(t,e),Tr.addOrder(t,s),Tr.addParts(t,i),Tr.addWireSets(t,r),Tr.addCircleCurves(t,n),Tr.endAxis(t)}}var br=(t=>(t[t.NONE=0]="NONE",t[t.WIRE=1]="WIRE",t[t.WIRE_SET=2]="WIRE_SET",t[t.CIRCLE_CURVE=3]="CIRCLE_CURVE",t))(br||{});class Rr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsBigShellHole(t,e){return(e||new Rr).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsBigShellHole(t,e){return t.setPosition(t.position()+4),(e||new Rr).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}profileId(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint16(this.bb_pos+t):0}mutate_profile_id(t){const e=this.bb.__offset(this.bb_pos,6);return 0!==e&&(this.bb.writeUint16(this.bb_pos+e,t),!0)}static startBigShellHole(t){t.startObject(2)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(4,e,4)}static addProfileId(t,e){t.addFieldInt16(1,e,0)}static endBigShellHole(t){const e=t.endObject();return t.requiredField(e,4),e}static createBigShellHole(t,e,s){return Rr.startBigShellHole(t),Rr.addIndices(t,e),Rr.addProfileId(t,s),Rr.endBigShellHole(t)}}class Ar{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsBigShellProfile(t,e){return(e||new Ar).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsBigShellProfile(t,e){return t.setPosition(t.position()+4),(e||new Ar).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startBigShellProfile(t){t.startObject(1)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(4,e,4)}static endBigShellProfile(t){const e=t.endObject();return t.requiredField(e,4),e}static createBigShellProfile(t,e){return Ar.startBigShellProfile(t),Ar.addIndices(t,e),Ar.endBigShellProfile(t)}}class yr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}min(t){return(t||new Er).__init(this.bb_pos,this.bb)}max(t){return(t||new Er).__init(this.bb_pos+12,this.bb)}static sizeOf(){return 24}static createBoundingBox(t,e,s,i,r,n,o){return t.prep(4,24),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(n),t.writeFloat32(r),t.prep(4,12),t.writeFloat32(i),t.writeFloat32(s),t.writeFloat32(e),t.offset()}}class Sr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCircleExtrusion(t,e){return(e||new Sr).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCircleExtrusion(t,e){return t.setPosition(t.position()+4),(e||new Sr).__init(t.readInt32(t.position())+t.position(),t)}radius(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat64(this.bb.__vector(this.bb_pos+e)+8*t):0}radiusLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}radiusArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float64Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}axes(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new Tr).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}axesLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startCircleExtrusion(t){t.startObject(2)}static addRadius(t,e){t.addFieldOffset(0,e,0)}static createRadiusVector(t,e){t.startVector(8,e.length,8);for(let s=e.length-1;s>=0;s--)t.addFloat64(e[s]);return t.endVector()}static startRadiusVector(t,e){t.startVector(8,e,8)}static addAxes(t,e){t.addFieldOffset(1,e,0)}static createAxesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAxesVector(t,e){t.startVector(4,e,4)}static endCircleExtrusion(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),e}static createCircleExtrusion(t,e,s){return Sr.startCircleExtrusion(t),Sr.addRadius(t,e),Sr.addAxes(t,s),Sr.endCircleExtrusion(t)}}class Fr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}x(){return this.bb.readFloat64(this.bb_pos)}mutate_x(t){return this.bb.writeFloat64(this.bb_pos+0,t),!0}y(){return this.bb.readFloat64(this.bb_pos+8)}mutate_y(t){return this.bb.writeFloat64(this.bb_pos+8,t),!0}z(){return this.bb.readFloat64(this.bb_pos+16)}mutate_z(t){return this.bb.writeFloat64(this.bb_pos+16,t),!0}static sizeOf(){return 24}static createDoubleVector(t,e,s,i){return t.prep(8,24),t.writeFloat64(i),t.writeFloat64(s),t.writeFloat64(e),t.offset()}}class wr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}r(){return this.bb.readUint8(this.bb_pos)}mutate_r(t){return this.bb.writeUint8(this.bb_pos+0,t),!0}g(){return this.bb.readUint8(this.bb_pos+1)}mutate_g(t){return this.bb.writeUint8(this.bb_pos+1,t),!0}b(){return this.bb.readUint8(this.bb_pos+2)}mutate_b(t){return this.bb.writeUint8(this.bb_pos+2,t),!0}a(){return this.bb.readUint8(this.bb_pos+3)}mutate_a(t){return this.bb.writeUint8(this.bb_pos+3,t),!0}renderedFaces(){return this.bb.readInt8(this.bb_pos+4)}mutate_rendered_faces(t){return this.bb.writeInt8(this.bb_pos+4,t),!0}stroke(){return this.bb.readInt8(this.bb_pos+5)}mutate_stroke(t){return this.bb.writeInt8(this.bb_pos+5,t),!0}static sizeOf(){return 6}static createMaterial(t,e,s,i,r,n,o){return t.prep(1,6),t.writeInt8(o),t.writeInt8(n),t.writeInt8(r),t.writeInt8(i),t.writeInt8(s),t.writeInt8(e),t.offset()}}class Lr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}id(){return this.bb.readUint32(this.bb_pos)}mutate_id(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}bbox(t){return(t||new yr).__init(this.bb_pos+4,this.bb)}representationClass(){return this.bb.readInt8(this.bb_pos+28)}mutate_representation_class(t){return this.bb.writeInt8(this.bb_pos+28,t),!0}static sizeOf(){return 32}static createRepresentation(t,e,s,i,r,n,o,a,l){return t.prep(4,32),t.pad(3),t.writeInt8(l),t.prep(4,24),t.prep(4,12),t.writeFloat32(a),t.writeFloat32(o),t.writeFloat32(n),t.prep(4,12),t.writeFloat32(r),t.writeFloat32(i),t.writeFloat32(s),t.writeInt32(e),t.offset()}}class Or{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}item(){return this.bb.readUint32(this.bb_pos)}mutate_item(t){return this.bb.writeUint32(this.bb_pos+0,t),!0}material(){return this.bb.readUint32(this.bb_pos+4)}mutate_material(t){return this.bb.writeUint32(this.bb_pos+4,t),!0}representation(){return this.bb.readUint32(this.bb_pos+8)}mutate_representation(t){return this.bb.writeUint32(this.bb_pos+8,t),!0}localTransform(){return this.bb.readUint32(this.bb_pos+12)}mutate_local_transform(t){return this.bb.writeUint32(this.bb_pos+12,t),!0}static sizeOf(){return 16}static createSample(t,e,s,i,r){return t.prep(4,16),t.writeInt32(r),t.writeInt32(i),t.writeInt32(s),t.writeInt32(e),t.offset()}}class xr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShellHole(t,e){return(e||new xr).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShellHole(t,e){return t.setPosition(t.position()+4),(e||new xr).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+2*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}profileId(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint16(this.bb_pos+t):0}mutate_profile_id(t){const e=this.bb.__offset(this.bb_pos,6);return 0!==e&&(this.bb.writeUint16(this.bb_pos+e,t),!0)}static startShellHole(t){t.startObject(2)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(2,e,2)}static addProfileId(t,e){t.addFieldInt16(1,e,0)}static endShellHole(t){const e=t.endObject();return t.requiredField(e,4),e}static createShellHole(t,e,s){return xr.startShellHole(t),xr.addIndices(t,e),xr.addProfileId(t,s),xr.endShellHole(t)}}class Nr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShellProfile(t,e){return(e||new Nr).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShellProfile(t,e){return t.setPosition(t.position()+4),(e||new Nr).__init(t.readInt32(t.position())+t.position(),t)}indices(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+2*t):0}indicesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}indicesArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startShellProfile(t){t.startObject(1)}static addIndices(t,e){t.addFieldOffset(0,e,0)}static createIndicesVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startIndicesVector(t,e){t.startVector(2,e,2)}static endShellProfile(t){const e=t.endObject();return t.requiredField(e,4),e}static createShellProfile(t,e){return Nr.startShellProfile(t),Nr.addIndices(t,e),Nr.endShellProfile(t)}}var vr=(t=>(t[t.NONE=0]="NONE",t[t.BIG=1]="BIG",t))(vr||{});class Pr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShell(t,e){return(e||new Pr).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShell(t,e){return t.setPosition(t.position()+4),(e||new Pr).__init(t.readInt32(t.position())+t.position(),t)}profiles(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Nr).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}profilesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}holes(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new xr).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}holesLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}points(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new Er).__init(this.bb.__vector(this.bb_pos+s)+12*t,this.bb):null}pointsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}bigProfiles(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new Ar).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}bigProfilesLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}bigHoles(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new Rr).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}bigHolesLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}type(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.readInt8(this.bb_pos+t):vr.NONE}mutate_type(t){const e=this.bb.__offset(this.bb_pos,14);return 0!==e&&(this.bb.writeInt8(this.bb_pos+e,t),!0)}profilesFaceIds(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readUint16(this.bb.__vector(this.bb_pos+e)+2*t):0}profilesFaceIdsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}profilesFaceIdsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint16Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startShell(t){t.startObject(7)}static addProfiles(t,e){t.addFieldOffset(0,e,0)}static createProfilesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startProfilesVector(t,e){t.startVector(4,e,4)}static addHoles(t,e){t.addFieldOffset(1,e,0)}static createHolesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHolesVector(t,e){t.startVector(4,e,4)}static addPoints(t,e){t.addFieldOffset(2,e,0)}static startPointsVector(t,e){t.startVector(12,e,4)}static addBigProfiles(t,e){t.addFieldOffset(3,e,0)}static createBigProfilesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startBigProfilesVector(t,e){t.startVector(4,e,4)}static addBigHoles(t,e){t.addFieldOffset(4,e,0)}static createBigHolesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startBigHolesVector(t,e){t.startVector(4,e,4)}static addType(t,e){t.addFieldInt8(5,e,vr.NONE)}static addProfilesFaceIds(t,e){t.addFieldOffset(6,e,0)}static createProfilesFaceIdsVector(t,e){t.startVector(2,e.length,2);for(let s=e.length-1;s>=0;s--)t.addInt16(e[s]);return t.endVector()}static startProfilesFaceIdsVector(t,e){t.startVector(2,e,2)}static endShell(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),t.requiredField(e,16),e}static createShell(t,e,s,i,r,n,o,a){return Pr.startShell(t),Pr.addProfiles(t,e),Pr.addHoles(t,s),Pr.addPoints(t,i),Pr.addBigProfiles(t,r),Pr.addBigHoles(t,n),Pr.addType(t,o),Pr.addProfilesFaceIds(t,a),Pr.endShell(t)}}class Mr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}position(t){return(t||new Fr).__init(this.bb_pos,this.bb)}xDirection(t){return(t||new Er).__init(this.bb_pos+24,this.bb)}yDirection(t){return(t||new Er).__init(this.bb_pos+36,this.bb)}static sizeOf(){return 48}static createTransform(t,e,s,i,r,n,o,a,l,c){return t.prep(8,48),t.prep(4,12),t.writeFloat32(c),t.writeFloat32(l),t.writeFloat32(a),t.prep(4,12),t.writeFloat32(o),t.writeFloat32(n),t.writeFloat32(r),t.prep(8,24),t.writeFloat64(i),t.writeFloat64(s),t.writeFloat64(e),t.offset()}}class Dr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsMeshes(t,e){return(e||new Dr).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsMeshes(t,e){return t.setPosition(t.position()+4),(e||new Dr).__init(t.readInt32(t.position())+t.position(),t)}coordinates(t){const e=this.bb.__offset(this.bb_pos,4);return e?(t||new Mr).__init(this.bb_pos+e,this.bb):null}meshesItems(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}meshesItemsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}meshesItemsArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}samples(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new Or).__init(this.bb.__vector(this.bb_pos+s)+16*t,this.bb):null}samplesLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}representations(t,e){const s=this.bb.__offset(this.bb_pos,10);return s?(e||new Lr).__init(this.bb.__vector(this.bb_pos+s)+32*t,this.bb):null}representationsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}materials(t,e){const s=this.bb.__offset(this.bb_pos,12);return s?(e||new wr).__init(this.bb.__vector(this.bb_pos+s)+6*t,this.bb):null}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}circleExtrusions(t,e){const s=this.bb.__offset(this.bb_pos,14);return s?(e||new Sr).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}circleExtrusionsLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}shells(t,e){const s=this.bb.__offset(this.bb_pos,16);return s?(e||new Pr).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}shellsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}localTransforms(t,e){const s=this.bb.__offset(this.bb_pos,18);return s?(e||new Mr).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}localTransformsLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}globalTransforms(t,e){const s=this.bb.__offset(this.bb_pos,20);return s?(e||new Mr).__init(this.bb.__vector(this.bb_pos+s)+48*t,this.bb):null}globalTransformsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}materialIds(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}materialIdsLength(){const t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}materialIdsArray(){const t=this.bb.__offset(this.bb_pos,22);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}representationIds(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}representationIdsLength(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}representationIdsArray(){const t=this.bb.__offset(this.bb_pos,24);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}sampleIds(t){const e=this.bb.__offset(this.bb_pos,26);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}sampleIdsLength(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}sampleIdsArray(){const t=this.bb.__offset(this.bb_pos,26);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}localTransformIds(t){const e=this.bb.__offset(this.bb_pos,28);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}localTransformIdsLength(){const t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}localTransformIdsArray(){const t=this.bb.__offset(this.bb_pos,28);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}globalTransformIds(t){const e=this.bb.__offset(this.bb_pos,30);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}globalTransformIdsLength(){const t=this.bb.__offset(this.bb_pos,30);return t?this.bb.__vector_len(this.bb_pos+t):0}globalTransformIdsArray(){const t=this.bb.__offset(this.bb_pos,30);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startMeshes(t){t.startObject(14)}static addCoordinates(t,e){t.addFieldStruct(0,e,0)}static addMeshesItems(t,e){t.addFieldOffset(1,e,0)}static createMeshesItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startMeshesItemsVector(t,e){t.startVector(4,e,4)}static addSamples(t,e){t.addFieldOffset(2,e,0)}static startSamplesVector(t,e){t.startVector(16,e,4)}static addRepresentations(t,e){t.addFieldOffset(3,e,0)}static startRepresentationsVector(t,e){t.startVector(32,e,4)}static addMaterials(t,e){t.addFieldOffset(4,e,0)}static startMaterialsVector(t,e){t.startVector(6,e,1)}static addCircleExtrusions(t,e){t.addFieldOffset(5,e,0)}static createCircleExtrusionsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startCircleExtrusionsVector(t,e){t.startVector(4,e,4)}static addShells(t,e){t.addFieldOffset(6,e,0)}static createShellsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startShellsVector(t,e){t.startVector(4,e,4)}static addLocalTransforms(t,e){t.addFieldOffset(7,e,0)}static startLocalTransformsVector(t,e){t.startVector(48,e,8)}static addGlobalTransforms(t,e){t.addFieldOffset(8,e,0)}static startGlobalTransformsVector(t,e){t.startVector(48,e,8)}static addMaterialIds(t,e){t.addFieldOffset(9,e,0)}static createMaterialIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startMaterialIdsVector(t,e){t.startVector(4,e,4)}static addRepresentationIds(t,e){t.addFieldOffset(10,e,0)}static createRepresentationIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startRepresentationIdsVector(t,e){t.startVector(4,e,4)}static addSampleIds(t,e){t.addFieldOffset(11,e,0)}static createSampleIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startSampleIdsVector(t,e){t.startVector(4,e,4)}static addLocalTransformIds(t,e){t.addFieldOffset(12,e,0)}static createLocalTransformIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startLocalTransformIdsVector(t,e){t.startVector(4,e,4)}static addGlobalTransformIds(t,e){t.addFieldOffset(13,e,0)}static createGlobalTransformIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startGlobalTransformIdsVector(t,e){t.startVector(4,e,4)}static endMeshes(t){const e=t.endObject();return t.requiredField(e,4),t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,10),t.requiredField(e,12),t.requiredField(e,14),t.requiredField(e,16),t.requiredField(e,18),t.requiredField(e,20),e}static createMeshes(t,e,s,i,r,n,o,a,l,c,h,d,u,f,p){return Dr.startMeshes(t),Dr.addCoordinates(t,e),Dr.addMeshesItems(t,s),Dr.addSamples(t,i),Dr.addRepresentations(t,r),Dr.addMaterials(t,n),Dr.addCircleExtrusions(t,o),Dr.addShells(t,a),Dr.addLocalTransforms(t,l),Dr.addGlobalTransforms(t,c),Dr.addMaterialIds(t,h),Dr.addRepresentationIds(t,d),Dr.addSampleIds(t,u),Dr.addLocalTransformIds(t,f),Dr.addGlobalTransformIds(t,p),Dr.endMeshes(t)}}class Ur{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsRelation(t,e){return(e||new Ur).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsRelation(t,e){return t.setPosition(t.position()+4),(e||new Ur).__init(t.readInt32(t.position())+t.position(),t)}data(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}dataLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startRelation(t){t.startObject(1)}static addData(t,e){t.addFieldOffset(0,e,0)}static createDataVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startDataVector(t,e){t.startVector(4,e,4)}static endRelation(t){const e=t.endObject();return t.requiredField(e,4),e}static createRelation(t,e){return Ur.startRelation(t),Ur.addData(t,e),Ur.endRelation(t)}}class Vr{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSpatialStructure(t,e){return(e||new Vr).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSpatialStructure(t,e){return t.setPosition(t.position()+4),(e||new Vr).__init(t.readInt32(t.position())+t.position(),t)}localId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):null}mutate_local_id(t){const e=this.bb.__offset(this.bb_pos,4);return 0!==e&&(this.bb.writeUint32(this.bb_pos+e,t),!0)}category(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}children(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new Vr).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}childrenLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSpatialStructure(t){t.startObject(3)}static addLocalId(t,e){t.addFieldInt32(0,e,null)}static addCategory(t,e){t.addFieldOffset(1,e,0)}static addChildren(t,e){t.addFieldOffset(2,e,0)}static createChildrenVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startChildrenVector(t,e){t.startVector(4,e,4)}static endSpatialStructure(t){return t.endObject()}static createSpatialStructure(t,e,s,i){return Vr.startSpatialStructure(t),null!==e&&Vr.addLocalId(t,e),Vr.addCategory(t,s),Vr.addChildren(t,i),Vr.endSpatialStructure(t)}}class Br{constructor(){ot(this,"bb",null),ot(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsModel(t,e){return(e||new Br).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsModel(t,e){return t.setPosition(t.position()+4),(e||new Br).__init(t.readInt32(t.position())+t.position(),t)}static bufferHasIdentifier(t){return t.__has_identifier("0001")}metadata(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}guids(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}guidsLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}guidsItems(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}guidsItemsLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}guidsItemsArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}maxLocalId(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readUint32(this.bb_pos+t):0}mutate_max_local_id(t){const e=this.bb.__offset(this.bb_pos,10);return 0!==e&&(this.bb.writeUint32(this.bb_pos+e,t),!0)}localIds(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}localIdsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}localIdsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}categories(t,e){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}categoriesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}meshes(t){const e=this.bb.__offset(this.bb_pos,16);return e?(t||new Dr).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}attributes(t,e){const s=this.bb.__offset(this.bb_pos,18);return s?(e||new mr).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}attributesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}relations(t,e){const s=this.bb.__offset(this.bb_pos,20);return s?(e||new Ur).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}relationsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}relationsItems(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}relationsItemsLength(){const t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}relationsItemsArray(){const t=this.bb.__offset(this.bb_pos,22);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}guid(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb_pos+e,t):null}spatialStructure(t){const e=this.bb.__offset(this.bb_pos,26);return e?(t||new Vr).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}uniqueAttributes(t,e){const s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}uniqueAttributesLength(){const t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}relationNames(t,e){const s=this.bb.__offset(this.bb_pos,30);return s?this.bb.__string(this.bb.__vector(this.bb_pos+s)+4*t,e):null}relationNamesLength(){const t=this.bb.__offset(this.bb_pos,30);return t?this.bb.__vector_len(this.bb_pos+t):0}static startModel(t){t.startObject(14)}static addMetadata(t,e){t.addFieldOffset(0,e,0)}static addGuids(t,e){t.addFieldOffset(1,e,0)}static createGuidsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startGuidsVector(t,e){t.startVector(4,e,4)}static addGuidsItems(t,e){t.addFieldOffset(2,e,0)}static createGuidsItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startGuidsItemsVector(t,e){t.startVector(4,e,4)}static addMaxLocalId(t,e){t.addFieldInt32(3,e,0)}static addLocalIds(t,e){t.addFieldOffset(4,e,0)}static createLocalIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startLocalIdsVector(t,e){t.startVector(4,e,4)}static addCategories(t,e){t.addFieldOffset(5,e,0)}static createCategoriesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startCategoriesVector(t,e){t.startVector(4,e,4)}static addMeshes(t,e){t.addFieldOffset(6,e,0)}static addAttributes(t,e){t.addFieldOffset(7,e,0)}static createAttributesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAttributesVector(t,e){t.startVector(4,e,4)}static addRelations(t,e){t.addFieldOffset(8,e,0)}static createRelationsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startRelationsVector(t,e){t.startVector(4,e,4)}static addRelationsItems(t,e){t.addFieldOffset(9,e,0)}static createRelationsItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startRelationsItemsVector(t,e){t.startVector(4,e,4)}static addGuid(t,e){t.addFieldOffset(10,e,0)}static addSpatialStructure(t,e){t.addFieldOffset(11,e,0)}static addUniqueAttributes(t,e){t.addFieldOffset(12,e,0)}static createUniqueAttributesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startUniqueAttributesVector(t,e){t.startVector(4,e,4)}static addRelationNames(t,e){t.addFieldOffset(13,e,0)}static createRelationNamesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startRelationNamesVector(t,e){t.startVector(4,e,4)}static endModel(t){const e=t.endObject();return t.requiredField(e,6),t.requiredField(e,8),t.requiredField(e,12),t.requiredField(e,14),t.requiredField(e,16),t.requiredField(e,24),e}static finishModelBuffer(t,e){t.finish(e,"0001")}static finishSizePrefixedModelBuffer(t,e){t.finish(e,"0001",!0)}}var zr=(t=>(t[t.ONE=0]="ONE",t[t.TWO=1]="TWO",t))(zr||{}),Gr=(t=>(t[t.NONE=0]="NONE",t[t.SHELL=1]="SHELL",t[t.CIRCLE_EXTRUSION=2]="CIRCLE_EXTRUSION",t))(Gr||{}),Hr=(t=>(t[t.DEFAULT=0]="DEFAULT",t))(Hr||{}),kr=(t=>(t[t.CREATE_MATERIAL=0]="CREATE_MATERIAL",t[t.CREATE_REPRESENTATION=1]="CREATE_REPRESENTATION",t[t.CREATE_SAMPLE=2]="CREATE_SAMPLE",t[t.CREATE_GLOBAL_TRANSFORM=3]="CREATE_GLOBAL_TRANSFORM",t[t.CREATE_LOCAL_TRANSFORM=4]="CREATE_LOCAL_TRANSFORM",t[t.CREATE_ITEM=5]="CREATE_ITEM",t[t.CREATE_RELATION=6]="CREATE_RELATION",t[t.UPDATE_MATERIAL=7]="UPDATE_MATERIAL",t[t.UPDATE_REPRESENTATION=8]="UPDATE_REPRESENTATION",t[t.UPDATE_SAMPLE=9]="UPDATE_SAMPLE",t[t.UPDATE_GLOBAL_TRANSFORM=10]="UPDATE_GLOBAL_TRANSFORM",t[t.UPDATE_LOCAL_TRANSFORM=11]="UPDATE_LOCAL_TRANSFORM",t[t.UPDATE_ITEM=12]="UPDATE_ITEM",t[t.UPDATE_MAX_LOCAL_ID=13]="UPDATE_MAX_LOCAL_ID",t[t.UPDATE_RELATION=14]="UPDATE_RELATION",t[t.UPDATE_METADATA=15]="UPDATE_METADATA",t[t.UPDATE_SPATIAL_STRUCTURE=16]="UPDATE_SPATIAL_STRUCTURE",t[t.DELETE_MATERIAL=17]="DELETE_MATERIAL",t[t.DELETE_REPRESENTATION=18]="DELETE_REPRESENTATION",t[t.DELETE_SAMPLE=19]="DELETE_SAMPLE",t[t.DELETE_GLOBAL_TRANSFORM=20]="DELETE_GLOBAL_TRANSFORM",t[t.DELETE_LOCAL_TRANSFORM=21]="DELETE_LOCAL_TRANSFORM",t[t.DELETE_ITEM=22]="DELETE_ITEM",t[t.DELETE_RELATION=23]="DELETE_RELATION",t))(kr||{});const Yr={0:"Create Material",1:"Create Representation",2:"Create Sample",3:"Create Global Transform",4:"Create Local Transform",5:"Create Item",6:"Create Relation",7:"Update Material",8:"Update Representation",9:"Update Sample",10:"Update Global Transform",11:"Update Local Transform",12:"Update Item",13:"Update Max Local Id",14:"Update Relation",15:"Update Metadata",16:"Update Spatial Structure",17:"Delete Material",18:"Delete Representation",19:"Delete Sample",20:"Delete Global Transform",21:"Delete Local Transform",22:"Delete Item",23:"Delete Relation"};function Wr(t,e){const s=t.position,i=t.xDirection,r=t.yDirection;return Mr.createTransform(e,s[0],s[1],s[2],i[0],i[1],i[2],r[0],r[1],r[2])}function qr(t,e){const s=e.position(),i=e.xDirection(),r=e.yDirection();return Mr.createTransform(t,s.x(),s.y(),s.z(),i.x(),i.y(),i.z(),r.x(),r.y(),r.z())}function jr(t,e){return Er.createFloatVector(t,e.x(),e.y(),e.z())}function Xr(t,e){const s=e.type,i=[],r=[],n=[],o=[],a=e.points.length;Pr.startPointsVector(t,a);for(let s=0;s<a;s++){const i=a-1-s,r=e.points[i];Er.createFloatVector(t,r[0],r[1],r[2])}const l=t.endVector();for(const[,s]of e.profiles){const e=Nr.createIndicesVector(t,s),r=Nr.createShellProfile(t,e);i.push(r)}const c=Pr.createProfilesVector(t,i);for(const[s,i]of e.holes)for(const e of i){const i=xr.createIndicesVector(t,e),n=xr.createShellHole(t,i,s);r.push(n)}const h=Pr.createHolesVector(t,r);for(const[,s]of e.bigProfiles){const e=Ar.createIndicesVector(t,s),i=Ar.createBigShellProfile(t,e);n.push(i)}const d=Pr.createBigProfilesVector(t,n);for(const[s,i]of e.bigHoles)for(const e of i){const i=Rr.createIndicesVector(t,e),r=Rr.createBigShellHole(t,i,s);o.push(r)}const u=Pr.createBigHolesVector(t,o),f=Pr.createProfilesFaceIdsVector(t,e.profilesFaceIds);return Pr.createShell(t,c,h,l,d,u,s,f)}function Zr(t,e){const s=e.type(),i=[],r=[],n=[],o=[],a=e.pointsLength();Pr.startPointsVector(t,a);for(let s=0;s<a;s++){const i=a-1-s;jr(t,e.points(i))}const l=t.endVector(),c=e.profilesLength();for(let s=0;s<c;s++){const r=e.profiles(s).indicesArray(),n=Nr.createIndicesVector(t,r),o=Nr.createShellProfile(t,n);i.push(o)}const h=Pr.createProfilesVector(t,i),d=e.holesLength();for(let s=0;s<d;s++){const i=e.holes(s),n=i.indicesArray(),o=i.profileId(),a=xr.createIndicesVector(t,n),l=xr.createShellHole(t,a,o);r.push(l)}const u=Pr.createHolesVector(t,r),f=e.bigProfilesLength();for(let s=0;s<f;s++){const i=e.bigProfiles(s).indicesArray(),r=Ar.createIndicesVector(t,i),o=Ar.createBigShellProfile(t,r);n.push(o)}const p=Pr.createBigProfilesVector(t,n),I=e.bigHolesLength();for(let s=0;s<I;s++){const i=e.bigHoles(s),r=i.indicesArray(),n=i.profileId(),a=Rr.createIndicesVector(t,r),l=Rr.createBigShellHole(t,a,n);o.push(l)}const m=Pr.createBigHolesVector(t,o),E=Pr.createProfilesFaceIdsVector(t,e.profilesFaceIdsArray()||[]);return Pr.createShell(t,h,u,l,p,m,s,E)}function $r(t,e){const s=e.radiusArray(),i=Sr.createRadiusVector(t,s),r=e.axesLength(),n=[];for(let s=0;s<r;s++){const i=e.axes(s),r=i.circleCurvesLength();Tr.startCircleCurvesVector(t,r);for(let e=0;e<r;e++){const s=r-1-e,n=i.circleCurves(s),o=n.position(),a=n.radius(),l=n.aperture(),c=n.xDirection(),h=n.yDirection(),d=o.x(),u=o.y(),f=o.z(),p=c.x(),I=c.y(),m=c.z(),E=h.x(),_=h.y(),g=h.z();_r.createCircleCurve(t,l,d,u,f,a,p,I,m,E,_,g)}const o=t.endVector(),a=i.wiresLength();Tr.startWiresVector(t,a);for(let e=0;e<a;e++){const s=a-1-e,r=i.wires(s),n=r.p1(),o=r.p2();gr.createWire(t,n.x(),n.y(),n.z(),o.x(),o.y(),o.z())}const l=t.endVector();Tr.startWireSetsVector(t,0);const c=t.endVector(),h=i.orderArray(),d=Tr.createOrderVector(t,h),u=Array.from(i.partsArray()),f=Tr.createPartsVector(t,u);Tr.startAxis(t),Tr.addCircleCurves(t,o),Tr.addOrder(t,d),Tr.addWires(t,l),Tr.addWireSets(t,c),Tr.addParts(t,f);const p=Tr.endAxis(t);n.push(p)}const o=Sr.createAxesVector(t,n);Sr.startCircleExtrusion(t),Sr.addAxes(t,o),Sr.addRadius(t,i);return Sr.endCircleExtrusion(t)}function Qr(t,e){const s=e.radius,i=Sr.createRadiusVector(t,s),r=[];for(const s of e.axes){const e=s.circleCurves.length;Tr.startCircleCurvesVector(t,e);for(const e of s.circleCurves)_r.createCircleCurve(t,e.aperture,e.position[0],e.position[1],e.position[2],e.radius,e.xDirection[0],e.xDirection[1],e.xDirection[2],e.yDirection[0],e.yDirection[1],e.yDirection[2]);const i=t.endVector(),n=s.wires.length;Tr.startWiresVector(t,n);for(const e of s.wires)gr.createWire(t,e[0],e[1],e[2],e[3],e[4],e[5]);const o=t.endVector(),a=[];for(const e of s.wireSets){Cr.startPsVector(t,e.length/3);for(let s=0;s<e.length-2;s+=3)Er.createFloatVector(t,e[s],e[s+1],e[s+2]);const s=t.endVector();Cr.startWireSet(t),Cr.addPs(t,s);const i=Cr.endWireSet(t);a.push(i)}const l=Tr.createWireSetsVector(t,a),c=Tr.createOrderVector(t,s.order),h=Tr.createPartsVector(t,s.parts);Tr.startAxis(t),Tr.addCircleCurves(t,i),Tr.addOrder(t,c),Tr.addWires(t,o),Tr.addWireSets(t,l),Tr.addParts(t,h);const d=Tr.endAxis(t);r.push(d)}const n=Sr.createAxesVector(t,r);Sr.startCircleExtrusion(t),Sr.addAxes(t,n),Sr.addRadius(t,i);return Sr.endCircleExtrusion(t)}function Kr(t,e){if(!e)return null;const s=e.childrenLength(),i=[];for(let r=0;r<s;r++){const s=Kr(t,e.children(r));null!==s&&i.push(s)}const r=Vr.createChildrenVector(t,i),n=e.localId(),o=e.category();if(null!==n)return Vr.startSpatialStructure(t),Vr.addLocalId(t,n),Vr.addChildren(t,r),Vr.endSpatialStructure(t);if(null!==o){const e=t.createSharedString(o);return Vr.startSpatialStructure(t),Vr.addCategory(t,e),Vr.addChildren(t,r),Vr.endSpatialStructure(t)}throw new Error("Spatial structure must have a local id or a category")}function Jr(t,e){const s=e.children??[],i=s?s.length:0,r=[];for(let e=0;e<i;e++){const i=Jr(t,s[e]);null!==i&&r.push(i)}const n=Vr.createChildrenVector(t,r),o=e.localId,a=e.category;if(null!==o)return Vr.startSpatialStructure(t),Vr.addLocalId(t,o),Vr.addChildren(t,n),Vr.endSpatialStructure(t);if(null!==a){const e=t.createSharedString(a);return Vr.startSpatialStructure(t),Vr.addCategory(t,e),Vr.addChildren(t,n),Vr.endSpatialStructure(t)}throw new Error("Spatial structure must have a local id or a category")}function tn(t,e,s,i,r,n){if(!e.has(s))throw new Error("Invalid sample: item id not found");if(!e.has(i))throw new Error("Invalid sample: mat id not found");if(!e.has(r))throw new Error("Invalid sample: repr id not found");if(!e.has(n))throw new Error("Invalid sample: lt id not found");const o=e.get(s),a=e.get(i),l=e.get(r),c=e.get(n);Or.createSample(t,o,a,l,c)}function en(t){const e=new Jt(1024);Dr.startGlobalTransformsVector(e,0);const s=e.endVector(),i=Dr.createShellsVector(e,[]);Dr.startRepresentationsVector(e,0);const r=e.endVector();Dr.startSamplesVector(e,0);const n=e.endVector();Dr.startLocalTransformsVector(e,0);const o=e.endVector();Dr.startMaterialsVector(e,0);const a=e.endVector(),l=Dr.createCircleExtrusionsVector(e,[]),c=Dr.createMeshesItemsVector(e,[]),h=Dr.createRepresentationIdsVector(e,[]),d=Dr.createSampleIdsVector(e,[]),u=Dr.createMaterialIdsVector(e,[]),f=Dr.createLocalTransformIdsVector(e,[]),p=Dr.createGlobalTransformIdsVector(e,[]);Dr.startMeshes(e);const I=Wr({position:[0,0,0],xDirection:[1,0,0],yDirection:[0,1,0]},e);Dr.addCoordinates(e,I),Dr.addGlobalTransforms(e,s),Dr.addShells(e,i),Dr.addRepresentations(e,r),Dr.addSamples(e,n),Dr.addLocalTransforms(e,o),Dr.addMaterials(e,a),Dr.addCircleExtrusions(e,l),Dr.addMeshesItems(e,c),Dr.addRepresentationIds(e,h),Dr.addSampleIds(e,d),Dr.addMaterialIds(e,u),Dr.addLocalTransformIds(e,f),Dr.addGlobalTransformIds(e,p);const m=Dr.endMeshes(e),E=e.createString("{}"),_=Br.createAttributesVector(e,[]),g=Br.createUniqueAttributesVector(e,[]),C=Br.createRelationNamesVector(e,[]),T=Br.createLocalIdsVector(e,[]),b=Br.createCategoriesVector(e,[]),R=Br.createRelationsItemsVector(e,[]),A=Br.createRelationsVector(e,[]),y=Br.createGuidsItemsVector(e,[]),S=Br.createGuidsVector(e,[]),F=e.createString(ft.MathUtils.generateUUID());Br.startModel(e),Br.addMeshes(e,m),Br.addMetadata(e,E),Br.addAttributes(e,_),Br.addUniqueAttributes(e,g),Br.addRelationNames(e,C),Br.addLocalIds(e,T),Br.addCategories(e,b),Br.addRelationsItems(e,R),Br.addRelations(e,A),Br.addGuidsItems(e,y),Br.addGuids(e,S),Br.addGuid(e,F),Br.addMaxLocalId(e,1);const w=Br.endModel(e);e.finish(w);const L=e.asUint8Array();e.clear();return t.raw?L:Ir.deflate(L)}function sn(t,e,s,i,r){for(const s of t)s.type!==kr.UPDATE_SAMPLE&&s.type!==kr.DELETE_SAMPLE||e.add(s.localId);for(let t=0;t<s.sampleIdsLength();t++){const n=s.sampleIds(t);if(e.has(n)){const e=s.samples(t).item(),n=s.meshesItems(e),o=i.localIds(n);r.add(o)}}}const rn="-DELTA-MODEL-";function nn(t){return{item:t.item(),localTransform:t.localTransform(),material:t.material(),representation:t.representation()}}function on(t){const e=t.position(),s=t.xDirection(),i=t.yDirection();return{position:[e.x(),e.y(),e.z()],xDirection:[s.x(),s.y(),s.z()],yDirection:[i.x(),i.y(),i.z()]}}function an(t){return{r:t.r(),g:t.g(),b:t.b(),a:t.a(),renderedFaces:t.renderedFaces(),stroke:t.stroke()}}function ln(t){const e=t.bbox(),s=e.min(),i=e.max();return{id:t.id(),bbox:[s.x(),s.y(),s.z(),i.x(),i.y(),i.z()],representationClass:t.representationClass()}}function cn(t){const e=[];for(let s=0;s<t.pointsLength();s++){const i=t.points(s);e.push([i.x(),i.y(),i.z()])}const s=new Map;for(let e=0;e<t.profilesLength();e++){const i=t.profiles(e),r=Array.from(i.indicesArray()||[]);s.set(e,r)}const i=new Map;for(let e=0;e<t.holesLength();e++){const s=t.holes(e),r=Array.from(s.indicesArray()||[]),n=s.profileId();i.has(n)||i.set(n,[]),i.get(n).push(r)}const r=new Map;for(let e=0;e<t.bigProfilesLength();e++){const s=t.bigProfiles(e),i=Array.from(s.indicesArray()||[]);r.set(e,i)}const n=new Map;for(let e=0;e<t.bigHolesLength();e++){const s=t.bigHoles(e),i=Array.from(s.indicesArray()||[]),r=s.profileId();n.has(r)||n.set(r,[]),n.get(r).push(i)}const o=Array.from(t.profilesFaceIdsArray()||[]);return{points:e,profiles:s,holes:i,bigProfiles:r,bigHoles:n,type:t.type(),profilesFaceIds:o}}function hn(t){const e={radius:[],axes:[]},s=t.radiusArray();e.radius=Array.from(s);const i=t.axesLength();for(let s=0;s<i;s++){const i=t.axes(s),r=i.wiresLength(),n=[];for(let t=0;t<r;t++){const e=i.wires(t),s=e.p1(),r=e.p2();n.push([s.x(),s.y(),s.z(),r.x(),r.y(),r.z()])}const o=i.orderLength(),a=[];for(let t=0;t<o;t++)a.push(i.order(t));const l=i.partsLength(),c=[];for(let t=0;t<l;t++)c.push(i.parts(t));const h=i.wireSetsLength(),d=[];for(let t=0;t<h;t++){const e=i.wireSets(t),s=e.psLength(),r=[];for(let t=0;t<s;t++){const s=e.ps(t);r.push(s.x(),s.y(),s.z())}d.push(r)}const u=i.circleCurvesLength(),f=[];for(let t=0;t<u;t++){const e=i.circleCurves(t),s=e.aperture(),r=e.position(),n=r.x(),o=r.y(),a=r.z(),l=e.radius(),c=e.xDirection(),h=c.x(),d=c.y(),u=c.z(),p=e.yDirection(),I=p.x(),m=p.y(),E=p.z();f.push({aperture:s,position:[n,o,a],radius:l,xDirection:[h,d,u],yDirection:[I,m,E]})}e.axes.push({wires:n,order:a,parts:c,wireSets:d,circleCurves:f})}return e}function dn(t,e,s){const i=t[e];if("string"==typeof i){const r=s.get(i);if(void 0===r)throw new Error(`Malformed request: temp id ${t[e]} not found`);t[e]=r}}function un(t,e,s){const i=t[e];if("string"==typeof i){const r=s.get(i);if(void 0===r)throw new Error(`Malformed request: temp id ${t[e]} not found`);t[e]=r}}function fn(t,e,s){const i=t[e];if("string"==typeof i){const r=s.get(i);if(void 0===r)throw new Error(`Malformed request: temp id ${t[e]} not found`);t[e]=r}}class pn{}ot(pn,"edit",(function(t,e,s){const i=t.meshes(),r=(null==s?void 0:s.raw)??!1,n=(null==s?void 0:s.delta)??!1;let o=new Set,a=new Set,l=new Set,c=new Set,h=new Set,d=new Set,u=new Set,f=new Set,p=0,I=0,m=0,E=0,_=0,g=0,C=0;if(n){const s=function(t,e){const s=new Set,i=new Set,r=new Set,n=new Set,o=new Set,a=new Set,l=new Set,c=new Set;let h=!1,d=0,u=0,f=0,p=0,I=0,m=0,E=0;const _=new Set,g=new Set,C=new Set,T=new Set,b=new Set,R=new Set,A=new Set,y=t.meshes(),S=new Set(y.globalTransformIdsArray()),F=new Set(y.localTransformIdsArray()),w=new Set(y.materialIdsArray()),L=new Set(y.representationIdsArray()),O=new Set(t.localIdsArray()),x=new Set(y.sampleIdsArray()),N=new Set;for(const t of e)t.type===kr.CREATE_SAMPLE&&(h=!0),t.type!==kr.UPDATE_LOCAL_TRANSFORM?t.type!==kr.UPDATE_MATERIAL?t.type!==kr.UPDATE_REPRESENTATION?t.type!==kr.UPDATE_ITEM?t.type!==kr.CREATE_GLOBAL_TRANSFORM?t.type!==kr.UPDATE_GLOBAL_TRANSFORM?t.type!==kr.UPDATE_SAMPLE?t.type!==kr.CREATE_SAMPLE||(N.add(t.localId),S.has(t.data.item)&&i.add(t.data.item),F.has(t.data.localTransform)&&C.add(t.data.localTransform),w.has(t.data.material)&&T.add(t.data.material),L.has(t.data.representation)&&b.add(t.data.representation)):(N.has(t.localId)||n.add(t.localId),S.has(t.data.item)&&i.add(t.data.item),F.has(t.data.localTransform)&&C.add(t.data.localTransform),w.has(t.data.material)&&T.add(t.data.material),L.has(t.data.representation)&&b.add(t.data.representation)):(i.add(t.localId),O.has(t.data.itemId)&&s.add(t.data.itemId)):O.has(t.data.itemId)&&s.add(t.data.itemId):s.add(t.localId):a.add(t.localId):o.add(t.localId):r.add(t.localId);const v=new Set;for(const t of e)t.type!==kr.DELETE_GLOBAL_TRANSFORM?t.type!==kr.DELETE_LOCAL_TRANSFORM?t.type!==kr.DELETE_SAMPLE?t.type!==kr.DELETE_MATERIAL?t.type!==kr.DELETE_REPRESENTATION?t.type!==kr.DELETE_ITEM||s.delete(t.localId):(a.delete(t.localId),v.add(t.localId),L.has(t.localId)||I++):(o.delete(t.localId),w.has(t.localId)||p++):(n.delete(t.localId),_.add(t.localId),x.has(t.localId)||f++):(r.delete(t.localId),F.has(t.localId)||u++):(i.delete(t.localId),S.has(t.localId)||d++);const P=pn.getRepresentations(t,v);for(const[,t]of P)if(t.representationClass===Gr.SHELL)m++;else{if(t.representationClass!==Gr.CIRCLE_EXTRUSION)throw new Error("Unsupported representation class");E++}for(const t of e)if(t.type===kr.CREATE_REPRESENTATION&&v.has(t.localId))if(t.data.representationClass===Gr.SHELL)m++;else{if(t.data.representationClass!==Gr.CIRCLE_EXTRUSION)throw new Error("Unsupported representation class");E++}for(let e=0;e<y.samplesLength();e++){const n=y.samples(e),l=n.item(),c=n.localTransform(),h=n.material(),d=n.representation(),u=y.globalTransformIds(l),f=y.localTransformIds(c),p=y.materialIds(h),I=y.representationIds(d),m=y.meshesItems(l),E=t.localIds(m);(i.has(u)||r.has(f)||o.has(p)||a.has(I)||s.has(E))&&O.has(E)&&s.add(E)}for(let e=0;e<y.samplesLength();e++){const n=y.sampleIds(e);if(_.has(n))continue;const l=y.samples(e),c=l.item(),h=l.localTransform(),d=l.material(),u=l.representation(),f=y.globalTransformIds(c),p=y.localTransformIds(h),I=y.materialIds(d),m=y.representationIds(u),E=y.meshesItems(c),x=t.localIds(E);(i.has(f)||r.has(p)||o.has(I)||a.has(m)||s.has(x))&&(S.has(f)&&g.add(f),F.has(p)&&C.add(p),w.has(I)&&T.add(I),L.has(m)&&b.add(m),O.has(x)&&A.add(x),R.add(n))}S.clear(),F.clear(),w.clear(),L.clear(),O.clear(),x.clear();for(const t of g)i.add(t);for(const t of C)r.add(t);for(const t of T)o.add(t);for(const t of b)a.add(t);for(const t of R)n.add(t);for(const t of A)s.add(t);g.clear(),C.clear(),T.clear(),b.clear(),R.clear(),A.clear();const M=pn.getGeometryIndicesFromRepresentations(t,a);for(const t of M.shellsIndices)l.add(t);for(const t of M.rebarsIndices)c.add(t);return{itemIds:s,globalTranforms:i,localTransforms:r,samples:n,materials:o,representations:a,shells:l,circleExtrusions:c,detaDeletedGts:d,detaDeletedLts:u,detaDeletedSamples:f,detaDeletedMaterials:p,detaDeletedRepresentations:I,detaDeletedShells:m,detaDeletedCircleExtrusions:E,createNewSample:h}}(t,e);o=s.itemIds,a=s.globalTranforms,l=s.localTransforms,c=s.samples,h=s.materials,d=s.representations,u=s.shells,f=s.circleExtrusions,p=s.detaDeletedGts,I=s.detaDeletedLts,m=s.detaDeletedSamples,E=s.detaDeletedMaterials,_=s.detaDeletedRepresentations,g=s.detaDeletedShells,C=s.detaDeletedCircleExtrusions;if(!s.createNewSample&&0===o.size&&0===a.size&&0===l.size&&0===c.size&&0===h.size&&0===d.size&&0===u.size&&0===f.size){const s=new Set;return sn(e,new Set,i,t,s),{model:en({raw:r}),items:Array.from(s)}}}const T=new Map,b=new Map,R=new Map,A=new Map,y=new Map,S=new Map,F=new Map,w=new Map,L=new Map;let O=null,x=null;const N=new Map,v=new Map,P=new Map,M=new Map,D=new Map,U=new Map,V=new Map,B=new Map,z=new Map,G=new Set,H=new Set,k=new Set,Y=new Set,W=new Set,q=new Set,j=new Set,X=new Set,Z=new Set,$=new Set(i.materialIdsArray()),Q=new Set(i.representationIdsArray()),K=new Set(i.sampleIdsArray()),J=new Set(i.globalTransformIdsArray()),tt=new Set(i.localTransformIdsArray()),et=new Set(t.localIdsArray());let st=t.maxLocalId();for(const t of e)if(t.type!==kr.UPDATE_MATERIAL)if(t.type!==kr.UPDATE_REPRESENTATION)if(t.type!==kr.UPDATE_SAMPLE)if(t.type!==kr.UPDATE_GLOBAL_TRANSFORM)if(t.type!==kr.UPDATE_LOCAL_TRANSFORM)if(t.type!==kr.UPDATE_ITEM)if(t.type!==kr.UPDATE_RELATION)if(t.type!==kr.UPDATE_METADATA)if(t.type!==kr.UPDATE_SPATIAL_STRUCTURE)if(t.type!==kr.CREATE_MATERIAL)if(t.type!==kr.CREATE_REPRESENTATION)if(t.type!==kr.CREATE_SAMPLE)if(t.type!==kr.CREATE_GLOBAL_TRANSFORM)if(t.type!==kr.CREATE_LOCAL_TRANSFORM){if(t.type===kr.CREATE_ITEM){const e=t.localId;if(et.has(e))continue;B.set(e,t.data)}if(t.type===kr.CREATE_RELATION){const e=t.localId;z.set(e,t.data)}t.type!==kr.DELETE_MATERIAL?t.type!==kr.DELETE_REPRESENTATION?t.type!==kr.DELETE_SAMPLE?t.type!==kr.DELETE_GLOBAL_TRANSFORM?t.type!==kr.DELETE_LOCAL_TRANSFORM?t.type!==kr.DELETE_ITEM?t.type!==kr.UPDATE_MAX_LOCAL_ID?t.type!==kr.DELETE_RELATION||Z.add(t.localId):st=t.localId:X.add(t.localId):j.add(t.localId):q.add(t.localId):H.add(t.localId):k.add(t.localId):G.add(t.localId)}else{const e=t.localId;if(tt.has(e))continue;V.set(e,t.data)}else{const e=t.localId;if(J.has(e))continue;U.set(e,t.data)}else{const e=t.localId;if(K.has(e))continue;D.set(e,t.data)}else{const e=t.localId;if(Q.has(e))continue;v.set(e,t.data),t.data.representationClass===Gr.SHELL?P.set(e,t.data.geometry):t.data.representationClass===Gr.CIRCLE_EXTRUSION&&M.set(e,t.data.geometry)}else{const e=t.localId;if($.has(e))continue;N.set(e,t.data)}else x=t.data;else O=t.data;else L.set(t.localId,t.data);else w.set(t.localId,t.data);else y.set(t.localId,t.data);else A.set(t.localId,t.data);else R.set(t.localId,t.data);else b.set(t.localId,t.data);else T.set(t.localId,t.data);for(let t=0;t<i.representationsLength();t++){const e=i.representations(t),s=e.id(),r=i.representationIds(t);if(n&&!d.has(r))continue;if(k.has(r)){if(e.representationClass()===Gr.SHELL)Y.add(s);else{if(e.representationClass()!==Gr.CIRCLE_EXTRUSION)throw new Error("Representation class is not supported");W.add(s)}continue}if(!b.has(r))continue;const o=e.representationClass();if(o===Gr.SHELL)S.set(s,r);else{if(o!==Gr.CIRCLE_EXTRUSION)throw new Error("Representation class is not supported");F.set(s,r)}}$.clear(),Q.clear(),K.clear(),J.clear(),tt.clear(),et.clear();const it=i.materialsLength(),rt=n?h.size:it,nt=n?E:G.size,ot=rt+N.size-nt,at=i.representationsLength(),lt=n?d.size:at,ct=n?_:k.size,ht=lt+v.size-ct,dt=i.shellsLength(),ut=n?u.size:dt,ft=n?g:Y.size,pt=ut+P.size-ft,It=i.circleExtrusionsLength(),mt=n?f.size:It,Et=n?C:W.size,_t=mt+M.size-Et,gt=i.samplesLength(),Ct=n?c.size:gt,Tt=n?m:H.size,bt=Ct+D.size-Tt,Rt=i.globalTransformsLength(),At=n?a.size:Rt,yt=n?p:q.size,St=At+U.size-yt,Ft=i.localTransformsLength(),wt=n?l.size:Ft,Lt=n?I:j.size,Ot=wt+V.size-Lt;if(St<0||ht<0||bt<0||Ot<0||ot<0||pt<0||_t<0)throw new Error("Invalid number of elements");const xt=new Map,Nt=[],vt=[],Pt=[],Mt=[],Dt=[],Ut=[],Vt=[];let Bt=0;for(let t=0;t<i.globalTransformsLength();t++){const e=i.globalTransformIds(t);if(!q.has(e)&&(!n||a.has(e))){if(xt.has(e))throw new Error("Local id already exists");xt.set(e,Bt++),Mt.push(e)}}for(const[t]of U)if(!q.has(t)){if(xt.has(t))throw new Error("Local id already exists");xt.set(t,Bt++),Mt.push(t)}let zt=0;for(let t=0;t<i.materialIdsLength();t++){const e=i.materialIds(t);if(!G.has(e)&&(!n||h.has(e))){if(xt.has(e))throw new Error("Local id already exists");xt.set(e,zt++),Nt.push(e)}}for(const[t]of N)if(!G.has(t)){if(xt.has(t))throw new Error("Local id already exists");xt.set(t,zt++),Nt.push(t)}let Gt=0;for(let t=0;t<i.localTransformIdsLength();t++){const e=i.localTransformIds(t);if(!j.has(e)&&(!n||l.has(e))){if(xt.has(e))throw new Error("Local id already exists");xt.set(e,Gt++),Ut.push(e)}}for(const[t]of V)if(!j.has(t)){if(xt.has(t))throw new Error("Local id already exists");xt.set(t,Gt++),Ut.push(t)}let Ht=0;for(let t=0;t<i.representationIdsLength();t++){const e=i.representationIds(t);if(!k.has(e)&&(!n||d.has(e))){if(xt.has(e))throw new Error("Local id already exists");xt.set(e,Ht++),vt.push(e)}}for(const[t]of v)if(!k.has(t)){if(xt.has(t))throw new Error("Local id already exists");xt.set(t,Ht++),vt.push(t)}for(let t=0;t<i.sampleIdsLength();t++){const e=i.sampleIds(t);H.has(e)||(n&&!c.has(e)||Pt.push(e))}for(const[t]of D)H.has(t)||Pt.push(t);let kt=0;for(let e=0;e<t.localIdsLength();e++){const s=t.localIds(e);X.has(s)||(n&&!o.has(s)||(xt.set(s,kt++),Vt.push(s)))}for(const[t]of B)X.has(t)||(xt.set(t,kt++),Vt.push(t));const Yt=new Jt(1024);Dr.startGlobalTransformsVector(Yt,St);const Wt=Array.from(U.keys());for(let t=0;t<Wt.length;t++){const e=Wt[Wt.length-1-t],s=A.has(e)?A.get(e):U.get(e);if(!s)throw new Error(`Global transform not found: ${e}`);if(q.has(e))continue;const i=s.itemId;if(!xt.has(i))throw new Error("Item id not found for global transform");const r=xt.get(i);Dt.unshift(r),Wr(s,Yt)}Wt.length=0;for(let e=0;e<Rt;e++){const s=Rt-1-e,r=i.globalTransforms(s),o=i.globalTransformIds(s);if(q.has(o))continue;if(n&&!a.has(o))continue;if(A.has(o)){const t=A.get(o),e=t.itemId;if(!xt.has(e))throw new Error(`Item id not found for global transform: ${o}`);const s=xt.get(e);Dt.unshift(s),Wr(t,Yt)}else{const e=i.meshesItems(s),n=t.localIds(e);if(!xt.has(n))throw new Error(`Item id not found for global transform: ${o}`);const a=xt.get(n);Dt.unshift(a),qr(Yt,r)}}const qt=Yt.endVector(),jt=[];for(let t=0;t<dt;t++){if(Y.has(t))continue;if(n&&!u.has(t))continue;if(S.has(t)){const e=S.get(t),s=b.get(e).geometry,i=Xr(Yt,s);jt.push(i);continue}const e=i.shells(t),s=Zr(Yt,e);jt.push(s)}for(const[t]of P){if(k.has(t))continue;let e=0;if(S.has(t)){const s=S.get(t),i=b.get(s).geometry;e=Xr(Yt,i)}else{const s=P.get(t);e=Xr(Yt,s)}jt.push(e)}const Xt=Dr.createShellsVector(Yt,jt),Zt=[];for(let t=0;t<It;t++){if(W.has(t))continue;if(n&&!f.has(t))continue;if(F.has(t)){const e=F.get(t),s=b.get(e).geometry,i=Qr(Yt,s);Zt.push(i);continue}const e=i.circleExtrusions(t),s=$r(Yt,e);Zt.push(s)}for(const[t]of M){if(W.has(t))continue;let e=0;if(F.has(t)){const s=F.get(t),i=b.get(s).geometry;e=Qr(Yt,i)}else{const s=M.get(t);e=Qr(Yt,s)}Zt.push(e)}const $t=Dr.createCircleExtrusionsVector(Yt,Zt);Dr.startRepresentationsVector(Yt,ht);const Qt=Array.from(v.keys());let Kt=pt-1,te=_t-1;for(let t=0;t<Qt.length;t++){const e=Qt[Qt.length-1-t];if(k.has(e))continue;const s=b.has(e)?b.get(e):v.get(e);if(!s)throw new Error(`Representation not found: ${e}`);const i=s.bbox,r=s.representationClass;let n=0;if(s.representationClass===Gr.SHELL)n=Kt--;else{if(s.representationClass!==Gr.CIRCLE_EXTRUSION)throw new Error("Representation class is not supported");n=te--}Lr.createRepresentation(Yt,n,i[0],i[1],i[2],i[3],i[4],i[5],r)}Qt.length=0;for(let t=0;t<at;t++){const e=at-1-t,s=i.representations(e),r=i.representationIds(e);if(k.has(r))continue;if(n&&!d.has(r))continue;if(b.has(r)){const t=b.get(r),e=t.bbox;let s=0;if(t.representationClass===Gr.SHELL)s=Kt--;else{if(t.representationClass!==Gr.CIRCLE_EXTRUSION)throw new Error("Representation class is not supported");s=te--}const i=t.representationClass;Lr.createRepresentation(Yt,s,e[0],e[1],e[2],e[3],e[4],e[5],i)}else{const t=s.bbox();let e=0;if(s.representationClass()===Gr.SHELL)e=Kt--;else{if(s.representationClass()!==Gr.CIRCLE_EXTRUSION)throw new Error("Representation class is not supported");e=te--}const i=s.representationClass(),r=t.min(),n=t.max();Lr.createRepresentation(Yt,e,r.x(),r.y(),r.z(),n.x(),n.y(),n.z(),i)}}const ee=Yt.endVector();Dr.startSamplesVector(Yt,bt);const se=Array.from(D.keys());for(let t=0;t<se.length;t++){const e=se[se.length-1-t];if(H.has(e))continue;const s=R.has(e)?R.get(e):D.get(e);if(!s)throw new Error(`Sample not found: ${e}`);if(G.has(s.material))throw new Error(`Material to delete found in sample ${e}`);if(k.has(s.representation))throw new Error(`Representation to delete found in sample ${e}`);const i=s.item,r=s.material,n=s.representation,o=s.localTransform;tn(Yt,xt,i,r,n,o)}se.length=0;for(let t=0;t<gt;t++){const e=gt-1-t,s=i.samples(e),r=i.sampleIds(e);if(H.has(r))continue;if(n&&!c.has(r))continue;if(R.has(r)){const t=R.get(r),e=t.item,s=t.material,i=t.representation,n=t.localTransform;tn(Yt,xt,e,s,i,n);continue}const o=i.globalTransformIds(s.item()),a=i.materialIds(s.material()),l=i.representationIds(s.representation()),h=i.localTransformIds(s.localTransform());if(G.has(a))throw new Error(`Material to delete found in sample ${r}`);tn(Yt,xt,o,a,l,h)}const ie=Yt.endVector();Dr.startLocalTransformsVector(Yt,Ot);const re=Array.from(V.keys());for(let t=0;t<re.length;t++){const e=re[re.length-1-t];if(j.has(e))continue;const s=y.has(e)?y.get(e):V.get(e);if(!s)throw new Error(`Local transform not found: ${e}`);Wr(s,Yt)}re.length=0;for(let t=0;t<Ft;t++){const e=Ft-1-t,s=i.localTransforms(e),r=i.localTransformIds(e),o=y.has(r);if(!j.has(r)&&(!n||l.has(r)))if(o){Wr(y.get(r),Yt)}else qr(Yt,s)}const ne=Yt.endVector();Dr.startMaterialsVector(Yt,ot);const oe=Array.from(N.keys());for(let t=0;t<oe.length;t++){const e=oe[oe.length-1-t];if(G.has(e))continue;const s=T.has(e)?T.get(e):N.get(e);if(!s)throw new Error(`Material not found: ${e}`);const i=s.r,r=s.g,n=s.b,o=s.a,a=s.stroke,l=s.renderedFaces;wr.createMaterial(Yt,i,r,n,o,l,a)}oe.length=0;for(let t=0;t<it;t++){const e=it-1-t,s=i.materials(e),r=i.materialIds(e);if(G.has(r))continue;if(n&&!h.has(r))continue;const o=T.has(r),a=T.get(r),l=o?a.r:s.r(),c=o?a.g:s.g(),d=o?a.b:s.b(),u=o?a.a:s.a(),f=o?a.stroke:s.stroke(),p=o?a.renderedFaces:s.renderedFaces();wr.createMaterial(Yt,l,c,d,u,p,f)}const ae=Yt.endVector(),le=Dr.createMeshesItemsVector(Yt,Dt),ce=Dr.createRepresentationIdsVector(Yt,vt),he=Dr.createSampleIdsVector(Yt,Pt),de=Dr.createMaterialIdsVector(Yt,Nt),ue=Dr.createLocalTransformIdsVector(Yt,Ut),fe=Dr.createGlobalTransformIdsVector(Yt,Mt);Dr.startMeshes(Yt);const pe=i.coordinates(),Ie=qr(Yt,pe);Dr.addCoordinates(Yt,Ie),Dr.addGlobalTransforms(Yt,qt),Dr.addShells(Yt,Xt),Dr.addRepresentations(Yt,ee),Dr.addSamples(Yt,ie),Dr.addLocalTransforms(Yt,ne),Dr.addMaterials(Yt,ae),Dr.addCircleExtrusions(Yt,$t),Dr.addMeshesItems(Yt,le),Dr.addRepresentationIds(Yt,ce),Dr.addSampleIds(Yt,he),Dr.addMaterialIds(Yt,de),Dr.addLocalTransformIds(Yt,ue),Dr.addGlobalTransformIds(Yt,fe);const me=Dr.endMeshes(Yt);let Ee;if(O){const t=JSON.stringify(O);Ee=Yt.createString(t)}else{const e=t.metadata();Ee=Yt.createString(e)}const _e=t.attributesLength(),ge=[],Ce=new Set,Te=[],be=[],Re=[],Ae=new Map;for(let e=0;e<t.guidsItemsLength();e++){const s=t.guidsItems(e);Ae.set(s,e)}for(let e=0;e<_e;e++){const s=t.localIds(e);if(X.has(s))continue;const i=t.attributes(e),r=[];if(w.has(s)){const t=w.get(s);Te.push(Yt.createSharedString(t.category)),t.guid&&(be.push(Yt.createSharedString(t.guid)),Re.push(s));for(const e in t.data){const{value:s,type:i}=t.data[e],n=JSON.stringify([e,s,i]);Ce.add(n);const o=Yt.createSharedString(n);r.push(o)}}else{const n=t.categories(e);Te.push(Yt.createSharedString(n));const o=Ae.get(s);if(void 0!==o){const e=t.guids(o);be.push(Yt.createSharedString(e)),Re.push(s)}const a=i.dataLength();for(let t=0;t<a;t++){const e=i.data(t);Ce.add(e);const s=Yt.createSharedString(e);r.push(s)}}const n=mr.createDataVector(Yt,r),o=mr.createAttribute(Yt,n);ge.push(o)}for(const[t,e]of B){if(X.has(t))continue;Te.push(Yt.createSharedString(e.category)),e.guid&&(console.log(e.guid),be.push(Yt.createSharedString(e.guid)),Re.push(t));const s=[];for(const t in e.data){const{value:i,type:r}=e.data[t],n=JSON.stringify([t,i,r]);Ce.add(n);const o=Yt.createSharedString(n);s.push(o)}const i=mr.createDataVector(Yt,s),r=mr.createAttribute(Yt,i);ge.push(r)}const ye=Br.createAttributesVector(Yt,ge),Se=[];for(const t of Ce){const e=Yt.createSharedString(t);Se.push(e)}const Fe=Br.createUniqueAttributesVector(Yt,Se),we=t.relationNamesLength(),Le=[];for(let e=0;e<we;e++){const s=t.relationNames(e),i=Yt.createSharedString(s);Le.push(i)}const Oe=Br.createRelationNamesVector(Yt,Le),xe=Br.createLocalIdsVector(Yt,Vt),Ne=Br.createCategoriesVector(Yt,Te),ve=[],Pe=[],Me=new Set,De=t.relationsItemsLength(),Ue=t=>{const e=[];for(const s in t.data){const i=t.data[s].filter((t=>!X.has(t)));if(!i.length)continue;const r=Yt.createSharedString(JSON.stringify([s,...i]));e.push(r)}const s=Ur.createDataVector(Yt,e),i=Ur.createRelation(Yt,s);ve.push(i)};for(let e=0;e<De;e++){const s=t.relationsItems(e);if(Me.add(s),X.has(s)||Z.has(s)||!xt.has(s))continue;let i;if(L.has(s))i=L.get(s);else{const s=t.relations(e);i=pn.getRelationData(s)}Ue(i),Pe.push(s)}for(const[t,e]of z){if(X.has(t)||Z.has(t)||Me.has(t))continue;let s;s=L.has(t)?L.get(t):e,Ue(s),Pe.push(t)}Me.clear();const Ve=Br.createRelationsVector(Yt,ve),Be=Br.createRelationsItemsVector(Yt,Pe),ze=Br.createGuidsItemsVector(Yt,Re),Ge=Br.createGuidsVector(Yt,be);let He=null;if(x)He=Jr(Yt,x);else{const e=t.spatialStructure();He=Kr(Yt,e)}const ke=t.guid(),Ye=Yt.createString(ke);Br.startModel(Yt),Br.addMeshes(Yt,me),Br.addMetadata(Yt,Ee),Br.addAttributes(Yt,ye),Br.addUniqueAttributes(Yt,Fe),Br.addRelationNames(Yt,Oe),Br.addLocalIds(Yt,xe),Br.addCategories(Yt,Ne),Br.addRelationsItems(Yt,Be),Br.addRelations(Yt,Ve),Br.addGuidsItems(Yt,ze),Br.addGuids(Yt,Ge),null!==He&&Br.addSpatialStructure(Yt,He),Br.addGuid(Yt,Ye),Br.addMaxLocalId(Yt,st);const We=Br.endModel(Yt);Yt.finish(We);const qe=Yt.asUint8Array();Yt.clear();const je=r?qe:Ir.deflate(qe),Xe=new Set(Vt);return sn(e,new Set(Pt),i,t,Xe),{model:je,items:Array.from(Xe)}})),ot(pn,"solveIds",(function(t,e){const s=new Map,i=[];for(const r of t){if(void 0!==r.localId)continue;const t=e++;r.tempId&&s.set(r.tempId,t),r.localId=t,i.push(t)}for(const e of t)if(e.type!==kr.UPDATE_SAMPLE&&e.type!==kr.CREATE_SAMPLE)if(e.type!==kr.UPDATE_GLOBAL_TRANSFORM&&e.type!==kr.CREATE_GLOBAL_TRANSFORM)fn(e,"localId",s);else{dn(e.data,"itemId",s)}else{const t=e.data;un(t,"item",s),un(t,"material",s),un(t,"representation",s),un(t,"localTransform",s)}return s.clear(),i})),ot(pn,"newModel",en),ot(pn,"applyChangesToRawData",(function(t,e,s,i){const r=kr[`CREATE_${s}`],n=kr[`UPDATE_${s}`],o=kr[`DELETE_${s}`];if(t)for(const s of t)if(s.type!==r&&s.type!==n)s.type===o&&e.delete(s.localId);else{if(i&&!i.has(s.localId))continue;e.set(s.localId,s.data)}})),ot(pn,"applyChangesToSpecialData",(function(t,e){const s=kr[`UPDATE_${e}`];if(t)for(let e=t.length-1;e>=0;e--){const i=t[e];if(i.type===s)return JSON.parse(JSON.stringify(i.data))}return null})),ot(pn,"applyChangesToIds",(function(t,e,s,i){const r=new Set(e),n=kr[`DELETE_${s}`],o=kr[`CREATE_${s}`];if(t){for(const e of t)e.type!==n?i&&e.type===o&&r.add(e.localId):r.delete(e.localId);return Array.from(r)}return e})),ot(pn,"getModelFromBuffer",(function(t,e){const s=new Kt(e?t:Ir.inflate(t));return Br.getRootAsModel(s)})),ot(pn,"getSampleData",nn),ot(pn,"getTransformData",on),ot(pn,"getRelationData",(function(t){const e={data:{}},s=t.dataLength();for(let i=0;i<s;i++){const s=t.data(i),[r,...n]=JSON.parse(s);e.data[r]=n}return e})),ot(pn,"getMaterialData",an),ot(pn,"getRepresentationData",ln),ot(pn,"getShellData",cn),ot(pn,"getMaterialsIds",(function(t){return t.meshes().materialIdsArray()||[]})),ot(pn,"getMaterials",(function(t,e){const s=t.meshes(),i=e||s.materialIdsArray(),r=new Set(i),n=new wr,o=new Map;for(let t=0;t<s.materialsLength();t++){const e=s.materialIds(t);if(!r.has(e))continue;s.materials(t,n);const i=an(n);o.set(e,i)}return o})),ot(pn,"getRepresentationsIds",(function(t){return t.meshes().representationIdsArray()||[]})),ot(pn,"getRepresentations",(function(t,e){const s=t.meshes(),i=e||s.representationIdsArray(),r=new Set(i),n=new Map,o=new Lr;for(let t=0;t<s.representationsLength();t++){const e=s.representationIds(t);if(!r.has(e))continue;s.representations(t,o);const i=ln(o);if(i.representationClass===Gr.SHELL){const t=cn(s.shells(i.id));i.geometry=t}else if(i.representationClass===Gr.CIRCLE_EXTRUSION){const t=hn(s.circleExtrusions(i.id));i.geometry=t}n.set(e,i)}return n})),ot(pn,"getLocalTransformsIds",(function(t){return t.meshes().localTransformIdsArray()||[]})),ot(pn,"getLocalTransforms",(function(t,e){const s=t.meshes(),i=e||s.localTransformIdsArray(),r=new Set(i),n=new Map,o=new Mr;for(let t=0;t<s.localTransformsLength();t++){const e=s.localTransformIds(t);if(!r.has(e))continue;s.localTransforms(t,o);const i=on(o);n.set(e,i)}return n})),ot(pn,"getGlobalTransformsIds",(function(t){return t.meshes().globalTransformIdsArray()||[]})),ot(pn,"getGlobalTransforms",(function(t,e){const s=t.meshes();let i=null;i=e?new Set(e):new Set(s.globalTransformIdsArray());const r=new Map,n=new Mr,o=s.globalTransformsLength();for(let e=0;e<o;e++){s.globalTransforms(e,n);const o=s.globalTransformIds(e),a=s.meshesItems(e),l=t.localIds(a);if(!i.has(o))continue;const c=on(n);r.set(o,{...c,itemId:l})}return r})),ot(pn,"getSamplesIds",(function(t){return t.meshes().sampleIdsArray()||[]})),ot(pn,"getSamples",(function(t,e){const s=t.meshes(),i=e||s.sampleIdsArray(),r=new Set(i),n=new Map,o=new Or;for(let t=0;t<s.samplesLength();t++){const e=s.sampleIds(t);if(!r.has(e))continue;s.samples(t,o);const i=nn(o);i.item=s.globalTransformIds(i.item),i.material=s.materialIds(i.material),i.representation=s.representationIds(i.representation),i.localTransform=s.localTransformIds(i.localTransform),n.set(e,i)}return n})),ot(pn,"getItemsIds",(function(t){return t.localIdsArray()})),ot(pn,"getItems",(function(t,e){let s=new Set;if(e)s=new Set(e);else for(let e=0;e<t.localIdsLength();e++)s.add(e);const i=new Map;for(const e of s){const s=t.localIds(e),r=t.categories(e),n=t.guids(e),o=t.attributes(e),a={};for(let t=0;t<o.dataLength();t++){const e=o.data(t),[s,i,r]=JSON.parse(e);a[s]={value:i,type:r}}i.set(s,{data:a,category:r,guid:n})}return i})),ot(pn,"getGlobalTranformsIdsOfItems",(function(t,e){const s=t.meshes(),i=new Set(e),r=new Set;for(let e=0;e<s.meshesItemsLength();e++){const n=s.meshesItems(e),o=t.localIds(n);i.has(o)&&r.add(s.globalTransformIds(e))}return Array.from(r)})),ot(pn,"getElementsData",(function(t,e){const s=t.data,i=s.meshes(),r={},n=new Set(e),o=new Mr,a=new wr,l=new Lr,c=new Pr;for(let t=0;t<i.samplesLength();t++){const e=i.samples(t),h=e.item(),d=i.meshesItems(h),u=s.localIds(d);if(!n.has(u))continue;r[u]||(r[u]={samples:{},localTransforms:{},globalTransforms:{},representations:{},materials:{}});const f=r[u],p=e.localTransform(),I=e.material(),m=e.representation(),E=i.sampleIds(t),_=i.globalTransformIds(h),g=i.localTransformIds(p),C=i.materialIds(I),T=i.representationIds(m);f.samples[E]={item:_,localTransform:g,material:C,representation:T},i.localTransforms(p,o),f.localTransforms[g]=on(o),i.globalTransforms(h,o);const b=on(o);f.globalTransforms[_]={...b,itemId:u},i.materials(I,a),f.materials[C]=an(a),i.representations(m,l);const R=ln(l);if(R.representationClass===Gr.SHELL){i.shells(R.id,c);const t=cn(c);R.geometry=t}f.representations[T]=R}const h=new Map;for(let t=0;t<s.relationsItemsLength();t++){const e=s.relationsItems(t);h.set(e,t)}const d=new Map;for(let t=0;t<s.localIdsLength();t++){const e=s.localIds(t);d.set(e,t)}return r})),ot(pn,"getGeometryIndicesFromRepresentations",(function(t,e){const s=t.meshes(),i=e||s.representationIdsArray(),r=new Set(i),n=new Lr,o=new Set,a=new Set;for(let t=0;t<s.representationsLength();t++){const e=s.representationIds(t);if(!r.has(e))continue;s.representations(t,n);const i=ln(n);if(i.representationClass===Gr.SHELL)o.add(i.id);else{if(i.representationClass!==Gr.CIRCLE_EXTRUSION)throw new Error("Rebars not supported yet");a.add(i.id)}}return{shellsIndices:o,rebarsIndices:a}})),ot(pn,"getRootModelId",(function(t){return t.includes(rn)?t.substring(0,t.indexOf(rn)):t})),ot(pn,"getSerializedAttributes",(function(t){const e=[];for(const s in t){if("_"===s[0])continue;const i=t[s];if(Array.isArray(i))continue;const r=i.value,n=i.type,o=JSON.stringify([s,r,n]);e.push(o)}return e})),ot(pn,"itemDataToRawItemData",(function(t){const e=t._category;if(!e)throw new Error("Category is required");const s=e.value,i=t._guid,r={};for(const e in t){if("_"===e[0])continue;const s=t[e];Array.isArray(s)||(r[e]=s)}return{data:r,category:s,guid:i?i.value:void 0}})),ot(pn,"DELTA_MODEL_ID",rn);class In{constructor(t,e,s,i){ot(this,"x"),ot(this,"y"),ot(this,"z"),ot(this,"hash"),ot(this,"id"),this.x=An.round(t[3*e],i),this.y=An.round(t[3*e+1],i),this.z=An.round(t[3*e+2],i),this.hash=`${this.x}/${this.y}/${this.z}`,this.id=s}}class mn{constructor(t){ot(this,"list",new Map),ot(this,"tempV1",new ft.Vector3),ot(this,"tempV2",new ft.Vector3),ot(this,"tempV3",new ft.Vector3),ot(this,"precission"),this.precission=t}create(t,e){const s=new In(t,e,this.list.size,this.precission);return this.list.has(s.hash)||this.list.set(s.hash,s),this.list.get(s.hash)}get(){return Array.from(this.list.values()).map((t=>[t.x,t.y,t.z]))}isValidTriangle(t,e,s,i){this.tempV1.set(t[3*e],t[3*e+1],t[3*e+2]),this.tempV2.set(t[3*s],t[3*s+1],t[3*s+2]),this.tempV3.set(t[3*i],t[3*i+1],t[3*i+2]);const r=1/this.precission*10,n=this.tempV1.distanceTo(this.tempV2)>r,o=this.tempV1.distanceTo(this.tempV3)>r,a=this.tempV2.distanceTo(this.tempV3)>r;return n&&o&&a}}class En{constructor(t,e){ot(this,"edges",new Map),ot(this,"openEdges",new Set),ot(this,"id"),ot(this,"plane"),this.id=t,this.plane=e}add(t){if(0!==this.edges.size)for(const e of t)this.openEdges.has(e.hash)?this.openEdges.delete(e.hash):this.openEdges.add(e.hash),this.edges.set(e.hash,e);else for(const e of t)this.openEdges.add(e.hash),this.edges.set(e.hash,e)}match(t,e){if(e.id!==this.plane.id)return!1;for(const e of t)if(this.openEdges.has(e.hash))return!0;return!1}getOpenEdges(){const t=[];for(const e of this.openEdges)t.push(this.edges.get(e));return t}merge(t){for(const[e,s]of t.edges)this.edges.set(e,s);for(const e of t.openEdges)this.openEdges.has(e)?this.openEdges.delete(e):this.openEdges.add(e)}}class _n{constructor(){ot(this,"list",new Map),ot(this,"nextFaceID",0)}add(t,e){const s=this.match(t,e);if(0===s.length){const s=this.nextFaceID++,i=new En(s,e);return i.add(t),void this.list.set(i.id,i)}if(1!==s.length){if(s.length>1){const e=this.list.get(s[0]);e.add(t);for(let t=1;t<s.length;t++){const i=s[t],r=this.list.get(i);e.merge(r),this.list.delete(i)}}}else{this.list.get(s[0]).add(t)}}match(t,e){let s=[];for(const i of this.list.values())i.match(t,e)&&s.push(i.id);return s}}class gn{constructor(t,e){ot(this,"p1"),ot(this,"p2"),ot(this,"hash"),this.p1=t,this.p2=e;const s=[this.p1,this.p2];s.sort(((t,e)=>t.x-e.x||t.y-e.y||t.z-e.z)),this.hash=`${s[0].hash}_${s[1].hash}`}}let Cn=class{constructor(t){ot(this,"closed",!1),ot(this,"openStartPoint",null),ot(this,"openEndPoint",null),ot(this,"plane"),ot(this,"orderedPoints",[]),this.plane=t}getEdges(t=!1){const e=[];if(t)for(let t=this.orderedPoints.length-1;t>0;t--)e.push(new gn(this.orderedPoints[t],this.orderedPoints[t-1]));else for(let t=0;t<this.orderedPoints.length-1;t++)e.push(new gn(this.orderedPoints[t],this.orderedPoints[t+1]));return e}getIndices(){return this.orderedPoints.map((t=>t.id))}add(t){if(0===this.orderedPoints.length)return this.openStartPoint=t.p1.hash,this.openEndPoint=t.p2.hash,void this.orderedPoints.push(t.p1,t.p2);const e=this.match(t);if(0===e)throw new Error("Fragments: Edge doesn't match with any open point");if(e>2)throw new Error("Fragments: Edge matches with more than 2 open points");if(2===e)return this.closed=!0,this.openEndPoint=null,void(this.openStartPoint=null);this.openStartPoint===t.p1.hash?(this.orderedPoints.unshift(t.p2),this.openStartPoint=t.p2.hash):this.openEndPoint===t.p1.hash?(this.orderedPoints.push(t.p2),this.openEndPoint=t.p2.hash):this.openStartPoint===t.p2.hash?(this.orderedPoints.unshift(t.p1),this.openStartPoint=t.p1.hash):this.openEndPoint===t.p2.hash&&(this.orderedPoints.push(t.p1),this.openEndPoint=t.p1.hash)}match(t){if(this.closed)return 0;let e=0;return this.openStartPoint===t.p1.hash&&e++,this.openStartPoint===t.p2.hash&&e++,this.openEndPoint===t.p1.hash&&e++,this.openEndPoint===t.p2.hash&&e++,e}merge(t){if(t.closed||this.closed)throw new Error("Fragments: Cannot merge closed profiles");if(t.openStartPoint===this.openEndPoint&&t.openEndPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");if(t.openEndPoint===this.openEndPoint&&t.openStartPoint===this.openStartPoint)throw new Error("Fragments: Cannot merge profiles that close each other");let e=!1;t.openEndPoint!==this.openStartPoint&&t.openEndPoint!==this.openEndPoint||(e=!0);const s=t.getEdges(e);for(const t of s)this.add(t)}getArea(){const t=this.orderedPoints.map((t=>[t.x,t.y,t.z]));let e=0,s=1;const i=Math.abs(this.plane.normal.x),r=Math.abs(this.plane.normal.y),n=Math.abs(this.plane.normal.z);i>=r&&i>=n?(e=1,s=2):r>=i&&r>=n?(e=0,s=2):(e=0,s=1);const o=[];for(const i of t)o.push(new ft.Vector2(i[e],i[s]));let a=0;for(let t=0,e=o.length;t<e;t++){a+=o[t].x*o[t===o.length-1?0:t+1].y*.5,a-=o[t===o.length-1?0:t+1].x*o[t].y*.5}return Math.abs(a)}};class Tn{constructor(t){ot(this,"list",new Map),ot(this,"plane"),ot(this,"nextProfileID",0),this.plane=t}add(t){const e=this.match(t);if(0===e.length){const e=this.nextProfileID++,s=new Cn(this.plane);return s.add(t),void this.list.set(e,s)}if(1!==e.length){if(e.length>1){const s=this.list.get(e[0]);s.add(t);const i=this.list.get(e[1]);s.merge(i),this.list.delete(e[1])}}else{this.list.get(e[0]).add(t)}}getProfiles(){let t=null,e=0;for(const[s,i]of this.list){const r=i.getArea();r>e&&(e=r,t=s)}if(null===t)return null;const s=this.list.get(t).getIndices(),i=[];for(const[e,s]of this.list)e!==t&&i.push(s.getIndices());return{profile:s,holes:i}}match(t){const e=[];for(const[s,i]of this.list)i.match(t)>0&&e.push(s);return e}}class bn{constructor(t,e,s){ot(this,"normal"),ot(this,"constant"),ot(this,"id"),ot(this,"faces",[]);const i=An.round(t.normal.x,s),r=An.round(t.normal.y,s),n=An.round(t.normal.z,s),o=An.round(t.constant,e);this.normal=new ft.Vector3(i,r,n),this.constant=o;const a="||";this.id=`${i}${a}${r}${a}${n}${a}${o}`}}const Rn=class t{static round(t,e){return Math.round(t*e)/e}static getAABB(t){let e=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let a=0;a<t.length;a+=3){const l=t[a],c=t[a+1],h=t[a+2];l<e&&(e=l),c<s&&(s=c),h<i&&(i=h),l>r&&(r=l),c>n&&(n=c),h>o&&(o=h)}return{min:{x:e,y:s,z:i},max:{x:r,y:n,z:o}}}static transformFromMatrix(t,e={position:[0,0,0],xDirection:[1,0,0],yDirection:[0,1,0]}){const s=t.elements[12],i=t.elements[13],r=t.elements[14],n=t.elements[0],o=t.elements[1],a=t.elements[2],l=t.elements[4],c=t.elements[5],h=t.elements[6];return e.position[0]=s,e.position[1]=i,e.position[2]=r,e.xDirection[0]=n,e.xDirection[1]=o,e.xDirection[2]=a,e.yDirection[0]=l,e.yDirection[1]=c,e.yDirection[2]=h,e}static matrixFromTransform(t){const e=new ft.Matrix4,[s,i,r]=t.position,[n,o,a]=t.xDirection,[l,c,h]=t.yDirection,d=new ft.Vector3(n,o,a),u=new ft.Vector3(l,c,h),{x:f,y:p,z:I}=d.cross(u);return e.fromArray([n,o,a,0,l,c,h,0,f,p,I,0,s,i,r,1]),e}static bboxFromCircleExtrusion(t){const e=new ft.Box3,s=[];for(const e of t.axes)for(const t of e.wires)for(let e=0;e<t.length-2;e+=3){const i=t[e],r=t[e+1],n=t[e+2];s.push(new ft.Vector3(i,r,n))}e.setFromPoints(s);return[e.min.x,e.min.y,e.min.z,e.max.x,e.max.y,e.max.z]}static representationFromGeometry(e,s={bbox:[0,0,0,0,0,0],representationClass:Gr.SHELL,geometry:{points:[],type:vr.NONE,profiles:new Map,holes:new Map,bigHoles:new Map,bigProfiles:new Map,profilesFaceIds:[]}},i={threshold:3e3,precision:1e6,normalPrecision:1e7,planePrecision:1e3,faceThreshold:.6,forceTransparentSpaces:!0}){const r=e.getAttribute("position").array,n=e.getAttribute("normal").array,o=e.index.array,a=t.getShellData({position:r,normals:n,index:o,raw:!1,settings:i}),{min:l,max:c}=a.bbox;if(s.bbox=[l.x,l.y,l.z,c.x,c.y,c.z],s.representationClass===Gr.CIRCLE_EXTRUSION)throw new Error("Circle extrusions can't be represented as shells");const h=s.geometry,d=a.points,u=d.length>t.ushortMaxValue;return h.type=u?vr.BIG:vr.NONE,h.points=d,h.profilesFaceIds=a.profilesFaceIds,u?(h.profiles=new Map,h.holes=new Map,h.bigHoles=a.holes,h.bigProfiles=a.profiles):(h.profiles=a.profiles,h.holes=a.holes,h.bigHoles=new Map,h.bigProfiles=new Map),s}static getRawShellData(t,e,s,i,r){var n;const o=new Map,a=new Map,l=(t,e,s)=>{const i=`${t},${e},${s}`;if(o.has(i))return o.get(i)[0];const r=o.size;return o.set(i,[r,t,e,s]),r};for(let s=0;s<t.length-2;s+=3){const i=t[s],r=t[s+1],n=t[s+2],o=e[3*i],c=e[3*i+1],h=e[3*i+2],d=e[3*r],u=e[3*r+1],f=e[3*r+2],p=e[3*n],I=e[3*n+1],m=e[3*n+2],E=l(o,c,h),_=l(d,u,f),g=l(p,I,m);a.set(a.size,[E,_,g])}const c=[];for(const[,[,t,e,s]]of o)c.push([t,e,s]);const h={bbox:s,type:Gr.SHELL,profiles:a,holes:new Map,points:c,profilesFaceIds:[]};if(r&&(null==(n=i.categoryFaceThresholds)?void 0:n.has(r)))this.computeShellFaceIds(h,i,r);else for(let t=0;t<a.size;t++)h.profilesFaceIds.push(0);return h}static getShellData(t){const{position:e,normals:s,index:i,raw:r,settings:n,category:o}=t,{threshold:a,precision:l,normalPrecision:c,planePrecision:h}=n,d=e.length/3>a,u=this.getAABB(e);if(0===u.min.x&&0===u.min.y&&0===u.min.z&&0===u.max.x&&0===u.max.y&&0===u.max.z)throw new Error("Fragments: Bbox is not valid");if(r||d)return this.getRawShellData(i,e,u,n,o);const f=new ft.Plane,p=new ft.Vector3,I=new ft.Vector3,m=new Map;for(let t=0;t<i.length-2;t+=3){const r=i[t];p.set(s[3*r],s[3*r+1],s[3*r+2]),I.set(e[3*r],e[3*r+1],e[3*r+2]),f.setFromNormalAndCoplanarPoint(p,I);const n=new bn(f,h,c);m.has(n.id)||m.set(n.id,n),m.get(n.id).faces.push(t)}const E=new mn(l),_=new _n;for(const[,t]of m)for(const s of t.faces){const r=i[s],n=i[s+1],o=i[s+2];if(!E.isValidTriangle(e,r,n,o))continue;const a=E.create(e,r),l=E.create(e,n),c=E.create(e,o),h=[new gn(a,l),new gn(l,c),new gn(c,a)];_.add(h,t)}const g=new Map,C=new Map;let T=0;for(const[,t]of _.list){const s=new Tn(t.plane),r=t.getOpenEdges();if(0===r.length)return this.getRawShellData(i,e,u,n,o);for(const t of r)s.add(t);const a=s.getProfiles();g.set(T,(null==a?void 0:a.profile)||[]),C.set(T,(null==a?void 0:a.holes)||[]),T++}let b=0;const R=new Map,A=new Map;for(const[t,e]of g)e.length&&(R.set(t,b),A.set(b,e),b++);const y=new Map;for(const[t,e]of C)if(e.length){const s=R.get(t);y.set(s,e)}const S={bbox:u,type:Gr.SHELL,profiles:A,holes:y,points:E.get(),profilesFaceIds:[]};return this.computeShellFaceIds(S,n,o),S}static computeShellFaceIds(t,e,s){var i;let r=e.faceThreshold;s&&(null==(i=e.categoryFaceThresholds)?void 0:i.has(s))&&(r=e.categoryFaceThresholds.get(s));const n=new Map;let o=0;const a=new Map,l=new Map,c=new Map,h=new ft.Vector3,d=new ft.Vector3,u=new ft.Vector3,f=new ft.Vector3,p=new ft.Triangle,I=t.profiles.size;for(let e=0;e<I;e++){const s=t.profiles.get(e),i=s.length;for(let t=0;t<i;t++){const r=s[t],n=t===i-1?s[0]:s[t+1],o=Math.min(r,n),c=Math.max(r,n),h=o+this.makeDecimal(c);l.has(e)?l.get(e).push(h):l.set(e,[h]),a.has(h)?a.get(h).push(e):a.set(h,[e])}let r=0,n=1,o=2;for(;o<i;){const e=s[r],i=s[n],a=s[o];if(h.set(t.points[e][0],t.points[e][1],t.points[e][2]),d.set(t.points[i][0],t.points[i][1],t.points[i][2]),u.set(t.points[a][0],t.points[a][1],t.points[a][2]),p.set(h,d,u),p.getNormal(f),0!==f.x||0!==f.y||0!==f.z)break;r++,n++,o++}c.set(e,[f.x,f.y,f.z])}for(const[t,e]of l){let s=n.get(t);void 0===s&&(s=o++,n.set(t,s));const[i,l,h]=c.get(t);for(const d of e){const e=a.get(d);for(const a of e){if(a===t)continue;const[e,d,u]=c.get(a),f=Math.abs(i*e+l*d+h*u)<r;if(n.has(a)){if(!f){const t=n.get(a);for(const[e,i]of n)i===t&&n.set(e,s)}}else{const t=f?o++:s;n.set(a,t)}}}}for(let e=0;e<t.profiles.size;e++)if(!n.has(e))throw new Error(`Face id not found for profile ${e}`);const m=Array.from(n.keys()).sort(((t,e)=>t-e));for(const e of m){const s=n.get(e);t.profilesFaceIds.push(s)}}static makeDecimal(t){let e=1;for(;e<=t;)e*=10;return t/e}};ot(Rn,"ushortMaxValue",65e3);let An=Rn;class yn{static getAbsolutePlacement(t,e,s=this.getUnitsFactor(t)){const i=e.ObjectPlacement.value,r=t.GetLine(0,i),n=new ft.Matrix4;n.identity(),this.getAbsolutePlacementRecursively(t,r,n,s);const o=new ft.Matrix4;return o.makeRotationX(-Math.PI/2),n.premultiply(o),n}static getUnitsFactor(t){var e,s,i,r;const n=t.GetLineIDsWithType(0,Bt.IFCUNITASSIGNMENT);let o=1;if(0===n.size())return o;for(let a=0;a<n.size();a++){const l=n.get(a),c=t.GetLine(0,l);for(const n of c.Units){const a=t.GetLine(0,n.value);if("LENGTHUNIT"!==(null==(e=a.UnitType)?void 0:e.value))continue;let l=1,c=1;"METRE"===a.Name.value&&(c=1),"FOOT"===a.Name.value&&(c=.3048),"MILLI"===(null==(s=a.Prefix)?void 0:s.value)?l=.001:"CENTI"===(null==(i=a.Prefix)?void 0:i.value)?l=.01:"DECI"===(null==(r=a.Prefix)?void 0:r.value)&&(l=.1),o=c*l}}return o}static getAbsolutePlacementRecursively(t,e,s,i){const r=e.RelativePlacement.value,n=t.GetLine(0,r),o=n.Location.value,a=n.Axis,l=n.RefDirection,c=new ft.Vector3(0,0,0),h=new ft.Vector3(0,0,1),d=new ft.Vector3(1,0,0),u=t.GetLine(0,o);if(u){const[t,e,s]=u.Coordinates;c.x=t.value*i,c.y=e.value*i,c.z=s.value*i}if(a){const e=t.GetLine(0,a.value),[s,i,r]=e.DirectionRatios;h.x=s.value,h.y=i.value,h.z=r.value}if(l){const e=t.GetLine(0,l.value),[s,i,r]=e.DirectionRatios;d.x=s.value,d.y=i.value,d.z=r.value}const f=h.clone().cross(d),p=new ft.Matrix4;if(p.fromArray([d.x,d.y,d.z,0,f.x,f.y,f.z,0,h.x,h.y,h.z,0,c.x,c.y,c.z,1]),s.premultiply(p),!e.PlacementRelTo||!e.PlacementRelTo.value)return;const I=e.PlacementRelTo.value,m=t.GetLine(0,I);this.getAbsolutePlacementRecursively(t,m,s,i)}}const Sn=new Set([Bt.IFCCARTESIANPOINT]),Fn=new Set([Bt.IFCCARTESIANPOINT,Bt.IFCCARTESIANPOINTLIST,Bt.IFCCARTESIANPOINTLIST2D,Bt.IFCCARTESIANPOINTLIST3D,Bt.IFCARBITRARYCLOSEDPROFILEDEF,Bt.IFCDIRECTION,Bt.IFCAXIS2PLACEMENT2D,Bt.IFCASYMMETRICISHAPEPROFILEDEF,Bt.IFCAXIS2PLACEMENT3D,Bt.IFCLOCALPLACEMENT,Bt.IFCSHAPEREPRESENTATION,Bt.IFCRECTANGLEPROFILEDEF,Bt.IFCPOLYLINE,Bt.IFCPLANE,Bt.IFCEXTRUDEDAREASOLID,Bt.IFCSURFACESTYLERENDERING,Bt.IFCSURFACESTYLE,Bt.IFCSURFACESTYLELIGHTING,Bt.IFCSURFACESTYLEREFRACTION,Bt.IFCSURFACESTYLERENDERING,Bt.IFCSURFACESTYLESHADING,Bt.IFCSURFACESTYLEWITHTEXTURES,Bt.IFCPRESENTATIONSTYLEASSIGNMENT,Bt.IFCSTYLEDREPRESENTATION,Bt.IFCCARTESIANTRANSFORMATIONOPERATOR3D,Bt.IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM,Bt.IFCCOLOURRGB,Bt.IFCCOLOURRGBLIST,Bt.IFCSTYLEDITEM,Bt.IFCCURVEBOUNDEDPLANE,Bt.IFCCONNECTIONSURFACEGEOMETRY,Bt.IFCPRODUCTDEFINITIONSHAPE,Bt.IFCGEOMETRICREPRESENTATIONCONTEXT,Bt.IFCGEOMETRICREPRESENTATIONSUBCONTEXT,Bt.IFCPOLYLOOP,Bt.IFCFACEOUTERBOUND,Bt.IFCFACE,Bt.IFCFACEBOUND,Bt.IFCCLOSEDSHELL,Bt.IFCFACETEDBREP,Bt.IFCFACETEDBREPWITHVOIDS,Bt.IFCREPRESENTATIONMAP,Bt.IFCMAPPEDITEM,Bt.IFCARBITRARYPROFILEDEFWITHVOIDS,Bt.IFCCOMPOSITECURVE,Bt.IFCCOMPOSITECURVESEGMENT,Bt.IFCCIRCLE,Bt.IFCELLIPSE,Bt.IFCCIRCLEHOLLOWPROFILEDEF,Bt.IFCRECTANGLEHOLLOWPROFILEDEF,Bt.IFCLINE,Bt.IFCISHAPEPROFILEDEF,Bt.IFCGEOMETRICREPRESENTATIONCONTEXT,Bt.IFCGEOMETRICREPRESENTATIONSUBCONTEXT,Bt.IFCCURVESTYLE,Bt.IFCDRAUGHTINGPREDEFINEDCURVEFONT,Bt.IFCGEOMETRICSET,Bt.IFCCIRCLEPROFILEDEF,Bt.IFCPOLYGONALBOUNDEDHALFSPACE,Bt.IFCFACEBASEDSURFACEMODEL,Bt.IFCCONNECTEDFACESET,Bt.IFCTRIMMEDCURVE,Bt.IFCOPENSHELL,Bt.IFCSHELLBASEDSURFACEMODEL,Bt.IFCHALFSPACESOLID,Bt.IFCBOOLEANCLIPPINGRESULT,Bt.IFCGEOMETRICCURVESET,Bt.IFCCURVESTYLEFONT,Bt.IFCCURVESTYLEFONTPATTERN,Bt.IFCADVANCEDBREP,Bt.IFCADVANCEDBREPWITHVOIDS,Bt.IFCADVANCEDFACE,Bt.IFCARBITRARYOPENPROFILEDEF,Bt.IFCAXIS1PLACEMENT,Bt.IFCBOOLEANRESULT,Bt.IFCBOOLEANCLIPPINGRESULT,Bt.IFCBOUNDARYCURVE,Bt.IFCBOUNDEDCURVE,Bt.IFCBOUNDEDSURFACE,Bt.IFCBOXEDHALFSPACE,Bt.IFCCSHAPEPROFILEDEF,Bt.IFCCARTESIANTRANSFORMATIONOPERATOR,Bt.IFCCARTESIANTRANSFORMATIONOPERATOR2D,Bt.IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM,Bt.IFCCENTERLINEPROFILEDEF,Bt.IFCTESSELLATEDFACESET,Bt.IFCCOLOURSPECIFICATION,Bt.IFCCOMPOSITECURVEONSURFACE,Bt.IFCCOMPOSITEPROFILEDEF,Bt.IFCCONNECTEDFACESET,Bt.IFCCONNECTIONCURVEGEOMETRY,Bt.IFCCONNECTIONGEOMETRY,Bt.IFCCONNECTIONPOINTECCENTRICITY,Bt.IFCCONNECTIONPOINTGEOMETRY,Bt.IFCCONNECTIONSURFACEGEOMETRY,Bt.IFCCONNECTIONVOLUMEGEOMETRY,Bt.IFCCSGSOLID,Bt.IFCCURVE,Bt.IFCCURVEBOUNDEDSURFACE,Bt.IFCCURVESTYLEFONTANDSCALING,Bt.IFCCYLINDRICALSURFACE,Bt.IFCDERIVEDPROFILEDEF,Bt.IFCEDGE,Bt.IFCEDGECURVE,Bt.IFCEDGELOOP,Bt.IFCEXTRUDEDAREASOLIDTAPERED,Bt.IFCFACESURFACE,Bt.IFCFILLAREASTYLE,Bt.IFCFILLAREASTYLEHATCHING,Bt.IFCFILLAREASTYLETILES,Bt.IFCIMAGETEXTURE,Bt.IFCINDEXEDCOLOURMAP,Bt.IFCINDEXEDPOLYCURVE,Bt.IFCINDEXEDPOLYGONALFACE,Bt.IFCINDEXEDPOLYGONALFACEWITHVOIDS,Bt.IFCINDEXEDTEXTUREMAP,Bt.IFCINDEXEDTRIANGLETEXTUREMAP,Bt.IFCLSHAPEPROFILEDEF,Bt.IFCSWEPTSURFACE,Bt.IFCLINEARPLACEMENT,Bt.IFCLOCALPLACEMENT,Bt.IFCMANIFOLDSOLIDBREP,Bt.IFCMAPCONVERSION,Bt.IFCMAPPEDITEM,Bt.IFCPCURVE,Bt.IFCPATH,Bt.IFCPOLYGONALFACESET,Bt.IFCPROFILEDEF,Bt.IFCSURFACE,Bt.IFCSTYLEMODEL,Bt.IFCUSHAPEPROFILEDEF]),wn=new Map([[Bt.IFCRELADHERESTOELEMENT,{forRelating:"HasSurfaceFeatures",forRelated:"AdheresToElement"}],[Bt.IFCRELPOSITIONS,{forRelating:"Positions",forRelated:"PositionedRelativeTo"}],[Bt.IFCRELASSOCIATESPROFILEDEF,{forRelating:"AssociatedTo",forRelated:"HasAssociations"}],[Bt.IFCRELSPACEBOUNDARY2NDLEVEL,{forRelating:"BoundedBy",forRelated:"ProvidesBoundaries"}],[Bt.IFCRELSPACEBOUNDARY1STLEVEL,{forRelating:"BoundedBy",forRelated:"ProvidesBoundaries"}],[Bt.IFCRELINTERFERESELEMENTS,{forRelating:"InterferesElements",forRelated:"IsInterferedByElements"}],[Bt.IFCRELDEFINESBYTEMPLATE,{forRelating:"Defines",forRelated:"IsDefinedBy"}],[Bt.IFCRELDEFINESBYOBJECT,{forRelating:"Declares",forRelated:"IsDeclaredBy"}],[Bt.IFCRELDECLARES,{forRelating:"Declares",forRelated:"HasContext"}],[Bt.IFCRELASSIGNSTOGROUPBYFACTOR,{forRelating:"IsGroupedBy",forRelated:"HasAssignments"}],[Bt.IFCRELASSIGNSTASKS,{forRelating:"Controls",forRelated:"HasAssignments"}],[Bt.IFCRELAGGREGATES,{forRelating:"IsDecomposedBy",forRelated:"Decomposes"}],[Bt.IFCRELVOIDSELEMENT,{forRelating:"HasOpenings",forRelated:"VoidsElements"}],[Bt.IFCRELSPACEBOUNDARY,{forRelating:"BoundedBy",forRelated:"ProvidesBoundaries"}],[Bt.IFCRELSERVICESBUILDINGS,{forRelating:"ServicesBuildings",forRelated:"ServicedBySystems"}],[Bt.IFCRELSEQUENCE,{forRelating:"IsPredecessorTo",forRelated:"IsSuccessorFrom"}],[Bt.IFCRELSCHEDULESCOSTITEMS,{forRelating:"ReferencedBy",forRelated:"HasAssignments"}],[Bt.IFCRELREFERENCEDINSPATIALSTRUCTURE,{forRelating:"ReferencesElements",forRelated:"ReferencedInStructures"}],[Bt.IFCRELPROJECTSELEMENT,{forRelating:"HasProjections",forRelated:"ProjectsElements"}],[Bt.IFCRELOVERRIDESPROPERTIES,{forRelating:"DefinesOccurrence",forRelated:"IsDefinedBy"}],[Bt.IFCRELOCCUPIESSPACES,{forRelating:"IsActingUpon",forRelated:"HasAssignments"}],[Bt.IFCRELNESTS,{forRelating:"IsNestedBy",forRelated:"Nests"}],[Bt.IFCRELINTERACTIONREQUIREMENTS,{forRelating:"HasInteractionReqsTo",forRelated:"HasInteractionReqsFrom"}],[Bt.IFCRELFLOWCONTROLELEMENTS,{forRelating:"HasControlElements",forRelated:"AssignedToFlowElement"}],[Bt.IFCRELFILLSELEMENT,{forRelating:"HasFillings",forRelated:"FillsVoids"}],[Bt.IFCRELDEFINESBYTYPE,{forRelating:"Types",forRelated:"IsTypedBy"}],[Bt.IFCRELDEFINESBYPROPERTIES,{forRelating:"DefinesOccurrence",forRelated:"IsDefinedBy"}],[Bt.IFCRELDEFINES,{forRelating:"DefinesOccurrence",forRelated:"IsDefinedBy"}],[Bt.IFCRELDECOMPOSES,{forRelating:"IsDecomposedBy",forRelated:"Decomposes"}],[Bt.IFCRELCOVERSSPACES,{forRelating:"HasCoverings",forRelated:"CoversSpaces"}],[Bt.IFCRELCOVERSBLDGELEMENTS,{forRelating:"HasCoverings",forRelated:"CoversElements"}],[Bt.IFCRELCONTAINEDINSPATIALSTRUCTURE,{forRelating:"ContainsElements",forRelated:"ContainedInStructure"}],[Bt.IFCRELCONNECTSWITHREALIZINGELEMENTS,{forRelating:"ConnectedTo",forRelated:"ConnectedFrom"}],[Bt.IFCRELCONNECTSWITHECCENTRICITY,{forRelating:"ConnectedBy",forRelated:"ConnectsStructuralMembers"}],[Bt.IFCRELCONNECTSSTRUCTURALMEMBER,{forRelating:"ConnectedBy",forRelated:"ConnectsStructuralMembers"}],[Bt.IFCRELCONNECTSSTRUCTURALELEMENT,{forRelating:"HasStructuralMember",forRelated:"ReferencesElement"}],[Bt.IFCRELCONNECTSSTRUCTURALACTIVITY,{forRelating:"AssignedStructuralActivity",forRelated:"AssignedToStructuralItem"}],[Bt.IFCRELCONNECTSPORTS,{forRelating:"ConnectedTo",forRelated:"ConnectedFrom"}],[Bt.IFCRELCONNECTSPORTTOELEMENT,{forRelating:"ContainedIn",forRelated:"HasPorts"}],[Bt.IFCRELCONNECTSPATHELEMENTS,{forRelating:"ConnectedTo",forRelated:"ConnectedFrom"}],[Bt.IFCRELCONNECTSELEMENTS,{forRelating:"ConnectedTo",forRelated:"ConnectedFrom"}],[Bt.IFCRELCONNECTS,{forRelating:"ConnectedTo",forRelated:"ConnectedFrom"}],[Bt.IFCRELASSOCIATESPROFILEPROPERTIES,{forRelating:"AssociatedTo",forRelated:"HasAssociations"}],[Bt.IFCRELASSOCIATESMATERIAL,{forRelating:"AssociatedTo",forRelated:"HasAssociations"}],[Bt.IFCRELASSOCIATESLIBRARY,{forRelating:"LibraryInfoForObjects",forRelated:"HasAssociations"}],[Bt.IFCRELASSOCIATESDOCUMENT,{forRelating:"DocumentInfoForObjects",forRelated:"DocumentRefForObjects"}],[Bt.IFCRELASSOCIATESCONSTRAINT,{forRelating:"AssociatedTo",forRelated:"HasAssociations"}],[Bt.IFCRELASSOCIATESCLASSIFICATION,{forRelating:"HasReferences",forRelated:"ClassificationRefForObjects"}],[Bt.IFCRELASSOCIATESAPPROVAL,{forRelating:"ApprovedObjects",forRelated:"HasAssociations"}],[Bt.IFCRELASSOCIATESAPPLIEDVALUE,{forRelating:"AssociatedTo",forRelated:"HasAssociations"}],[Bt.IFCRELASSOCIATES,{forRelating:"AssociatedTo",forRelated:"HasAssociations"}],[Bt.IFCRELASSIGNSTORESOURCE,{forRelating:"ResourceOf",forRelated:"HasAssignments"}],[Bt.IFCRELASSIGNSTOPROJECTORDER,{forRelating:"ReferencedBy",forRelated:"HasAssignments"}],[Bt.IFCRELASSIGNSTOPRODUCT,{forRelating:"ReferencedBy",forRelated:"HasAssignments"}],[Bt.IFCRELASSIGNSTOPROCESS,{forRelating:"OperatesOn",forRelated:"HasAssignments"}],[Bt.IFCRELASSIGNSTOGROUP,{forRelating:"IsGroupedBy",forRelated:"HasAssignments"}],[Bt.IFCRELASSIGNSTOCONTROL,{forRelating:"Controls",forRelated:"HasAssignments"}],[Bt.IFCRELASSIGNSTOACTOR,{forRelating:"IsActingUpon",forRelated:"HasAssignments"}],[Bt.IFCRELASSIGNS,{forRelating:"ReferencedBy",forRelated:"HasAssignments"}]]),Ln=65536;var On=(t=>(t[t.LINE=0]="LINE",t[t.SHELL=1]="SHELL",t))(On||{}),xn=(t=>(t[t.UPDATE=0]="UPDATE",t[t.CREATE=1]="CREATE",t[t.DELETE=2]="DELETE",t[t.FINISH=3]="FINISH",t))(xn||{}),Nn=(t=>(t[t.GEOMETRY=0]="GEOMETRY",t[t.WIRES=1]="WIRES",t[t.INVISIBLE=2]="INVISIBLE",t))(Nn||{}),vn=(t=>(t[t.CREATE_MODEL=0]="CREATE_MODEL",t[t.DELETE_MODEL=1]="DELETE_MODEL",t[t.EXECUTE=2]="EXECUTE",t[t.RAYCAST=3]="RAYCAST",t[t.FETCH_BOXES=4]="FETCH_BOXES",t[t.REFRESH_VIEW=5]="REFRESH_VIEW",t[t.RECOMPUTE_MESHES=6]="RECOMPUTE_MESHES",t[t.CREATE_MATERIAL=7]="CREATE_MATERIAL",t[t.THROW_ERROR=8]="THROW_ERROR",t))(vn||{}),Pn=(t=>(t[t.VISIBLE=0]="VISIBLE",t))(Pn||{}),Mn=(t=>(t[t.POINT=0]="POINT",t[t.LINE=1]="LINE",t[t.FACE=2]="FACE",t))(Mn||{});const Dn="ThatOpenAlignment",Un="ThatOpenGrid";var Vn=(t=>(t[t.NONE=0]="NONE",t[t.LINES=1]="LINES",t[t.CLOTHOID=2]="CLOTHOID",t[t.ELLIPSE_ARC=3]="ELLIPSE_ARC",t[t.PARABOLA=4]="PARABOLA",t))(Vn||{}),Bn=(t=>(t[t.DEFAULT=0]="DEFAULT",t[t.ALL_VISIBLE=1]="ALL_VISIBLE",t[t.ALL_GEOMETRY=2]="ALL_GEOMETRY",t))(Bn||{});class zn{static containedInParallelPlanes(t,e){let s=!0;for(const i of t){const t=i.distanceToPoint(e);s=s&&t>=0}return s}static collides(t,e,s){for(const i of e){if(this.getPointDistance(i,s,t)<0)return!1}return!0}static getPointDistance(t,e,s){const i=t.normal;for(const t of this.dimensions){const r=i[t]>=0!==e;this.tempPoint[t]=r?s.max[t]:s.min[t]}return t.distanceToPoint(this.tempPoint)}}ot(zn,"tempPoint",new ft.Vector3),ot(zn,"dimensions",["x","y","z"]);class Gn{static transform(t,e,s=new ft.Frustum){for(let i=0;i<s.planes.length;i++){const r=s.planes[i],n=t.planes[i];r.copy(n),r.applyMatrix4(e)}return s}static isIncluded(t,e){return zn.collides(t,e,!0)}static collides(t,e){return zn.collides(t,e,!1)}}function Hn(t,e,s=2){const i=e&&e.length,r=i?e[0]*s:t.length;let n=kn(t,0,r,s,!0);const o=[];if(!n||n.next===n.prev)return o;let a,l,c;if(i&&(n=function(t,e,s,i){const r=[];for(let s=0,n=e.length;s<n;s++){const o=kn(t,e[s]*i,s<n-1?e[s+1]*i:t.length,i,!1);o===o.next&&(o.steiner=!0),r.push(to(o))}r.sort($n);for(let t=0;t<r.length;t++)s=Qn(r[t],s);return s}(t,e,n,s)),t.length>80*s){a=1/0,l=1/0;let e=-1/0,i=-1/0;for(let n=s;n<r;n+=s){const s=t[n],r=t[n+1];s<a&&(a=s),r<l&&(l=r),s>e&&(e=s),r>i&&(i=r)}c=Math.max(e-a,i-l),c=0!==c?32767/c:0}return Wn(n,o,s,a,l,c,0),o}function kn(t,e,s,i,r){let n;if(r===function(t,e,s,i){let r=0;for(let n=e,o=s-i;n<s;n+=i)r+=(t[o]-t[n])*(t[n+1]+t[o+1]),o=n;return r}(t,e,s,i)>0)for(let r=e;r<s;r+=i)n=uo(r/i|0,t[r],t[r+1],n);else for(let r=s-i;r>=e;r-=i)n=uo(r/i|0,t[r],t[r+1],n);return n&&no(n,n.next)&&(fo(n),n=n.next),n}function Yn(t,e){if(!t)return t;e||(e=t);let s,i=t;do{if(s=!1,i.steiner||!no(i,i.next)&&0!==ro(i.prev,i,i.next))i=i.next;else{if(fo(i),i=e=i.prev,i===i.next)break;s=!0}}while(s||i!==e);return e}function Wn(t,e,s,i,r,n,o){if(!t)return;!o&&n&&function(t,e,s,i){let r=t;do{0===r.z&&(r.z=Jn(r.x,r.y,e,s,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){let e,s=1;do{let i,r=t;t=null;let n=null;for(e=0;r;){e++;let o=r,a=0;for(let t=0;t<s&&(a++,o=o.nextZ,o);t++);let l=s;for(;a>0||l>0&&o;)0!==a&&(0===l||!o||r.z<=o.z)?(i=r,r=r.nextZ,a--):(i=o,o=o.nextZ,l--),n?n.nextZ=i:t=i,i.prevZ=n,n=i;r=o}n.nextZ=null,s*=2}while(e>1)}(r)}(t,i,r,n);let a=t;for(;t.prev!==t.next;){const l=t.prev,c=t.next;if(n?jn(t,i,r,n):qn(t))e.push(l.i,t.i,c.i),fo(t),t=c.next,a=c.next;else if((t=c)===a){o?1===o?Wn(t=Xn(Yn(t),e),e,s,i,r,n,2):2===o&&Zn(t,e,s,i,r,n):Wn(Yn(t),e,s,i,r,n,1);break}}}function qn(t){const e=t.prev,s=t,i=t.next;if(ro(e,s,i)>=0)return!1;const r=e.x,n=s.x,o=i.x,a=e.y,l=s.y,c=i.y,h=Math.min(r,n,o),d=Math.min(a,l,c),u=Math.max(r,n,o),f=Math.max(a,l,c);let p=i.next;for(;p!==e;){if(p.x>=h&&p.x<=u&&p.y>=d&&p.y<=f&&so(r,a,n,l,o,c,p.x,p.y)&&ro(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function jn(t,e,s,i){const r=t.prev,n=t,o=t.next;if(ro(r,n,o)>=0)return!1;const a=r.x,l=n.x,c=o.x,h=r.y,d=n.y,u=o.y,f=Math.min(a,l,c),p=Math.min(h,d,u),I=Math.max(a,l,c),m=Math.max(h,d,u),E=Jn(f,p,e,s,i),_=Jn(I,m,e,s,i);let g=t.prevZ,C=t.nextZ;for(;g&&g.z>=E&&C&&C.z<=_;){if(g.x>=f&&g.x<=I&&g.y>=p&&g.y<=m&&g!==r&&g!==o&&so(a,h,l,d,c,u,g.x,g.y)&&ro(g.prev,g,g.next)>=0)return!1;if(g=g.prevZ,C.x>=f&&C.x<=I&&C.y>=p&&C.y<=m&&C!==r&&C!==o&&so(a,h,l,d,c,u,C.x,C.y)&&ro(C.prev,C,C.next)>=0)return!1;C=C.nextZ}for(;g&&g.z>=E;){if(g.x>=f&&g.x<=I&&g.y>=p&&g.y<=m&&g!==r&&g!==o&&so(a,h,l,d,c,u,g.x,g.y)&&ro(g.prev,g,g.next)>=0)return!1;g=g.prevZ}for(;C&&C.z<=_;){if(C.x>=f&&C.x<=I&&C.y>=p&&C.y<=m&&C!==r&&C!==o&&so(a,h,l,d,c,u,C.x,C.y)&&ro(C.prev,C,C.next)>=0)return!1;C=C.nextZ}return!0}function Xn(t,e){let s=t;do{const i=s.prev,r=s.next.next;!no(i,r)&&oo(i,s,s.next,r)&&co(i,r)&&co(r,i)&&(e.push(i.i,s.i,r.i),fo(s),fo(s.next),s=t=r),s=s.next}while(s!==t);return Yn(s)}function Zn(t,e,s,i,r,n){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&io(o,t)){let a=ho(o,t);return o=Yn(o,o.next),a=Yn(a,a.next),Wn(o,e,s,i,r,n,0),void Wn(a,e,s,i,r,n,0)}t=t.next}o=o.next}while(o!==t)}function $n(t,e){let s=t.x-e.x;if(0===s&&(s=t.y-e.y,0===s)){s=(t.next.y-t.y)/(t.next.x-t.x)-(e.next.y-e.y)/(e.next.x-e.x)}return s}function Qn(t,e){const s=function(t,e){let s=e;const i=t.x,r=t.y;let n,o=-1/0;if(no(t,s))return s;do{if(no(t,s.next))return s.next;if(r<=s.y&&r>=s.next.y&&s.next.y!==s.y){const t=s.x+(r-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(t<=i&&t>o&&(o=t,n=s.x<s.next.x?s:s.next,t===i))return n}s=s.next}while(s!==e);if(!n)return null;const a=n,l=n.x,c=n.y;let h=1/0;s=n;do{if(i>=s.x&&s.x>=l&&i!==s.x&&eo(r<c?i:o,r,l,c,r<c?o:i,r,s.x,s.y)){const e=Math.abs(r-s.y)/(i-s.x);co(s,t)&&(e<h||e===h&&(s.x>n.x||s.x===n.x&&Kn(n,s)))&&(n=s,h=e)}s=s.next}while(s!==a);return n}(t,e);if(!s)return e;const i=ho(s,t);return Yn(i,i.next),Yn(s,s.next)}function Kn(t,e){return ro(t.prev,t,e.prev)<0&&ro(e.next,t,t.next)<0}function Jn(t,e,s,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-s)*r|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-i)*r|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function to(t){let e=t,s=t;do{(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next}while(e!==t);return s}function eo(t,e,s,i,r,n,o,a){return(r-o)*(e-a)>=(t-o)*(n-a)&&(t-o)*(i-a)>=(s-o)*(e-a)&&(s-o)*(n-a)>=(r-o)*(i-a)}function so(t,e,s,i,r,n,o,a){return!(t===o&&e===a)&&eo(t,e,s,i,r,n,o,a)}function io(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let s=t;do{if(s.i!==t.i&&s.next.i!==t.i&&s.i!==e.i&&s.next.i!==e.i&&oo(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}(t,e)&&(co(t,e)&&co(e,t)&&function(t,e){let s=t,i=!1;const r=(t.x+e.x)/2,n=(t.y+e.y)/2;do{s.y>n!=s.next.y>n&&s.next.y!==s.y&&r<(s.next.x-s.x)*(n-s.y)/(s.next.y-s.y)+s.x&&(i=!i),s=s.next}while(s!==t);return i}(t,e)&&(ro(t.prev,t,e.prev)||ro(t,e.prev,e))||no(t,e)&&ro(t.prev,t,t.next)>0&&ro(e.prev,e,e.next)>0)}function ro(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function no(t,e){return t.x===e.x&&t.y===e.y}function oo(t,e,s,i){const r=lo(ro(t,e,s)),n=lo(ro(t,e,i)),o=lo(ro(s,i,t)),a=lo(ro(s,i,e));return r!==n&&o!==a||(!(0!==r||!ao(t,s,e))||(!(0!==n||!ao(t,i,e))||(!(0!==o||!ao(s,t,i))||!(0!==a||!ao(s,e,i)))))}function ao(t,e,s){return e.x<=Math.max(t.x,s.x)&&e.x>=Math.min(t.x,s.x)&&e.y<=Math.max(t.y,s.y)&&e.y>=Math.min(t.y,s.y)}function lo(t){return t>0?1:t<0?-1:0}function co(t,e){return ro(t.prev,t,t.next)<0?ro(t,e,t.next)>=0&&ro(t,t.prev,e)>=0:ro(t,e,t.prev)<0||ro(t,t.next,e)<0}function ho(t,e){const s=po(t.i,t.x,t.y),i=po(e.i,e.x,e.y),r=t.next,n=e.prev;return t.next=e,e.prev=t,s.next=r,r.prev=s,i.next=s,s.prev=i,n.next=i,i.prev=n,i}function uo(t,e,s,i){const r=po(t,e,s);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function fo(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function po(t,e,s){return{i:t,x:e,y:s,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}class Io{constructor(){ot(this,"_inverseMatrix",new ft.Matrix4),ot(this,"_localPlane",new ft.Plane),ot(this,"_tempLine",new ft.Line3),ot(this,"_tempVector",new ft.Vector3),ot(this,"_plane"),ot(this,"_plane2DCoordinateSystem",new ft.Matrix4),ot(this,"_precission",1e4)}get plane(){if(!this._plane)throw new Error("Fragments: Plane not set");return this._plane}set plane(t){this._plane=t}createEdges(t){const{meshes:e,posAttr:s}=t;let i=0;s.array.fill(0);const r=[];let n=0;const o=new ft.Mesh;for(const t of e)if(t.geometry){if(t.geometry.boundsTree||t.geometry.computeBoundsTree(),!t.geometry.boundsTree)throw new Error("Fragments: Bounds tree not found for edges generation.");if(t instanceof ft.InstancedMesh){if(0===t.count)continue;const e=t;for(let a=0;a<e.count;a++){o.geometry=t.geometry,o.matrix.copy(t.matrix);const l=new ft.Matrix4;e.getMatrixAt(a,l),o.applyMatrix4(l),o.applyMatrix4(t.matrixWorld),o.updateMatrix(),o.updateMatrixWorld(),this._inverseMatrix.copy(o.matrixWorld).invert(),this._localPlane.copy(this.plane).applyMatrix4(this._inverseMatrix),i=this.shapecast(o,s,i),i!==n&&(r.push(i),n=i)}}else this._inverseMatrix.copy(t.matrixWorld).invert(),this._localPlane.copy(this.plane).applyMatrix4(this._inverseMatrix),i=this.shapecast(t,s,i),i!==n&&(r.push(i),n=i)}return{indexes:r,index:i}}createFills(t,e){this.updatePlane2DCoordinateSystem();const s=[];let i=0;for(let r=0;r<e.length;r++){const n=e[r],o=[];for(let t=i;t<n;t+=2)o.push(3*t);const a=this.computeFill(o,t);for(const t of a)s.push(t);i=n}return s}computeFill(t,e){const s=new Map,i={},r=new Map;let n=0;const o=new Map,a=new Map,l=new Set,c=this._precission;for(let h=0;h<t.length;h++){const d=t[h];let u=0,f=0,p=0,I=0;const m=e[d],E=e[d+1],_=e[d+2],g=e[d+3],C=e[d+4],T=e[d+5];if(this._tempVector.set(m,E,_),this._tempVector.applyMatrix4(this._plane2DCoordinateSystem),u=Math.trunc(this._tempVector.x*c)/c,f=Math.trunc(this._tempVector.y*c)/c,this._tempVector.set(g,C,T),this._tempVector.applyMatrix4(this._plane2DCoordinateSystem),p=Math.trunc(this._tempVector.x*c)/c,I=Math.trunc(this._tempVector.y*c)/c,u===p&&f===I)continue;const b=`${u}|${f}`,R=`${p}|${I}`;s.has(b)||s.set(b,d/3),s.has(R)||s.set(R,d/3+1);const A=s.get(b),y=s.get(R);i[A]=[u,f],i[y]=[p,I];const S=a.has(A),F=o.has(A),w=a.has(y),L=o.has(y);if(!(S||F||w||L))a.set(A,n),o.set(y,n),l.add(n),r.set(n,[A,y]),n++;else if(S&&L){const t=a.get(A),e=o.get(y);if(t!==e){const s=r.get(e),i=r.get(t);if(!s||!i)continue;r.delete(t),l.delete(t),o.set(i[i.length-1],e),o.delete(s[s.length-1]);for(const t of i)s.push(t)}else l.delete(e);a.delete(A),o.delete(y)}else if(F&&w){const t=a.get(y),e=o.get(A);if(t!==e){const s=r.get(e),i=r.get(t);if(!s||!i)continue;r.delete(t),l.delete(t),o.set(i[i.length-1],e),o.delete(s[s.length-1]);for(const t of i)s.push(t)}else l.delete(e);a.delete(y),o.delete(A)}else if(S&&w){const t=a.get(y),e=a.get(A),s=r.get(e),i=r.get(t);if(!s||!i)continue;r.delete(t),l.delete(t),a.delete(s[0]),a.delete(i[0]),o.delete(i[i.length-1]),a.set(i[i.length-1],e),i.reverse(),s.splice(0,0,...i)}else if(F&&L){const t=o.get(y),e=o.get(A),s=r.get(e),i=r.get(t);if(!s||!i)continue;r.delete(t),l.delete(t),o.delete(s[s.length-1]),o.delete(i[i.length-1]),a.delete(i[0]),o.set(i[0],e),i.reverse(),s.push(...i)}else if(S){const t=a.get(A),e=r.get(t);if(!e)continue;e.unshift(y),a.delete(A),a.set(y,t)}else if(F){const t=o.get(A),e=r.get(t);if(!e)continue;e.push(y),o.delete(A),o.set(y,t)}else if(w){const t=a.get(y),e=r.get(t);if(!e)continue;e.unshift(A),a.delete(y),a.set(A,t)}else if(L){const t=o.get(y),e=r.get(t);if(!e)continue;e.push(A),o.delete(y),o.set(A,t)}}const h=[];for(const[t,e]of r){if(l.has(t))continue;const s=[],r=new Map;let n=0;for(const t of e){const e=i[t];s.push(e[0],e[1]),r.set(n++,t)}const o=Hn(s);for(const t of o){const e=r.get(t);if(void 0===e)throw new Error("Fragments: Map error!");h.push(e)}}return h}updatePlane2DCoordinateSystem(){this._plane2DCoordinateSystem=new ft.Matrix4;const t=this.plane.normal,e=new ft.Vector3;let s,i;if(this.plane.coplanarPoint(e),Math.abs(t.z)>.99)s=new ft.Vector3(1,0,0),i=new ft.Vector3(0,1,0);else if(Math.abs(t.x)>.99)s=new ft.Vector3(0,1,0),i=new ft.Vector3(0,0,1);else if(Math.abs(t.y)>.99)s=new ft.Vector3(1,0,0),i=new ft.Vector3(0,0,1);else{const e=Math.abs(t.x)<.5?new ft.Vector3(1,0,0):new ft.Vector3(0,1,0);s=new ft.Vector3,s.crossVectors(e,t).normalize(),i=new ft.Vector3,i.crossVectors(t,s).normalize()}this._plane2DCoordinateSystem.fromArray([s.x,s.y,s.z,0,i.x,i.y,i.z,0,t.x,t.y,t.z,0,e.x,e.y,e.z,1]),this._plane2DCoordinateSystem.invert()}shapecast(t,e,s){return t.geometry.boundsTree.shapecast({intersectsBounds:t=>this._localPlane.intersectsBox(t),intersectsTriangle:i=>{let r=0;if(this._tempLine.start.copy(i.a),this._tempLine.end.copy(i.b),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const i=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,i.x,i.y,i.z),r++,s++}if(this._tempLine.start.copy(i.b),this._tempLine.end.copy(i.c),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const i=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,i.x,i.y,i.z),r++,s++}if(this._tempLine.start.copy(i.c),this._tempLine.end.copy(i.a),this._localPlane.intersectLine(this._tempLine,this._tempVector)){const i=this._tempVector.applyMatrix4(t.matrixWorld);e.setXYZ(s,i.x,i.y,i.z),r++,s++}2!==r&&(s-=r)}}),s}}class mo{constructor(){ot(this,"int"),ot(this,"float"),ot(this,"buffer"),ot(this,"s1",4),ot(this,"s2",8);const{intBuffer:t,floatBuffer:e,buffer:s}=this.newBuffers();this.int=t,this.float=e,this.buffer=s}newBuffers(){const t=new Int32Array(1),e=t.buffer;return{intBuffer:t,floatBuffer:new Float32Array(e),buffer:new Uint8Array(e)}}}class Eo{static check(t){const e=Number.isInteger(t),s=t<this._max,i=t>this._min;return e&&s&&i}}ot(Eo,"_max",2147483647),ot(Eo,"_min",-2147483648);const _o=class t{constructor(){ot(this,"_core",new mo),ot(this,"_handlers"),ot(this,"_result",-1),ot(this,"handleObject",(t=>{const e=Object.keys(t);for(const s of e)t.hasOwnProperty(s)&&this.compute(t[s])})),ot(this,"handleString",(t=>{const e=t.length;for(let s=0;s<e;++s){const e=t.codePointAt(s);this._core.int[0]=e,this.update()}})),ot(this,"handleBoolean",(t=>{this._core.int[0]=t?1:0,this.update()})),ot(this,"handleNumber",(t=>{(Eo.check(t)?this._core.int:this._core.float)[0]=t,this.update()})),this._handlers=this.newHandlers()}get value(){return~this._result}fromMaterialData(t){const{modelId:e,objectClass:s,currentLod:i,templateId:r,...n}=t;this.reset(),this.compute(e),this.compute(s),this.compute(n),this.compute(i),this.compute(void 0!==r)}generate(t){this.reset();for(const e of t)this.compute(e);return this.value}compute(t){return this.getHandler(t)(t),this}reset(){return this._result=-1,this}getHandler(t){const e=typeof t,s=this._handlers[e];if(!s)throw new Error("Fragments: Unsupported input type");return s}newHandlers(){return{number:this.handleNumber,boolean:this.handleBoolean,string:this.handleString,object:this.handleObject}}update(){for(let e=0;e<this._core.s1;++e){this._result^=this._core.buffer[e];for(let e=0;e<this._core.s2;++e)1&this._result?this._result=this._result>>1^t._polynomial:this._result>>=1}}};ot(_o,"_polynomial",2197175160);let go=_o;const Co=class t{constructor(t,e){ot(this,"_first"),this._first=this.newData(t,e)}static getComplementary(t,e){let s=0;const i=t.position.length;s=this.makeBufferComplementary(i,t,s,e),s!==1/0&&e(s,1/0)}static get(t,e,s,i){const{filtered:r,position:n,size:o}=this.getData(t,s);return this.setAllBufferData(r,e,n,o,i),{position:n,size:o}}fullOf(t){const e=this._first.following,s=this._first.data;return null===e&&s===t}update(t,e){const s=this.getBufferData(t);if(!(s.data===e)){const{a:i,c:r,b:n}=this.newBuffers(t,s,e);this.setupInputData(s,i,r),this.setupUpdateBuffers(i,n,r)}}size(t){let e=0,s=this._first;for(;null!==s;){this.doesFilterPass(t,s)&&e++,s=s.following}return e}static setAllBufferData(t,e,s,i,r){for(let n=0;n<t.length;++n){const o=t[n];this.transform(o,e),this.setBuffers(s,i,n),r&&r(n,o.data)}}static makeBufferComplementary(t,e,s,i){for(let r=0;r<t;++r){const t=this.getBuffers(e,r),{position:n,size:o}=t;n>s&&i(s,n-s),s=n+o}return s}static setBuffers(t,e,s){t[s]=this._tempData.position;const i=this._tempData.size===1/0;e[s]=i?this._inf:this._tempData.size}add(e,s,i){if(!t._stash.length)return this.newData(s,i,e);const r=t._stash.pop();if(!r)throw new Error("Fragments: No stash found");return r.position=e,r.size=s,r.data=i,r}remove(e){e&&(e.following=null,e.past=null,t._stash.push(e))}static getData(t,e){const s=t.filter(e),i=s.length;return{filtered:s,position:new Uint32Array(i),size:new Uint32Array(i)}}filter(t){const e=[];let s=this._first;for(;null!==s;){this.doesFilterPass(t,s)&&e.push(s),s=s.following}return e}static transform(t,e){const s=this.getTempData(),i=t.position+t.size,r=i===e.length;if(s.position=e[t.position],r)s.size=1/0;else{const t=e[i];s.size=t-s.position}return s}static getBuffers(t,e){const s=t.position[e];let i;return i=t.size[e]===this._inf?1/0:t.size[e],{position:s,size:i}}static getTempData(){return this._tempData?this._tempData:{position:0,size:0}}doesFilterPass(t,e){return!t||t(e.data)}setupUpdateBuffers(t,e,s){this.chainBuffers(t,e,s),this.setupFirstBuffer(t,e),this.setupLastBuffer(s,e),this.setupMiddleBufferStart(e),this.setupMiddleBufferEnd(e)}setupMiddleBufferEnd(t){var e;if((null==(e=t.following)?void 0:e.data)===t.data){if(!t.following)return;const e=t.following.size+t.size,s=t.following.following;t.size=e,this.remove(t.following),t.following=s,t.following&&(t.following.past=t)}}setupFirstBuffer(t,e){t.size||(t.past?t.past.following=e:this._first=e,e.past=t.past,this.remove(t))}setupMiddleBufferStart(t){var e;if((null==(e=t.past)?void 0:e.data)===t.data){if(!t.past)return;t.size=t.past.size+t.size,t.position=t.past.position;const e=t.past.past;this.remove(t.past),t.past=e,t.past?t.past.following=t:this._first=t}}chainBuffers(t,e,s){t.following=e,e.past=t,e.following=s,s.past=e}setupLastBuffer(t,e){t.size||(t.following&&(t.following.past=e),e.following=t.following,this.remove(t))}newBuffers(t,e,s){const i=t-e.position,r=this.add(e.position,i,e.data),n=this.add(t,1,s),o=e.size-r.size-1;return{a:r,c:this.add(t+1,o,e.data),b:n}}setupInputData(t,e,s){t.past?(t.past.following=e,e.past=t.past):this._first=e,t.following&&(t.following.past=s,s.following=t.following),this.remove(t)}newData(t,e,s=0){return{position:s,size:t,past:null,following:null,data:e}}getBufferData(t){let e=this._first;for(;;){const s=null===e,i=e.position<=t,r=t<e.position+e.size;if(s||i&&r)return e;e=e.following}}};ot(Co,"_stash",[]),ot(Co,"_tempData",{position:0,size:0}),ot(Co,"_inf",4294967295);let To=Co;class bo{static fixNumber(t){return Number.isNaN(t)?0:Number.isFinite(t)?t:0}static forEach(t,e){if(Array.isArray(t)){let s=0;for(const i of t)e(i,s++)}else e(t,0)}}class Ro{static estimateCapacity(){const t=this.capacityFactor,e=window.screen.width,s=window.screen.height,i=window.devicePixelRatio;return Math.trunc(e*s*i*i*t)}}ot(Ro,"capacityFactor",200);class Ao{static check(t,e,s){const i=this.get(s),r=t[e];return Boolean(r&i)}static apply(t,e,s,i){const r=this.get(s);i?t[e]|=r:t[e]&=~r}static checkMemory(t){if(t>Ln)throw new Error("Fragments: Memory overflow!")}static get(t){return 1<<t}}class yo{static parseMaterial(t){const e=t.r()/255,s=t.g()/255,i=t.b()/255,r=t.a()/255,n=t.a()<255;return{color:(new ft.Color).setRGB(e,s,i,ft.SRGBColorSpace),renderedFaces:t.renderedFaces(),opacity:r,transparent:n,localId:void 0}}static parseBox(t,e){this.getBox(t,e,"min"),this.getBox(t,e,"max")}static parseTransform(t,e){return this.getVector(t,"position",this._doubleVector),this.getVector(t,"xDirection",this._floatVector),this.getVector(t,"yDirection",this._floatVector),this.computeZVector(),this.setTransform(e),e}static setTransform(t){const{x:e,y:s,z:i}=this._temp.xDirection,{x:r,y:n,z:o}=this._temp.yDirection,{x:a,y:l,z:c}=this._temp.zDirection,{x:h,y:d,z:u}=this._temp.position;t.set(e,r,a,h,s,n,l,d,i,o,c,u,0,0,0,1)}static getBox(t,e,s){t[s](this._floatVector);const i=this._floatVector.x(),r=this._floatVector.y(),n=this._floatVector.z();e[s].x=bo.fixNumber(i),e[s].y=bo.fixNumber(r),e[s].z=bo.fixNumber(n)}static getVector(t,e,s){t[e](s);const i=this._temp[e],r=s.x(),n=s.y(),o=s.z();i.x=bo.fixNumber(r),i.y=bo.fixNumber(n),i.z=bo.fixNumber(o)}static computeZVector(){this._temp.zDirection.crossVectors(this._temp.xDirection,this._temp.yDirection)}}ot(yo,"_temp",{position:new ft.Vector3,xDirection:new ft.Vector3,yDirection:new ft.Vector3,zDirection:new ft.Vector3}),ot(yo,"_doubleVector",new Fr),ot(yo,"_floatVector",new Er);const So=class{static get(t,e,s){this.fetchSampleTransform(t,e),this.fetchItemTransform(t,e),s.multiplyMatrices(this._item,this._sample)}static getBox(t,e){t.bbox(this._box),yo.parseBox(this._box,e)}static getBoxData(t){this._min.copy(t.min),this._max.copy(t.max),this._center.addVectors(this._min,this._max),this._center.divideScalar(2),t.getSize(this._distance)}static boxSize(t){return this.getBoxData(t),this.applyTransformer(),this._edge.start=this._min.clone(),this._edge.end=this._max.clone(),this._edge}static applyTransformer(){const{x:t,y:e,z:s}=this._distance,i=Math.max(t,e,s);t===i?this._transformers.x():e===i?this._transformers.y():this._transformers.z()}static fetchItemTransform(t,e){const s=t.item();e.globalTransforms(s,this._transform),yo.parseTransform(this._transform,this._item)}static fetchSampleTransform(t,e){const s=t.localTransform();e.localTransforms(s,this._transform),yo.parseTransform(this._transform,this._sample)}static setBoxZ(){this._min.set(this._center.x,this._center.y,this._min.z),this._max.set(this._center.x,this._center.y,this._max.z)}static setBoxY(){this._min.set(this._center.x,this._min.y,this._center.z),this._max.set(this._center.x,this._max.y,this._center.z)}static setBoxX(){this._min.set(this._min.x,this._center.y,this._center.z),this._max.set(this._max.x,this._center.y,this._center.z)}};ot(So,"_transform",new Mr),ot(So,"_min",new ft.Vector3),ot(So,"_max",new ft.Vector3),ot(So,"_center",new ft.Vector3),ot(So,"_distance",new ft.Vector3),ot(So,"_edge",new ft.Line3),ot(So,"_item",new ft.Matrix4),ot(So,"_sample",new ft.Matrix4),ot(So,"_box",new yr),ot(So,"_transformers",{x:()=>So.setBoxX(),y:()=>So.setBoxY(),z:()=>So.setBoxZ()});let Fo=So;class wo{static getWidth(t){return t.getSize(this._temp.vector),this._temp.vector.x>this._temp.vector.y&&this._temp.vector.set(this._temp.vector.y,this._temp.vector.x,this._temp.vector.z),this._temp.vector.y>this._temp.vector.z&&this._temp.vector.set(this._temp.vector.x,this._temp.vector.z,this._temp.vector.y),this._temp.vector.x>this._temp.vector.y&&this._temp.vector.set(this._temp.vector.y,this._temp.vector.x,this._temp.vector.z),this._temp.vector.y}}ot(wo,"_temp",{vector:new ft.Vector3});class Lo{static getEarcutDimensions(t){const e=Math.abs(t.x),s=Math.abs(t.y),i=Math.abs(t.z);if(i>e&&i>s){return t.z>0?[0,1]:[1,0]}if(s>e&&s>i){return t.y>0?[2,0]:[0,2]}return t.x>0?[1,2]:[2,1]}}const Oo=new Ct,xo=new bt;class No extends It{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new mt([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new mt([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,s=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),s.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new Et(e,6,1);return this.setAttribute("instanceStart",new _t(s,3,0)),this.setAttribute("instanceEnd",new _t(s,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const s=new Et(e,6,1);return this.setAttribute("instanceColorStart",new _t(s,3,0)),this.setAttribute("instanceColorEnd",new _t(s,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new gt(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Ct);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),Oo.setFromBufferAttribute(e),this.boundingBox.union(Oo))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Tt),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){const s=this.boundingSphere.center;this.boundingBox.getCenter(s);let i=0;for(let r=0,n=t.count;r<n;r++)xo.fromBufferAttribute(t,r),i=Math.max(i,s.distanceToSquared(xo)),xo.fromBufferAttribute(e,r),i=Math.max(i,s.distanceToSquared(xo));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}Ft.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new St(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},At.line={uniforms:yt.merge([Ft.common,Ft.fog,Ft.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};class vo extends Rt{constructor(t){super({type:"LineMaterial",uniforms:yt.clone(At.line.uniforms),vertexShader:At.line.vertexShader,fragmentShader:At.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(t)}get color(){return this.uniforms.diffuse.value}set color(t){this.uniforms.diffuse.value=t}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(t){!0===t?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(t){this.uniforms.linewidth&&(this.uniforms.linewidth.value=t)}get dashed(){return"USE_DASH"in this.defines}set dashed(t){!0===t!==this.dashed&&(this.needsUpdate=!0),!0===t?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(t){this.uniforms.dashScale.value=t}get dashSize(){return this.uniforms.dashSize.value}set dashSize(t){this.uniforms.dashSize.value=t}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(t){this.uniforms.dashOffset.value=t}get gapSize(){return this.uniforms.gapSize.value}set gapSize(t){this.uniforms.gapSize.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}get resolution(){return this.uniforms.resolution.value}set resolution(t){this.uniforms.resolution.value.copy(t)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(t){this.defines&&(!0===t!==this.alphaToCoverage&&(this.needsUpdate=!0),!0===t?this.defines.USE_ALPHA_TO_COVERAGE="":delete this.defines.USE_ALPHA_TO_COVERAGE)}}const Po=new Lt,Mo=new bt,Do=new bt,Uo=new Lt,Vo=new Lt,Bo=new Lt,zo=new bt,Go=new xt,Ho=new Ot,ko=new bt,Yo=new Ct,Wo=new Tt,qo=new Lt;let jo,Xo;function Zo(t,e,s){return qo.set(0,0,-e,1).applyMatrix4(t.projectionMatrix),qo.multiplyScalar(1/qo.w),qo.x=Xo/s.width,qo.y=Xo/s.height,qo.applyMatrix4(t.projectionMatrixInverse),qo.multiplyScalar(1/qo.w),Math.abs(Math.max(qo.x,qo.y))}class $o extends wt{constructor(t=new No,e=new vo({color:16777215*Math.random()})){super(t,e),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,s=t.attributes.instanceEnd,i=new Float32Array(2*e.count);for(let t=0,r=0,n=e.count;t<n;t++,r+=2)Mo.fromBufferAttribute(e,t),Do.fromBufferAttribute(s,t),i[r]=0===r?0:i[r-1],i[r+1]=i[r]+Mo.distanceTo(Do);const r=new Et(i,2,1);return t.setAttribute("instanceDistanceStart",new _t(r,1,0)),t.setAttribute("instanceDistanceEnd",new _t(r,1,1)),this}raycast(t,e){const s=this.material.worldUnits,i=t.camera;null!==i||s||console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const r=void 0!==t.params.Line2&&t.params.Line2.threshold||0;jo=t.ray;const n=this.matrixWorld,o=this.geometry,a=this.material;let l,c;if(Xo=a.linewidth+r,null===o.boundingSphere&&o.computeBoundingSphere(),Wo.copy(o.boundingSphere).applyMatrix4(n),s)l=.5*Xo;else{l=Zo(i,Math.max(i.near,Wo.distanceToPoint(jo.origin)),a.resolution)}if(Wo.radius+=l,!1!==jo.intersectsSphere(Wo)){if(null===o.boundingBox&&o.computeBoundingBox(),Yo.copy(o.boundingBox).applyMatrix4(n),s)c=.5*Xo;else{c=Zo(i,Math.max(i.near,Yo.distanceToPoint(jo.origin)),a.resolution)}Yo.expandByScalar(c),!1!==jo.intersectsBox(Yo)&&(s?function(t,e){const s=t.matrixWorld,i=t.geometry,r=i.attributes.instanceStart,n=i.attributes.instanceEnd;for(let o=0,a=Math.min(i.instanceCount,r.count);o<a;o++){Ho.start.fromBufferAttribute(r,o),Ho.end.fromBufferAttribute(n,o),Ho.applyMatrix4(s);const i=new bt,a=new bt;jo.distanceSqToSegment(Ho.start,Ho.end,a,i),a.distanceTo(i)<.5*Xo&&e.push({point:a,pointOnLine:i,distance:jo.origin.distanceTo(a),object:t,face:null,faceIndex:o,uv:null,uv1:null})}}(this,e):function(t,e,s){const i=e.projectionMatrix,r=t.material.resolution,n=t.matrixWorld,o=t.geometry,a=o.attributes.instanceStart,l=o.attributes.instanceEnd,c=Math.min(o.instanceCount,a.count),h=-e.near;jo.at(1,Bo),Bo.w=1,Bo.applyMatrix4(e.matrixWorldInverse),Bo.applyMatrix4(i),Bo.multiplyScalar(1/Bo.w),Bo.x*=r.x/2,Bo.y*=r.y/2,Bo.z=0,zo.copy(Bo),Go.multiplyMatrices(e.matrixWorldInverse,n);for(let e=0,o=c;e<o;e++){if(Uo.fromBufferAttribute(a,e),Vo.fromBufferAttribute(l,e),Uo.w=1,Vo.w=1,Uo.applyMatrix4(Go),Vo.applyMatrix4(Go),Uo.z>h&&Vo.z>h)continue;if(Uo.z>h){const t=Uo.z-Vo.z,e=(Uo.z-h)/t;Uo.lerp(Vo,e)}else if(Vo.z>h){const t=Vo.z-Uo.z,e=(Vo.z-h)/t;Vo.lerp(Uo,e)}Uo.applyMatrix4(i),Vo.applyMatrix4(i),Uo.multiplyScalar(1/Uo.w),Vo.multiplyScalar(1/Vo.w),Uo.x*=r.x/2,Uo.y*=r.y/2,Vo.x*=r.x/2,Vo.y*=r.y/2,Ho.start.copy(Uo),Ho.start.z=0,Ho.end.copy(Vo),Ho.end.z=0;const o=Ho.closestPointToPointParameter(zo,!0);Ho.at(o,ko);const c=pt.lerp(Uo.z,Vo.z,o),d=c>=-1&&c<=1,u=zo.distanceTo(ko)<.5*Xo;if(d&&u){Ho.start.fromBufferAttribute(a,e),Ho.end.fromBufferAttribute(l,e),Ho.start.applyMatrix4(n),Ho.end.applyMatrix4(n);const i=new bt,r=new bt;jo.distanceSqToSegment(Ho.start,Ho.end,r,i),s.push({point:r,pointOnLine:i,distance:jo.origin.distanceTo(r),object:t,face:null,faceIndex:e,uv:null,uv1:null})}}}(this,i,e))}}onBeforeRender(t){const e=this.material.uniforms;e&&e.resolution&&(t.getViewport(Po),this.material.uniforms.resolution.value.set(Po.z,Po.w))}}class Qo extends No{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(t){const e=t.length-3,s=new Float32Array(2*e);for(let i=0;i<e;i+=3)s[2*i]=t[i],s[2*i+1]=t[i+1],s[2*i+2]=t[i+2],s[2*i+3]=t[i+3],s[2*i+4]=t[i+4],s[2*i+5]=t[i+5];return super.setPositions(s),this}setColors(t){const e=t.length-3,s=new Float32Array(2*e);for(let i=0;i<e;i+=3)s[2*i]=t[i],s[2*i+1]=t[i+1],s[2*i+2]=t[i+2],s[2*i+3]=t[i+3],s[2*i+4]=t[i+4],s[2*i+5]=t[i+5];return super.setColors(s),this}setFromPoints(t){const e=t.length-1,s=new Float32Array(6*e);for(let i=0;i<e;i++)s[6*i]=t[i].x,s[6*i+1]=t[i].y,s[6*i+2]=t[i].z||0,s[6*i+3]=t[i+1].x,s[6*i+4]=t[i+1].y,s[6*i+5]=t[i+1].z||0;return super.setPositions(s),this}fromLine(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}}class Ko extends $o{constructor(t=new Qo,e=new vo({color:16777215*Math.random()})){super(t,e),this.isLine2=!0,this.type="Line2"}}class Jo{constructor(t){ot(this,"model"),ot(this,"_endpointsMaterials",{interior:new ft.PointsMaterial({color:15658734,size:8,sizeAttenuation:!1,depthTest:!1}),exterior:new ft.PointsMaterial({color:16777215,size:16,sizeAttenuation:!1,depthTest:!1})}),ot(this,"_absoluteAlignments",new ft.Group),ot(this,"_horizontalAlignments",new ft.Group),ot(this,"_verticalAlignments",new ft.Group),ot(this,"_alignmentMaterials",new Map([[Vn.NONE,new vo({color:16777215,linewidth:5,depthTest:!1})],[Vn.LINES,new vo({color:16711935,linewidth:5,depthTest:!1})],[Vn.CLOTHOID,new vo({color:16711680,linewidth:5,depthTest:!1})],[Vn.ELLIPSE_ARC,new vo({color:65535,linewidth:5,depthTest:!1})],[Vn.PARABOLA,new vo({color:255,linewidth:5,depthTest:!1})]])),this.model=t}async getAlignments(){return this._absoluteAlignments.children.length||await this.constructAlignments(),this._absoluteAlignments}async getHorizontalAlignments(){return this._horizontalAlignments.children.length||await this.constructAlignments(),this._horizontalAlignments}async getVerticalAlignments(){return this._verticalAlignments.children.length||await this.constructAlignments(),this._verticalAlignments}async getAlignmentStyles(){return{...this._alignmentMaterials,...this._endpointsMaterials}}async constructAlignments(){const t=await this.model.threads.invoke(this.model.modelId,"getAlignments");for(const e of t)this.constructLine(e.absolute,this._absoluteAlignments),this.constructLine(e.horizontal,this._horizontalAlignments),this.constructLine(e.vertical,this._verticalAlignments)}constructLine(t,e){if(!t.length)return;const s=[],i=[],r=new ft.Group;e.add(r);const n=t[0].points,o=t[t.length-1].points;i.push(o[0],o[1],o[2]),i.push(n[n.length-3],n[n.length-2],n[n.length-1]);for(const e of t){const t=e.points;s.push(t[0],t[1],t[2]),s.push(t[t.length-3],t[t.length-2],t[t.length-1]);const i=new Qo;i.setPositions(t);const n=this._alignmentMaterials.get(e.type),o=new Ko(i,n);r.add(o),o.renderOrder=1,o.userData.points=t}const{interior:a,exterior:l}=this._endpointsMaterials;this.constructPoints(s,a,r),this.constructPoints(i,l,r)}constructPoints(t,e,s){const i=new ft.Points,r=new ft.BufferGeometry,n=new Float32Array(t),o=new ft.BufferAttribute(n,3);r.setAttribute("position",o),i.geometry=r,i.material=e,s.add(i),i.renderOrder=2}dispose(){this._absoluteAlignments.removeFromParent();for(const t of this._absoluteAlignments.children){const e=t;e.geometry.dispose(),e.geometry=void 0,e.material=void 0}for(const t of Object.values(this._alignmentMaterials))t.dispose();this._alignmentMaterials={}}}class ta{async setup(t,e,s,i,r){const n=this.getCreateModelMessage(t,s,i,r),o=this.formatModelData(s),a=await t.threads.fetch(n,o);this.updateBox(e,a)}formatModelData(t){if(t instanceof ArrayBuffer)return[t]}updateBox(t,e){t.min.copy(e.boundingBox.min),t.max.copy(e.boundingBox.max)}getCreateModelMessage(t,e,s,i){return{class:vn.CREATE_MODEL,modelId:t.modelId,modelData:e,raw:s,config:i}}}class ea{async getBoxes(t,e){const s=this.getIndividualBoxesIds(e),i=this.getBoxRequest(t,s),r=await t.threads.fetch(i);return this.getAllBoxes(r,t)}async getMergedBox(t,e){const s=this.getBoxRequest(t,[e]),{boxes:i}=await t.threads.fetch(s),[r]=i;return this.getAbsoluteBox(r,t)}getAbsoluteBox(t,e){const s=new ft.Box3;return s.copy(t),s.applyMatrix4(e.object.matrixWorld),s}getIndividualBoxesIds(t){if(!t)return;const e=[];for(const s of t)e.push([s]);return e}getAllBoxes(t,e){const s=t.boxes,i=[];for(const t of s){const s=new ft.Box3;s.copy(t),s.applyMatrix4(e.object.matrixWorld),i.push(s)}return i}getBoxRequest(t,e){return{class:vn.FETCH_BOXES,modelId:t.modelId,localIds:e}}}class sa{constructor(){ot(this,"_coordinationMatrices",new Map)}async getCoordinationMatrix(t){let e=this._coordinationMatrices.get(t.modelId);if(e)return e;e=new ft.Matrix4,this._coordinationMatrices.set(t.modelId,e);const[s,i,r,n,o,a,l,c,h]=await this.getCoordinates(t),d=new ft.Vector3(n,o,a),u=new ft.Vector3(l,c,h),f=(new ft.Vector3).crossVectors(d,u);return e.set(n,l,f.x,s,o,c,f.y,i,a,h,f.z,r,0,0,0,1),e}async getCoordinates(t){const e=t.modelId;return t.threads.invoke(e,"getCoordinates")}async getPositions(t,e){const s=[e],i=await t.threads.invoke(t.modelId,"getPositions",s);return this.getAbsolutePositions(i,t)}getAbsolutePositions(t,e){const s=[];for(const i of t){const{x:t,y:r,z:n}=i,o=new ft.Vector3(t,r,n);o.applyMatrix4(e.object.matrixWorld),s.push(o)}return s}}class ia extends Map{constructor(t,e){super(e),ot(this,"tracker",null),ot(this,"localId"),ot(this,"guard",(()=>!0)),this.localId=t}get object(){const t={};for(const[e,s]of this.entries())t[e]=s.value;return t}set(t,e){if(!(this.guard??(()=>!0))(t,e))return this;const s=void 0!==e.type?e:{value:e.value,type:this.getType(t)};if(!this.tracker)return super.set(t,s);if(null===this.localId)return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),super.set(t,s);let i=this.tracker.get(this.localId);return i||(i={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(this.localId,i)),"added"===i.type?i.data[t]=s:"modified"===i.type&&(this.has(t)?i.modified[t]=s:i.deleted.includes(t)?(i.deleted=i.deleted.filter((e=>e!==t)),i.modified[t]=s):i.added[t]=s),super.set(t,s)}setValue(t,e){return this.set(t,{value:e,type:this.getType(t)})}setType(t,e){const s=this.getValue(t);return s?this.set(t,{value:s,type:e}):this}delete(t){if(!this.tracker)return super.delete(t);const e=this.get("localId");if(void 0===e||"number"!=typeof e)return console.warn("Item attributes are missing a valid localId. Changes can't be tracked."),"localId"!==t&&super.delete(t);if("localId"===t)return!1;if(!this.has(t))return!1;let s=this.tracker.get(e);return s||(s={type:"modified",added:{},deleted:[],modified:{}},this.tracker.set(e,s)),"added"===s.type?delete s.data[t]:"modified"===s.type&&(t in s.added?delete s.added[t]:t in s.modified?(delete s.modified[t],s.deleted.push(t)):s.deleted.push(t)),super.delete(t)}getValue(t){const e=this.get(t);return e?e.value:null}getType(t){var e;return null==(e=this.get(t))?void 0:e.type}}class ra extends Map{constructor(t,e){super(e),ot(this,"tracker",null),ot(this,"localId"),ot(this,"guard",(()=>!0)),ot(this,"onItemsRequested",null),this.localId=t}get itemChanges(){if(!this.tracker)return null;if(!this.localId)return console.warn("Item relations can't be tracked."),null;let t=this.tracker.get(this.localId);return t||(t={type:"modified",added:{},deleted:new Set,removed:{},modified:{}},this.tracker.set(this.localId,t)),t}set(t,e){const s=this.has(t);if(!(this.guard??(()=>!0))(t,e))return this;const i=this.itemChanges;return i?(s?i.modified[t]=e:i.added[t]=e,super.set(t,e)):super.set(t,e)}add(t,e){var s;const i=this.has(t);let r=this.get(t);if(!r)return r=new Set([e]),this.set(t,r),!0;if(!r||r.has(e))return!1;const n=this.itemChanges;if(!n)return r.add(e),!0;if(i)if(null==(s=n.removed[t])?void 0:s.has(e))n.removed[t].delete(e),0===n.removed[t].size&&delete n.removed[t];else{let s=n.modified[t];s||(s=new Set,n.modified[t]=s),s.add(e)}else{let s=n.added[t];s||(s=new Set,n.added[t]=s),s.add(e)}return r.add(e),!0}remove(t,e){var s;const i=this.get(t);if(!i)return!1;if(!i.has(e))return!1;const r=this.itemChanges;if(!r)return i.delete(e);if(null==(s=r.modified[t])?void 0:s.has(e))r.modified[t].delete(e),0===r.modified[t].size&&delete r.modified[t];else{let s=r.removed[t];s||(s=new Set,r.removed[t]=s),s.add(e)}return i.delete(e)}delete(t){if(!this.has(t))return!1;const e=this.itemChanges;return e?(e.deleted.add(t),super.delete(t)):super.delete(t)}async getItems(t){if(!this.onItemsRequested)return null;const e=this.get(t);if(!e)return null;return await this.onItemsRequested([...e])}}class na{constructor(t,e){ot(this,"model"),ot(this,"localId"),ot(this,"_indices",null),ot(this,"_transform",null),ot(this,"_normals",null),ot(this,"_positions",null),ot(this,"_vertices",null),ot(this,"_triangles",null),ot(this,"_position",null),ot(this,"_box",null),this.model=t,this.localId=e}async get(){const[t]=await this.model.threads.invoke(this.model.modelId,"getItemsGeometry",[[this.localId]]);for(const e of t){e.transform=(new ft.Matrix4).fromArray(e.transform.elements);const{indices:t,normals:s,positions:i,transform:r}=e;this._indices||(this._indices=[]),this._normals||(this._normals=[]),this._positions||(this._positions=[]),this._transform||(this._transform=[]),this._indices.push(t),this._normals.push(s),this._positions.push(i),this._transform.push(r)}return t}async getIndices(){return null!==this._indices||await this.get(),this._indices}async getTransform(){return null!==this._transform||await this.get(),this._transform}async getNormals(){return null!==this._normals||await this.get(),this._normals}async getPositions(){return null!==this._positions||await this.get(),this._positions}async getVertices(){if(this._vertices)return this._vertices;const t=await this.getPositions(),e=await this.getTransform();if(!t||!e)return this._vertices;this._vertices=[];for(let s=0;s<t.length;s++){const i=t[s],r=e[s];if(!i||!r)continue;const n=[];this._vertices.push(n);const o=Object.keys(i).length/3,a=[];for(let t=0;t<o;t++){const e=i[3*t],s=i[3*t+1],o=i[3*t+2];if("number"!=typeof e||"number"!=typeof s||"number"!=typeof o)continue;const l=`${e},${s},${o}`;if(a.includes(l))continue;a.push(l);const c=new ft.Vector3(e,s,o);c.applyMatrix4(r),n.push(c)}}return this._vertices}async getTriangles(){if(this._triangles)return this._triangles;const t=await this.getIndices(),e=await this.getPositions(),s=await this.getTransform();if(!t||!e||!s)return this._triangles;this._triangles=[];for(let i=0;i<t.length;i++){const r=t[i],n=e[i],o=s[i];if(!r||!n||!o)continue;const a=[];this._triangles.push(a);for(let t=0;t<r.length;t+=3){const e=r[t],s=r[t+1],i=r[t+2],l=new ft.Vector3(n[3*e],n[3*e+1],n[3*e+2]),c=new ft.Vector3(n[3*s],n[3*s+1],n[3*s+2]),h=new ft.Vector3(n[3*i],n[3*i+1],n[3*i+2]);l.applyMatrix4(o),c.applyMatrix4(o),h.applyMatrix4(o),a.push(new ft.Triangle(l,c,h))}}return this._triangles}async getPosition(){if(!this._position){if(null===this.localId)return null;this._position=await this.model.getPositions([this.localId])}return this._position}async getBox(){if(!this._box){if(null===this.localId)return null;this._box=await this.model.getBoxes([this.localId])}return this._box}async setVisibility(t){await this.model.setVisible([this.localId],t)}async getVisibility(){const[t]=await this.model.getVisible([this.localId]);return t}}class oa{constructor(t,e){ot(this,"model"),ot(this,"_localId",null),ot(this,"_attributes",null),ot(this,"_relations",null),ot(this,"_guid",null),ot(this,"_category",null),ot(this,"_geometry",null),this.model=t,"number"==typeof e&&(this._localId=e),"string"==typeof e&&(this._guid=e)}async getLocalId(){if(!this._localId){if(!this._guid)throw new Error("Fragments: Item localId couldn't be get.");[this._localId]=await this.model.threads.invoke(this.model.modelId,"getLocalIdsByGuids",[[this._guid]])}return this._localId}async getAttributes(){if(this._attributes)return this._attributes;const t=await this.getLocalId();if(null===t)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemAttributes",[t]);if(this._attributes=new ia(t),!e){const e=this.model.attrsChanges.get(t);if(!e||"added"!==e.type)return null;this._attributes.localId=t;for(const[t,s]of Object.entries(e.data))this._attributes.set(t,s);return this._attributes}const s=this.model.attrsChanges.get(t);if(s&&"modified"===s.type)for(const[t,e]of Object.entries(s.added))this._attributes.set(t,e);for(const t in e){const{value:i,type:r}=e[t];"modified"===(null==s?void 0:s.type)&&s.deleted.includes(t)||("modified"===(null==s?void 0:s.type)&&t in s.modified?this._attributes.set(t,s.modified[t]):this._attributes.set(t,{value:i,type:r}))}return this._attributes.tracker=this.model.attrsChanges,this._attributes}async getRelations(){if(this._relations)return this._relations;const t=await this.getLocalId();if(null===t)return null;const e=await this.model.threads.invoke(this.model.modelId,"getItemRelations",[t]);if(!e)return null;this._relations=new ra(t),this._relations.onItemsRequested=async t=>{const e=[];for(const s of t){const t=this.model.getItem(s);t&&e.push(t)}return e};const s=this.model.relsChanges.get(t);if(s&&"modified"===s.type)for(const[t,e]of Object.entries(s.added))this._relations.set(t,e);for(const[t,i]of Object.entries(e))if("modified"!==(null==s?void 0:s.type)||!s.deleted.has(t))if("modified"===(null==s?void 0:s.type)&&t in s.modified){const e=new Set([...s.modified[t],...i]);this._relations.set(t,new Set(e))}else this._relations.set(t,new Set(i));return this._relations.tracker=this.model.relsChanges,this._relations}async getGuid(){if(!this._guid){const t=await this.getLocalId();if(null===t)return null;[this._guid]=await this.model.threads.invoke(this.model.modelId,"getGuidsByLocalIds",[[t]])}return this._guid}async getCategory(){if(!this._category){const t=await this.getLocalId();if(null===t)return null;this._category=await this.model.threads.invoke(this.model.modelId,"getItemCategory",[t])}return this._category}async getGeometry(){if(this._geometry)return this._geometry;const t=await this.getLocalId();if(null===t)return null;return new na(this.model,t)}async getData(t=[]){var e;const s=await this.getLocalId();if(null==s)return{};t.push(s);const i=null==(e=await this.getAttributes())?void 0:e.object,r=await this.getRelations(),n={};if(r)for(const e of r.keys()){const s=[];n[e]=s;const i=await r.getItems(e);if(i)for(const e of i){const i=await e.getLocalId();if(!i)continue;if(void 0!==t.find((t=>t===i)))continue;t.push(i);const r=await e.getData(t);r&&s.push(r)}}return{...i,...n}}}class aa{getItem(t,e){return new oa(t,e)}async getItemsData(t,e,s){return t.threads.invoke(t.modelId,"getItemsData",[e,s])}async getItemsChildren(t,e){return t.threads.invoke(t.modelId,"getItemsChildren",[e])}}class la{constructor(){ot(this,"getClippingPlanesEvent",(()=>[])),ot(this,"currentCamera",null),ot(this,"_tempMatrix",new ft.Matrix4),ot(this,"_tempVec",new ft.Vector3),ot(this,"_tempFrustum",new ft.Frustum),ot(this,"_updateCameraPositionEvent",(()=>{})),ot(this,"_updateCameraFrustumEvent",(()=>{})),ot(this,"_updateFOVEvent",(()=>{})),ot(this,"_updateOrthoSizeEvent",(()=>{}))}async refreshView(t,e){const s=this.setup(e,t),i=Gn.transform(this._tempFrustum,this._tempMatrix),r=this.newViewRequest(i,s,t);await t.threads.fetch(r)}useCamera(t){const e=new ft.Matrix4;this.setCameraPosition(t),this.setCameraFrustum(t,e),this.setFov(t),this.setOrtho(),this.currentCamera=t}async setLodMode(t,e){return t.threads.invoke(t.modelId,"setLodMode",[e])}getOrthoSize(){let t=this._updateOrthoSizeEvent();if(t){t*=this._tempMatrix.getMaxScaleOnAxis()}return t}setup(t,e){t.requests.clean(e.modelId),this._tempMatrix.copy(e.object.matrixWorld).invert(),this._updateCameraPositionEvent(this._tempVec),this._updateCameraFrustumEvent(this._tempFrustum);return this._updateFOVEvent()}newViewRequest(t,e,s){const i=this.newView(t,e,s),r={};return r.class=vn.REFRESH_VIEW,r.modelId=s.modelId,r.cameraFrustum=t,r.view=i,r}newView(t,e,s){const i={};return i.cameraFrustum=t,i.cameraPosition=this._tempVec.applyMatrix4(this._tempMatrix),i.fov=e,i.orthogonalDimension=this.getOrthoSize(),i.viewSize=Math.max(window.innerWidth,window.innerHeight),i.graphicThreshold=Ro.estimateCapacity(),i.graphicQuality=-1.5*s.graphicsQuality+2,i.clippingPlanes=this.getPlanes(),i.modelPlacement=s.object.matrixWorld,i}setOrtho(){this._updateOrthoSizeEvent=()=>{}}setFov(t){this._updateFOVEvent=()=>{if(t instanceof ft.PerspectiveCamera)return t.fov}}getPlanes(){const t=[],e=this.getClippingPlanesEvent();for(const s of e){const e=s.clone();e.applyMatrix4(this._tempMatrix),t.push(e)}return t}setCameraPosition(t){this._updateCameraPositionEvent=e=>{e.copy(t.position)}}setCameraFrustum(t,e){this._updateCameraFrustumEvent=s=>{t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0);const{projectionMatrix:i,matrixWorldInverse:r}=t;e.multiplyMatrices(i,r),s.setFromProjectionMatrix(e)}}}class ca{constructor(){ot(this,"_caster",new ft.Raycaster),ot(this,"_ray",new ft.Ray),ot(this,"_frustum",new ft.Frustum),ot(this,"_inverseTransform",new ft.Matrix4),ot(this,"_t",new ft.Plane),ot(this,"_r",new ft.Plane),ot(this,"_b",new ft.Plane),ot(this,"_l",new ft.Plane),ot(this,"_n",new ft.Plane),ot(this,"_f",new ft.Plane),ot(this,"_tl",new ft.Vector3),ot(this,"_tr",new ft.Vector3),ot(this,"_bl",new ft.Vector3),ot(this,"_br",new ft.Vector3),ot(this,"_tln",new ft.Vector3),ot(this,"_brn",new ft.Vector3),ot(this,"_tlp",new ft.Vector2),ot(this,"_brp",new ft.Vector2),ot(this,"distance",10)}async raycast(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),r=this.getRequest(t,s,i);if(!r)return null;const n=await t.threads.fetch(r);if(n.results&&n.results.length){const[e]=n.results;return this.getResult({hit:e,frustum:s,ray:i,model:t})}return null}async raycastAll(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),r=this.getRequest(t,s,i);if(!r)return null;r.returnAll=!0;const n=[],o=await t.threads.fetch(r);if(o.results&&o.results.length){for(const e of o.results)n.push(this.getResult({hit:e,frustum:s,ray:i,model:t}));return n}return null}async rectangleRaycast(t,e,s){const i=this.getFrustum(s),r=this.getRequest(t,i);if(!r)return null;r.fullyIncluded=s.fullyIncluded;const n=await t.threads.fetch(r);return n.localIds&&n.localIds.length?this.newRectangleCastResponse(n,e):null}async raycastWithSnapping(t,e){const{frustum:s,ray:i}=this.getRayAndFrustum(e),r=this.getRequest(t,s,i);if(!r)return null;r.snappingClass=e.snappingClasses;const n=await t.threads.fetch(r);return n.results?this.newRaycastSnapResult(n,s,i,t):null}screenRectToFrustum(t,e,s,i){return this.screenToCast(t,s,this._tlp),this.screenToCast(e,s,this._brp),this.setVectors(i),this.setPlanes(i),this.newFrustum()}screenToCasterPoint(t,e,s){const i=this.screenToCast(t,e);return this._caster.setFromCamera(i,s),this._caster.ray.clone()}setPlanes(t){this.setBasePoints(),t.getWorldDirection(this._n.normal),this.setEnds(t)}setVectors(t){this.setVector(this._tl,this._tlp,this._tlp,1,t),this.setVector(this._tr,this._brp,this._tlp,1,t),this.setVector(this._bl,this._tlp,this._brp,1,t),this.setVector(this._br,this._brp,this._brp,1,t),this.setVector(this._tln,this._tlp,this._tlp,0,t),this.setVector(this._brn,this._brp,this._brp,0,t)}newFrustum(){return new ft.Frustum(this._t,this._b,this._l,this._r,this._f,this._n)}setEnds(t){t instanceof ft.OrthographicCamera?(this._n.constant=t.near,this._f.constant=t.far):(this._n.constant=t.position.length(),this._f.constant=1/0),this._f.normal=this._n.normal}screenToCast(t,e,s=new ft.Vector2){const i=e.getBoundingClientRect(),r=i.width/e.clientWidth,n=i.height/e.clientHeight,o=(t.x-i.left)/r,a=(t.y-i.top)/n;return s.x=o/e.clientWidth*2-1,s.y=-a/e.clientHeight*2+1,s}setVector(t,e,s,i,r){t.set(e.x,s.y,i),t.unproject(r)}setPlane(t,e,s,i){t.setFromCoplanarPoints(e,s,i)}setBasePoints(){this.setPlane(this._t,this._tln,this._tl,this._tr),this.setPlane(this._r,this._brn,this._tr,this._br),this.setPlane(this._b,this._brn,this._br,this._bl),this.setPlane(this._l,this._tln,this._bl,this._tl)}setupRay(t,e){t&&(this._ray.copy(t),this._ray.applyMatrix4(this._inverseTransform),e.ray=this._ray)}setupMatrix(t){this._inverseTransform.copy(t.matrixWorld),this._inverseTransform.invert()}getRequest(t,e,s){const{object:i,box:r,modelId:n}=t;return e.intersectsBox(r)?this.newCastRequest(i,n,s,e):null}getRayAndFrustum(t){this.updateCamera(t.camera);const{bottomLeft:e,topRight:s}=this.getCorners(t.mouse);return{ray:this.screenToCasterPoint(t.mouse,t.dom,t.camera),frustum:this.screenRectToFrustum(e,s,t.dom,t.camera)}}getFrustum(t){return this.updateCamera(t.camera),this.screenRectToFrustum(t.topLeft,t.bottomRight,t.dom,t.camera)}getCorners(t){return{bottomLeft:t.clone().subScalar(this.distance),topRight:t.clone().addScalar(this.distance)}}getResult(t){const{hit:e,frustum:s,ray:i,model:r}=t,n={};return this.setPoint(r,e,n),this.setNormal(r,e,n),this.setDistance(r,e,n),this.setRayDistance(r,e,n),this.setBasicHitData(r,e,n,i,s),this.setSnapEdge(r,e,n,"snappedEdgeP1"),this.setSnapEdge(r,e,n,"snappedEdgeP2"),n.facePoints=e.facePoints,n.faceIndices=e.faceIndices,n}updateCamera(t){t.updateProjectionMatrix(),t.updateWorldMatrix(!0,!0)}newCastRequest(t,e,s,i){this.setupMatrix(t);const r={};return r.class=vn.RAYCAST,r.modelId=e,this.setupRay(s,r),Gn.transform(i,this._inverseTransform,this._frustum),r.frustum=this._frustum,r}setSnapEdge(t,e,s,i){if(e[i]){const r=new ft.Vector3;r.copy(e[i]),r.applyMatrix4(t.object.matrixWorld),s[i]=r}else s[i]=void 0}setNormal(t,e,s){if(e.normal){const i=new ft.Vector3;return i.copy(e.normal),i.transformDirection(t.object.matrixWorld),i.normalize(),void(s.normal=i)}s.normal=void 0}setDistance(t,e,s){const i=Math.sqrt(e.cameraSquaredDistance),r=t.object.matrixWorld.getMaxScaleOnAxis();s.distance=i*r}setPoint(t,e,s){const i=new ft.Vector3;i.copy(e.point),i.applyMatrix4(t.object.matrixWorld),s.point=i}newRaycastSnapResult(t,e,s,i){const r=[];for(const n of t.results){const t=this.getResult({hit:n,frustum:e,ray:s,model:i});r.push(t)}return r}newRectangleCastResponse(t,e){return{localIds:t.localIds,fragments:e.list.get(t.modelId)}}setRayDistance(t,e,s){if(void 0===e.raySquaredDistance)s.rayDistance=void 0;else{const i=t.object.matrixWorld.getMaxScaleOnAxis(),r=Math.sqrt(e.raySquaredDistance);s.rayDistance=r*i}}setBasicHitData(t,e,s,i,r){s.itemId=e.itemId,s.localId=e.localId,s.object=t.object,s.fragments=t,s.ray=i,s.frustum=r,s.representationClass=e.representationClass,s.snappingClass=e.snappingClass}}class ha{async resetVisible(t){await t.threads.invoke(t.modelId,"resetVisible")}async getItemsByVisibility(t,e){return t.threads.invoke(t.modelId,"getItemsByVisibility",[e])}async getVisible(t,e){return t.threads.invoke(t.modelId,"getVisible",[e])}}class da{}ot(da,"vertex","\n            #include <common>\n            #include <clipping_planes_pars_vertex>\n\n            attribute float itemFilter;\n            uniform vec2 lodSize;\n            attribute vec3 itemFirst;\n            attribute vec3 itemLast;\n\n            float lodWidth = 2.0;\n            \n            void cutLodLine(const in vec4 first, inout vec4 second ) {\n                float projValue1 = projectionMatrix[2][2];\n                float projValue2 = projectionMatrix[3][2];\n                float approxResult = -(projValue2 / projValue1) / 2.0;\n                float diff1 = approxResult - first.z;\n                float diff2 = second.z - first.z;\n                float cutFilter = diff1 / diff2;\n                second.xyz = mix(first.xyz, second.xyz, cutFilter);\n            }\n                \n            void main() {\n                if (itemFilter == 0.0) {\n                    gl_Position = vec4(0,0,0,0);\n                    return;\n                }\n\n                vec4 rawFirst = vec4(itemFirst, 1.0);\n                vec4 rawLast = vec4(itemLast, 1.0);\n                vec4 first = modelViewMatrix * rawFirst;\n                vec4 last = modelViewMatrix * rawLast;\n                \n                bool lodPerspective = projectionMatrix[2][3] == -1.0;\n                if (lodPerspective) {\n                    bool firstCut = first.z < 0.0 && last.z >= 0.0;\n                    bool lastCut = last.z < 0.0 && first.z >= 0.0;\n                    if (firstCut) {\n                        cutLodLine( first, last );\n                    } else if (lastCut) {\n                        cutLodLine( last, first );\n                    }\n                }\n\n                vec4 firstCut = projectionMatrix * first;\n                vec4 lastCut = projectionMatrix * last;\n                vec3 firstNdc = firstCut.xyz / firstCut.w;\n                vec3 lastNdc = lastCut.xyz / lastCut.w;\n\n                vec2 lodOrientation = lastNdc.xy - firstNdc.xy;\n\n                float lodRatio = lodSize.x / lodSize.y;\n                lodOrientation.x *= lodRatio;\n                lodOrientation = normalize(lodOrientation);\n                \n                vec2 lodDistance = vec2(lodOrientation.y, - lodOrientation.x);\n                lodOrientation.x /= lodRatio;\n                lodDistance.x /= lodRatio;\n\n                if (position.x < 0.0) { \n                    lodDistance *= - 1.0;\n                }\n\n                if (position.y < 0.0) {\n                    lodDistance += -lodOrientation;\n                } else if (position.y > 1.0) {\n                    lodDistance += lodOrientation;\n                }\n\n                lodDistance *= lodWidth;\n                lodDistance /= lodSize.y;\n\n                bool isFirst = position.y < 0.5;\n                vec4 lodPosition = isFirst ? firstCut : lastCut;\n                lodDistance *= lodPosition.w;\n                lodPosition.xy += lodDistance;\n                gl_Position = lodPosition;\n\n                vec4 mvPosition = isFirst ? first : last;\n                #include <clipping_planes_vertex>\n            }\n    "),ot(da,"fragment","\n            #include <common>\n            #include <clipping_planes_pars_fragment>\n\n            uniform vec3 lodColor;\n            uniform float lodOpacity;\n\n            void main() {\n                #include <clipping_planes_fragment>\n                gl_FragColor = vec4(lodColor, lodOpacity);\n                #include <colorspace_fragment>\n            }\n    ");const ua=class t{static setupLodMeshResize(t){t.onBeforeRender=e=>{e.getSize(t.material[0].lodSize)}}static setupLodAttributes(e){e.setIndex(t.indices),e.setAttribute("position",t.vertices)}static setLodBuffer(t,e,s){let i=t.getItemFirst(),r=t.getItemLast(),n=this.setItemFirst(t,i,e,r);const o=this.resetAttributes(i,n,e,r);({itemFirst:i,dataBuffer:n,itemLast:r}=o),this.setupFinish(s,n),t.setAttribute("itemFirst",i),t.setAttribute("itemLast",r)}static setLodVisibility(t,e){const s=this.setupItemFilter(t);this.applyVisibilityState(t,e,s),s.needsUpdate=!0}static getInterAttribute(t,e){return t.getAttribute(e)}static computeLodSphere(e){if(!e.boundingSphere)return;const s=e.getItemFirst();if(s){const i=t.getLodMidPoint(e,s),r=t.getLodRadius(i,s);e.boundingSphere.radius=r}}static newLodMaterialParams(t){const e={lodColor:{value:new ft.Color(t.color)},lodSize:{value:new ft.Vector2(1,1)},lodOpacity:{value:t.opacity??1}};return{uniforms:ft.UniformsUtils.merge([ft.UniformsLib.common,e]),transparent:t.transparent??!1,vertexShader:da.vertex,fragmentShader:da.fragment}}static setLodFilter(t,e){const s=t.getItemFilter(),i=s.array;for(let t=0;t<e.position.length;++t){const s=e.position[t]/2,r=e.size[t]/2;4294967295===r?i.fill(1,s):i.fill(1,s,s+r)}s.needsUpdate=!0}static getInstancedAttribute(t,e){return t.getAttribute(e)}static computeLodBox(t){if(!t.boundingBox)return;const e=t.getItemFirst();if(e){const s=e.data.array;t.boundingBox.setFromArray(s)}else t.boundingBox.makeEmpty()}static setDataBuffer(t,e,s){return(t=e.data).array=s,t.needsUpdate=!0,t}static disposeAllData(e){delete e.attributes.itemFilter,delete e.attributes.position,e.index=null,e.dispose(),t.setupLodAttributes(e)}static setItemFirst(t,e,s,i){let r=null;if(e){s.length===e.data.array.length?r=this.setDataBuffer(r,e,s):(e=void 0,this.disposeAllData(t))}return r}static setupFinish(t,e){t&&(e.onUploadCallback=t)}static resetAttributes(t,e,s,i){return t||(e=new ft.InstancedInterleavedBuffer(s,6,1),t=new ft.InterleavedBufferAttribute(e,3,0),i=new ft.InterleavedBufferAttribute(e,3,3)),{itemFirst:t,dataBuffer:e,itemLast:i}}static setupItemFilter(t){const e=t.getItemFirst().count;let s=t.getItemFilter();return s?s.array.fill(0):(s=new ft.InstancedBufferAttribute(new Uint8Array(e),1),t.setAttribute("itemFilter",s)),s}static applyVisibilityState(t,e,s){!0!==e?e&&this.setLodFilter(t,e):s.array.fill(1)}static getLodMidPoint(t,e){const s=t.boundingSphere.center;return this.tempBox.setFromArray(e.data.array),this.tempBox.getCenter(s),s}static getLodRadius(e,s){let i=0;const r=s.data.array.length;for(let n=0;n<r;n+=3){const r=s.data.array;t.tempVec.fromArray(r,n);const o=e.distanceToSquared(t.tempVec);i=Math.max(i,o)}return Math.sqrt(i)}};ot(ua,"tempVec",new ft.Vector3),ot(ua,"tempBox",new ft.Box3),ot(ua,"vertices",new ft.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),ot(ua,"indices",new ft.Uint8BufferAttribute([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5],1));let fa=ua;class pa extends ft.Mesh{constructor(t,e){super(t,e),ot(this,"geometry"),ot(this,"material"),this.geometry=t,this.material=e,fa.setupLodMeshResize(this)}}class Ia extends ft.InstancedBufferGeometry{constructor(){super(),ot(this,"isLODGeometry",!0),fa.setupLodAttributes(this)}isFiltered(){const t=this.getItemFilter();return Boolean(t)}computeBoundingBox(){this.boundingBox||(this.boundingBox=new ft.Box3),fa.computeLodBox(this)}applyMatrix4(t){return this.applyTransformToBuffers(t),this.updateBounds(),this}computeBoundingSphere(){this.boundingSphere||(this.boundingSphere=new ft.Sphere),fa.computeLodSphere(this)}getItemFilter(){return fa.getInstancedAttribute(this,"itemFilter")}getItemLast(){return fa.getInterAttribute(this,"itemLast")}getItemFirst(){return fa.getInterAttribute(this,"itemFirst")}applyTransformToBuffers(t){this.getItemFirst().applyMatrix4(t);this.getItemLast().applyMatrix4(t)}updateBounds(){this.boundingBox&&this.computeBoundingBox(),this.boundingSphere&&this.computeBoundingSphere()}}class ma extends ft.ShaderMaterial{constructor(t){super(fa.newLodMaterialParams(t)),ot(this,"isLodMaterial",!0),ot(this,"isLineMaterial",!0),this.clipping=!0,this.lights=!1,this.needsUpdate=!0}get lodSize(){return this.uniforms.lodSize.value}set lodColor(t){this.uniforms.lodColor.value=t}set lodSize(t){this.uniforms.lodSize.value.copy(t)}get lodColor(){return this.uniforms.lodColor.value}}class Ea{constructor(){ot(this,"list",new Yt),ot(this,"_modelMaterialMapping",new Map),ot(this,"_definitions",new Map),ot(this,"_idGenerator",new go),ot(this,"white",4294967295)}static resetColors(t){for(const e of t){if(!e||!e.color)continue;const{color:t}=e;if(t.isColor)continue;const{r:s,g:i,b:r}=t;e.color=(new ft.Color).setRGB(s,i,r,ft.SRGBColorSpace)}}dispose(t){this._definitions.delete(t);const e=this._modelMaterialMapping.get(t);if(e){for(const t of e){const e=this.list.get(t);e&&(e.dispose(),this.list.delete(t))}this._modelMaterialMapping.delete(t)}}get(t,e){const{modelId:s,objectClass:i,currentLod:r,templateId:n}=e;if(!s||void 0===i||void 0===r)throw new Error("Fragments: material definition information is missing to create the material.");this._idGenerator.fromMaterialData({modelId:s,objectClass:i,currentLod:r,templateId:n,...t});const{value:o}=this._idGenerator;return this.getUniqueMaterial(o,t,e)}addDefinitions(t,e){const s=this._definitions.get(t);s?s.push(...e):this._definitions.set(t,e)}createHighlights(t,e){const{tileData:{highlightData:s,highlightIds:i},modelId:r,material:n}=e,{geometry:o}=t,a=t.material.slice(0,2),l=new Map,c=this._definitions.get(r);if(!c)return a;for(let t=0;t<s.position.length;t++){const r=i[t];this.processHighlight(l,r,c,n,e,a);const h=s.position[t],d=s.size[t],u=d===this.white?1/0:d;o.addGroup(h,u,l.get(i[t]))}return a}getFromRequest(t){const{material:e,modelId:s}=t,i=this._definitions.get(s),r=null==i?void 0:i[e];if(!r)throw new Error(`Fragments: Missing mesh material for index ${e}`);return this.get(r,t)}newLODMaterial(t,e){const{data:s}=t,i=new ft.Color(s.color);e.currentLod===Nn.WIRES&&i.multiplyScalar(.85);const r={color:i,...this.getParameters(s)},n=new ma(r);return n.userData={customId:s.customId},n}getParameters(t){const{opacity:e,transparent:s}=t;return{opacity:e,transparent:s||e<1,clipIntersection:!1}}new(t,e){const{objectClass:s,templateId:i}=e;let r;if(s===On.SHELL)r=new ft.MeshLambertMaterial({color:t.color,transparent:t.opacity<1,opacity:t.opacity,userData:{customId:t.customId,localId:t.localId},depthTest:t.depthTest??!0,depthWrite:t.depthWrite??!0,side:1===t.renderedFaces?ft.DoubleSide:ft.FrontSide});else{if(s!==On.LINE)throw new Error("Fragments: Unsupported object class");r=this.newLODMaterial({data:t,instancing:void 0!==i},e)}return r}addMaterialToModel(t,e){let s=this._modelMaterialMapping.get(t);s||(s=new Set,this._modelMaterialMapping.set(t,s)),s.add(e)}processHighlight(t,e,s,i,r,n){if(!t.has(e)){const o=s[i],a=s[e],{preserveOriginalMaterial:l,...c}=a,h={...o};l?(void 0!==c.color&&(h.color=c.color),void 0!==c.opacity&&(h.opacity=c.opacity),void 0!==c.transparent&&(h.transparent=c.transparent),void 0!==c.renderedFaces&&(h.renderedFaces=c.renderedFaces),void 0!==c.depthTest&&(h.depthTest=c.depthTest)):Object.assign(h,c);const d=this.get(h,r);n.push(d),t.set(e,n.length-1)}}getUniqueMaterial(t,e,s){const i=s.modelId,r=this.list.get(t);if(r)return r;const n=this.new(e,s);return this.list.set(t,n),this.addMaterialToModel(i,t),this.list.get(t)}}class _a{async getHighlight(t,e){const s=await t.threads.invoke(t.modelId,"getHighlight",[e]);return Ea.resetColors(s),s}async highlight(t,e,s){await t.threads.invoke(t.modelId,"highlight",[e,s])}async setColor(t,e,s){await t.threads.invoke(t.modelId,"setColor",[e,s])}async resetColor(t,e){await t.threads.invoke(t.modelId,"resetColor",[e])}async setOpacity(t,e,s){await t.threads.invoke(t.modelId,"setOpacity",[e,s])}async resetOpacity(t,e){await t.threads.invoke(t.modelId,"resetOpacity",[e])}async getHighlightItemIds(t){return t.threads.invoke(t.modelId,"getHighlightItemIds")}async resetHighlight(t,e){await t.threads.invoke(t.modelId,"resetHighlight",[e])}}class ga{async getSection(t,e,s){const i=[e,s];return await t.threads.invoke(t.modelId,"getSection",i)}}class Ca{async dispose(t,e,s,i){e.list.delete(t.modelId),await this.requestModelDelete(t),t.threads.delete(t.modelId),t.object.removeFromParent(),this.deleteAllTiles(t),e.materials.dispose(t.modelId),s.dispose(),i.dispose()}async getBuffer(t,e){return t.threads.invoke(t.modelId,"getBuffer",[e])}async getCategories(t){return t.threads.invoke(t.modelId,"getCategories")}async getMaxLocalId(t){return t.threads.invoke(t.modelId,"getMaxLocalId")}async getLocalIdsByGuids(t,e){return t.threads.invoke(t.modelId,"getLocalIdsByGuids",[e])}async getSpatialStructure(t){return t.threads.invoke(t.modelId,"getSpatialStructure")}async getItemsWithGeometry(t){return(await t.threads.invoke(t.modelId,"getItemsWithGeometry",[])).map((e=>t.getItem(e)))}async getItemsWithGeometryCategories(t){return t.threads.invoke(t.modelId,"getItemsWithGeometryCategories",[])}async getItemsIdsWithGeometry(t){return t.threads.invoke(t.modelId,"getItemsWithGeometry",[])}async getItemsOfCategories(t,e){const s=[e];return await t.threads.invoke(t.modelId,"getItemsOfCategories",s)}async getItemsByQuery(t,e,s){const i=[e,s];return await t.threads.invoke(t.modelId,"getItemsByQuery",i)}async getMetadata(t){return t.threads.invoke(t.modelId,"getMetadata",[])}async getGuidsByLocalIds(t,e){return t.threads.invoke(t.modelId,"getGuidsByLocalIds",[e])}async requestModelDelete(t){await t.threads.fetch({class:vn.DELETE_MODEL,modelId:t.modelId})}deleteAllTiles(t){for(const[e]of t.tiles)t.tiles.delete(e)}}class Ta{async getSequenced(t,e,s,i){const r=[e,s,i];return await t.threads.invoke(t.modelId,"getSequenced",r)}}class ba{constructor(t,e){ot(this,"_deltaModels",{}),ot(this,"_fragments"),ot(this,"_connection"),this._fragments=t,this._connection=e}async edit(t,e,s={removeRedo:!0}){const i=this._fragments.models.list.get(t);if(!i)throw new Error(`Model ${t} not found`);const r=this._deltaModels[t]||[];this._deltaModels[t]=null,s.removeRedo&&i._setRequests({undoneRequests:[]});const{deltaModelBuffer:n,ids:o}=await i._edit(e);for(let t=0;t<e.length;t++)void 0===e[t].localId&&(e[t].localId=o[t]);const a=await this.load(n,i);this._deltaModels[t]=[a],i.deltaModelId=a.modelId;const l=[];for(const t of r)l.push(t.dispose());return await Promise.all(l),o}async save(t){const e=this._fragments.models.list.get(t);if(!e)return console.log(`Model ${t} not found`),null;const s=e.object.parent,i=await e._getRequests(),r=e.camera||void 0,n=await e._save();await e.dispose();const o=await this._fragments.load(n,{modelId:t,raw:!0,camera:r});return await o._setRequests({undoneRequests:i.undoneRequests}),s&&s.add(o.object),i}async reset(t){const e=this._fragments.models.list.get(t);e?(await e._reset(),await this.disposeDeltaModels(t)):console.log(`Model ${t} not found`)}async getRequests(t){const e=this._fragments.models.list.get(t);if(!e)throw new Error(`Model ${t} not found`);return e._getRequests()}async selectRequest(t,e){const s=this._fragments.models.list.get(t);if(!s)throw new Error(`Model ${t} not found`);return s._selectRequest(e)}async _update(t){const e=this._deltaModels[t];if(e){const t=[];for(const s of e)t.push(s._refreshView());await Promise.all(t)}}async disposeDeltaModels(t){const e=this._deltaModels[t];if(e){for(const t of e)await t.dispose();this._deltaModels[t]=[]}}async load(t,e){const s=pn.DELTA_MODEL_ID,i=`${e.modelId}${s}${performance.now()}`,r=new La(i,this._fragments.models,this._connection,this._fragments.editor);r._setDeltaModel(e.modelId),r.frozen=!0,r.graphicsQuality=this._fragments.settings.graphicsQuality;try{this._fragments.models.list.set(r.modelId,r),await r._setup(t,!0),e.object.add(r.object)}catch(t){throw this._fragments.models.list.delete(r.modelId),t}const n=e.camera;return n&&r.useCamera(n),r.frozen=!1,r}}class Ra{constructor(t){ot(this,"_nextTempIds",{}),ot(this,"_requests",{}),ot(this,"_fragments"),this._fragments=t}getRequests(t){const e=this.getModelRequests(t);this._requests[t]=this.newRequests();const{create:s,update:i,remove:r,relations:{create:n,update:o,remove:a}}=e,l=Object.values(s),c=Object.values(i),h=[...Object.values(r),...l,...c,...Object.values(n),...Object.values(o),...Object.values(a)];return h.length>0?h:null}createMaterial(t,e){const s=this.getNextTempId(t),i={r:255*e.color.r,g:255*e.color.g,b:255*e.color.b,a:255*e.opacity,renderedFaces:e.side===ft.DoubleSide?1:0,stroke:0};return this.addRequest(t,s,"create",{type:kr.CREATE_MATERIAL,tempId:s,data:i}),s}createLocalTransform(t,e){const s=this.getNextTempId(t),i=An.transformFromMatrix(e);return this.addRequest(t,s,"create",{type:kr.CREATE_LOCAL_TRANSFORM,tempId:s,data:i}),s}createShell(t,e){const s=this.getNextTempId(t),i=An.representationFromGeometry(e);return this.addRequest(t,s,"create",{type:kr.CREATE_REPRESENTATION,tempId:s,data:i}),s}createCircleExtrusion(t,e){const s=An.bboxFromCircleExtrusion(e),i=this.getNextTempId(t);return this.addRequest(t,i,"create",{type:kr.CREATE_REPRESENTATION,tempId:i,data:{representationClass:Gr.CIRCLE_EXTRUSION,bbox:s,geometry:e}}),i}createGlobalTransform(t,e,s){const i=this.getNextTempId(t),r=An.transformFromMatrix(e);return this.addRequest(t,i,"create",{type:kr.CREATE_GLOBAL_TRANSFORM,tempId:i,data:{itemId:s,...r}}),i}createSample(t,e){const{localTransform:s,representation:i,material:r,globalTransform:n}=e,o=this.getNextTempId(t);return this.addRequest(t,o,"create",{type:kr.CREATE_SAMPLE,tempId:o,data:{localTransform:s,representation:i,material:r,item:n}}),o}createItem(t,e){const s=this.getNextTempId(t);return this.addRequest(t,s,"create",{type:kr.CREATE_ITEM,tempId:s,data:e}),s}setItem(t,e){const s=e._localId;if(!s)throw new Error("No local id provided for the item to set");const i=s.value,r=pn.itemDataToRawItemData(e);this.addRequest(t,s.value,"update",{type:kr.UPDATE_ITEM,localId:i,data:r})}async relate(t,e,s,i){const r=this._fragments.models.list.get(t);if(!r)throw new Error(`Model ${t} not found`);const n=(await r.getRelations([e])).get(e);if(n){if(n.data[s]){const t=new Set(n.data[s]);for(const e of i)t.add(e);n.data[s]=Array.from(t)}else n.data[s]=i;this.addRelationRequest(t,e,"update",{type:kr.UPDATE_RELATION,localId:e,data:n})}else this.addRelationRequest(t,e,"create",{type:kr.CREATE_RELATION,localId:e,data:{data:{[s]:i}}})}async unrelate(t,e,s,i){const r=this._fragments.models.list.get(t);if(!r)throw new Error(`Model ${t} not found`);const n=(await r.getRelations([e])).get(e);if(!n)return;if(!n.data[s])return;const o=new Set(n.data[s]);for(const t of i)o.delete(t);n.data[s]=Array.from(o),this.addRelationRequest(t,e,"update",{type:kr.UPDATE_RELATION,localId:e,data:n})}async get(t,e){const s=this._fragments.models.list.get(t);if(!s)throw new Error(`Model ${t} not found`);return s._getElements(e)}async create(t,e){for(const s of e){const{attributes:e,samples:i,globalTransform:r}=s,n=this.getNextTempId(t),o=pn.itemDataToRawItemData(e);this.addRequest(t,n,"create",{type:kr.CREATE_ITEM,tempId:n,data:o});const a=this.createGlobalTransform(t,r,n);for(const e of i){const{localTransform:s,representation:i,material:r}=e;let n,o,l;n="number"!=typeof s&&"string"!=typeof s?this.createLocalTransform(t,s):s,o="number"!=typeof i&&"string"!=typeof i?this.createShell(t,i):i,l="number"!=typeof r&&"string"!=typeof r?this.createMaterial(t,r):r,this.createSample(t,{localTransform:n,representation:o,material:l,globalTransform:a})}}const s=this.getRequests(t);if(!s)return console.log("Something went wrong, no requests sent"),null;const i=[];for(let t=0;t<s.length;t++)s[t].type===kr.CREATE_ITEM&&i.push(t);const r=await this._fragments.editor.edit(t,s),n=i.map((t=>r[t]));return this.get(t,n)}delete(t,e){for(const s of e){s.delete();const e=s.getRequests();if(e)for(const s of e){const e=s.localId;e&&this.addRequest(t,e,"remove",s)}}}async applyChanges(t,e=[]){const s=[];for(const t of e){const e=t.getRequests();e&&s.push(...e)}const i=this.getRequests(t);return i&&s.push(...i),s.length>0?this._fragments.editor.edit(t,s):[]}async deleteData(t,e){const s=this._fragments.models.list.get(t);if(!s)throw new Error(`Model ${t} not found`);const i=e.filterInUse??!0,{itemIds:r,materialIds:n,localTransformIds:o,representationIds:a,sampleIds:l}=e,c=new Set,h=new Set,d=new Set,u=new Set;if(i){const t=await s.getSamples();for(const e of t.values())c.add(e.material),h.add(e.localTransform),d.add(e.item),u.add(e.representation)}if(n)for(const e of n)i&&c.has(e)?console.log(`Material ${e} is used, skipping`):this.isBeingCreated(t,e)?delete this._requests[t].create[e]:this.addRequest(t,e,"remove",{type:kr.DELETE_MATERIAL,localId:e});if(o)for(const e of o)i&&h.has(e)?console.log(`Local transform ${e} is used, skipping`):this.isBeingCreated(t,e)?delete this._requests[t].create[e]:this.addRequest(t,e,"remove",{type:kr.DELETE_LOCAL_TRANSFORM,localId:e});if(a)for(const e of a)i&&u.has(e)?console.log(`Representation ${e} is used, skipping`):this.isBeingCreated(t,e)?delete this._requests[t].create[e]:this.addRequest(t,e,"remove",{type:kr.DELETE_REPRESENTATION,localId:e});if(l)for(const e of l)this.isBeingCreated(t,e)?delete this._requests[t].create[e]:this.addRequest(t,e,"remove",{type:kr.DELETE_SAMPLE,localId:e});if(r)for(const e of r)this.isBeingCreated(t,e)?delete this._requests[t].create[e]:this.addRequest(t,e,"remove",{type:kr.DELETE_ITEM,localId:e})}getNextTempId(t){return this._nextTempIds[t]||(this._nextTempIds[t]=0),(this._nextTempIds[t]++).toString()}addRelationRequest(t,e,s,i){this.getModelRequests(t).relations[s][e]=i}addRequest(t,e,s,i){this.getModelRequests(t)[s][e]=i}getModelRequests(t){return this._requests[t]||(this._requests[t]=this.newRequests()),this._requests[t]}isBeingCreated(t,e){if(!this._requests[t])return!1;return void 0!==this._requests[t].create[e]}newRequests(){return{update:{},create:{},remove:{},relations:{create:{},update:{},remove:{}}}}}class Aa{constructor(t,e){ot(this,"onEdit",new Ht),ot(this,"_editHelper"),ot(this,"_elementsHelper"),this._editHelper=new ba(t,e),this._elementsHelper=new Ra(t)}async edit(t,e,s={removeRedo:!0}){const i=await this._editHelper.edit(t,e,s);return this.onEdit.trigger(),i}async save(t){return this._editHelper.save(t)}async reset(t){await this._editHelper.reset(t)}async getModelRequests(t){return this._editHelper.getRequests(t)}async selectRequest(t,e){return this._editHelper.selectRequest(t,e)}clearElementsRequests(t){return this._elementsHelper.getRequests(t)}createMaterial(t,e){return this._elementsHelper.createMaterial(t,e)}createLocalTransform(t,e){return this._elementsHelper.createLocalTransform(t,e)}createShell(t,e){return this._elementsHelper.createShell(t,e)}createCircleExtrusion(t,e){return this._elementsHelper.createCircleExtrusion(t,e)}createGlobalTransform(t,e,s){return this._elementsHelper.createGlobalTransform(t,e,s)}createSample(t,e){return this._elementsHelper.createSample(t,e)}createItem(t,e){return this._elementsHelper.createItem(t,e)}setItem(t,e){return this._elementsHelper.setItem(t,e)}async relate(t,e,s,i){return this._elementsHelper.relate(t,e,s,i)}async unrelate(t,e,s,i){return this._elementsHelper.unrelate(t,e,s,i)}async getElements(t,e){return this._elementsHelper.get(t,e)}async createElements(t,e){return this._elementsHelper.create(t,e)}deleteElements(t,e){return this._elementsHelper.delete(t,e)}async applyChanges(t,e=[]){return this._elementsHelper.applyChanges(t,e)}async deleteData(t,e){return this._elementsHelper.deleteData(t,e)}async _update(t){await this._editHelper._update(t)}}class ya{constructor(t,e,s){ot(this,"localId"),ot(this,"model"),ot(this,"core"),ot(this,"config",{data:{attributesDefault:!0,relations:{IsDefinedBy:{attributes:!0,relations:!0},DefinesOcurrence:{attributes:!1,relations:!1}}}}),ot(this,"updateRequests",{}),ot(this,"createRequests",{}),ot(this,"removeRequests",{}),ot(this,"_elementChanged",!1),this.localId=t,this.core=e,this.model=s}get elementChanged(){return this._elementChanged}getRequests(){const t=Object.values(this.createRequests);this.createRequests={};const e=Object.values(this.updateRequests);this.updateRequests={};const s=Object.values(this.removeRequests);this.removeRequests={};const i=[...s,...t,...e];return i.length>0?i:null}delete(){this.createRequests[this.localId]?delete this.createRequests[this.localId]:this.removeRequests[this.localId]={type:kr.DELETE_ITEM,localId:this.localId};for(const t in this.core.samples){const e=this.core.samples[t],s=parseInt(t,10);this.createRequests[e.localTransform]?delete this.createRequests[e.localTransform]:this.removeRequests[e.localTransform]={type:kr.DELETE_LOCAL_TRANSFORM,localId:e.localTransform},this.createRequests[e.representation]?delete this.createRequests[e.representation]:this.removeRequests[e.representation]={type:kr.DELETE_REPRESENTATION,localId:e.representation},this.createRequests[e.material]?delete this.createRequests[e.material]:this.removeRequests[e.material]={type:kr.DELETE_MATERIAL,localId:e.material},this.createRequests[e.item]?delete this.createRequests[e.item]:this.removeRequests[e.item]={type:kr.DELETE_GLOBAL_TRANSFORM,localId:e.item},this.createRequests[s]?delete this.createRequests[s]:this.removeRequests[s]={type:kr.DELETE_SAMPLE,localId:s}}}async getData(){return(await this.model.getItemsData([this.localId],this.config.data))[0]}getGlobalTransformId(){return parseInt(Object.keys(this.core.globalTransforms)[0],10)}disposeMeshes(t,e){const s=(null==e?void 0:e.disposeGeometry)??!0,i=(null==e?void 0:e.disposeMaterial)??!0;t.removeFromParent(),t.traverse((t=>{t instanceof ft.Mesh&&(s&&t.geometry.dispose(),i&&t.material.dispose())}))}async getMeshes(){const t=new ft.Group,e=Object.values(this.core.globalTransforms)[0],s=An.matrixFromTransform(e);t.applyMatrix4(s);const i=new Map,r=new Map,n=Object.keys(this.core.representations).map(Number),o=await this.model.getGeometries(n),a=new Map;for(const t of o){const e=t.representationId;a.set(e,t)}for(const e in this.core.samples){const s=parseInt(e,10),n=this.core.samples[s],o=a.get(n.representation);if(!o)throw new Error(`No geometry found for representation ${n.representation}`);const{indices:l,positions:c,normals:h}=o;if(!l||!c||!h)continue;if(!i.has(n.material)){const{r:t,g:e,b:s,a:r}=this.core.materials[n.material],o=(new ft.Color).setRGB(t/255,e/255,s/255,ft.SRGBColorSpace),a=new ft.MeshLambertMaterial({color:o,transparent:!0,opacity:r/255});a.userData.localId=n.material,i.set(n.material,a)}const d=i.get(n.material),u=this.core.localTransforms[n.localTransform],f=An.matrixFromTransform(u);if(!r.has(n.representation)){const t=new ft.BufferGeometry;t.setIndex(Array.from(l)),t.setAttribute("position",new ft.BufferAttribute(c,3)),t.setAttribute("normal",new ft.BufferAttribute(h,3)),t.userData.localId=n.representation,r.set(n.representation,t)}const p=r.get(n.representation),I=new ft.Group;I.userData.localId=n.localTransform,t.add(I),I.applyMatrix4(f);const m=new ft.Mesh(p,d);m.userData.sampleId=s,I.add(m)}return t}async setMeshes(t){const e=await this.getMeshes();let s=!0;t.updateMatrix();const i=1e3;for(let r=0;r<t.matrix.elements.length;r++){if(Math.trunc(t.matrix.elements[r]*i)/i!==Math.trunc(e.matrix.elements[r]*i)/i){s=!1;break}}if(!s){const e=parseInt(Object.keys(this.core.globalTransforms)[0],10),s=this.core.globalTransforms[e];An.transformFromMatrix(t.matrix,s),this._elementChanged=!0,this.updateRequests[e]={type:kr.UPDATE_GLOBAL_TRANSFORM,localId:e,data:s}}const r=new Map,n=new Map;e.traverse((t=>{t instanceof ft.Mesh&&r.set(t.material.userData.localId,t.material)})),t.traverse((t=>{t instanceof ft.Mesh&&n.set(t.material.userData.localId,t.material)}));for(const[t,e]of r){const s=n.get(t);if(!s)continue;const i=e.color.r,r=e.color.g,o=e.color.b,a=e.opacity,l=s.color.r,c=s.color.g,h=s.color.b,d=s.opacity,u=this.core.materials[t];u.r=255*l,u.g=255*c,u.b=255*h,u.a=255*d,i===l&&r===c&&o===h&&a===d||(this._elementChanged=!0,this.updateRequests[t]={type:kr.UPDATE_MATERIAL,localId:t,data:u})}r.clear(),n.clear();const o=new Map,a=new Map;for(const e of t.children)e.updateMatrix(),a.set(e.userData.localId,e.matrix);for(const t of e.children)o.set(t.userData.localId,t.matrix);for(const[t,e]of o){const s=a.get(t);if(s&&!e.equals(s)){const e=this.core.localTransforms[t];An.transformFromMatrix(s,e),this._elementChanged=!0,this.updateRequests[t]={type:kr.UPDATE_LOCAL_TRANSFORM,localId:t,data:e}}}o.clear(),a.clear();const l=new Map,c=new Map;t.traverse((t=>{if(t instanceof ft.Mesh){const e=t.geometry;c.set(e.userData.localId,e)}})),e.traverse((t=>{if(t instanceof ft.Mesh){const e=t.geometry;l.set(e.userData.localId,e)}}));for(const[t,e]of l){const s=this.core.representations[t];if(s.representationClass===Gr.CIRCLE_EXTRUSION)continue;const i=c.get(t);if(!i)continue;let r=!0;const n=e.getAttribute("position"),o=i.getAttribute("position");if(n&&o)if(n.count===o.count){for(let t=0;t<n.array.length;t++)if(n.array[t]!==o.array[t]){r=!1;break}}else r=!1;r||(An.representationFromGeometry(i,s),this._elementChanged=!0,this.updateRequests[t]={type:kr.UPDATE_REPRESENTATION,localId:t,data:s})}}createSamples(t){for(const e of t){const t=Math.trunc(performance.now());this.core.samples[t]=e,this.createRequests[t]={type:kr.CREATE_SAMPLE,data:e}}}deleteSamples(t){this._elementChanged=!0;for(const e of t){1!==Object.keys(this.core.samples).length&&(delete this.core.samples[e],delete this.updateRequests[e],this.createRequests[e]?delete this.createRequests[e]:this.removeRequests[e]={type:kr.DELETE_SAMPLE,localId:e})}}async updateSamples(){const t=new Set(Object.keys(this.core.materials).map(Number)),e=new Set(Object.keys(this.core.localTransforms).map(Number)),s=new Set(Object.keys(this.core.globalTransforms).map(Number)),i=new Set(Object.keys(this.core.representations).map(Number)),r=new Set,n=new Set,o=new Set,a=new Set,l=new Set;for(const c in this.core.samples){const h=parseInt(c,10),d=this.core.samples[h];t.delete(d.material),s.delete(d.item),e.delete(d.localTransform),i.delete(d.representation),this.core.materials[d.material]||(l.add(h),r.add(d.material)),this.core.globalTransforms[d.item]||(l.add(h),n.add(d.item)),this.core.localTransforms[d.localTransform]||(l.add(h),o.add(d.localTransform)),this.core.representations[d.representation]||(l.add(h),a.add(d.representation))}for(const e of t)delete this.core.materials[e];for(const t of s)delete this.core.globalTransforms[t];for(const t of e)delete this.core.localTransforms[t];for(const t of i)delete this.core.representations[t];let c=new Map;r.size&&(c=await this.model.getMaterials(r));let h=new Map;n.size&&(h=await this.model.getGlobalTransforms(n));let d=new Map;o.size&&(d=await this.model.getLocalTransforms(o));let u=new Map;a.size&&(u=await this.model.getRepresentations(a));for(const[t,e]of c)this.core.materials[t]=e;for(const[t,e]of h)this.core.globalTransforms[t]=e;for(const[t,e]of d)this.core.localTransforms[t]=e;for(const[t,e]of u)this.core.representations[t]=e;for(const t of l)if(this.createRequests[t]){this.createRequests[t].data=this.core.samples[t]}else this._elementChanged=!0,this.updateRequests[t]={type:kr.UPDATE_SAMPLE,localId:t,data:this.core.samples[t]}}}class Sa{async edit(t,e){return t.threads.invoke(t.modelId,"edit",[e])}async reset(t){return t.threads.invoke(t.modelId,"reset",[])}async save(t){return t.threads.invoke(t.modelId,"save",[])}async getItemsGeometry(t,e,s){const i=await t.threads.invoke(t.modelId,"getItemsGeometry",[e,s]),r=t.deltaModelId;if(!r)return i;const n=await t.threads.invoke(r,"getItemsGeometry",[e]),o=new Map;for(const t of i){const e=t[0].localId;o.set(e,t)}for(const t of n){const e=t[0].localId;o.set(e,t)}return Array.from(o.values())}async getGeometries(t,e){const s=await t.threads.invoke(t.modelId,"getGeometries",[e]),i=t.deltaModelId;if(!i)return s;const r=await t.threads.invoke(i,"getGeometries",[e]),n=new Map;for(const t of s){const e=t.representationId;n.set(e,t)}for(const t of r){const e=t.representationId;n.set(e,t)}return Array.from(n.values())}async getMaterialsIds(t){return t.threads.invoke(t.modelId,"getMaterialsIds",[])}async getMaterials(t,e){return t.threads.invoke(t.modelId,"getMaterials",[e])}async getSamplesIds(t){return t.threads.invoke(t.modelId,"getSamplesIds",[])}async getSamples(t,e){return t.threads.invoke(t.modelId,"getSamples",[e])}async getRepresentationsIds(t){return t.threads.invoke(t.modelId,"getRepresentationsIds",[])}async getRepresentations(t,e){return t.threads.invoke(t.modelId,"getRepresentations",[e])}async getLocalTransformsIds(t){return t.threads.invoke(t.modelId,"getLocalTransformsIds",[])}async getLocalTransforms(t,e){return t.threads.invoke(t.modelId,"getLocalTransforms",[e])}async getGlobalTransformsIds(t){return t.threads.invoke(t.modelId,"getGlobalTransformsIds",[])}async getGlobalTransforms(t,e){return t.threads.invoke(t.modelId,"getGlobalTransforms",[e])}async getItemsIds(t){return t.threads.invoke(t.modelId,"getItemsIds",[])}async getItems(t,e){return t.threads.invoke(t.modelId,"getItems",[e])}async getRelations(t,e){return t.threads.invoke(t.modelId,"getRelations",[e])}async getGlobalTranformsIdsOfItems(t,e){return await t.threads.invoke(t.modelId,"getGlobalTranformsIdsOfItems",[e])}async getEditedElements(t){return t.deltaModelId?t.threads.invoke(t.deltaModelId,"getItemsWithGeometry",[]):[]}async getElements(t,e){const s=await t.threads.invoke(t.modelId,"getElementsData",[e]);if(t.deltaModelId){const i=await t.threads.invoke(t.deltaModelId,"getElementsData",[e]);for(const t in i)s[t]=i[t]}const i=[];for(const e in s){const r=new ya(Number(e),s[e],t);i.push(r)}return i}async getRequests(t){return t.threads.invoke(t.modelId,"getRequests",[])}async setRequests(t,e){return t.threads.invoke(t.modelId,"setRequests",[e])}async selectRequest(t,e){return t.threads.invoke(t.modelId,"selectRequest",[e])}}class Fa{constructor(t){ot(this,"model"),ot(this,"_grids",new ft.Group),ot(this,"_gridMaterial",new ft.LineDashedMaterial({color:16777215,linewidth:5,depthTest:!1,dashSize:1,gapSize:.3})),this.model=t}async getGrids(){return this._grids.children.length||await this.constructGrids(),this._grids}async constructGrids(){const t=await this.model.threads.invoke(this.model.modelId,"getGrids"),e=new ft.Matrix4;for(const s of t){const t=new ft.Group;this._grids.add(t),t.userData.id=s.id,e.fromArray(s.transform),t.applyMatrix4(e),this.getGridAxis(s,t,"uAxes"),this.getGridAxis(s,t,"vAxes"),this.getGridAxis(s,t,"wAxes"),this._grids.add(t)}}getGridAxis(t,e,s){for(const{curve:i,tag:r}of t[s]){const[t,s,n,o]=i,a=new ft.BufferGeometry;a.setAttribute("position",new ft.BufferAttribute(new Float32Array([t,s,0,n,o,0]),3));const l=new ft.Line(a,this._gridMaterial);l.userData.tag=r,l.computeLineDistances(),l.renderOrder=1,e.add(l)}}dispose(){this._grids.removeFromParent();for(const t of this._grids.children){const e=t;e.geometry.dispose(),e.geometry=void 0,e.material=void 0}this._gridMaterial.dispose(),this._gridMaterial=void 0}}const wa=class t{constructor(t,e,s,i){ot(this,"attrsChanges",new Map),ot(this,"relsChanges",new Map),ot(this,"threads"),ot(this,"tiles",new Yt),ot(this,"object",new ft.Object3D),ot(this,"graphicsQuality",0),ot(this,"deltaModelId",null),ot(this,"_boxManager",new ea),ot(this,"_itemsManager",new aa),ot(this,"_coordinatesManager",new sa),ot(this,"_setupManager",new ta),ot(this,"_viewManager",new la),ot(this,"_raycastManager",new ca),ot(this,"_visibilityManager",new ha),ot(this,"_highlightManager",new _a),ot(this,"_sectionManager",new ga),ot(this,"_dataManager",new Ca),ot(this,"_sequenceManager",new Ta),ot(this,"_bbox",new ft.Box3),ot(this,"_alignmentsManager"),ot(this,"_gridsManager"),ot(this,"_meshManager"),ot(this,"_editManager",new Sa),ot(this,"_editor"),ot(this,"_isProcessing",!1),ot(this,"_isLoaded",!1),ot(this,"_frozen",!1),ot(this,"_isSetup",!1),ot(this,"_parentModelId",null),this.object.name=t,this.object.up.set(0,0,1),this._meshManager=e,this.threads=s,this._editor=i,this._alignmentsManager=new Jo(this),this._gridsManager=new Fa(this),this.tiles.onItemSet.add((({value:t})=>this.object.add(t))),this.tiles.onBeforeDelete.add((({value:t})=>{this.object.remove(t),t.geometry.dispose(),bo.forEach(t.material,(t=>t.dispose()))}))}get modelId(){return this.object.name}get box(){return this._bbox.clone().applyMatrix4(this.object.matrixWorld)}get isBusy(){const t=this._meshManager.requests.arePending;return!this._isLoaded||this._isProcessing||t}get frozen(){return Boolean(this._frozen)}set frozen(t){t!==this._frozen&&(this._frozen=t,t||this._refreshView())}get getClippingPlanesEvent(){return this._viewManager.getClippingPlanesEvent}set getClippingPlanesEvent(t){this._viewManager.getClippingPlanesEvent=t}get camera(){return this._viewManager.currentCamera}get isDeltaModel(){return this.object.userData[t._deltaModelId]}get parentModelId(){return this._parentModelId}async dispose(){this._isLoaded=!1,await this._dataManager.dispose(this,this._meshManager,this._alignmentsManager,this._gridsManager)}async getSpatialStructure(){return this._dataManager.getSpatialStructure(this)}async getLocalIdsByGuids(t){return this._dataManager.getLocalIdsByGuids(this,t)}async getCategories(){return this._dataManager.getCategories(this)}async getItemsWithGeometryCategories(){return this._dataManager.getItemsWithGeometryCategories(this)}async getItemsWithGeometry(){return this._dataManager.getItemsWithGeometry(this)}async getItemsIdsWithGeometry(){return this._dataManager.getItemsIdsWithGeometry(this)}async getMetadata(){return this._dataManager.getMetadata(this)}async getGuidsByLocalIds(t){return this._dataManager.getGuidsByLocalIds(this,t)}async getBuffer(t=!1){return this._dataManager.getBuffer(this,t)}async getItemsOfCategories(t){return this._dataManager.getItemsOfCategories(this,t)}async getGuids(){return await this.threads.invoke(this.modelId,"getGuids",[])}async getLocalIds(){return await this.threads.invoke(this.modelId,"getLocalIds",[])}async getItemsByQuery(t,e){return this._dataManager.getItemsByQuery(this,t,e)}async getItemsMaterialDefinition(t){return await this.threads.invoke(this.modelId,"getItemsMaterialDefinition",[t])}async getItemsGeometry(t,e=Nn.GEOMETRY){return this._editManager.getItemsGeometry(this,t,e)}async getGeometries(t){return this._editManager.getGeometries(this,t)}async getItemsVolume(t){return await this.threads.invoke(this.modelId,"getItemsVolume",[t])}async getAttributeNames(){return await this.threads.invoke(this.modelId,"getAttributeNames",[])}async getAttributeValues(){return await this.threads.invoke(this.modelId,"getAttributeValues",[])}async getAttributesUniqueValues(t){return await this.threads.invoke(this.modelId,"getAttributesUniqueValues",[t])}async getAttributeTypes(){return await this.threads.invoke(this.modelId,"getAttributeTypes",[])}async getRelationNames(){return await this.threads.invoke(this.modelId,"getRelationNames",[])}async getMaxLocalId(){return this._dataManager.getMaxLocalId(this)}getItem(t){return this._itemsManager.getItem(this,t)}async getItemsChildren(t){return this._itemsManager.getItemsChildren(this,t)}async getItemsData(t,e){return this._itemsManager.getItemsData(this,t,e)}async getPositions(t){return this._coordinatesManager.getPositions(this,t)}async getCoordinates(){return this._coordinatesManager.getCoordinates(this)}async getCoordinationMatrix(){return this._coordinatesManager.getCoordinationMatrix(this)}async getMergedBox(t){return this._boxManager.getMergedBox(this,t)}async getBoxes(t){return this._boxManager.getBoxes(this,t)}async getAlignments(){return this._alignmentsManager.getAlignments()}async getHorizontalAlignments(){return this._alignmentsManager.getHorizontalAlignments()}async getVerticalAlignments(){return this._alignmentsManager.getVerticalAlignments()}getAlignmentStyles(){return this._alignmentsManager.getAlignmentStyles()}async getGrids(){return this._gridsManager.getGrids()}useCamera(t){this._viewManager.useCamera(t)}async setLodMode(t){return this._viewManager.setLodMode(this,t)}async rectangleRaycast(t){return this._raycastManager.rectangleRaycast(this,this._meshManager,t)}async raycast(t){return this._raycastManager.raycast(this,t)}async raycastAll(t){return this._raycastManager.raycastAll(this,t)}async raycastWithSnapping(t){return this._raycastManager.raycastWithSnapping(this,t)}async setVisible(t,e){const s=[t,e];await this.threads.invoke(this.modelId,"setVisible",s)}async toggleVisible(t){const e=[t];await this.threads.invoke(this.modelId,"toggleVisible",e)}async getItemsByVisibility(t){return this._visibilityManager.getItemsByVisibility(this,t)}async getVisible(t){return this._visibilityManager.getVisible(this,t)}async resetVisible(){return this._visibilityManager.resetVisible(this)}async highlight(t,e){return this._highlightManager.highlight(this,t,e)}async setColor(t,e){return this._highlightManager.setColor(this,t,e)}async resetColor(t){return this._highlightManager.resetColor(this,t)}async setOpacity(t,e){return this._highlightManager.setOpacity(this,t,e)}async resetOpacity(t){return this._highlightManager.resetOpacity(this,t)}async getHighlight(t){return this._highlightManager.getHighlight(this,t)}async resetHighlight(t){return this._highlightManager.resetHighlight(this,t)}async getHighlightItemIds(){return this._highlightManager.getHighlightItemIds(this)}async getSection(t,e){return this._sectionManager.getSection(this,t,e)}async getMaterialsIds(){return this._editManager.getMaterialsIds(this)}async getMaterials(t){return this._editManager.getMaterials(this,t)}async getRepresentationsIds(){return this._editManager.getRepresentationsIds(this)}async getRepresentations(t){return this._editManager.getRepresentations(this,t)}async getLocalTransformsIds(){return this._editManager.getLocalTransformsIds(this)}async getLocalTransforms(t){return this._editManager.getLocalTransforms(this,t)}async getGlobalTransformsIds(){return this._editManager.getGlobalTransformsIds(this)}async getGlobalTransforms(t){return this._editManager.getGlobalTransforms(this,t)}async getSamplesIds(){return this._editManager.getSamplesIds(this)}async getSamples(t){return this._editManager.getSamples(this,t)}async getItemsIds(){return this._editManager.getItemsIds(this)}async getItems(t){return this._editManager.getItems(this,t)}async getRelations(t){return this._editManager.getRelations(this,t)}async getGlobalTranformsIdsOfItems(t){return this._editManager.getGlobalTranformsIdsOfItems(this,t)}async getEditedElements(){return this._editManager.getEditedElements(this)}async getSequenced(t,e,s){return this._sequenceManager.getSequenced(this,t,e,s)}async handleRequest(t){await this._meshManager.requests.handleRequest(this._meshManager,t)}async _getElements(t){return this._editManager.getElements(this,t)}_finishProcessing(){this._isProcessing=!1}_setDeltaModel(e){this.object.userData[t._deltaModelId]=!0,this._parentModelId=e}async _refreshView(){if(this.frozen)return;this._isProcessing=!0;const t=this._viewManager.refreshView(this,this._meshManager),e=this._editor._update(this.modelId);await Promise.all([t,e])}async _setup(t,e,s){this._isSetup||(await this._setupManager.setup(this,this._bbox,t,e,s),this._isLoaded=!0,this._isProcessing=!0,this._isSetup=!0)}async _edit(t){return this._editManager.edit(this,t)}async _reset(){return this._editManager.reset(this)}async _save(){return this._editManager.save(this)}async _getRequests(){return this._editManager.getRequests(this)}async _setRequests(t){return this._editManager.setRequests(this,t)}async _selectRequest(t){return this._editManager.selectRequest(this,t)}};ot(wa,"_deltaModelId","isDeltaModel");let La=wa;class Oa{constructor(){ot(this,"list",[]),ot(this,"onFinish",(()=>{}))}get arePending(){return this.list.length>0}async handleRequest(t,e){if(e.class===vn.RECOMPUTE_MESHES)this.add(e.list),e.list=void 0;else if(e.class===vn.CREATE_MATERIAL){const{materialDefinitions:s,modelId:i}=e;Ea.resetColors(s),t.materials.addDefinitions(i,s),e.materialDefinitions=void 0}else e.class===vn.THROW_ERROR&&console.error(e)}add(t){for(const e of t)this.insert(e)||this.list.push(e),e.tileRequestClass===xn.FINISH&&this.onFinish()}clean(t){const e=this.list.filter((e=>e.modelId!==t||e.tileRequestClass!==xn.FINISH));this.list=e}insert(t){const{modelId:e,tileId:s,tileRequestClass:i,tileData:r}=t;if(void 0===s)return!1;if(i===xn.DELETE){const t=this.list.filter((t=>!((t.tileRequestClass===xn.CREATE||t.tileRequestClass===xn.DELETE)&&t.modelId===e&&t.tileId===s)));this.list=t}if(i===xn.CREATE){const t=this.list.filter((t=>!(t.tileRequestClass===xn.CREATE&&t.modelId===e&&t.tileId===s)));this.list=t}if(i===xn.UPDATE){const t=this.list.find((t=>t.modelId===e&&t.tileId===s));if(t)return t.tileRequestClass!==xn.CREATE&&t.tileRequestClass!==xn.UPDATE||(t.tileData=r),!0}return!1}}class xa{constructor(t){ot(this,"_materials"),ot(this,"white",4294967295),this._materials=t}createMesh(t,e){const s=this._materials.getFromRequest(e);if(!("isLodMaterial"in s)||!s.isLodMaterial)throw new Error("Fragments: material is not an instance of LodMaterial.");const{positions:i}=e;if(!i)throw new Error("Fragments: no positions provided to create the LOD mesh.");const r=new Ia,n=this.deleteAttributeEvent(t);fa.setLodBuffer(r,i,n);return new pa(r,[s])}updateVisibility(t,e){const{geometry:s}=t,{visibilityData:i,highlightData:r}=e;fa.setLodVisibility(s,i),r?(fa.setLodFilter(s,r),To.getComplementary(r,((t,e)=>{s.addGroup(t,e,0)}))):s.addGroup(0,1/0,0)}processMesh(t,e){const{geometry:s}=t,{tileData:{visibilityData:i},currentLod:r}=e;if(r===Nn.WIRES&&t instanceof pa)this.updateVisibility(t,e.tileData);else if(i&&i.position.length>0)for(let t=0;t<i.position.length;++t){const e=i.size[t]===this.white,r=i.position[t],n=e?1/0:i.size[t];s.addGroup(r,n,0)}}deleteAttributeEvent(t){return function(){delete this.array}}}class Na{constructor(t){ot(this,"list",new Yt),ot(this,"materials",new Ea),ot(this,"lod",new xa(this.materials)),ot(this,"requests",new Oa),ot(this,"updateThreshold",4),ot(this,"_updateFinished",!0),ot(this,"_onUpdate"),this._onUpdate=t,this.requests.onFinish=()=>this._updateFinished=!0}async forceUpdateFinish(t=200,e=500){let s=!1;for(;!s;)await new Promise((e=>{this._updateFinished=!1;const s=setInterval((()=>{this.update(),this._updateFinished&&(clearInterval(s),e())}),t)})),await new Promise((t=>{setTimeout(t,e)})),s=this._updateFinished}update(){const t=performance.now();for(;this.requests.arePending;){const e=this.requests.list.shift();if(e&&(this.processTileRequest(e),this._onUpdate(),performance.now()-t>this.updateThreshold))return}}setTileData(t,e){const{tileId:s,itemId:i,matrix:r,aabb:n}=e;this.setMeshData(t,s,i,r),this.setupBoundings(t,n),this.updateStatus(t,e)}processTileRequest(t){const{tileRequestClass:e,tileId:s,modelId:i}=t,r=this.list.get(i);if(r)if(e===xn.CREATE){if(void 0===t.objectClass)return;const e=this.create(t);this.setTileData(e,t),r.tiles.set(e.userData.tileId,e)}else if(e===xn.DELETE)r.tiles.delete(s);else if(e===xn.UPDATE){const e=r.tiles.get(s);e&&this.updateStatus(e,t)}else e===xn.FINISH&&r._finishProcessing()}createMesh(t){const{indices:e,positions:s,normals:i,itemIds:r,faceIds:n}=t,o=new ft.BufferGeometry;this.setIndex(o,e),this.setPositions(s,o),this.setNormals(i,o),this.setItemIds(r,o),this.setFaceIds(n,o);const a=this.materials.getFromRequest(t);return new ft.Mesh(o,[a])}setupBoundings(t,e){const{geometry:s}=t,i=(new ft.Box3).copy(e),r=new ft.Sphere;i.getBoundingSphere(r),s.boundingBox=i,s.boundingSphere=r}create(t){if(t.objectClass===On.SHELL)return this.createMesh(t);if(t.objectClass===On.LINE){const e=new ft.BufferGeometry;return this.lod.createMesh(e,t)}throw new Error(`Fragments: object class ${t.objectClass} is not supported.`)}updateStatus(t,e){const{tileData:{highlightData:s},currentLod:i}=e,{geometry:r}=t;if(r.clearGroups(),this.lod.processMesh(t,e),!s||i===Nn.WIRES)return;const n=this.materials.createHighlights(t,e);t.material=n}cleanAttributeMemory(t,e){t.attributes[e].onUpload(this.deleteAttribute(t))}setPositions(t,e){if(!t)throw new Error("Fragments: no positions provided to create the mesh.");e.setAttribute("position",new ft.BufferAttribute(t,3)),this.cleanAttributeMemory(e,"position")}setFaceIds(t,e){t&&(e.setAttribute("color",new ft.BufferAttribute(t,3)),this.cleanAttributeMemory(e,"color"))}setIndex(t,e){if(!e)throw new Error("Fragments: no indices provided to create the mesh.");t.setIndex(new ft.BufferAttribute(e,1)),t.index.onUpload(this.deleteAttribute(t))}setNormals(t,e){t&&e.setAttribute("normal",new ft.BufferAttribute(t,3,!0)),this.cleanAttributeMemory(e,"normal")}setItemIds(t,e){t&&(e.setAttribute("id",new ft.BufferAttribute(t,1,!1)),this.cleanAttributeMemory(e,"id"))}deleteAttribute(t){return function(){delete this.array}}setMeshData(t,e,s,i){t.userData={tileId:e,itemId:s},t.matrixAutoUpdate=!1,t.applyMatrix4(i),t.matrix.copy(i)}}class va{constructor(){ot(this,"_list",new Map),ot(this,"_communicationKey",0)}setupInput(t){t.requestId=this._communicationKey++}set(t,e,s){const i=this.newHandler(e,s);this._list.set(t,i)}run(t){const e=this._list.get(t.requestId);this._list.delete(t.requestId),e(t)}newHandler(t,e){return s=>{s.errorInfo?t(s.errorInfo):e(s)}}}class Pa{static newThread(t){return new Worker(t,{type:"module"})}static newUpdater(t,e){return setInterval(t,e)}static getMeshComputeRequest(t,e){return{class:vn.RECOMPUTE_MESHES,modelId:t,list:e}}static planeSet(t){const e=[];for(const s of t){const t=this.array(s.normal),i=s.constant,r=new ft.Plane(t,i);e.push(r)}return e}static data(t){var e,s;if(void 0!==(null==t?void 0:t.elements))return Pa.transform(t);if(void 0!==(null==t?void 0:t.origin)&&void 0!==(null==t?void 0:t.direction))return Pa.beam(t);if(void 0!==(null==t?void 0:t.planes))return Pa.frustum(t);const i=void 0!==(null==t?void 0:t.normal),r=void 0!==(null==t?void 0:t.constant);if(i&&r)return Pa.plane(t);const n=void 0!==(null==(e=t[0])?void 0:e.normal),o=void 0!==(null==(s=t[0])?void 0:s.constant);if(n&&o)return Pa.planeSet(t);const a=void 0!==(null==t?void 0:t.x),l=void 0!==(null==t?void 0:t.y),c=void 0!==(null==t?void 0:t.z);return a&&l&&c?Pa.array(t):t}static getExecuteRequest(t,e,s){const i=Array.from(s);return{class:vn.EXECUTE,modelId:t,function:e,parameters:i}}static plane(t){const e=this.array(t.normal),s=t.constant;return new ft.Plane(e,s)}static getRequestContent(t){const e=[];for(const s of t.list)Pa.setupCreateRequest(s,e),Pa.setupUpdateRequest(s,e);return e}static array(t){const e=new ft.Vector3;return e.set(t.x,t.y,t.z),e}static cleanRequests(t){const e=[],s=Pa;for(const i of t){s.isFinishRequest(i)||e.push(i)}return e}static frustum(t){const e=this.planeSet(t.planes),[s,i,r,n,o,a]=e;return new ft.Frustum(s,i,r,n,o,a)}static beam(t){const e=this.array(t.origin),s=this.array(t.direction);return new ft.Ray(e,s)}static transform(t){const e=new ft.Matrix4;return e.copy(t),e}static deleteUpdater(t){clearInterval(t)}static areCoresAvailable(t){const e=Pa.getCpuCapacity();return t<Math.max(e,2)}static isFinishRequest(t){return t.tileRequestClass===xn.FINISH}static setupUpdateRequest(t,e){t.tileRequestClass===xn.UPDATE&&this.addAllTileData(t,e)}static getCpuCapacity(){var t;return(null==(t=globalThis.navigator)?void 0:t.hardwareConcurrency)?navigator.hardwareConcurrency-3:0}static addAllTileData(t,e){this.addRequestTileData(t,e,"visibilityData");this.addRequestTileData(t,e,"highlightData",["highlightIds"])}static addRequestContent(t,e,s){if(!e[t])return;const i=e[t].buffer;s.push(i)}static addRequestTileData(t,e,s,i=[]){const r=t.tileData[s];if(r){e.push(r.position.buffer),e.push(r.size.buffer);for(const s of i)e.push(t.tileData[s].buffer)}}static setupCreateRequest(t,e){if(t.tileRequestClass!==xn.CREATE)return;const s=this.getCreateRequestIds();for(const i of s)this.addRequestContent(i,t,e);this.addAllTileData(t,e)}static getCreateRequestIds(){return["positions","indices","normals","itemIds"]}}class Ma{constructor(t){ot(this,"_handlers",new va),ot(this,"_handleInput"),ot(this,"_port"),ot(this,"onInput",(t=>{t.data.toMainThread?this._handlers.run(t.data):this.manageInput(t.data)})),this._handleInput=t}fetchMeshCompute(t,e){const s=Pa,i=s.getMeshComputeRequest(t,e),r=s.getRequestContent(i);this.fetch(i,r)}fetch(t,e){return this._handlers.setupInput(t),new Promise(((s,i)=>{this._handlers.set(t.requestId,i,s),this.executeConnection(t,e)}))}init(t){this._port=t,this.initConnection(t)}initConnection(t){t.onmessage=this.onInput}async fetchConnection(t){if(!this._port)throw new Error("Fragments: Connection not initialized");return this._port}async executeConnection(t,e){(await this.fetchConnection(t)).postMessage(t,e)}async manageOutput(t){const e=await this.fetchConnection(t);t.toMainThread=!0,e.postMessage(t)}async manageConnection(t){try{await this._handleInput(t)}catch(e){t.errorInfo=e.toString(),console.error(e)}}async manageInput(t){await this.manageConnection(t),await this.manageOutput(t)}}class Da{constructor(t){ot(this,"_modelThread",new Map),ot(this,"_threadsModelAmount",new Map),ot(this,"_threadPort",new Map),ot(this,"_threadPath"),ot(this,"_placeholder"),this._placeholder={},this._threadPath=t}get path(){return this._threadPath}usePlaceholder(t){this._modelThread.set(t,this._placeholder)}getAmount(t){return this._threadsModelAmount.get(t)}getThread(t){return this._modelThread.get(t)}getAndCheckThread(t){const e=this._modelThread.get(t);if(e===this._placeholder)throw new Error("Fragments: Error fetching thread!");return e}set(t,e){this._modelThread.set(t,e)}deleteModel(t){const e=this.getThreadSafe(t),s=this.getAmountSafe(e)-1;this.setAmount(e,s),this._modelThread.delete(t)}getThreadSafe(t){const e=this.getThread(t);if(!e)throw new Error(`Fragments: Thread for model ${t} not found`);return e}deleteThread(t){this._threadsModelAmount.delete(t),this._threadPort.delete(t),t.terminate()}getThreadAmount(){return this._threadsModelAmount.size}balanceThreadLoad(t){const{lessBusyThread:e,modelAmount:s}=this.getLessBusyThread();return this._threadsModelAmount.set(e,s+1),this._modelThread.set(t.modelId,e),this._threadPort.get(e)}getAmountSafe(t){const e=this.getAmount(t);if(!e)throw new Error(`Fragments: Amount for thread ${t} not found`);return e}setPort(t,e){this._threadPort.set(t,e)}setAmount(t,e){this._threadsModelAmount.set(t,e)}getPort(t){return this._threadPort.get(t)}getLessBusyThread(){let t=Number.MAX_VALUE,e=this._threadsModelAmount.keys().next().value;for(const[s,i]of this._threadsModelAmount)i<t&&(t=i,e=s);return{lessBusyThread:e,modelAmount:t}}}class Ua extends Ma{constructor(t,e){super(t),ot(this,"_data"),this._data=new Da(e)}delete(t){const e=this._data.getThreadSafe(t),s=this._data.getAmountSafe(e)-1;this._data.deleteModel(t),0===s&&this._data.deleteThread(e)}async invoke(t,e,s=[]){const i=Pa.getExecuteRequest(t,e,s);return(await this.fetch(i)).result}async fetchConnection(t){const e=this._data.getAndCheckThread(t.modelId);return e?this._data.getPort(e):this.setupNewThread(t)}setupNewThread(t){const e=Pa;this._data.usePlaceholder(t.modelId);const s=this._data.getThreadAmount();return e.areCoresAvailable(s)?this.newThread(t,this._data.path):this._data.balanceThreadLoad(t)}setupThread(t){const e=new MessageChannel,s=e.port1,i=e.port2;this.initConnection(s),this._data.setPort(t,s),t.postMessage(i,[i])}newThread(t,e){const s=Pa.newThread(e);return this.setupThread(s),this._data.setAmount(s,1),this._data.set(t.modelId,s),this._data.getPort(s)}}const Va=1.25,Ba=65535,za=Math.pow(2,-24),Ga=Symbol("SKIP_GENERATION");function Ha(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function ka(t,e){if(!t.index){const s=t.attributes.position.count,i=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(s,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new Nt(i,1));for(let t=0;t<s;t++)i[t]=t}}function Ya(t){const e=Ha(t),s=t.drawRange,i=s.start/3,r=(s.start+s.count)/3,n=Math.max(0,i),o=Math.min(e,r)-n;return[{offset:Math.floor(n),count:Math.floor(o)}]}function Wa(t){if(!t.groups||!t.groups.length)return Ya(t);const e=[],s=new Set,i=t.drawRange,r=i.start/3,n=(i.start+i.count)/3;for(const e of t.groups){const t=e.start/3,i=(e.start+e.count)/3;s.add(Math.max(r,t)),s.add(Math.min(n,i))}const o=Array.from(s.values()).sort(((t,e)=>t-e));for(let t=0;t<o.length-1;t++){const s=o[t],i=o[t+1];e.push({offset:Math.floor(s),count:Math.floor(i-s)})}return e}function qa(t,e,s){return s.min.x=e[t],s.min.y=e[t+1],s.min.z=e[t+2],s.max.x=e[t+3],s.max.y=e[t+4],s.max.z=e[t+5],s}function ja(t){let e=-1,s=-1/0;for(let i=0;i<3;i++){const r=t[i+3]-t[i];r>s&&(s=r,e=i)}return e}function Xa(t,e){e.set(t)}function Za(t,e,s){let i,r;for(let n=0;n<3;n++){const o=n+3;i=t[n],r=e[n],s[n]=i<r?i:r,i=t[o],r=e[o],s[o]=i>r?i:r}}function $a(t,e,s){for(let i=0;i<3;i++){const r=e[t+2*i],n=e[t+2*i+1],o=r-n,a=r+n;o<s[i]&&(s[i]=o),a>s[i+3]&&(s[i+3]=a)}}function Qa(t){const e=t[3]-t[0],s=t[4]-t[1],i=t[5]-t[2];return 2*(e*s+s*i+i*e)}function Ka(t,e,s,i,r=null){let n=1/0,o=1/0,a=1/0,l=-1/0,c=-1/0,h=-1/0,d=1/0,u=1/0,f=1/0,p=-1/0,I=-1/0,m=-1/0;const E=null!==r;for(let i=6*e,r=6*(e+s);i<r;i+=6){const e=t[i+0],s=t[i+1],r=e-s,_=e+s;r<n&&(n=r),_>l&&(l=_),E&&e<d&&(d=e),E&&e>p&&(p=e);const g=t[i+2],C=t[i+3],T=g-C,b=g+C;T<o&&(o=T),b>c&&(c=b),E&&g<u&&(u=g),E&&g>I&&(I=g);const R=t[i+4],A=t[i+5],y=R-A,S=R+A;y<a&&(a=y),S>h&&(h=S),E&&R<f&&(f=R),E&&R>m&&(m=R)}i[0]=n,i[1]=o,i[2]=a,i[3]=l,i[4]=c,i[5]=h,E&&(r[0]=d,r[1]=u,r[2]=f,r[3]=p,r[4]=I,r[5]=m)}const Ja=32,tl=(t,e)=>t.candidate-e.candidate,el=new Array(Ja).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),sl=new Float32Array(6);class il{constructor(){}}function rl(t,e,s,i,r,n){let o=i,a=i+r-1;const l=n.pos,c=2*n.axis;for(;;){for(;o<=a&&s[6*o+c]<l;)o++;for(;o<=a&&s[6*a+c]>=l;)a--;if(!(o<a))return o;for(let t=0;t<3;t++){let s=e[3*o+t];e[3*o+t]=e[3*a+t],e[3*a+t]=s}for(let t=0;t<6;t++){let e=s[6*o+t];s[6*o+t]=s[6*a+t],s[6*a+t]=e}o++,a--}}function nl(t,e,s,i,r,n){let o=i,a=i+r-1;const l=n.pos,c=2*n.axis;for(;;){for(;o<=a&&s[6*o+c]<l;)o++;for(;o<=a&&s[6*a+c]>=l;)a--;if(!(o<a))return o;{let e=t[o];t[o]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=s[6*o+t];s[6*o+t]=s[6*a+t],s[6*a+t]=e}o++,a--}}}function ol(t,e){const s=t.geometry,i=s.index?s.index.array:null,r=e.maxDepth,n=e.verbose,o=e.maxLeafTris,a=e.strategy,l=e.onProgress,c=Ha(s),h=t._indirectBuffer;let d=!1;const u=new Float32Array(6),f=new Float32Array(6),p=function(t,e){var s;(s=e)[0]=s[1]=s[2]=1/0,s[3]=s[4]=s[5]=-1/0;const i=t.attributes.position,r=t.index?t.index.array:null,n=Ha(t),o=new Float32Array(6*n),a=i.normalized,l=i.array,c=i.offset||0;let h=3;i.isInterleavedBufferAttribute&&(h=i.data.stride);const d=["getX","getY","getZ"];for(let t=0;t<n;t++){const s=3*t,n=6*t;let u=s+0,f=s+1,p=s+2;r&&(u=r[u],f=r[f],p=r[p]),a||(u=u*h+c,f=f*h+c,p=p*h+c);for(let t=0;t<3;t++){let s,r,c;a?(s=i[d[t]](u),r=i[d[t]](f),c=i[d[t]](p)):(s=l[u+t],r=l[f+t],c=l[p+t]);let h=s;r<h&&(h=r),c<h&&(h=c);let I=s;r>I&&(I=r),c>I&&(I=c);const m=(I-h)/2,E=2*t;o[n+E+0]=h+m,o[n+E+1]=m+(Math.abs(h)+m)*za,h<e[t]&&(e[t]=h),I>e[t+3]&&(e[t+3]=I)}}return o}(s,u),I=e.indirect?nl:rl,m=[],E=e.indirect?Ya(s):Wa(s);if(1===E.length){const t=E[0],e=new il;e.boundingData=u,function(t,e,s,i){let r=1/0,n=1/0,o=1/0,a=-1/0,l=-1/0,c=-1/0;for(let i=6*e,h=6*(e+s);i<h;i+=6){const e=t[i+0];e<r&&(r=e),e>a&&(a=e);const s=t[i+2];s<n&&(n=s),s>l&&(l=s);const h=t[i+4];h<o&&(o=h),h>c&&(c=h)}i[0]=r,i[1]=n,i[2]=o,i[3]=a,i[4]=l,i[5]=c}(p,t.offset,t.count,f),g(e,t.offset,t.count,f),m.push(e)}else for(let t of E){const e=new il;e.boundingData=new Float32Array(6),Ka(p,t.offset,t.count,e.boundingData,f),g(e,t.offset,t.count,f),m.push(e)}return m;function _(t){l&&l(t/c)}function g(t,e,l,c=null,u=0){if(!d&&u>=r&&(d=!0,n&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(s))),l<=o||u>=r)return _(e+l),t.offset=e,t.count=l,t;const m=function(t,e,s,i,r,n){let o=-1,a=0;if(0===n)o=ja(e),-1!==o&&(a=(e[o]+e[o+3])/2);else if(1===n)o=ja(t),-1!==o&&(a=function(t,e,s,i){let r=0;for(let n=e,o=e+s;n<o;n++)r+=t[6*n+2*i];return r/s}(s,i,r,o));else if(2===n){const n=Qa(t);let l=Va*r;const c=6*i,h=6*(i+r);for(let t=0;t<3;t++){const i=e[t],d=(e[t+3]-i)/Ja;if(r<8){const e=[...el];e.length=r;let i=0;for(let r=c;r<h;r+=6,i++){const n=e[i];n.candidate=s[r+2*t],n.count=0;const{bounds:o,leftCacheBounds:a,rightCacheBounds:l}=n;for(let t=0;t<3;t++)l[t]=1/0,l[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0;$a(r,s,o)}e.sort(tl);let d=r;for(let t=0;t<d;t++){const s=e[t];for(;t+1<d&&e[t+1].candidate===s.candidate;)e.splice(t+1,1),d--}for(let i=c;i<h;i+=6){const r=s[i+2*t];for(let t=0;t<d;t++){const n=e[t];r>=n.candidate?$a(i,s,n.rightCacheBounds):($a(i,s,n.leftCacheBounds),n.count++)}}for(let s=0;s<d;s++){const i=e[s],c=i.count,h=r-i.count,d=i.leftCacheBounds,u=i.rightCacheBounds;let f=0;0!==c&&(f=Qa(d)/n);let p=0;0!==h&&(p=Qa(u)/n);const I=1+Va*(f*c+p*h);I<l&&(o=t,l=I,a=i.candidate)}}else{for(let t=0;t<Ja;t++){const e=el[t];e.count=0,e.candidate=i+d+t*d;const s=e.bounds;for(let t=0;t<3;t++)s[t]=1/0,s[t+3]=-1/0}for(let e=c;e<h;e+=6){let r=~~((s[e+2*t]-i)/d);r>=Ja&&(r=31);const n=el[r];n.count++,$a(e,s,n.bounds)}const e=el[31];Xa(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=el[t],s=el[t+1];Za(e.bounds,s.rightCacheBounds,e.rightCacheBounds)}let u=0;for(let e=0;e<31;e++){const s=el[e],i=s.count,c=s.bounds,h=el[e+1].rightCacheBounds;0!==i&&(0===u?Xa(c,sl):Za(c,sl,sl)),u+=i;let d=0,f=0;0!==u&&(d=Qa(sl)/n);const p=r-u;0!==p&&(f=Qa(h)/n);const I=1+Va*(d*u+f*p);I<l&&(o=t,l=I,a=s.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);return{axis:o,pos:a}}(t.boundingData,c,p,e,l,a);if(-1===m.axis)return _(e+l),t.offset=e,t.count=l,t;const E=I(h,i,p,e,l,m);if(E===e||E===e+l)_(e+l),t.offset=e,t.count=l;else{t.splitAxis=m.axis;const s=new il,i=e,r=E-e;t.left=s,s.boundingData=new Float32Array(6),Ka(p,i,r,s.boundingData,f),g(s,i,r,f,u+1);const n=new il,o=E,a=l-r;t.right=n,n.boundingData=new Float32Array(6),Ka(p,o,a,n.boundingData,f),g(n,o,a,f,u+1)}return t}}function al(t,e){const s=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const s=(t.index?t.index.count:t.attributes.position.count)/3,i=s>65536,r=i?4:2,n=e?new SharedArrayBuffer(s*r):new ArrayBuffer(s*r),o=i?new Uint32Array(n):new Uint16Array(n);for(let t=0,e=o.length;t<e;t++)o[t]=t;return o}(s,e.useSharedArrayBuffer),function(t){if(0===t.groups.length)return!1;const e=Ha(t),s=Wa(t).sort(((t,e)=>t.offset-e.offset)),i=s[s.length-1];i.count=Math.min(e-i.offset,i.count);let r=0;return s.forEach((({count:t})=>r+=t)),e!==r}(s)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||ka(s,e);const i=ol(t,e);let r,n,o;const a=[],l=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<i.length;t++){const e=i[t];const s=new l(32*c(e));r=new Float32Array(s),n=new Uint32Array(s),o=new Uint16Array(s),h(0,e),a.push(s)}return void(t._roots=a);function c(t){return t.count?1:1+c(t.left)+c(t.right)}function h(t,e){const s=t/4,i=t/2,a=!!e.count,l=e.boundingData;for(let t=0;t<6;t++)r[s+t]=l[t];if(a){const r=e.offset,a=e.count;return n[s+6]=r,o[i+14]=a,o[i+15]=Ba,t+32}{const i=e.left,r=e.right,o=e.splitAxis;let a;if(a=h(t+32,i),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return n[s+6]=a/4,a=h(a,r),n[s+7]=o,a}}}class ll{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let r=0,n=t.length;r<n;r++){const n=t[r][e];s=n<s?n:s,i=n>i?n:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let r=0,n=e.length;r<n;r++){const n=e[r],o=t.dot(n);s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}ll.prototype.setFromBox=function(){const t=new bt;return function(e,s){const i=s.min,r=s.max;let n=1/0,o=-1/0;for(let s=0;s<=1;s++)for(let a=0;a<=1;a++)for(let l=0;l<=1;l++){t.x=i.x*s+r.x*(1-s),t.y=i.y*a+r.y*(1-a),t.z=i.z*l+r.z*(1-l);const c=e.dot(t);n=Math.min(c,n),o=Math.max(c,o)}this.min=n,this.max=o}}();const cl=function(){const t=new bt,e=new bt,s=new bt;return function(i,r,n){const o=i.start,a=t,l=r.start,c=e;s.subVectors(o,l),t.subVectors(i.end,i.start),e.subVectors(r.end,r.start);const h=s.dot(c),d=c.dot(a),u=c.dot(c),f=s.dot(a),p=a.dot(a)*u-d*d;let I,m;I=0!==p?(h*d-f*u)/p:0,m=(h+I*d)/u,n.x=I,n.y=m}}(),hl=function(){const t=new St,e=new bt,s=new bt;return function(i,r,n,o){cl(i,r,t);let a=t.x,l=t.y;if(a>=0&&a<=1&&l>=0&&l<=1)return i.at(a,n),void r.at(l,o);if(a>=0&&a<=1)return l<0?r.at(0,o):r.at(1,o),void i.closestPointToPoint(o,!0,n);if(l>=0&&l<=1)return a<0?i.at(0,n):i.at(1,n),void r.closestPointToPoint(n,!0,o);{let t,c;t=a<0?i.start:i.end,c=l<0?r.start:r.end;const h=e,d=s;return i.closestPointToPoint(c,!0,e),r.closestPointToPoint(t,!0,s),h.distanceToSquared(c)<=d.distanceToSquared(t)?(n.copy(h),void o.copy(c)):(n.copy(t),void o.copy(d))}}}(),dl=function(){const t=new bt,e=new bt,s=new vt,i=new Ot;return function(r,n){const{radius:o,center:a}=r,{a:l,b:c,c:h}=n;i.start=l,i.end=c;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;i.start=l,i.end=h;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;i.start=c,i.end=h;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;const d=n.getPlane(s);if(Math.abs(d.distanceToPoint(a))<=o){const t=d.projectPoint(a,e);if(n.containsPoint(t))return!0}return!1}}();function ul(t){return Math.abs(t)<1e-15}class fl extends Pt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new bt)),this.satBounds=new Array(4).fill().map((()=>new ll)),this.points=[this.a,this.b,this.c],this.sphere=new Tt,this.plane=new vt,this.needsUpdate=!0}intersectsSphere(t){return dl(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,r=this.satAxes,n=this.satBounds,o=r[0],a=n[0];this.getNormal(o),a.setFromPoints(o,i);const l=r[1],c=n[1];l.subVectors(t,e),c.setFromPoints(l,i);const h=r[2],d=n[2];h.subVectors(e,s),d.setFromPoints(h,i);const u=r[3],f=n[3];u.subVectors(s,t),f.setFromPoints(u,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}fl.prototype.closestPointToSegment=function(){const t=new bt,e=new bt,s=new Ot;return function(i,r=null,n=null){const{start:o,end:a}=i,l=this.points;let c,h=1/0;for(let o=0;o<3;o++){const a=(o+1)%3;s.start.copy(l[o]),s.end.copy(l[a]),hl(s,i,t,e),c=t.distanceToSquared(e),c<h&&(h=c,r&&r.copy(t),n&&n.copy(e))}return this.closestPointToPoint(o,t),c=o.distanceToSquared(t),c<h&&(h=c,r&&r.copy(t),n&&n.copy(o)),this.closestPointToPoint(a,t),c=a.distanceToSquared(t),c<h&&(h=c,r&&r.copy(t),n&&n.copy(a)),Math.sqrt(h)}}(),fl.prototype.intersectsTriangle=function(){const t=new fl,e=new Array(3),s=new Array(3),i=new ll,r=new ll,n=new bt,o=new bt,a=new bt,l=new bt,c=new bt,h=new Ot,d=new Ot,u=new Ot,f=new bt;function p(t,e,s){const i=t.points;let r=0,n=-1;for(let t=0;t<3;t++){const{start:a,end:l}=h;a.copy(i[t]),l.copy(i[(t+1)%3]),h.delta(o);const c=ul(e.distanceToPoint(a));if(ul(e.normal.dot(o))&&c){s.copy(h),r=2;break}const d=e.intersectLine(h,f);if(!d&&c&&f.copy(a),(d||c)&&!ul(f.distanceTo(l))){if(r<=1){(1===r?s.start:s.end).copy(f),c&&(n=r)}else if(r>=2){(1===n?s.start:s.end).copy(f),r=2;break}if(r++,2===r&&-1===n)break}}return r}return function(o,h=null,f=!1){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const I=this.plane,m=o.plane;if(Math.abs(I.normal.dot(m.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;s[0]=o.a,s[1]=o.b,s[2]=o.c;for(let e=0;e<4;e++){const r=t[e],n=a[e];if(i.setFromPoints(n,s),r.isSeparated(i))return!1}const l=o.satBounds,c=o.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const s=l[t],r=c[t];if(i.setFromPoints(r,e),s.isSeparated(i))return!1}for(let t=0;t<4;t++){const o=a[t];for(let t=0;t<4;t++){const a=c[t];if(n.crossVectors(o,a),i.setFromPoints(n,e),r.setFromPoints(n,s),i.isSeparated(r))return!1}}return h&&(f||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),h.start.set(0,0,0),h.end.set(0,0,0)),!0}{const t=p(this,m,d);if(1===t&&o.containsPoint(d.end))return h&&(h.start.copy(d.end),h.end.copy(d.end)),!0;if(2!==t)return!1;const e=p(o,I,u);if(1===e&&this.containsPoint(u.end))return h&&(h.start.copy(u.end),h.end.copy(u.end)),!0;if(2!==e)return!1;if(d.delta(a),u.delta(l),a.dot(l)<0){let t=u.start;u.start=u.end,u.end=t}const s=d.start.dot(a),i=d.end.dot(a),r=u.start.dot(a),n=u.end.dot(a);return(s===n||r===i||i<r!==s<n)&&(h&&(c.subVectors(d.start,u.start),c.dot(a)>0?h.start.copy(d.start):h.start.copy(u.start),c.subVectors(d.end,u.end),c.dot(a)<0?h.end.copy(d.end):h.end.copy(u.end)),!0)}}}(),fl.prototype.distanceToPoint=function(){const t=new bt;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),fl.prototype.distanceToTriangle=function(){const t=new bt,e=new bt,s=["a","b","c"],i=new Ot,r=new Ot;return function(n,o=null,a=null){const l=o||a?i:null;if(this.intersectsTriangle(n,l))return(o||a)&&(o&&l.getCenter(o),a&&l.getCenter(a)),0;let c=1/0;for(let e=0;e<3;e++){let i;const r=s[e],l=n[r];this.closestPointToPoint(l,t),i=l.distanceToSquared(t),i<c&&(c=i,o&&o.copy(t),a&&a.copy(l));const h=this[r];n.closestPointToPoint(h,t),i=h.distanceToSquared(t),i<c&&(c=i,o&&o.copy(h),a&&a.copy(t))}for(let l=0;l<3;l++){const h=s[l],d=s[(l+1)%3];i.set(this[h],this[d]);for(let l=0;l<3;l++){const h=s[l],d=s[(l+1)%3];r.set(n[h],n[d]),hl(i,r,t,e);const u=t.distanceToSquared(e);u<c&&(c=u,o&&o.copy(t),a&&a.copy(e))}}return Math.sqrt(c)}}();class pl{constructor(t,e,s){this.isOrientedBox=!0,this.min=new bt,this.max=new bt,this.matrix=new xt,this.invMatrix=new xt,this.points=new Array(8).fill().map((()=>new bt)),this.satAxes=new Array(3).fill().map((()=>new bt)),this.satBounds=new Array(3).fill().map((()=>new ll)),this.alignedSatBounds=new Array(3).fill().map((()=>new ll)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}pl.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let r=0;r<=1;r++)for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){const a=i[1*r|2*n|4*o];a.x=r?s.x:e.x,a.y=n?s.y:e.y,a.z=o?s.z:e.z,a.applyMatrix4(t)}const r=this.satBounds,n=this.satAxes,o=i[0];for(let t=0;t<3;t++){const e=n[t],s=r[t],a=i[1<<t];e.subVectors(o,a),s.setFromPoints(e,i)}const a=this.alignedSatBounds;a[0].setFromPointsField(i,"x"),a[1].setFromPointsField(i,"y"),a[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),pl.prototype.intersectsBox=function(){const t=new ll;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,r=this.satBounds,n=this.satAxes,o=this.alignedSatBounds;if(t.min=s.x,t.max=i.x,o[0].isSeparated(t))return!1;if(t.min=s.y,t.max=i.y,o[1].isSeparated(t))return!1;if(t.min=s.z,t.max=i.z,o[2].isSeparated(t))return!1;for(let s=0;s<3;s++){const i=n[s],o=r[s];if(t.setFromBox(i,e),o.isSeparated(t))return!1}return!0}}(),pl.prototype.intersectsTriangle=function(){const t=new fl,e=new Array(3),s=new ll,i=new ll,r=new bt;return function(n){this.needsUpdate&&this.update(),n.isExtendedTriangle?n.needsUpdate&&n.update():(t.copy(n),t.update(),n=t);const o=this.satBounds,a=this.satAxes;e[0]=n.a,e[1]=n.b,e[2]=n.c;for(let t=0;t<3;t++){const i=o[t],r=a[t];if(s.setFromPoints(r,e),i.isSeparated(s))return!1}const l=n.satBounds,c=n.satAxes,h=this.points;for(let t=0;t<3;t++){const e=l[t],i=c[t];if(s.setFromPoints(i,h),e.isSeparated(s))return!1}for(let t=0;t<3;t++){const n=a[t];for(let t=0;t<4;t++){const o=c[t];if(r.crossVectors(n,o),s.setFromPoints(r,e),i.setFromPoints(r,h),s.isSeparated(i))return!1}}return!0}}(),pl.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}(),pl.prototype.distanceToPoint=function(){const t=new bt;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),pl.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new Ot)),s=new Array(12).fill().map((()=>new Ot)),i=new bt,r=new bt;return function(n,o=0,a=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(n))return(a||l)&&(n.getCenter(r),this.closestPointToPoint(r,i),n.closestPointToPoint(i,r),a&&a.copy(i),l&&l.copy(r)),0;const c=o*o,h=n.min,d=n.max,u=this.points;let f=1/0;for(let t=0;t<8;t++){const e=u[t];r.copy(e).clamp(h,d);const s=e.distanceToSquared(r);if(s<f&&(f=s,a&&a.copy(e),l&&l.copy(r),s<c))return Math.sqrt(s)}let p=0;for(let i=0;i<3;i++)for(let r=0;r<=1;r++)for(let n=0;n<=1;n++){const o=(i+1)%3,a=(i+2)%3,l=1<<i|r<<o|n<<a,c=u[r<<o|n<<a],f=u[l];e[p].set(c,f);const I=t[i],m=t[o],E=t[a],_=s[p],g=_.start,C=_.end;g[I]=h[I],g[m]=r?h[m]:d[m],g[E]=n?h[E]:d[m],C[I]=d[I],C[m]=r?h[m]:d[m],C[E]=n?h[E]:d[m],p++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let s=0;s<=1;s++){r.x=t?d.x:h.x,r.y=e?d.y:h.y,r.z=s?d.z:h.z,this.closestPointToPoint(r,i);const n=r.distanceToSquared(i);if(n<f&&(f=n,a&&a.copy(i),l&&l.copy(r),n<c))return Math.sqrt(n)}for(let t=0;t<12;t++){const n=e[t];for(let t=0;t<12;t++){const e=s[t];hl(n,e,i,r);const o=i.distanceToSquared(r);if(o<f&&(f=o,a&&a.copy(i),l&&l.copy(r),o<c))return Math.sqrt(o)}}return Math.sqrt(f)}}();class Il{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ml extends Il{constructor(){super((()=>new fl))}}const El=new ml;function _l(t,e){return 65535===e[t+15]}function gl(t,e){return e[t+6]}function Cl(t,e){return e[t+14]}function Tl(t){return t+8}function bl(t,e){return e[t+6]}function Rl(t,e){return e[t+7]}const Al=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let yl,Sl;const Fl=[],wl=new Il((()=>new Ct));function Ll(t,e,s,i,r,n){yl=wl.getPrimitive(),Sl=wl.getPrimitive(),Fl.push(yl,Sl),Al.setBuffer(t._roots[e]);const o=Ol(0,t.geometry,s,i,r,n);Al.clearBuffer(),wl.releasePrimitive(yl),wl.releasePrimitive(Sl),Fl.pop(),Fl.pop();const a=Fl.length;return a>0&&(Sl=Fl[a-1],yl=Fl[a-2]),o}function Ol(t,e,s,i,r=null,n=0,o=0){const{float32Array:a,uint16Array:l,uint32Array:c}=Al;let h=2*t;if(_l(h,l)){const e=gl(t,c),s=Cl(h,l);return qa(t,a,yl),i(e,s,!1,o,n+t,yl)}{let h=function(t){const{uint16Array:e,uint32Array:s}=Al;let i=2*t;for(;!_l(i,e);)i=2*(t=Tl(t));return gl(t,s)},d=function(t){const{uint16Array:e,uint32Array:s}=Al;let i=2*t;for(;!_l(i,e);)i=2*(t=bl(t,s));return gl(t,s)+Cl(i,e)};const u=Tl(t),f=bl(t,c);let p,I,m,E,_=u,g=f;if(r&&(m=yl,E=Sl,qa(_,a,m),qa(g,a,E),p=r(m),I=r(E),I<p)){_=f,g=u;const t=p;p=I,I=t,m=E}m||(m=yl,qa(_,a,m));const C=s(m,_l(2*_,l),p,o+1,n+_);let T;if(2===C){const t=h(_);T=i(t,d(_)-t,!0,o+1,n+_,m)}else T=C&&Ol(_,e,s,i,r,n,o+1);if(T)return!0;E=Sl,qa(g,a,E);const b=s(E,_l(2*g,l),I,o+1,n+g);let R;if(2===b){const t=h(g);R=i(t,d(g)-t,!0,o+1,n+g,E)}else R=b&&Ol(g,e,s,i,r,n,o+1);return!!R}}const xl=new bt,Nl=new bt;const vl=new bt,Pl=new bt,Ml=new bt,Dl=new St,Ul=new St,Vl=new St,Bl=new bt,zl=new bt,Gl=new bt,Hl=new bt;function kl(t,e,s,i,r,n,o,a,l){vl.fromBufferAttribute(e,n),Pl.fromBufferAttribute(e,o),Ml.fromBufferAttribute(e,a);const c=function(t,e,s,i,r,n){let o;return o=n===Mt?t.intersectTriangle(i,s,e,!0,r):t.intersectTriangle(e,s,i,n!==Dt,r),null===o?null:{distance:t.origin.distanceTo(r),point:r.clone()}}(t,vl,Pl,Ml,Hl,l);if(c){i&&(Dl.fromBufferAttribute(i,n),Ul.fromBufferAttribute(i,o),Vl.fromBufferAttribute(i,a),c.uv=Pt.getInterpolation(Hl,vl,Pl,Ml,Dl,Ul,Vl,new St)),r&&(Dl.fromBufferAttribute(r,n),Ul.fromBufferAttribute(r,o),Vl.fromBufferAttribute(r,a),c.uv1=Pt.getInterpolation(Hl,vl,Pl,Ml,Dl,Ul,Vl,new St)),s&&(Bl.fromBufferAttribute(s,n),zl.fromBufferAttribute(s,o),Gl.fromBufferAttribute(s,a),c.normal=Pt.getInterpolation(Hl,vl,Pl,Ml,Bl,zl,Gl,new bt),c.normal.dot(t.direction)>0&&c.normal.multiplyScalar(-1));const e={a:n,b:o,c:a,normal:new bt,materialIndex:0};Pt.getNormal(vl,Pl,Ml,e.normal),c.face=e,c.faceIndex=n}return c}function Yl(t,e,s,i,r){const n=3*i;let o=n+0,a=n+1,l=n+2;const c=t.index;t.index&&(o=c.getX(o),a=c.getX(a),l=c.getX(l));const{position:h,normal:d,uv:u,uv1:f}=t.attributes,p=kl(s,h,d,u,f,o,a,l,e);return p?(p.faceIndex=i,r&&r.push(p),p):null}function Wl(t,e,s,i){const r=t.a,n=t.b,o=t.c;let a=e,l=e+1,c=e+2;s&&(a=s.getX(a),l=s.getX(l),c=s.getX(c)),r.x=i.getX(a),r.y=i.getY(a),r.z=i.getZ(a),n.x=i.getX(l),n.y=i.getY(l),n.z=i.getZ(l),o.x=i.getX(c),o.y=i.getY(c),o.z=i.getZ(c)}function ql(t,e,s,i,r,n,o){const{geometry:a}=s,{index:l}=a,c=a.attributes.position;for(let s=t,a=e+t;s<a;s++){let t;if(t=s,Wl(o,3*t,l,c),o.needsUpdate=!0,i(o,t,r,n))return!0}return!1}function jl(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const s=t.geometry,i=s.index?s.index.array:null,r=s.attributes.position;let n,o,a,l,c=0;const h=t._roots;for(let t=0,e=h.length;t<e;t++)n=h[t],o=new Uint32Array(n),a=new Uint16Array(n),l=new Float32Array(n),d(0,c),c+=n.byteLength;function d(t,s,n=!1){const c=2*t;if(a[c+15]===Ba){const e=o[t+6];let s=1/0,n=1/0,h=1/0,d=-1/0,u=-1/0,f=-1/0;for(let t=3*e,o=3*(e+a[c+14]);t<o;t++){let e=i[t];const o=r.getX(e),a=r.getY(e),l=r.getZ(e);o<s&&(s=o),o>d&&(d=o),a<n&&(n=a),a>u&&(u=a),l<h&&(h=l),l>f&&(f=l)}return(l[t+0]!==s||l[t+1]!==n||l[t+2]!==h||l[t+3]!==d||l[t+4]!==u||l[t+5]!==f)&&(l[t+0]=s,l[t+1]=n,l[t+2]=h,l[t+3]=d,l[t+4]=u,l[t+5]=f,!0)}{const i=t+8,r=o[t+6],a=i+s,c=r+s;let h=n,u=!1,f=!1;e?h||(u=e.has(a),f=e.has(c),h=!u&&!f):(u=!0,f=!0);const p=h||f;let I=!1;(h||u)&&(I=d(i,s,h));let m=!1;p&&(m=d(r,s,h));const E=I||m;if(E)for(let e=0;e<3;e++){const s=i+e,n=r+e,o=l[s],a=l[s+3],c=l[n],h=l[n+3];l[t+e]=o<c?o:c,l[t+e+3]=a>h?a:h}return E}}}const Xl=new Ct;function Zl(t,e,s,i){return qa(t,e,Xl),s.intersectBox(Xl,i)}function $l(t,e,s,i,r,n,o){const{geometry:a}=s,{index:l}=a,c=a.attributes.position;for(let a=t,h=e+t;a<h;a++){let t;if(t=s.resolveTriangleIndex(a),Wl(o,3*t,l,c),o.needsUpdate=!0,i(o,t,r,n))return!0}return!1}const Ql=new bt;function Kl(t,e,s,i,r){Al.setBuffer(t._roots[e]),Jl(0,t,s,i,r),Al.clearBuffer()}function Jl(t,e,s,i,r){const{float32Array:n,uint16Array:o,uint32Array:a}=Al,l=2*t;if(_l(l,o)){!function(t,e,s,i,r,n){const{geometry:o,_indirectBuffer:a}=t;for(let t=i,a=i+r;t<a;t++)Yl(o,e,s,t,n)}(e,s,i,gl(t,a),Cl(l,o),r)}else{const o=Tl(t);Zl(o,n,i,Ql)&&Jl(o,e,s,i,r);const l=bl(t,a);Zl(l,n,i,Ql)&&Jl(l,e,s,i,r)}}const tc=new bt,ec=["x","y","z"];function sc(t,e,s,i){Al.setBuffer(t._roots[e]);const r=ic(0,t,s,i);return Al.clearBuffer(),r}function ic(t,e,s,i){const{float32Array:r,uint16Array:n,uint32Array:o}=Al;let a=2*t;if(_l(a,n)){return function(t,e,s,i,r){const{geometry:n,_indirectBuffer:o}=t;let a=1/0,l=null;for(let t=i,o=i+r;t<o;t++){let i;i=Yl(n,e,s,t),i&&i.distance<a&&(l=i,a=i.distance)}return l}(e,s,i,gl(t,o),Cl(a,n))}{const n=Rl(t,o),a=ec[n],l=i.direction[a]>=0;let c,h;l?(c=Tl(t),h=bl(t,o)):(c=bl(t,o),h=Tl(t));const d=Zl(c,r,i,tc)?ic(c,e,s,i):null;if(d){const t=d.point[a];if(l?t<=r[h+n]:t>=r[h+n+3])return d}const u=Zl(h,r,i,tc)?ic(h,e,s,i):null;return d&&u?d.distance<=u.distance?d:u:d||u||null}}const rc=new Ct,nc=new fl,oc=new fl,ac=new xt,lc=new pl,cc=new pl;function hc(t,e,s,i){Al.setBuffer(t._roots[e]);const r=dc(0,t,s,i);return Al.clearBuffer(),r}function dc(t,e,s,i,r=null){const{float32Array:n,uint16Array:o,uint32Array:a}=Al;let l=2*t;null===r&&(s.boundingBox||s.computeBoundingBox(),lc.set(s.boundingBox.min,s.boundingBox.max,i),r=lc);if(!_l(l,o)){const o=t+8,l=a[t+6];qa(o,n,rc);if(r.intersectsBox(rc)&&dc(o,e,s,i,r))return!0;qa(l,n,rc);return!!(r.intersectsBox(rc)&&dc(l,e,s,i,r))}{const r=e.geometry,c=r.index,h=r.attributes.position,d=s.index,u=s.attributes.position,f=gl(t,a),p=Cl(l,o);if(ac.copy(i).invert(),s.boundsTree){qa(t,n,cc),cc.matrix.copy(ac),cc.needsUpdate=!0;return s.boundsTree.shapecast({intersectsBounds:t=>cc.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(i),t.b.applyMatrix4(i),t.c.applyMatrix4(i),t.needsUpdate=!0;for(let e=3*f,s=3*(p+f);e<s;e+=3)if(Wl(oc,e,c,h),oc.needsUpdate=!0,t.intersectsTriangle(oc))return!0;return!1}})}for(let t=3*f,e=3*(p+f);t<e;t+=3){Wl(nc,t,c,h),nc.a.applyMatrix4(ac),nc.b.applyMatrix4(ac),nc.c.applyMatrix4(ac),nc.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(Wl(oc,t,d,u),oc.needsUpdate=!0,nc.intersectsTriangle(oc))return!0}}}const uc=new xt,fc=new pl,pc=new pl,Ic=new bt,mc=new bt,Ec=new bt,_c=new bt;function gc(t,e,s,i={},r={},n=0,o=1/0){e.boundingBox||e.computeBoundingBox(),fc.set(e.boundingBox.min,e.boundingBox.max,s),fc.needsUpdate=!0;const a=t.geometry,l=a.attributes.position,c=a.index,h=e.attributes.position,d=e.index,u=El.getPrimitive(),f=El.getPrimitive();let p=Ic,I=mc,m=null,E=null;r&&(m=Ec,E=_c);let _=1/0,g=null,C=null;return uc.copy(s).invert(),pc.matrix.copy(uc),t.shapecast({boundsTraverseOrder:t=>fc.distanceToBox(t),intersectsBounds:(t,e,s)=>s<_&&s<o&&(e&&(pc.min.copy(t.min),pc.max.copy(t.max),pc.needsUpdate=!0),!0),intersectsRange:(t,i)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>pc.distanceToBox(t),intersectsBounds:(t,e,s)=>s<_&&s<o,intersectsRange:(e,r)=>{for(let o=e,a=e+r;o<a;o++){Wl(f,3*o,d,h),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=t,s=t+i;e<s;e++){Wl(u,3*e,c,l),u.needsUpdate=!0;const t=u.distanceToTriangle(f,p,m);if(t<_&&(I.copy(p),E&&E.copy(m),_=t,g=e,C=o),t<n)return!0}}}})}for(let r=0,o=Ha(e);r<o;r++){Wl(f,3*r,d,h),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=t,s=t+i;e<s;e++){Wl(u,3*e,c,l),u.needsUpdate=!0;const t=u.distanceToTriangle(f,p,m);if(t<_&&(I.copy(p),E&&E.copy(m),_=t,g=e,C=r),t<n)return!0}}}}),El.releasePrimitive(u),El.releasePrimitive(f),_===1/0?null:(i.point?i.point.copy(I):i.point=I.clone(),i.distance=_,i.faceIndex=g,r&&(r.point?r.point.copy(E):r.point=E.clone(),r.point.applyMatrix4(uc),I.applyMatrix4(uc),r.distance=I.sub(r.point).length(),r.faceIndex=C),i)}function Cc(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const s=t.geometry,i=s.index?s.index.array:null,r=s.attributes.position;let n,o,a,l,c=0;const h=t._roots;for(let t=0,e=h.length;t<e;t++)n=h[t],o=new Uint32Array(n),a=new Uint16Array(n),l=new Float32Array(n),d(0,c),c+=n.byteLength;function d(s,n,c=!1){const h=2*s;if(a[h+15]===Ba){const e=o[s+6];let n=1/0,c=1/0,d=1/0,u=-1/0,f=-1/0,p=-1/0;for(let s=e,o=e+a[h+14];s<o;s++){const e=3*t.resolveTriangleIndex(s);for(let t=0;t<3;t++){let s=e+t;s=i?i[s]:s;const o=r.getX(s),a=r.getY(s),l=r.getZ(s);o<n&&(n=o),o>u&&(u=o),a<c&&(c=a),a>f&&(f=a),l<d&&(d=l),l>p&&(p=l)}}return(l[s+0]!==n||l[s+1]!==c||l[s+2]!==d||l[s+3]!==u||l[s+4]!==f||l[s+5]!==p)&&(l[s+0]=n,l[s+1]=c,l[s+2]=d,l[s+3]=u,l[s+4]=f,l[s+5]=p,!0)}{const t=s+8,i=o[s+6],r=t+n,a=i+n;let h=c,u=!1,f=!1;e?h||(u=e.has(r),f=e.has(a),h=!u&&!f):(u=!0,f=!0);const p=h||f;let I=!1;(h||u)&&(I=d(t,n,h));let m=!1;p&&(m=d(i,n,h));const E=I||m;if(E)for(let e=0;e<3;e++){const r=t+e,n=i+e,o=l[r],a=l[r+3],c=l[n],h=l[n+3];l[s+e]=o<c?o:c,l[s+e+3]=a>h?a:h}return E}}}const Tc=new bt;function bc(t,e,s,i,r){Al.setBuffer(t._roots[e]),Rc(0,t,s,i,r),Al.clearBuffer()}function Rc(t,e,s,i,r){const{float32Array:n,uint16Array:o,uint32Array:a}=Al,l=2*t;if(_l(l,o)){!function(t,e,s,i,r,n){const{geometry:o,_indirectBuffer:a}=t;for(let t=i,l=i+r;t<l;t++)Yl(o,e,s,a?a[t]:t,n)}(e,s,i,gl(t,a),Cl(l,o),r)}else{const o=Tl(t);Zl(o,n,i,Tc)&&Rc(o,e,s,i,r);const l=bl(t,a);Zl(l,n,i,Tc)&&Rc(l,e,s,i,r)}}const Ac=new bt,yc=["x","y","z"];function Sc(t,e,s,i){Al.setBuffer(t._roots[e]);const r=Fc(0,t,s,i);return Al.clearBuffer(),r}function Fc(t,e,s,i){const{float32Array:r,uint16Array:n,uint32Array:o}=Al;let a=2*t;if(_l(a,n)){return function(t,e,s,i,r){const{geometry:n,_indirectBuffer:o}=t;let a=1/0,l=null;for(let t=i,c=i+r;t<c;t++){let i;i=Yl(n,e,s,o?o[t]:t),i&&i.distance<a&&(l=i,a=i.distance)}return l}(e,s,i,gl(t,o),Cl(a,n))}{const n=Rl(t,o),a=yc[n],l=i.direction[a]>=0;let c,h;l?(c=Tl(t),h=bl(t,o)):(c=bl(t,o),h=Tl(t));const d=Zl(c,r,i,Ac)?Fc(c,e,s,i):null;if(d){const t=d.point[a];if(l?t<=r[h+n]:t>=r[h+n+3])return d}const u=Zl(h,r,i,Ac)?Fc(h,e,s,i):null;return d&&u?d.distance<=u.distance?d:u:d||u||null}}const wc=new Ct,Lc=new fl,Oc=new fl,xc=new xt,Nc=new pl,vc=new pl;function Pc(t,e,s,i){Al.setBuffer(t._roots[e]);const r=Mc(0,t,s,i);return Al.clearBuffer(),r}function Mc(t,e,s,i,r=null){const{float32Array:n,uint16Array:o,uint32Array:a}=Al;let l=2*t;null===r&&(s.boundingBox||s.computeBoundingBox(),Nc.set(s.boundingBox.min,s.boundingBox.max,i),r=Nc);if(!_l(l,o)){const o=t+8,l=a[t+6];qa(o,n,wc);if(r.intersectsBox(wc)&&Mc(o,e,s,i,r))return!0;qa(l,n,wc);return!!(r.intersectsBox(wc)&&Mc(l,e,s,i,r))}{const r=e.geometry,c=r.index,h=r.attributes.position,d=s.index,u=s.attributes.position,f=gl(t,a),p=Cl(l,o);if(xc.copy(i).invert(),s.boundsTree){qa(t,n,vc),vc.matrix.copy(xc),vc.needsUpdate=!0;return s.boundsTree.shapecast({intersectsBounds:t=>vc.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(i),t.b.applyMatrix4(i),t.c.applyMatrix4(i),t.needsUpdate=!0;for(let s=f,i=p+f;s<i;s++)if(Wl(Oc,3*e.resolveTriangleIndex(s),c,h),Oc.needsUpdate=!0,t.intersectsTriangle(Oc))return!0;return!1}})}for(let t=f,s=p+f;t<s;t++){const s=e.resolveTriangleIndex(t);Wl(Lc,3*s,c,h),Lc.a.applyMatrix4(xc),Lc.b.applyMatrix4(xc),Lc.c.applyMatrix4(xc),Lc.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(Wl(Oc,t,d,u),Oc.needsUpdate=!0,Lc.intersectsTriangle(Oc))return!0}}}const Dc=new xt,Uc=new pl,Vc=new pl,Bc=new bt,zc=new bt,Gc=new bt,Hc=new bt;function kc(t,e,s,i={},r={},n=0,o=1/0){e.boundingBox||e.computeBoundingBox(),Uc.set(e.boundingBox.min,e.boundingBox.max,s),Uc.needsUpdate=!0;const a=t.geometry,l=a.attributes.position,c=a.index,h=e.attributes.position,d=e.index,u=El.getPrimitive(),f=El.getPrimitive();let p=Bc,I=zc,m=null,E=null;r&&(m=Gc,E=Hc);let _=1/0,g=null,C=null;return Dc.copy(s).invert(),Vc.matrix.copy(Dc),t.shapecast({boundsTraverseOrder:t=>Uc.distanceToBox(t),intersectsBounds:(t,e,s)=>s<_&&s<o&&(e&&(Vc.min.copy(t.min),Vc.max.copy(t.max),Vc.needsUpdate=!0),!0),intersectsRange:(i,r)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>Vc.distanceToBox(t),intersectsBounds:(t,e,s)=>s<_&&s<o,intersectsRange:(e,o)=>{for(let T=e,b=e+o;T<b;T++){const e=a.resolveTriangleIndex(T);Wl(f,3*e,d,h),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=i,s=i+r;e<s;e++){const s=t.resolveTriangleIndex(e);Wl(u,3*s,c,l),u.needsUpdate=!0;const i=u.distanceToTriangle(f,p,m);if(i<_&&(I.copy(p),E&&E.copy(m),_=i,g=e,C=T),i<n)return!0}}}})}for(let o=0,a=Ha(e);o<a;o++){Wl(f,3*o,d,h),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=i,s=i+r;e<s;e++){const s=t.resolveTriangleIndex(e);Wl(u,3*s,c,l),u.needsUpdate=!0;const i=u.distanceToTriangle(f,p,m);if(i<_&&(I.copy(p),E&&E.copy(m),_=i,g=e,C=o),i<n)return!0}}}}),El.releasePrimitive(u),El.releasePrimitive(f),_===1/0?null:(i.point?i.point.copy(I):i.point=I.clone(),i.distance=_,i.faceIndex=g,r&&(r.point?r.point.copy(E):r.point=E.clone(),r.point.applyMatrix4(Dc),I.applyMatrix4(Dc),r.distance=I.sub(r.point).length(),r.faceIndex=C),i)}const Yc=new Al.constructor,Wc=new Al.constructor,qc=new Il((()=>new Ct)),jc=new Ct,Xc=new Ct,Zc=new Ct,$c=new Ct;let Qc=!1;function Kc(t,e,s,i,r,n=0,o=0,a=0,l=0,c=null,h=!1){let d,u;h?(d=Wc,u=Yc):(d=Yc,u=Wc);const f=d.float32Array,p=d.uint32Array,I=d.uint16Array,m=u.float32Array,E=u.uint32Array,_=u.uint16Array,g=2*e,C=_l(2*t,I),T=_l(g,_);let b=!1;if(T&&C)b=h?r(gl(e,E),Cl(2*e,_),gl(t,p),Cl(2*t,I),l,o+e,a,n+t):r(gl(t,p),Cl(2*t,I),gl(e,E),Cl(2*e,_),a,n+t,l,o+e);else if(T){const c=qc.getPrimitive();qa(e,m,c),c.applyMatrix4(s);const d=Tl(t),u=bl(t,p);qa(d,f,jc),qa(u,f,Xc);const I=c.intersectsBox(jc),E=c.intersectsBox(Xc);b=I&&Kc(e,d,i,s,r,o,n,l,a+1,c,!h)||E&&Kc(e,u,i,s,r,o,n,l,a+1,c,!h),qc.releasePrimitive(c)}else{const d=Tl(e),u=bl(e,E);qa(d,m,Zc),qa(u,m,$c);const I=c.intersectsBox(Zc),_=c.intersectsBox($c);if(I&&_)b=Kc(t,d,s,i,r,n,o,a,l+1,c,h)||Kc(t,u,s,i,r,n,o,a,l+1,c,h);else if(I)if(C)b=Kc(t,d,s,i,r,n,o,a,l+1,c,h);else{const e=qc.getPrimitive();e.copy(Zc).applyMatrix4(s);const c=Tl(t),u=bl(t,p);qa(c,f,jc),qa(u,f,Xc);const I=e.intersectsBox(jc),m=e.intersectsBox(Xc);b=I&&Kc(d,c,i,s,r,o,n,l,a+1,e,!h)||m&&Kc(d,u,i,s,r,o,n,l,a+1,e,!h),qc.releasePrimitive(e)}else if(_)if(C)b=Kc(t,u,s,i,r,n,o,a,l+1,c,h);else{const e=qc.getPrimitive();e.copy($c).applyMatrix4(s);const c=Tl(t),d=bl(t,p);qa(c,f,jc),qa(d,f,Xc);const I=e.intersectsBox(jc),m=e.intersectsBox(Xc);b=I&&Kc(u,c,i,s,r,o,n,l,a+1,e,!h)||m&&Kc(u,d,i,s,r,o,n,l,a+1,e,!h),qc.releasePrimitive(e)}}return b}const Jc=new pl,th=new Ct;class eh{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,r=t._indirectBuffer,n=s.getIndex();let o;return o=e.cloneBuffers?{roots:i.map((t=>t.slice())),index:n.array.slice(),indirectBuffer:r?r.slice():null}:{roots:i,index:n.array,indirectBuffer:r},o}static deserialize(t,e,s={}){s={setIndex:!0,indirect:Boolean(t.indirectBuffer),...s};const{index:i,roots:r,indirectBuffer:n}=t,o=new eh(e,{...s,[Ga]:!0});if(o._roots=r,o._indirectBuffer=n||null,s.setIndex){const s=e.getIndex();if(null===s){const s=new Nt(t.index,1,!1);e.setIndex(s)}else s.array!==i&&(s.array.set(i),s.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Ga]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Ga]||(al(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Ct)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?t=>s[t]:t=>t}refit(t=null){return(this.indirect?Cc:jl)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),r=new Uint16Array(s);!function e(n,o=0){const a=2*n,l=r[a+15]===Ba;if(l){const e=i[n+6],c=r[a+14];t(o,l,new Float32Array(s,4*n,6),e,c)}else{const r=n+8,a=i[n+6],c=i[n+7];t(o,l,new Float32Array(s,4*n,6),c)||(e(r,o+1),e(a,o+1))}}(0)}raycast(t,e=Ut){const s=this._roots,i=this.geometry,r=[],n=e.isMaterial,o=Array.isArray(e),a=i.groups,l=n?e.side:e,c=this.indirect?bc:Kl;for(let i=0,n=s.length;i<n;i++){const s=o?e[a[i].materialIndex].side:l,n=r.length;if(c(this,i,s,t,r),o){const t=a[i].materialIndex;for(let e=n,s=r.length;e<s;e++)r[e].face.materialIndex=t}}return r}raycastFirst(t,e=Ut){const s=this._roots,i=this.geometry,r=e.isMaterial,n=Array.isArray(e);let o=null;const a=i.groups,l=r?e.side:e,c=this.indirect?Sc:sc;for(let i=0,r=s.length;i<r;i++){const s=c(this,i,n?e[a[i].materialIndex].side:l,t);null!=s&&(null==o||s.distance<o.distance)&&(o=s,n&&(s.face.materialIndex=a[i].materialIndex))}return o}intersectsGeometry(t,e){let s=!1;const i=this._roots,r=this.indirect?Pc:hc;for(let n=0,o=i.length;n<o&&(s=r(this,n,t,e),!s);n++);return s}shapecast(t){const e=El.getPrimitive(),s=this.indirect?$l:ql;let{boundsTraverseOrder:i,intersectsBounds:r,intersectsRange:n,intersectsTriangle:o}=t;if(n&&o){const t=n;n=(i,r,n,a,l)=>!!t(i,r,n,a,l)||s(i,r,this,o,n,a,e)}else n||(n=o?(t,i,r,n)=>s(t,i,this,o,r,n,e):(t,e,s)=>s);let a=!1,l=0;const c=this._roots;for(let t=0,e=c.length;t<e;t++){const e=c[t];if(a=Ll(this,t,r,n,i,l),a)break;l+=e.byteLength}return El.releasePrimitive(e),a}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const n=El.getPrimitive(),o=this.geometry.index,a=this.geometry.attributes.position,l=this.indirect?t=>{const e=this.resolveTriangleIndex(t);Wl(n,3*e,o,a)}:t=>{Wl(n,3*t,o,a)},c=El.getPrimitive(),h=t.geometry.index,d=t.geometry.attributes.position,u=t.indirect?e=>{const s=t.resolveTriangleIndex(e);Wl(c,3*s,h,d)}:t=>{Wl(c,3*t,h,d)};if(r){const t=(t,s,i,o,a,h,d,f)=>{for(let p=i,I=i+o;p<I;p++){u(p),c.a.applyMatrix4(e),c.b.applyMatrix4(e),c.c.applyMatrix4(e),c.needsUpdate=!0;for(let e=t,i=t+s;e<i;e++)if(l(e),n.needsUpdate=!0,r(n,c,e,p,a,h,d,f))return!0}return!1};if(i){const e=i;i=function(s,i,r,n,o,a,l,c){return!!e(s,i,r,n,o,a,l,c)||t(s,i,r,n,o,a,l,c)}}else i=t}return function(t,e,s,i){if(Qc)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Qc=!0;const r=t._roots,n=e._roots;let o,a=0,l=0;const c=(new xt).copy(s).invert();for(let t=0,e=r.length;t<e;t++){Yc.setBuffer(r[t]),l=0;const e=qc.getPrimitive();qa(0,Yc.float32Array,e),e.applyMatrix4(c);for(let r=0,h=n.length;r<h&&(Wc.setBuffer(n[t]),o=Kc(0,0,s,c,i,a,l,0,0,e),Wc.clearBuffer(),l+=n[r].length,!o);r++);if(qc.releasePrimitive(e),Yc.clearBuffer(),a+=r[t].length,o)break}return Qc=!1,o}(this,t,e,i)}intersectsBox(t,e){return Jc.set(t.min,t.max,e),Jc.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Jc.intersectsBox(t),intersectsTriangle:t=>Jc.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},r=0,n=1/0){return(this.indirect?kc:gc)(this,t,e,s,i,r,n)}closestPointToPoint(t,e={},s=0,i=1/0){return function(t,e,s={},i=0,r=1/0){const n=i*i,o=r*r;let a=1/0,l=null;if(t.shapecast({boundsTraverseOrder:t=>(xl.copy(e).clamp(t.min,t.max),xl.distanceToSquared(e)),intersectsBounds:(t,e,s)=>s<a&&s<o,intersectsTriangle:(t,s)=>{t.closestPointToPoint(e,xl);const i=e.distanceToSquared(xl);return i<a&&(Nl.copy(xl),a=i,l=s),i<n}}),a===1/0)return null;const c=Math.sqrt(a);return s.point?s.point.copy(Nl):s.point=Nl.clone(),s.distance=c,s.faceIndex=l,s}(this,t,e,s,i)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{qa(0,new Float32Array(e),th),t.union(th)})),t}}function sh(t,e,s){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(s.ray.origin),t.object=e,t.distance<s.near||t.distance>s.far?null:t)}const ih=new Vt,rh=new xt,nh=wt.prototype.raycast;function oh(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;rh.copy(this.matrixWorld).invert(),ih.copy(t.ray).applyMatrix4(rh);const s=this.geometry.boundsTree;if(!0===t.firstHitOnly){const i=sh(s.raycastFirst(ih,this.material),this,t);i&&e.push(i)}else{const i=s.raycast(ih,this.material);for(let s=0,r=i.length;s<r;s++){const r=sh(i[s],this,t);r&&e.push(r)}}}else nh.call(this,t,e)}function ah(t){return this.boundsTree=new eh(this,t),this.boundsTree}function lh(){this.boundsTree=null}class ch{constructor(t,e){ot(this,"meshes"),ot(this,"_templateController",new xd),ot(this,"_meshIds",new Set),ot(this,"_idGenerator",new go),ot(this,"_modelCode"),this.meshes=e,this._modelCode=this.getModelCode(t)}dispose(){Ad.delete(this._meshIds)}useMesh(t,e,s){const i=this.meshCode(t,s);Ad.lockIn(e),this._templateController.add(i,e)}getMesh(t,e){const s=this.meshCode(t,e);return Ad.get(s)??this._templateController.get(s)}saveMesh(t,e,s){bo.forEach(e,Ad.updateMeshMemory);const i=this.meshCode(t,s);Ad.add(i,e),this._meshIds.add(i)}meshCode(t,e){const s=[this._modelCode,this.getRepresentation(),e,t];return this._idGenerator.generate(s)}getModelCode(t){return this._idGenerator.generate([t])}}const hh=32767;var dh=(t=>(t[t.NONE=0]="NONE",t[t.AABB=1]="AABB",t[t.CUSTOM=2]="CUSTOM",t))(dh||{});const uh=class t{static getProfile(t,e,s){return t.type()===vr.BIG?t.bigProfiles(e,s):t.profiles(e,s)}static getPoints(t){const e=new Float32Array(3*t.pointsLength());for(let s=0;s<t.pointsLength();s++)t.points(s,this._tempPoint),e[3*s]=this._tempPoint.x(),e[3*s+1]=this._tempPoint.y(),e[3*s+2]=this._tempPoint.z();return e}static getProfileIndices(e,s){const i=e.type()===vr.BIG,r={outer:[],inners:[]},n=i?e.bigHolesLength():e.holesLength(),o=i?"bigHoles":"holes",a=t.getProfile(e,s);r.outer=Array.from(a.indicesArray());for(let t=0;t<n;t++){const i=e[o](t);if(i.profileId()===s){const t=Array.from(i.indicesArray());r.inners.push(t)}}return r}static getHole(t,e,s){return t.type()===vr.BIG?t.bigHoles(e,s):t.holes(e,s)}static getProfilesLength(t){return t.type()===vr.BIG?t.bigProfilesLength():t.profilesLength()}static getHolesLength(t){return t.type()===vr.BIG?t.bigHolesLength():t.holesLength()}static getShell(t,e){return t.shells(e,this._shell)}static point(t,e,s){t instanceof Pr&&t.points(e,this._tempPoint);const i=this._tempPoint.x(),r=this._tempPoint.y(),n=this._tempPoint.z();s.set(i,r,n)}static getNormalsOfShellProfile(e,s){const i=t.getProfilesLength(e);for(let r=0;r<i;r++){const i=t.getProfile(e,r),n=this.fetchNormalsOfProfile(e,i);s.push(n)}return s}static computeNormalsAvg(t,e,s,i){this.setupNormalBuffer(t);const r=s[e];for(let e=0;e<t.length;e++){const n=t[e],o=i.get(n);this.aggregateNormals(o,s,r),this.computeAvgNormal(e)}return this._normalBuffer}static getBuffer(t){const e=t.bb,s=e.__offset(t.bb_pos,8),i=3*t.pointsLength(),r=e.__vector(t.bb_pos+s),n=e.bytes().buffer;return new Float32Array(n,r,i)}static getPointsShell(e){return this._pointsByProfile.clear(),this.fetchAllPointsByProfile(e),t.fetchAllPointsByHole(e),this._pointsByProfile}static addNormals(t,e,s){for(const i of t){const t=e[i];s.dot(t)>this._faceThreshold&&this._tempNormal.add(t)}}static setupNormalBuffer(t){const e=3*t.length;this._normalBuffer.length<e&&(this._normalBuffer=new Int16Array(e))}static fetchNormalsOfProfile(t,e){const s=e.indicesLength();return this.isTooSmall(t,s)?new ft.Vector3(1,0,0):this.computeProfileNormal(s,e,t)}static fetchAllPointsByHole(e){const s=t.getHolesLength(e),i=this.getTempHole(e);for(let r=0;r<s;r++){t.getHole(e,r,i);const s=i.profileId(),n=i.indicesLength();for(let e=0;e<n;e++){const r=i.indices(e);t.savePointByProfile(r,s)}}}static computeProfileNormal(t,e,s){this._v3.set(0,0,0);for(let i=0;i<t;i++)this.fetchPointsForNormal(i,t,e,s),this.computeProfilePointNormal();const i=this._v3.clone();return i.normalize(),i}static computeProfilePointNormal(){const t=this._v1.x-this._v2.x,e=this._v1.y-this._v2.y,s=this._v1.z-this._v2.z,i=this._v1.x+this._v2.x,r=this._v1.y+this._v2.y,n=this._v1.z+this._v2.z;this._v3.x+=e*n,this._v3.y+=s*i,this._v3.z+=t*r}static aggregateNormals(e,s,i){this._tempNormal.set(0,0,0);if(!e||!e.length)return void this._tempNormal.set(1,0,0);if(1===e.length){const t=e[0];this._tempNormal=s[t].clone()}else t.addNormals(e,s,i)}static fetchPointsForNormal(t,e,s,i){const r=(t+1)%e,n=s.indices(t),o=s.indices(r);this.point(i,n,this._v1),this.point(i,o,this._v2)}static savePointByProfile(t,e){this._pointsByProfile.has(t)||this._pointsByProfile.set(t,[]),this._pointsByProfile.get(t).push(e)}static isTooSmall(t,e){return t.pointsLength()<=2||e<=2}static fetchAllPointsByProfile(e){const s=this.getProfilesLength(e),i=this.getTempProfile(e);for(let r=0;r<s;r++){t.getProfile(e,r,i);const s=i.indicesLength();for(let e=0;e<s;e++){const s=i.indices(e);t.savePointByProfile(s,r)}}}static computeAvgNormal(t){this._tempNormal.normalize(),this._tempNormal.multiplyScalar(hh),this._tempNormal.toArray(this._normalBuffer,3*t)}static getTempProfile(t){return t.type()===vr.BIG?this._bigShellProfile:this._shellProfile}static getTempHole(t){return t.type()===vr.BIG?this._bigShellHole:this._shellHole}};ot(uh,"_faceThreshold",Math.cos(Math.PI/8)),ot(uh,"_shell",new Pr),ot(uh,"_normalBuffer",new Int16Array),ot(uh,"_tempNormal",new ft.Vector3),ot(uh,"_tempPoint",new Er),ot(uh,"_shellProfile",new Nr),ot(uh,"_bigShellProfile",new Ar),ot(uh,"_shellHole",new xr),ot(uh,"_bigShellHole",new Rr),ot(uh,"_pointsByProfile",new Map),ot(uh,"_v1",new ft.Vector3),ot(uh,"_v2",new ft.Vector3),ot(uh,"_v3",new ft.Vector3);let fh=uh;class ph{constructor(){ot(this,"_shellHole",new xr),ot(this,"_bigShellHole",new Rr),ot(this,"holePoints",0),ot(this,"profilePoints",0),ot(this,"triangleAmount",0),ot(this,"indexCount",0),ot(this,"meshes",[]),ot(this,"_shellProfile",new Nr),ot(this,"_bigShellProfile",new Ar)}newMeshTemplate(t){return this.getIsEmpty(t)?{objectClass:On.SHELL}:(this.reset(!0),this.processShell(t),this.getResult())}manageDataLeft(){this.getIsDataLeft()&&this.setMesh()}getIsEmpty(t){return 0===fh.getProfilesLength(t)}processShellHoles(t,e){let s=!1;const i=fh.getHolesLength(t),r=this.getTempHole(t);for(let n=0;n<i;n++){fh.getHole(t,n,r);r.profileId()===e&&(this.updateBuffers(t,s),s=!0)}this.manageFoundHoles(t,s)}newMesh(){return{objectClass:On.SHELL,indexCount:3*this.triangleAmount,positionCount:3*(this.holePoints+this.profilePoints),normalCount:3*(this.holePoints+this.profilePoints)}}reset(t){this.holePoints=0,this.profilePoints=0,this.triangleAmount=0,t&&(this.meshes=void 0)}getIsDataLeft(){const t=this.triangleAmount>0,e=this.holePoints>0,s=this.profilePoints>0;return t||e||s}processShell(t){const e=fh.getProfilesLength(t),s=this.getTempProfile(t);for(let i=0;i<e;i++)fh.getProfile(t,i,s),this.indexCount=s.indicesLength(),this.profilePoints+=this.indexCount,this.processShellHoles(t,i),this.manageMemory();this.manageDataLeft()}manageFoundHoles(t,e){const s=this.getTempProfile(t).indicesLength();e?this.triangleAmount+=s:s>2&&(this.triangleAmount+=s-2)}getResult(){const t=this.meshes;return this.meshes=void 0,t}manageMemory(){this.holePoints+this.profilePoints+this.indexCount>Ln&&this.setMesh()}updateBuffers(t,e){const s=this.getTempHole(t);this.holePoints+=s.indicesLength(),this.triangleAmount+=s.indicesLength(),e&&(this.triangleAmount+=2)}setMesh(){const t=this.newMesh();this.meshes?Array.isArray(this.meshes)?this.meshes.push(t):this.meshes=[this.meshes,t]:this.meshes=t,this.reset(!1)}getTempProfile(t){return t.type()===vr.BIG?this._bigShellProfile:this._shellProfile}getTempHole(t){return t.type()===vr.BIG?this._bigShellHole:this._shellHole}}var Ih=(t=>(t[t.four=4]="four",t[t.three=3]="three",t))(Ih||{});function mh(t,e,s,i,r,n){const o=e&&e.length,a=o?e[0]*s:t.length;let l,c,h,d=Eh(t,0,a,s,!0,i,r);if(d&&d.next!==d.prev){if(o&&(d=function(t,e,s,i,r,n){const o=[];for(let s=0,a=e.length;s<a;s++){const l=Eh(t,e[s]*i,s<a-1?e[s+1]*i:t.length,i,!1,r,n);l===l.next&&(l.steiner=!0),o.push(wh(l))}o.sort(Ah);for(let t=0;t<o.length;t++)s=_h(s=yh(o[t],s),s.next);return s}(t,e,d,s,i,r)),t.length>80*s){let e=t[i],n=t[r];l=e,c=n;for(let o=s;o<a;o+=s){const s=t[o+i],a=t[o+r];s<l&&(l=s),a<c&&(c=a),s>e&&(e=s),a>n&&(n=a)}h=Math.max(e-l,n-c),h=0!==h?1/h:0}gh(d,n,s,l,c,h)}}function Eh(t,e,s,i,r,n,o){let a,l,c;if(r===function(t,e,s,i,r,n){let o=0;for(let a=e,l=s-i;a<s;a+=i)o+=(t[l+r]-t[a+r])*(t[a+n]+t[l+n]),l=a;return o}(t,e,s,i,n,o)>0)for(c=e;c<s;c+=i)a=Vh(c,t[c+n],t[c+o],a);else for(c=s-i;c>=e;c-=i)a=Vh(c,t[c+n],t[c+o],a);return a&&Nh(a,a.next)&&(l=a.next,Bh(a),a=l),a}function _h(t,e){if(!t)return t;e||(e=t);let s,i,r=t;do{if(s=!1,r.steiner||!Nh(r,r.next)&&0!==xh(r.prev,r,r.next))r=r.next;else{if(i=r.prev,Bh(r),r=e=i,r===r.next)break;s=!0}}while(s||r!==e);return e}function gh(t,e,s,i,r,n,o){!o&&n&&function(t,e,s,i){let r=t;do{null===r.z&&(r.z=Fh(r.x,r.y,e,s,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){let e,s=1;do{let i,r=t;t=null;let n=null;for(e=0;r;){e++;let o=r,a=0;for(let t=0;t<s&&(a++,o=o.nextZ,o);t++);let l=s;for(;a>0||l>0&&o;)0!==a&&(0===l||!o||r.z<=o.z)?(i=r,r=r.nextZ,a--):(i=o,o=o.nextZ,l--),n?n.nextZ=i:t=i,i.prevZ=n,n=i;r=o}n.nextZ=null,s*=2}while(e>1)}(r)}(t,i,r,n);let a=t;for(;t.prev!==t.next;){const l=t.prev,c=t.next;if(n?Th(t,i,r,n):Ch(t))e(l.i/s,t.i/s,c.i/s),Bh(t),t=c.next,a=c.next;else if((t=c)===a){o?1===o?gh(t=bh(_h(t),e,s),e,s,i,r,n,2):2===o&&Rh(t,e,s,i,r,n):gh(_h(t),e,s,i,r,n,1);break}}}function Ch(t){const e=t.prev,s=t,i=t.next;if(xh(e,s,i)>=0)return!1;let r=t.next.next;for(;r!==t.prev;){if(Lh(e.x,e.y,s.x,s.y,i.x,i.y,r.x,r.y)&&xh(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function Th(t,e,s,i){const r=t.prev,n=t,o=t.next;if(xh(r,n,o)>=0)return!1;const a=Math.min(r.x,n.x,o.x),l=Math.min(r.y,n.y,o.y),c=Math.max(r.x,n.x,o.x),h=Math.max(r.y,n.y,o.y),d=Fh(a,l,e,s,i),u=Fh(c,h,e,s,i);let f=t.prevZ,p=t.nextZ;for(;f&&f.z>=d&&p&&p.z<=u;){if(f!==t.prev&&f!==t.next&&Lh(r.x,r.y,n.x,n.y,o.x,o.y,f.x,f.y)&&xh(f.prev,f,f.next)>=0)return!1;if(f=f.prevZ,p!==t.prev&&p!==t.next&&Lh(r.x,r.y,n.x,n.y,o.x,o.y,p.x,p.y)&&xh(p.prev,p,p.next)>=0)return!1;p=p.nextZ}for(;f&&f.z>=d;){if(f!==t.prev&&f!==t.next&&Lh(r.x,r.y,n.x,n.y,o.x,o.y,f.x,f.y)&&xh(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;p&&p.z<=u;){if(p!==t.prev&&p!==t.next&&Lh(r.x,r.y,n.x,n.y,o.x,o.y,p.x,p.y)&&xh(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function bh(t,e,s){let i=t;do{const r=i.prev,n=i.next.next;!Nh(r,n)&&vh(r,i,i.next,n)&&Dh(r,n)&&Dh(n,r)&&(e(r.i/s,i.i/s,n.i/s),Bh(i.next),Bh(i),i=t=n),i=i.next}while(i!==t);return _h(i)}function Rh(t,e,s,i,r,n){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.i!==t.i&&Oh(o,t)){let a=Uh(o,t);return o=_h(o,o.next),a=_h(a,a.next),gh(o,e,s,i,r,n),void gh(a,e,s,i,r,n)}t=t.next}o=o.next}while(o!==t)}function Ah(t,e){return t.x-e.x}function yh(t,e){const s=function(t,e){let s=e;const i=t.x,r=t.y;let n,o=-1/0;do{if(r<=s.y&&r>=s.next.y&&s.next.y!==s.y){const t=s.x+(r-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(t<=i&&t>o){if(o=t,t===i){if(r===s.y)return s;if(r===s.next.y)return s.next}n=s.x<s.next.x?s:s.next}}s=s.next}while(s!==e);if(!n)return null;if(i===o)return n;const a=n,l=n.x,c=n.y;let h=1/0;s=n;do{if(i>=s.x&&s.x>=l&&i!==s.x&&Lh(r<c?i:o,r,l,c,r<c?o:i,r,s.x,s.y)){const e=Math.abs(r-s.y)/(i-s.x);Dh(s,t)&&(e<h||e===h&&(s.x>n.x||s.x===n.x&&Sh(n,s)))&&(n=s,h=e)}s=s.next}while(s!==a);return n}(t,e);if(!s)return e;const i=Uh(s,t),r=_h(s,s.next);return _h(i,i.next),e===e.next||s===e?r:e}function Sh(t,e){return xh(t.prev,t,e.prev)<0&&xh(e.next,t,t.next)<0}function Fh(t,e,s,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*r)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*r)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function wh(t){let e=t,s=t;do{(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next}while(e!==t);return s}function Lh(t,e,s,i,r,n,o,a){return(r-o)*(e-a)-(t-o)*(n-a)>=0&&(t-o)*(i-a)-(s-o)*(e-a)>=0&&(s-o)*(n-a)-(r-o)*(i-a)>=0}function Oh(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let s=t;do{if(s.i!==t.i&&s.next.i!==t.i&&s.i!==e.i&&s.next.i!==e.i&&vh(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}(t,e)&&(Dh(t,e)&&Dh(e,t)&&function(t,e){let s=t,i=!1;const r=(t.x+e.x)/2,n=(t.y+e.y)/2;do{s.y>n!=s.next.y>n&&s.next.y!==s.y&&r<(s.next.x-s.x)*(n-s.y)/(s.next.y-s.y)+s.x&&(i=!i),s=s.next}while(s!==t);return i}(t,e)&&(xh(t.prev,t,e.prev)||xh(t,e.prev,e))||Nh(t,e)&&xh(t.prev,t,t.next)>0&&xh(e.prev,e,e.next)>0)}function xh(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function Nh(t,e){return t.x===e.x&&t.y===e.y}function vh(t,e,s,i){const r=Mh(xh(t,e,s)),n=Mh(xh(t,e,i)),o=Mh(xh(s,i,t)),a=Mh(xh(s,i,e));return r!==n&&o!==a||(!(0!==r||!Ph(t,s,e))||(!(0!==n||!Ph(t,i,e))||(!(0!==o||!Ph(s,t,i))||!(0!==a||!Ph(s,e,i)))))}function Ph(t,e,s){return e.x<=Math.max(t.x,s.x)&&e.x>=Math.min(t.x,s.x)&&e.y<=Math.max(t.y,s.y)&&e.y>=Math.min(t.y,s.y)}function Mh(t){return t>0?1:t<0?-1:0}function Dh(t,e){return xh(t.prev,t,t.next)<0?xh(t,e,t.next)>=0&&xh(t,t.prev,e)>=0:xh(t,e,t.prev)<0||xh(t,t.next,e)<0}function Uh(t,e){const s=zh(t.i,t.x,t.y),i=zh(e.i,e.x,e.y),r=t.next,n=e.prev;return t.next=e,e.prev=t,s.next=r,r.prev=s,i.next=s,s.prev=i,n.next=i,i.prev=n,i}function Vh(t,e,s,i){const r=zh(t,e,s);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function Bh(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ),t.next=t,t.prev=t}function zh(t,e,s){return{i:t,x:e,y:s,prev:null,next:null,z:null,prevZ:null,nextZ:null,steiner:!1}}const Gh=class t{static create(e,s,i,r,n,o,a,l){const c=e.length,h=a.verticesAmount;t.processBuffers(c,e,n,a,s,i);const d=n.positionBuffer,u=(a.verticesAmount-h)/3;this.processNormals(d,this._tempVec,u,h),this.triangulate(o,r,c,n,a,h),this.setFaceId(h,a,n,l)}static setFaceId(t,e,s,i){const r=t/3,n=e.verticesAmount/3;for(let t=r;t<n;t++)s.faceIdBuffer[t]=i}static getVertices(t,e,s){const i=t.positionBuffer.buffer,r=4*e,n=s.verticesAmount-e;return new Float32Array(i,r,n)}static getEvent(t,e,s){return(i,r,n)=>{const o=t.indexBuffer;o[e.indices++]=i+s/3,o[e.indices++]=r+s/3,o[e.indices++]=n+s/3}}static processBuffers(t,e,s,i,r,n){for(let o=0;o<t;o++)this.processPositionBuffer(s,e,o,i,r),this.processNormalbuffer(s,n,o,i),this.updateBufferData(i)}static getHoles(t,e,s,i,r){if(!t)return;if(t.has(e)){const n=t.get(e),o=[];for(const t of n.indices)o.push(t+s);return this.setHolesBuffers(i,n,r),o}}static setHolesBuffers(t,e,s){const i=t.positionBuffer,r=t.normalBuffer;i.set(e.points,s.verticesAmount);const n=e.points.length;s.verticesAmount+=n,s.vertices+=n/3,r.set(e.normals,s.normalsAmount),s.normalsAmount+=n}static updateBufferData(t){t.vertices+=1,t.verticesAmount+=3,t.normalsAmount+=3}static processPositionBuffer(t,e,s,i,r){const n=t.positionBuffer;for(let t=0;t<3;t++){const o=3*e[s];n[i.verticesAmount+t]=r[o+t]}}static triangulate(e,s,i,r,n,o){const a=this.getHoles(e,s,i,r,n),l=t.getVertices(r,o,n),c=Lo.getEarcutDimensions(this._tempVec),h=this.getEvent(r,n,o);mh(l,a,3,c[0],c[1],h)}static processNormals(t,e,s,i=0){e.set(0,0,0);for(let r=0;r<s;r++){const n=i+3*r,o=i+3*((r+1)%s),a=t[n+0],l=t[o+0],c=t[n+1],h=t[o+1],d=t[n+2],u=t[o+2];e.x+=(c-h)*(d+u),e.y+=(d-u)*(a+l),e.z+=(a-l)*(c+h)}e.normalize()}static processNormalbuffer(t,e,s,i){const r=t.normalBuffer,n=3*s,o=e[n],a=e[n+1],l=e[n+2];r.set([o,a,l],i.normalsAmount)}};ot(Gh,"_tempVec",new ft.Vector3);let Hh=Gh;const kh=class{static create(t,e,s,i,r,n,o){this.setAllVectors(t,e);this.getIsConvex()?this.processConvexFace4(r,n,s,o):Hh.create(t,e,s,i,r,void 0,n,o)}static setAllVectors(t,e){this.setVector(t,e,this.a,0),this.setVector(t,e,this.b,1),this.setVector(t,e,this.c,2),this.setVector(t,e,this.d,3),this.getCrossVectors()}static processConvexFace4(t,e,s,i){this.processIndices(t,e),this.processPoints(t,e),this.processNormal(t,e,s),this.setFaceId(t,e,i),this.updateData(e)}static setFaceId(t,e,s){const i=t.faceIdBuffer;for(let t=e.vertices;t<e.vertices+4;t++)i[t]=s}static getIsConvex(){return this.h.dot(this.i)>0}static getCrossVectors(){this.e.copy(this.b),this.f.copy(this.c),this.g.copy(this.d),this.e.sub(this.a),this.f.sub(this.a),this.g.sub(this.a),this.h.crossVectors(this.e,this.f),this.i.crossVectors(this.f,this.g)}static updateData(t){t.normalsAmount+=this.totalIncrease,t.vertices+=this.vertexIncrease,t.verticesAmount+=this.totalIncrease}static processPoints(t,e){let s=0;const i=t.positionBuffer,r=e.verticesAmount;for(let t=0;t<this.vertexIncrease;t++){const e=this._vecs[t];i[r+s++]=e.x,i[r+s++]=e.y,i[r+s++]=e.z}}static setVector(t,e,s,i){const r=3*t[i],n=e[r],o=e[r+1],a=e[r+2];s.set(n,o,a)}static processNormal(t,e,s){const i=t.normalBuffer,r=e.normalsAmount;for(let t=0;t<this.totalIncrease;t++)i[r+t]=s[t]}static processIndices(t,e){const s=t.indexBuffer;for(let t=0;t<this.indexIncrease;t++){const i=this._convexIndices[t];s[e.indices+t]=e.vertices+i}e.indices+=this.indexIncrease}};ot(kh,"a",new ft.Vector3),ot(kh,"b",new ft.Vector3),ot(kh,"c",new ft.Vector3),ot(kh,"d",new ft.Vector3),ot(kh,"e",new ft.Vector3),ot(kh,"f",new ft.Vector3),ot(kh,"g",new ft.Vector3),ot(kh,"h",new ft.Vector3),ot(kh,"i",new ft.Vector3),ot(kh,"_vecs",[kh.a,kh.b,kh.c,kh.d]),ot(kh,"_convexIndices",[0,1,3,3,1,2]),ot(kh,"totalIncrease",12),ot(kh,"indexIncrease",6),ot(kh,"vertexIncrease",4);let Yh=kh;const Wh=class t{static create(t,e,s,i,r,n){this.setFaceIds(r,i,n),this.setIndices(i,r),this.setPoints(t,i,r,e),this.setNormals(i,r,s),this.updateData(r)}static setFaceIds(t,e,s){const i=t.verticesAmount/3,r=i+3;for(let t=i;t<r;t++)e.faceIdBuffer[t]=s}static setNormals(t,e,s){const i=t.normalBuffer;for(let t=0;t<this.totalIncrease;t++)i[e.normalsAmount+t]=s[t]}static setPoints(t,e,s,i){let r=0;const n=e.positionBuffer;for(let e=0;e<this.vertexIncrease;e++){const o=t[e]*this.vertexIncrease;for(let t=0;t<this.vertexIncrease;t++)n[s.verticesAmount+r]=i[o+t],r++}}static setIndices(t,e){const s=t.indexBuffer;for(let t=0;t<this.vertexIncrease;t++)s[e.indices+t]=e.vertices+t;e.indices+=this.vertexIncrease}static updateData(e){e.normalsAmount+=t.totalIncrease,e.vertices+=t.vertexIncrease,e.verticesAmount+=t.totalIncrease}};ot(Wh,"vertexIncrease",3),ot(Wh,"totalIncrease",9);let qh=Wh;class jh{constructor(){ot(this,"point",new Er),ot(this,"_shellHole",new xr),ot(this,"_bigShellHole",new Rr),ot(this,"interiorProfiles",new Map),ot(this,"normalsAvgInterior",new Int16Array),ot(this,"_pointsPerProfile",new Map),ot(this,"_shellProfile",new Nr),ot(this,"_bigShellProfile",new Ar),ot(this,"_normalsAvg",new Int16Array),ot(this,"_normals",[]),ot(this,"_indices",0),ot(this,"_sizes",{vertices:0,indices:0,verticesAmount:0,normalsAmount:0,normals:0}),ot(this,"_tileData"),ot(this,"_faceIdPerProfile",new Map),ot(this,"nextBuffer",(t=>{this.setTileData(t),this.initializeIndices(),this.initializePositions(),this.initializeNormals(),this.initializeFaceIds(),this.initializeSizes(),this._indices++}))}construct(t,e){this.resetConstructData(e),this.getPointsPerWire(t);const s=fh.getBuffer(t);this.newShellInteriorProfiles(t),this.constructShell(t,s,e),this._tileData=void 0}getIntProfileNormalsAvg(t,e){const s=this.getTempHole(t).indicesArray();this.normalsAvgInterior=fh.computeNormalsAvg(s,e,this._normals,this._pointsPerProfile)}saveInteriorProfile(t){const e=this.getTempHole(t).profileId();if(this.interiorProfiles.has(e))return this.saveExistingInteriorProfile(e),e;const s=this.getNewIntProfileData();return this.interiorProfiles.set(e,s),e}computeNormalsAvg(t,e,s){if(!this.isShell(t))return;const i=this._normals,r=this._pointsPerProfile;this._normalsAvg=fh.computeNormalsAvg(e,s,i,r)}isShell(t){return t instanceof Pr}getPointsPerWire(t){this.isShell(t)&&(fh.getNormalsOfShellProfile(t,this._normals),this._pointsPerProfile=fh.getPointsShell(t))}getIndices(t,e){const s=this.getTempProfile(t);return fh.getProfile(t,e,s),s.indicesArray()}resetConstructData(t){this._indices=0,this._tileData=void 0,this.nextBuffer(t),this._normals.length=0}initializeIndices(){const t=this._tileData.indexCount;this._tileData.indexBuffer=new Uint16Array(t)}constructFace4(t,e,s){const i=this._faceIdPerProfile.get(s);Yh.create(t,e,this._normalsAvg,s,this._tileData,this._sizes,i)}initializeSizes(){this._sizes.vertices=0,this._sizes.indices=0,this._sizes.verticesAmount=0,this._sizes.normalsAmount=0,this._sizes.normals=0}getInteriorProfileBuffer(t,e){const s=this.getTempHole(t).indicesLength();if(this.isShell(t))for(let i=0;i<s;i++)this.getIntProfilePoints(i,t,e),this.getIntProfileNormals(e,i)}constructProfile(t,e,s,i){const r=this.getTempProfile(e).indicesLength(),n=!this.interiorProfiles.has(t);if(r===Ih.three&&n)return void this.constructFace3(s,i,t);r===Ih.four&&n?this.constructFace4(s,i,t):this.constructFaceX(s,i,t)}getIntProfileNormals(t,e){const s=3*e,i=this.normalsAvgInterior[s],r=this.normalsAvgInterior[s+1],n=this.normalsAvgInterior[s+2];t.normals.push(i,r,n)}saveExistingInteriorProfile(t){const e=this.interiorProfiles.get(t),s=e.points.length/3;e.indices.push(s),this.interiorProfiles.set(t,e)}getNewIntProfileData(){return{indices:[0],points:[],normals:[]}}constructFace3(t,e,s){const i=this._faceIdPerProfile.get(s);qh.create(t,e,this._normalsAvg,this._tileData,this._sizes,i)}getIntProfilePoints(t,e,s){const i=this.getTempHole(e).indices(t);e.points(i,this.point);const r=this.point.x(),n=this.point.y(),o=this.point.z();s.points.push(r,n,o)}manageMemory(t,e){const s=this.getTempProfile(t).indicesLength();this._sizes.verticesAmount/3+s>Ln&&this.nextBuffer(e)}initializeFaceIds(){const t=this._tileData.positionCount;this._tileData.faceIdBuffer=new Uint32Array(t/3)}getNextFaceId(){return 4294967295*Math.random()}newShellInteriorProfiles(t){this.interiorProfiles.clear();const e=fh.getHolesLength(t),s=this.getTempHole(t);for(let i=0;i<e;i++){fh.getHole(t,i,s);const e=this.saveInteriorProfile(t),r=this.interiorProfiles.get(e);this.getIntProfileNormalsAvg(t,e),this.getInteriorProfileBuffer(t,r)}return this.interiorProfiles}initializePositions(){const t=this._tileData.positionCount;this._tileData.positionBuffer=new Float32Array(t)}initializeNormals(){const t=this._tileData.normalCount;this._tileData.normalBuffer=new Int16Array(t)}setTileData(t){Array.isArray(t)?this._tileData=t[this._indices]:this._tileData=t}constructShell(t,e,s){this.getFaceIds(t);const i=fh.getProfilesLength(t);for(let r=0;r<i;r++){const i=this.getIndices(t,r);this.computeNormalsAvg(t,i,r),this.constructProfile(r,t,i,e),this.manageMemory(t,s)}}constructFaceX(t,e,s){const i=this._faceIdPerProfile.get(s);Hh.create(t,e,this._normalsAvg,s,this._tileData,this.interiorProfiles,this._sizes,i)}getTempProfile(t){return t.type()===vr.BIG?this._bigShellProfile:this._shellProfile}getTempHole(t){return t.type()===vr.BIG?this._bigShellHole:this._shellHole}getFaceIds(t){this._faceIdPerProfile.clear();const e=t.profilesFaceIdsArray(),s=new Map;if(e&&e.length>0)for(let t=0;t<e.length;t++){const i=e[t];s.has(i)||s.set(i,this.getNextFaceId());const r=s.get(i);this._faceIdPerProfile.set(t,r)}else for(let e=0;e<t.profilesLength();e++)this._faceIdPerProfile.set(e,this.getNextFaceId())}}class Xh{constructor(t){ot(this,"a",new ft.Vector3),ot(this,"b",new ft.Vector3),ot(this,"c",new ft.Vector3),ot(this,"d",new ft.Vector3),ot(this,"e",new ft.Vector3),ot(this,"f",new ft.Vector3),ot(this,"g",new ft.Vector3),ot(this,"h",new ft.Vector3),ot(this,"i",new ft.Vector3),ot(this,"j",new ft.Vector3),ot(this,"k",new ft.Vector3),ot(this,"tempTriangle",new ft.Triangle),ot(this,"tempPlane",new ft.Plane),ot(this,"includedVertices",[]),ot(this,"interiorProfiles",new Map),ot(this,"_meshes"),this._meshes=t}faceRaycast(t,e){const s=fh.getShell(this._meshes,t);this.resetData(),this.getInteriorProfiles(s);const i=fh.getBuffer(s);return this.processAllCollisions(s,i,e),this.includedVertices}resetVectors(){this.a.set(0,0,0),this.b.set(0,0,0),this.c.set(0,0,0),this.d.set(0,0,0)}resetData(){this.includedVertices.length=0,this.interiorProfiles.clear()}getInteriorProfiles(t){const e=fh.getHolesLength(t);for(let s=0;s<e;s++){const e=fh.getHole(t,s).profileId();this.interiorProfiles.has(e)||this.interiorProfiles.set(e,[]);this.interiorProfiles.get(e).push(s)}}processTriangle(t,e,s){const i=3*t[0],r=3*t[1],n=3*t[2];this.saveTriPoint(this.e,e,i),this.saveTriPoint(this.f,e,r),this.saveTriPoint(this.g,e,n);const o=this.triangleHit(s);if(o){const s=this.getTriangleBuffer(e,t);o.facePoints=s.points,o.faceIndices=s.indices,this.includedVertices.push(o)}}processAllCollisions(t,e,s){const i=fh.getProfilesLength(t);for(let r=0;r<i;r++){this.resetVectors();const i=this.getIndices(t,r);this.getValidCollision(i,e,s,r,t)&&this.processCollision(t,r,e,i)}}saveTriPoint(t,e,s){const i=e[s],r=e[s+1],n=e[s+2];t.set(i,r,n)}getIndices(t,e){return fh.getProfile(t,e).indicesArray()}getIsTriangle(t){return 3===t.length}getNormal(){this.tempTriangle.a=this.e,this.tempTriangle.b=this.f,this.tempTriangle.c=this.g;const t=new ft.Vector3;return this.tempTriangle.getNormal(t),t}isHole(t,e,s){if(this.interiorProfiles.has(t)){const i=this.interiorProfiles.get(t);return this.holeContains(i,e,s)}return!1}computeNormal(t,e){this.d.set(0,0,0);const s=e.length;for(let i=0;i<s;i++){const r=(i+1)%s,n=3*e[i],o=3*e[r];this.processNormal(t,n,o)}this.d.normalize()}holeContains(t,e,s){const i=t.length;for(let r=0;r<i;r++){const i=fh.getHole(e,t[r]).indicesArray();if(this.polygonContains(s,i))return!0}return!1}triangleHit(t){const e=this.e,s=this.f,i=this.g;if(!t.intersectTriangle(e,s,i,!1,this.h))return;const r=this.getNormal();return{point:this.h.clone(),normal:r}}getValidCollision(t,e,s,i,r){if(this.getIsTriangle(t))return this.processTriangle(t,e,s),!1;if(!this.getCollidesPlane(t,e,s))return!1;return!this.isHole(i,r,e)}processCollision(t,e,s,i){if(!this.polygonContains(s,i))return;const r=this.b.clone(),n=this.tempPlane.normal.clone(),o=this.getFaceBuffer(t,e,s);this.includedVertices.push({point:r,normal:n,facePoints:o.points,faceIndices:o.indices})}newOrthoNormalBasis(){const t=this.tempPlane.normal,e=this.j,s=this.i;if(Math.abs(t.x)>=Math.abs(t.y)){const i=1/Math.sqrt(t.x*t.x+t.z*t.z),r=-t.z*i,n=0,o=t.x*i;e.set(r,n,o);const a=t.y*e.z,l=t.z*e.x-t.x*e.z,c=-t.y*e.x;s.set(a,l,c)}else{const i=1/Math.sqrt(t.y*t.y+t.z*t.z),r=0,n=t.z*i,o=-t.y*i;e.set(r,n,o);const a=t.y*e.z-t.z*e.y,l=-t.x*e.z,c=t.x*e.y;s.set(a,l,c)}e.normalize(),s.normalize()}polygonContains(t,e){let s=!1;this.newOrthoNormalBasis(),this.setPolyContainVec(e,t);let i=this.k.dot(this.i),r=this.k.dot(this.j);for(let n=0;n<e.length;n++){const o=3*e[n],a=t[o],l=t[o+1],c=t[o+2];this.k.set(a,l,c),this.k.sub(this.b);const h=this.k.dot(this.i),d=this.k.dot(this.j);if(d>0!==r>0){(i-h)*-d/(r-d)+h>0&&(s=!s)}i=h,r=d}return s}processNormal(t,e,s){const i=t[e+0],r=t[s+0],n=t[e+1],o=t[s+1],a=t[e+2],l=t[s+2];this.d.x+=(n-o)*(a+l),this.d.y+=(a-l)*(i+r),this.d.z+=(i-r)*(n+o)}getCollidesPlane(t,e,s){const i=3*t[0],r=e[i],n=e[i+1],o=e[i+2];this.a.set(r,n,o),this.computeNormal(e,t),this.tempPlane.setFromNormalAndCoplanarPoint(this.d,this.a);return s.intersectPlane(this.tempPlane,this.b)}setPolyContainVec(t,e){const s=3*t[t.length-1],i=e[s],r=e[s+1],n=e[s+2];this.k.set(i,r,n),this.k.sub(this.b)}getTriangleBuffer(t,e){const s=[],i=[];for(let r=0;r<e.length;r++){const n=3*e[r];s.push(t[n],t[n+1],t[n+2]),i.push(r)}return{points:new Float32Array(s),indices:i}}getFaceBuffer(t,e,s){const i=fh.getProfileIndices(t,e),{outer:r,inners:n}=i,o=[];for(let t=0;t<r.length;t++){const e=3*r[t];o.push(s[e],s[e+1],s[e+2])}const a=[];for(let t=0;t<n.length;t++){const e=n[t];a.push(o.length/3);for(let t=0;t<e.length;t++){const i=3*e[t];o.push(s[i],s[i+1],s[i+2])}}const l=new ft.Vector3,c=new ft.Vector3,h=new ft.Vector3;l.set(o[0],o[1],o[2]),c.set(o[3],o[4],o[5]),h.set(o[6],o[7],o[8]);const d=new ft.Triangle;d.set(l,c,h);const u=new ft.Vector3;d.getNormal(u);const[f,p]=Lo.getEarcutDimensions(u),I=[];for(let t=0;t<o.length;t+=3){const e=[o[t],o[t+1],o[t+2]];I.push(e[f],e[p])}const m=Hn(I,a);return{points:new Float32Array(o),indices:m}}}class Zh{constructor(t){ot(this,"_meshes"),ot(this,"_minAngle",Math.PI/32),ot(this,"_shellProfile",new Nr),ot(this,"_bigShellProfile",new Ar),ot(this,"_tempV1",new ft.Vector3),ot(this,"_tempV2",new ft.Vector3),ot(this,"_tempPoint",new ft.Vector3),ot(this,"_normals",[]),ot(this,"_pointsByProfile",new Map),ot(this,"_shell",new Pr),ot(this,"_result",[]),this._meshes=t}lineRaycast(t,e,s){return this.resetData(t),this.lineRaycastItems(e,s),this._result}lineRaycastItems(t,e){const s=fh.getProfilesLength(this._shell);for(let i=0;i<s;i++){const s=this.getTempProfile(this._shell);fh.getProfile(this._shell,i,s),this.lineRaycastProfile(t,e,i)}}resetData(t){this._shell=fh.getShell(this._meshes,t),this._normals.length=0,fh.getNormalsOfShellProfile(this._shell,this._normals),this._pointsByProfile=fh.getPointsShell(this._shell),this._result=[]}lineRaycastProfile(t,e,s){const i=this.getTempProfile(this._shell),r=i.indicesLength();for(let n=0;n<r;n++){const o=i.indices(n),a=this.getSecondIndex(n,r);this.cast(o,a,t,e,s)&&this.saveResult(s)}}isInvalidAngle(t,e,s){const i=this.getProfile(t,e,s);if(!i.length)return!0;const r=this._normals[i[0]],n=this._normals[s];return r.dot(n)>Math.cos(this._minAngle)}getProfile(t,e,s){const i=this._pointsByProfile.get(t),r=this._pointsByProfile.get(e),n=[];for(const t of i)-1!==r.indexOf(t)&&t!==s&&n.push(t);return n}cast(t,e,s,i,r){fh.point(this._shell,t,this._tempV1),fh.point(this._shell,e,this._tempV2),this.raycastSegment(s);if(!i.containsPoint(this._tempPoint))return!1;return!this.isInvalidAngle(t,e,r)}saveResult(t){const e=this._tempV1.clone(),s=this._tempV2.clone(),i=this._normals[t],r=this._tempPoint.clone();this._result.push({point:r,normal:i,snappedEdgeP1:e,snappedEdgeP2:s})}getSecondIndex(t,e){const s=t===e-1,i=this.getTempProfile(this._shell);return s?i.indices(0):i.indices(t+1)}raycastSegment(t){t.distanceSqToSegment(this._tempV1,this._tempV2,void 0,this._tempPoint)}getTempProfile(t){return t.type()===vr.BIG?this._bigShellProfile:this._shellProfile}}class $h{constructor(t){ot(this,"_meshes"),ot(this,"_tempVec",new ft.Vector3),this._meshes=t}pointRaycast(t,e){const s=fh.getShell(this._meshes,t),i=[];return this.cast(s,e,i),i}cast(t,e,s){const i=t.pointsLength();for(let r=0;r<i;r++){fh.point(t,r,this._tempVec);if(!e.containsPoint(this._tempVec))continue;const i=this._tempVec.clone();s.push({point:i})}}}class Qh extends ch{constructor(){super(...arguments),ot(this,"_lodClass",dh.AABB),ot(this,"_objectClass",On.SHELL),ot(this,"_representationClass",Gr.SHELL),ot(this,"_templates",new ph),ot(this,"_constructor",new jh),ot(this,"_faceRaycaster",new Xh(this.meshes)),ot(this,"_lineRaycaster",new Zh(this.meshes)),ot(this,"_pointRaycaster",new $h(this.meshes))}fetchMeshes(t,e){const s=this.getMesh(t,Nn.GEOMETRY);return this.constructMesh(s,e,t),s}newMeshTemplate(t){return this._templates.newMeshTemplate(t)}lineRaycast(t,e,s){return this._lineRaycaster.lineRaycast(t,e,s)}faceRaycast(t,e){return this._faceRaycaster.faceRaycast(t,e)}raycast(t,e){return this._faceRaycaster.faceRaycast(t,e)}pointRaycast(t,e,s){return this._pointRaycaster.pointRaycast(t,s)}setupTemplates(){for(let t=0,e=this.meshes.shellsLength();t<e;t++){const e=fh.getShell(this.meshes,t);this.useMesh(t,this.newMeshTemplate(e),Nn.GEOMETRY)}}getRepresentation(){return this._representationClass}getObjectClass(){return this._objectClass}getLodClass(){return this._lodClass}isVoidMesh(t){return Array.isArray(t)?void 0===t[0].positionBuffer:void 0===t.positionBuffer}constructMesh(t,e,s){if(!this.isVoidMesh(t)||!e)return;const i=fh.getShell(this.meshes,s);this._constructor.construct(i,t),this.saveMesh(s,t,Nn.GEOMETRY)}}class Kh{static circleCurve3Divisions(t){const e=t.aperture()*t.radius()*4,s=Math.round(e);return Math.min(Math.max(s,4),32)}static traverseCircleCurve(t,e,s){const i=t.circleCurvesLength();for(let r=0;r<i;r++){this.getAllCircleCurveData(t,r);const i=s(this._circleCurve);this._circlePoints.length=i-2,this.getCircleCurveMids(i),this.getNewCircleCurveData(),e(this._circleP1,this._circlePoints,this._circleP2)}}static traverseWireSets(t,e){const s=t.wireSetsLength();for(let i=0;i<s;i++)t.wireSets(i,this._wireSet),this.traverseWireSetWires(e)}static raycastCircleExtr(t,e,s,i){const r=e.distanceTo(t);return this.setupCircleExtrusionAxes(e,t),this.setupCircleExtrusionTransform(t,i),this.setupCircleExtrusionRay(s),this.computeCircleExtrusionRaycast(r,i)}static traverseWires(t,e){const s=t.wiresLength();for(let i=0;i<s;i++)t.wires(i,this._wire),this.setWire(),e(this._wireP1,this._wireP2)}static getNewCircleCurveData(){this._circleP2.copy(this._circleP1);const t=this._circleCurve.aperture(),e=this._circleCurve.radius();this._circleP2.applyAxisAngle(this._circleOrientation,t),this._circleP2.multiplyScalar(e),this._circleP2.add(this._circleOrigin),this._circleP1.multiplyScalar(e),this._circleP1.add(this._circleOrigin)}static setWire(){this.setWirePoint("p1",this._wireP1),this.setWirePoint("p2",this._wireP2)}static getCircleCurveMids(t){const e=this._circlePoints.length;for(let s=0;s<e;s++)this._circlePoints[s]=this.newCirclePoint(s,t)}static newCirclePoint(t,e){const s=e-1,i=t+1,r=new ft.Vector3;r.copy(this._circleP1);const n=this._circleCurve.radius(),o=this._circleCurve.aperture()*i/s;return r.applyAxisAngle(this._circleOrientation,o),r.multiplyScalar(n),r.add(this._circleOrigin),r}static getAllCircleCurveData(t,e){t.circleCurves(e,this._circleCurve),this.getCircleCurveData(this._circleOrigin,"position"),this.getCircleCurveData(this._circleOrientation,"xDirection"),this.getCircleCurveData(this._circleP1,"yDirection")}static setWirePoint(t,e){this._wire[t](this._floats);const s=this._floats.x(),i=this._floats.y(),r=this._floats.z();e.set(s,i,r)}static getCircleCurveData(t,e){const s=this._circleCurve[e]();this.getVectorData(s,t)}static getVectorData(t,e){const s=t.x(),i=t.y(),r=t.z();e.set(s,i,r)}static traverseWireSetWires(t){const e=this._wireSet.psLength()-1;for(let s=0;s<e;s++)this.getWiresetPoint(this._currentWireSetPoint,s),this.getWiresetPoint(this._nextWireSetPoint,s+1),t(this._currentWireSetPoint,this._nextWireSetPoint)}static getWiresetPoint(t,e){const s=this._wireSet.ps(e);this.getVectorData(s,t)}static setupCircleExtrusionTransform(t,e){this._ceTransform.identity(),this._ceTransform.makeBasis(this._ceAxisX,this._ceAxisY,this._ceAxisZ),this._ceTransform.setPosition(t),this._ceSize.set(e,e,e),this._ceTransform.scale(this._ceSize)}static computeCircleExtrusionRaycastFactors(){const t=this._ceRay.direction,e=this._ceRay.origin,s=t.x*t.x+t.y*t.y,i=2*e.x*t.x+2*e.y*t.y,r=4*s*(e.x*e.x+e.y*e.y-1),n=i*i;if(r>n)return null;const o=2*s,a=Math.sqrt(n-r);return{factorA:(-i+a)/o,factorB:(-i-a)/o}}static computeCircleExtrusionRaycast(t,e){const s=this.computeCircleExtrusionRaycastFactors();if(null===s)return[];const{factorA:i,factorB:r}=s;return this._ceInverseTransform.transpose(),this._ceRaycastPoints=[],this.computeCircleExtrusionRaycastPoints(i,t,e),this.computeCircleExtrusionRaycastPoints(r,t,e),this._ceRaycastPoints}static setupCircleExtrusionRay(t){this._ceInverseTransform.copy(this._ceTransform),this._ceInverseTransform.invert(),this._ceRay.copy(t),this._ceRay.applyMatrix4(this._ceInverseTransform)}static computeCircleExtrusionRaycastPoints(t,e,s){if(!this.checkIfCircleExtrusionClashes(t,e,s))return;this._ceRaycastPoint.applyMatrix4(this._ceTransform);const i=this._ceRaycastPoint.clone();this._ceRaycastPoints.push({point:i})}static setupCircleExtrusionAxes(t,e){this._ceAxisZ.copy(t),this._ceAxisZ.sub(e),this._ceAxisZ.normalize(),this.computeNormal(this._ceAxisZ,this._ceAxisX),this._ceAxisY.crossVectors(this._ceAxisZ,this._ceAxisX)}static computeNormal(t,e){const s=t.dot(this._ceAbsoluteX),i=Math.abs(s)>.9?this._ceAbsoluteZ:this._ceAbsoluteX;e.crossVectors(t,i),e.normalize()}static setupCircleExtrusionRaycastPoint(t){this._ceRaycastPoint.copy(this._ceRay.direction),this._ceRaycastPoint.normalize(),this._ceRaycastPoint.multiplyScalar(t),this._ceRaycastPoint.add(this._ceRay.origin)}static checkIfCircleExtrusionClashes(t,e,s){this.setupCircleExtrusionRaycastPoint(t);const i=e/s,r=this._ceRaycastPoint.z;return r>=0&&r<=i}}ot(Kh,"_floats",new Er),ot(Kh,"_wire",new gr),ot(Kh,"_wireSet",new Cr),ot(Kh,"_circleCurve",new _r),ot(Kh,"_wireP1",new ft.Vector3),ot(Kh,"_wireP2",new ft.Vector3),ot(Kh,"_circleP1",new ft.Vector3),ot(Kh,"_circleP2",new ft.Vector3),ot(Kh,"_circleOrigin",new ft.Vector3),ot(Kh,"_circleOrientation",new ft.Vector3),ot(Kh,"_currentWireSetPoint",new ft.Vector3),ot(Kh,"_nextWireSetPoint",new ft.Vector3),ot(Kh,"_ceAxisZ",new ft.Vector3),ot(Kh,"_ceAxisY",new ft.Vector3),ot(Kh,"_ceAxisX",new ft.Vector3),ot(Kh,"_ceRaycastPoint",new ft.Vector3),ot(Kh,"_ceSize",new ft.Vector3),ot(Kh,"_ceAbsoluteX",new ft.Vector3(0,0,1)),ot(Kh,"_ceAbsoluteZ",new ft.Vector3(1,0,0)),ot(Kh,"_circlePoints",[]),ot(Kh,"_ceTransform",new ft.Matrix4),ot(Kh,"_ceInverseTransform",new ft.Matrix4),ot(Kh,"_ceRay",new ft.Ray),ot(Kh,"_ceRaycastPoints",[]);const Jh=class t{static newPaths(e,s){const i=t.newPathData();return this.fetchCircleCurveData(e,i),this.fetchCircleCurveMids(s,i,e),this.fetchCircleCurveEnds(i,e),this.fetchCircleCurveCuts(i),i.cuts}static getAxisPartSize(e,s,i){const r=e.parts(s),n=e.order(s),o=t.getAxisPartData(r,i,e,n);return t.fetchAxisPartSize(i,o),this._axisPartSize}static vertexLength(e,s=200){const i=Math.round(e*s),r=Math.max(i,t._minSize);return Math.min(r,t._maxSize)}static setPathVertices(t){const e=this.circleCurvePoints,s=!e,i=e&&e.length!==t;if(s||i){this.circleCurvePoints=[];for(let e=0;e<t;e++){const s=2*Math.PI*e/t,i=Math.sin(s),r=Math.cos(s),n=new ft.Vector3(i,r,0);this.circleCurvePoints.push(n)}}}static fetchCircleCurveEnds(t,e){t.last.copy(t.first),t.last.applyAxisAngle(t.axis,e.aperture()),t.last.multiplyScalar(e.radius()),t.last.add(t.center),t.first.multiplyScalar(e.radius()),t.first.add(t.center)}static getAxisPartData(t,e,s,i){return{[br.WIRE]:this.getAxisPartWireData,[br.WIRE_SET]:this.getAxisPartWireSetData,[br.CIRCLE_CURVE]:this.getAxisPartCircleCurveData}[t](s,i,e)}static newEmptyAxisPartData(){return{indices:0,points:0,faces:0,links:0}}static fetchCircleCurveMids(t,e,s){const i=t-2;for(let r=0;r<i;r++){const i=new ft.Vector3;i.copy(e.first);const n=s.aperture()*(r+1)/(t-1);i.applyAxisAngle(e.axis,n),i.multiplyScalar(s.radius()),i.add(e.center),e.mids[r]=i}}static validSize(t,e,s){return Ln>=t+e+s}static fetchCircleCurveCuts(t){t.cuts.push(t.first),t.cuts.push(...t.mids),t.cuts.push(t.last)}static fetchCircleCurveData(t,e){const s=t.position();e.center.set(s.x(),s.y(),s.z());const i=t.xDirection();e.axis.set(i.x(),i.y(),i.z());const r=t.yDirection();e.first.set(r.x(),r.y(),r.z())}static newPathData(){return{axis:new ft.Vector3,cuts:[],center:new ft.Vector3,last:new ft.Vector3,first:new ft.Vector3,mids:[]}}static fetchAxisPartSize(t,e){const s=t-2,i=e.faces*s*3,r=e.links*t*this._wireSize;this._axisPartSize.verticesLength=e.points,this._axisPartSize.indicesLength=e.indices+i+r}};ot(Jh,"up",new ft.Vector3(0,0,1)),ot(Jh,"circleCurves",[]),ot(Jh,"circleCurvePoints"),ot(Jh,"temp",{circleExtrusion:new Sr,circleCurve:new _r,wireSet:new Cr,axis:new Tr,rotation:new ft.Quaternion,vector:new ft.Vector3}),ot(Jh,"_wireSize",6),ot(Jh,"_minSize",6),ot(Jh,"_maxSize",30),ot(Jh,"_axisPartSize",{verticesLength:0,indicesLength:0}),ot(Jh,"getAxisPartWireSetData",((t,e,s)=>{const i=Jh.newEmptyAxisPartData();t.wireSets(e,Jh.temp.wireSet);const r=Jh.temp.wireSet.psLength()-1;return i.points=2*r*s,i.indices=Jh._wireSize*r*s,i.faces=2*r,i})),ot(Jh,"getAxisPartWireData",((t,e,s)=>{const i=Jh.newEmptyAxisPartData();return i.points=2*s,i.indices=Jh._wireSize*s,i.faces=2,i})),ot(Jh,"getAxisPartCircleCurveData",((t,e,s)=>{const i=Jh.newEmptyAxisPartData();t.circleCurves(e,Jh.temp.circleCurve);const r=Kh.circleCurve3Divisions(Jh.temp.circleCurve),n=s*r;i.points=n;const o=s*(r-1),a=Jh._wireSize*o;i.indices=a;return i.faces=2,i.links=2,i}));let td=Jh;class ed{constructor(){ot(this,"_minLinkDistance",1e-8),ot(this,"_first",new ft.Vector3),ot(this,"_last",new ft.Vector3),ot(this,"_currentPoint"),ot(this,"_currentIndex"),ot(this,"_v1",new ft.Vector3),ot(this,"_v2",new ft.Vector3),ot(this,"_v3",new ft.Vector3),ot(this,"_v4",new ft.Vector3),ot(this,"_tempLine",new ft.Line3),ot(this,"_total",0),ot(this,"_closest",0),ot(this,"_result",0)}newTemplate(t,e,s){const i=t.radius(e),r=t.axes(e,td.temp.axis),n=td.vertexLength(i);let o=s[s.length-1];const a=r.orderLength();for(let t=0;t<a;t++)o=this.generateTemplate(r,t,n,o,s)}construct(t,e){const s={};let i=0;for(let r=0,n=t.axesLength();r<n;r++){const n=t.radius(r);t.axes(r,td.temp.axis);const o=td.vertexLength(n);i=this.constructVce(o,s,undefined,i,0,e,n)}}getTemplateCreationData(t,e,s){const i=!t;let r=!1;if(!i){const i=t.positionCount/3,n=e.verticesLength;r=td.validSize(i,n,s)}return{isStart:i,fits:r}}generateTemplate(t,e,s,i,r){const n=td.getAxisPartSize(t,e,s),{isStart:o,fits:a}=this.getTemplateCreationData(i,n,s);return(o||!a)&&(i=this.newTemplateData(),r.push(i),this.savePrevious(o,e,s,i)),i.positionCount+=3*n.verticesLength,i.normalCount+=3*n.verticesLength,i.indexCount+=n.indicesLength,i}savePrevious(t,e,s,i){if(!t&&0!==e){const t=3*(s-2);i.positionCount+=3*s,i.normalCount+=3*s,i.indexCount+=t}}constructNewVce(t,e,s,i,r,n,o){const a=!t;let l=!1;if(!a){const t=e.verticesLength;l=td.validSize(s,t,i)}if(a||!l){t=r[n++],this.setupNewVceBuffers(t);const e=this._currentPoint;s=this.clearOffset(s);if(!a&&0!==o){const o=r[n-2];this.getClone(o,t,e,i),s+=i}}return{data:t,pointAmount:s,position:n}}constructVce(t,e,s,i,r,n,o){const a=td.temp.axis.orderLength();for(let l=0;l<a;l++){const a=td.temp.axis,c=td.getAxisPartSize(a,l,t);this.setupLink(l,e),({data:s,pointAmount:i,position:r}=this.constructNewVce(s,c,i,t,n,r,l)),this.newAxisPart(td.temp.axis,l,s,o,t,e),i+=c.verticesLength}return i}newTemplateData(){return{objectClass:On.SHELL,indexCount:0,positionCount:0,normalCount:0}}setupNewVceBuffers(t){t.positionBuffer=new Float32Array(t.positionCount),t.normalBuffer=new Int16Array(t.normalCount),t.indexBuffer=new Uint16Array(t.indexCount)}clearOffset(t){return this._currentPoint=0,this._currentIndex=0,0}getClone(t,e,s,i){for(let r=-3*i;r<0;r++){const i=e.positionBuffer,n=t.positionBuffer,o=e.normalBuffer,a=t.normalBuffer;i[this._currentPoint]=n[s+r],o[this._currentPoint]=a[s+r],this._currentPoint++}}manageAxisPartCreation(t,e,s,i,r,n,o){if(t!==br.CIRCLE_CURVE)if(t!==br.WIRE_SET){if(t===br.WIRE){const t=e.wires(s);this.newWire(t,i,r,n,o)}}else{const t=e.wireSets(s);this.newWireSet(t,i,r,n,o)}else{const t=e.circleCurves(s);this.newCircleCurve(t,i,r,n,o)}}newWireSetStart(t,e,s,i){1===t?this.linkStart(e,s,i,this._first,br.WIRE_SET):this.newPathOrderData(e,s)}newWireSet(t,e,s,i,r){for(let n=1,o=t.psLength();n<o;n++){const a=td.temp.rotation;this.getWireSetPoints(t,n),this.setWireSetVector(),this.newPath(this._first,e,a,s,i),this.newWireSetStart(n,s,i,r),this.newPath(this._last,e,a,s,i),this.fillWireSetData(n,o,r,s,i),this.linkPaths(s,i)}}fillWireSetData(t,e,s,i,r){t!==e-1||s.last?this.newPathOrderData(i,r,!0):(s.placement=this._last,s.axisClass=br.WIRE_SET)}setWireSetVector(){td.temp.vector.copy(this._last),td.temp.vector.sub(this._first),td.temp.vector.normalize(),td.temp.rotation.setFromUnitVectors(td.up,td.temp.vector)}newCircleCurveBody(t,e,s,i){const r=t-2;for(let t=0;t<r;t++){const r=td.circleCurves[t],n=td.circleCurves[t+1],o=td.circleCurves[t+2],a=td.temp.vector;a.copy(o),a.sub(r),a.normalize(),td.temp.rotation.setFromUnitVectors(td.up,a),this.newPath(n,e,td.temp.rotation,s,i),this.linkPaths(s,i,!0)}}newCircleCurveFinish(t,e,s,i,r){const n=t-2,o=t-1,a=td.circleCurves[n],l=td.circleCurves[o],c=td.temp.vector;c.copy(l),c.sub(a),c.normalize(),td.temp.rotation.setFromUnitVectors(td.up,c),this.newPath(l,e,td.temp.rotation,s,i),r.last?this.newPathOrderData(s,i,!0):(r.placement=td.circleCurves[o],r.axisClass=br.CIRCLE_CURVE)}setupLink(t,e){0===t&&(e.first=!0);t===td.temp.axis.orderLength()-1&&(e.last=!0)}newCircleCurveStart(t,e,s,i){const r=td.circleCurves[0],n=td.circleCurves[1],o=td.temp.vector;o.copy(n),o.sub(r),o.normalize(),td.temp.rotation.setFromUnitVectors(td.up,o),this.newPath(r,t,td.temp.rotation,e,s);const a=br.CIRCLE_CURVE;this.linkStart(e,s,i,r,a)}getWireSetPoints(t,e){const s=t.ps(e-1);this._first.set(s.x(),s.y(),s.z());const i=t.ps(e);this._last.set(i.x(),i.y(),i.z())}finishWire(t,e,s,i){this.newPath(this._last,t,td.temp.rotation,e,s),i.last?this.newPathOrderData(e,s,!0):(i.placement=this._last,i.axisClass=br.WIRE),this.linkPaths(e,s)}linkPaths(t,e,s=!1){const i=e,{p1:r,p2:n,p3:o}=this.getPathPositions(i,s,t),a=t.indexBuffer;for(let t=0;t<i;t++){const e=(t+1)%i,{i3:s,i4:l,i1:c,i2:h}=this.getLinkPathIndices(o,t,r,i,e,n);a[this._currentIndex++]=s,a[this._currentIndex++]=l,a[this._currentIndex++]=c,a[this._currentIndex++]=c,a[this._currentIndex++]=l,a[this._currentIndex++]=h}}startWire(t,e,s,i){this.newPath(this._first,t,td.temp.rotation,e,s);const r=br.WIRE;this.linkStart(e,s,i,this._first,r)}setupWireVectors(){const t=td.temp.vector;t.copy(this._last),t.sub(this._first),t.normalize(),td.temp.rotation.setFromUnitVectors(td.up,t)}getLinkPathIndices(t,e,s,i,r,n){let o=0,a=0,l=0,c=0;return o=t+e>=s?t+e-i:t+e,a=t+r>=s?t+r-i:t+r,l=n+e>=s+i?n+e-i:n+e,c=n+r>=s+i?n+r-i:n+r,{i3:l,i4:c,i1:o,i2:a}}fetchWirePoints(t){const e=t.p1(),s=t.p2();this._first.set(e.x(),e.y(),e.z()),this._last.set(s.x(),s.y(),s.z())}findLinkedVertex(t,e,s,i,r){for(let n=t;n<e;n++){this.point(n,s,this._v1);const e=n-i+r,o=e>=t?e-i:e;this.point(o,s,this._v2);const a=e+1>=t?e+1-i:e+1;this.point(a,s,this._v3),this._tempLine.set(this._v2,this._v3),this._tempLine.closestPointToPoint(this._v1,!0,this._v4),this._total+=this._v4.distanceTo(this._v1)}}newPath(t,e,s,i,r){td.setPathVertices(r);for(let n=0;n<r;n++)this.setPathPosition(n,e,s,t,i),this.setPathNormal(n,s,i),this._currentPoint+=3}linkStart(t,e,s,i,r){if(s.first)return void this.newPathOrderData(t,e);const n=br.CIRCLE_CURVE,o=s.axisClass===n||r===n,a=s.placement.distanceToSquared(i)<this._minLinkDistance;if(!o||!a)return this.newPathOrderData(t,e,!0,!0),void this.newPathOrderData(t,e);this.linkPaths(t,e,!0)}setPathPosition(t,e,s,i,r){const n=td.temp.vector;n.copy(td.circleCurvePoints[t]),n.multiplyScalar(e),n.applyQuaternion(s),n.add(i);const o=r.positionBuffer,a=this._currentPoint,l=this._currentPoint+1,c=this._currentPoint+2;o[a]=n.x,o[l]=n.y,o[c]=n.z}newWire(t,e,s,i,r){this.fetchWirePoints(t),this.setupWireVectors(),this.startWire(e,s,i,r),this.finishWire(e,s,i,r)}newCircleCurve(t,e,s,i,r){const n=Kh.circleCurve3Divisions(t);td.circleCurves=td.newPaths(t,n),this.newCircleCurveStart(e,s,i,r),this.newCircleCurveBody(n,e,s,i),this.newCircleCurveFinish(n,e,s,i,r),this.linkPaths(s,i,!0)}newPathOrderData(t,e,s=!1,i=!1){const r=e-2,n=t.indexBuffer;for(let t=0;t<r;t++){const r=this._currentPoint/3,o=e*(i?2:1),a=r-o;n[this._currentIndex]=a,this._currentIndex++;const l=r+t+(s?2:1)-o;n[this._currentIndex]=l,this._currentIndex++;const c=r+t+(s?1:2)-o;n[this._currentIndex]=c,this._currentIndex++}}getPathPositions(t,e,s){const i=this._currentPoint/3-t,r=i;let n=i-t;return e&&(n=this.fetchLinkedVertex(i,s,t)),{p3:n,p1:i,p2:r}}newAxisPart(t,e,s,i,r,n){const o=t.parts(e),a=t.order(e);this.manageAxisPartCreation(o,t,a,i,s,r,n),n.first=!1,n.last=!1}fetchLinkedVertex(t,e,s){this._closest=Number.MAX_VALUE;for(let i=0;i<s;i++){this._total=0;const r=t+s;this.findLinkedVertex(t,r,e,s,i);this._total<this._closest&&(this._closest=this._total,this._result=t-s+i+1)}return this._result}setPathNormal(t,e,s){const i=td.temp.vector,r=td.circleCurvePoints[t];i.copy(r),i.applyQuaternion(e);const n=s.normalBuffer,o=this._currentPoint,a=this._currentPoint+1,l=this._currentPoint+2;n[o]=i.x*hh,n[a]=i.y*hh,n[l]=i.z*hh}point(t,e,s){const i=e.positionBuffer,r=3*t+1,n=3*t+2,o=i[3*t],a=i[r],l=i[n];return s.set(o,a,l),s}}class sd{constructor(t){ot(this,"_meshes"),ot(this,"_results",[]),ot(this,"_circleExtrusion",new Sr),ot(this,"_axis",new Tr),this._meshes=t}raycast(t,e){this._results.length=0,this._meshes.circleExtrusions(t,this._circleExtrusion);for(let t=0,s=this._circleExtrusion.axesLength();t<s;t++){this._circleExtrusion.axes(t,this._axis);const s=this._circleExtrusion.radius(t);this.traverseAllCurves(e,s)}return this._results}getTraverseWiresEvent(t,e){return(s,i)=>{this.castCurveExtrusion(s,i,t,e)}}castCurveExtrusion(t,e,s,i){const r=Kh.raycastCircleExtr(t,e,s,i);for(const t of r)this._results.push(t)}getTraverseCircleCurveEvent(t,e){return(s,i,r)=>{const n=i[0];this.castCurveExtrusion(s,n,t,e);for(let s=0;s<i.length;s++){if(0===s)continue;const r=i[s-1],n=i[s];this.castCurveExtrusion(r,n,t,e)}const o=i[i.length-1];this.castCurveExtrusion(o,r,t,e)}}traverseAllCurves(t,e){const s=this.getTraverseWiresEvent(t,e);Kh.traverseWires(this._axis,s);const i=this.getTraverseCircleCurveEvent(t,e),r=Kh.circleCurve3Divisions;Kh.traverseCircleCurve(this._axis,i,r);const n=this.getTraverseWiresEvent(t,e);Kh.traverseWireSets(this._axis,n)}}class id{constructor(t){ot(this,"_meshes"),ot(this,"_found",[]),ot(this,"_circleExtrusion",new Sr),ot(this,"_axis",new Tr),ot(this,"_wirePoint",new ft.Vector3),this._meshes=t}lineRaycast(t,e){this._found.length=0,this._meshes.circleExtrusions(t,this._circleExtrusion);const s=this._circleExtrusion.axesLength();for(let t=0;t<s;t++)this._circleExtrusion.axes(t,this._axis),this.processLineRaycast(t,e);return this._found}wireSetRaycast(t,e){const s=this._axis;Kh.traverseWireSets(s,((s,i)=>{this.cylinderRaycast(s,i,t,e)}))}exclusiveCylinderRaycast(t,e){const s=this._axis,i=this.getCylinderRaycastEvent(t,e);Kh.traverseWires(s,i)}processLineRaycast(t,e){const s=this._circleExtrusion.radius(t);this.exclusiveCylinderRaycast(e,s),this.circleCurveRaycast(e,s),this.wireSetRaycast(e,s)}getCylinderRaycastEvent(t,e){return(s,i)=>{this.cylinderRaycast(s,i,t,e)}}processCircleCurveBody(t,e,s){for(let i=0;i<t.length;i++){if(0===i)continue;const r=t[i],n=t[i-1];this.cylinderRaycast(n,r,e,s)}}getCircleCurveRaycastEvent(t,e){return(s,i,r)=>{this.cylinderRaycast(s,i[0],t,e),this.processCircleCurveBody(i,t,e);const n=i[i.length-1];this.cylinderRaycast(n,r,t,e)}}fetchCylinderRaycastResult(t,e,s){t.distanceSqToSegment(e,s,void 0,this._wirePoint);const i=this.newResult(e,s);this._found.push(i)}circleCurveRaycast(t,e){const s=Kh.circleCurve3Divisions,i=this.getCircleCurveRaycastEvent(t,e);Kh.traverseCircleCurve(this._axis,i,s)}newResult(t,e){return{point:this._wirePoint.clone(),raySquaredDistance:void 0,snappedEdgeP1:t.clone(),snappedEdgeP2:e.clone()}}cylinderRaycast(t,e,s,i){const r=Kh.raycastCircleExtr(t,e,s,i);for(const i of r)i.point&&this.fetchCylinderRaycastResult(s,t,e)}}class rd{constructor(t){ot(this,"_meshes"),ot(this,"_results",[]),ot(this,"_circleExtrusion",new Sr),ot(this,"_axis",new Tr),ot(this,"_normal",new ft.Vector3),ot(this,"_point",new ft.Vector3),ot(this,"_plane",new ft.Plane),this._meshes=t}pointRaycast(t,e){return this._results.length=0,this._meshes.circleExtrusions(t,this._circleExtrusion),this.traverseAllCircleExtrusions(e),this.getCleanResults()}fetchOrientation(t,e){td.temp.vector.copy(t),td.temp.vector.sub(e),td.temp.vector.normalize();td.temp.rotation.setFromUnitVectors(td.up,td.temp.vector)}getTraverseWiresEvent(t,e){return(s,i)=>{this.fetchOrientation(s,i);const r=this.raycastCutCircleExtrusion(s,t,e),n=this.raycastCutCircleExtrusion(i,t,e);this._results.push(r,n)}}traverseAllCircleExtrusions(t){const e=this._circleExtrusion.axesLength();for(let s=0;s<e;s++){this._circleExtrusion.axes(s,this._axis);const e=this._circleExtrusion.radius(s),i=td.vertexLength(e);td.setPathVertices(i),this.traverseAllCurves(t,e)}}setupCuttedCircleExtrusion(t){this._normal.set(0,0,1),this._normal.applyQuaternion(td.temp.rotation),this._plane.setFromNormalAndCoplanarPoint(this._normal,t)}getTraverseCircleCurveEvent(t,e){return(s,i,r)=>{this.fetchOrientation(s,i[0]);const n=this.raycastCutCircleExtrusion(s,t,e),o=i[i.length-1];this.fetchOrientation(o,r);const a=this.raycastCutCircleExtrusion(r,t,e);this._results.push(n,a)}}computeCutCircleExtrCast(t,e,s){s.intersectPlane(this._plane,this._point);if(this._point.distanceTo(t)<=e){return{point:t.clone()}}}raycastCutCircleExtrusion(t,e,s){this.setupCuttedCircleExtrusion(t);if(e.intersectsPlane(this._plane))return this.computeCutCircleExtrCast(t,s,e)}getCleanResults(){const t=[];for(const e of this._results)e&&t.push(e);return t}traverseAllCurves(t,e){const s=this.getTraverseWiresEvent(t,e);Kh.traverseWires(this._axis,s);const i=this.getTraverseCircleCurveEvent(t,e),r=Kh.circleCurve3Divisions;Kh.traverseCircleCurve(this._axis,i,r);const n=this.getTraverseWiresEvent(t,e);Kh.traverseWireSets(this._axis,n)}}class nd{constructor(){ot(this,"_currentElement",0),ot(this,"_wireSize",6),ot(this,"newCircleCurveLod",((t,e,s)=>{const i=this.newCircleCurveLodPath(t,e),r=s.positionBuffer;for(let t=1;t<i;t++){const e=td.circleCurves[t-1],s=td.circleCurves[t];this.newWire(r,e,s)}})),ot(this,"newWireSetLod",((t,e,s)=>{const i=t.wireSets(e),r=i.psLength(),n=s.positionBuffer;for(let t=1;t<r;t++){const e=i.ps(t-1),s=i.ps(t);this.newWire(n,e,s)}})),ot(this,"newWireTemplate",((t,e)=>{e.positionCount+=this._wireSize})),ot(this,"newWireSetTemplate",((t,e)=>{const s=td.temp.axis.wireSets(t,td.temp.wireSet).psLength()-1;e.positionCount+=this._wireSize*s})),ot(this,"newWireLod",((t,e,s)=>{const i=t.wires(e),r=i.p1(),n=i.p2(),o=s.positionBuffer;this.newWire(o,r,n)})),ot(this,"newCircleCurveTemplate",((t,e)=>{const s=td.temp.axis.circleCurves(t,td.temp.circleCurve),i=Kh.circleCurve3Divisions(s);e.positionCount+=this._wireSize*(i-1)}))}construct(t,e){this._currentElement=0,e.positionBuffer=new Float32Array(e.positionCount);for(let s=0,i=t.axesLength();s<i;s++)t.axes(s,td.temp.axis),this.constructLod(e);return e}constructCircleExtrusionLod(t,e){const s=td.temp.axis,i=s.parts(t),r=s.order(t);this.getLodConstructor(i)(s,r,e)}newCircleCurveLodPath(t,e){const s=t.circleCurves(e),i=Kh.circleCurve3Divisions(s);return td.circleCurves=td.newPaths(s,i),i}selectNextWire(){this._currentElement+=this._wireSize}getAxisPartVertexSize(t,e){const s=td.temp.axis,i=s.parts(t),r=s.order(t);this.getTemplateConstructor(i)(r,e)}getIndices(){return{i1:this._currentElement,i2:this._currentElement+1,i3:this._currentElement+2,i4:this._currentElement+3,i5:this._currentElement+4,i6:this._currentElement+5}}setAxisTemplate(t,e){td.temp.circleExtrusion.axes(t,td.temp.axis);const s=td.temp.axis.partsLength();for(let t=0;t<s;t++)this.getAxisPartVertexSize(t,e);this.setAxisThickness(e,t)}constructLod(t){const e=td.temp.axis.orderLength();for(let s=0;s<e;s++)this.constructCircleExtrusionLod(s,t)}getLodConstructor(t){return{[br.WIRE]:this.newWireLod,[br.WIRE_SET]:this.newWireSetLod,[br.CIRCLE_CURVE]:this.newCircleCurveLod}[t]}newTemplate(){const t=td.temp.circleExtrusion,e=this.newTemplateData(),s=t.axesLength();for(let t=0;t<s;t++)this.setAxisTemplate(t,e);return e}setAxisThickness(t,e){const s=t.lodThickness,i=td.temp.circleExtrusion.radius(e);t.lodThickness=Math.max(s,i)}newTemplateData(){return{objectClass:On.LINE,lod:Nn.WIRES,lodThickness:0,positionCount:0}}getTemplateConstructor(t){return{[br.WIRE]:this.newWireTemplate,[br.WIRE_SET]:this.newWireSetTemplate,[br.CIRCLE_CURVE]:this.newCircleCurveTemplate}[t]}newWire(t,e,s){const i=e instanceof ft.Vector3?e.x:e.x(),r=e instanceof ft.Vector3?e.y:e.y(),n=e instanceof ft.Vector3?e.z:e.z(),o=s instanceof ft.Vector3?s.x:s.x(),a=s instanceof ft.Vector3?s.y:s.y(),l=s instanceof ft.Vector3?s.z:s.z(),{i1:c,i2:h,i3:d,i4:u,i5:f,i6:p}=this.getIndices();t[c]=i,t[h]=r,t[d]=n,t[u]=o,t[f]=a,t[p]=l,this.selectNextWire()}}class od extends ch{constructor(){super(...arguments),ot(this,"_vceConstructor",new ed),ot(this,"_lodConstructor",new nd),ot(this,"_vceRaycaster",new sd(this.meshes)),ot(this,"_vceLineRaycaster",new id(this.meshes)),ot(this,"_vcePointRaycaster",new rd(this.meshes)),ot(this,"_representationClass",Gr.CIRCLE_EXTRUSION),ot(this,"_objectClass",On.LINE),ot(this,"lodClass",dh.CUSTOM)}setupTemplates(){const t=this.meshes.circleExtrusionsLength();for(let e=0;e<t;e++)this.newCircleExtrusionTemplate(e)}fetchLod(t,e){const s=this.getMesh(t,Nn.WIRES);return this.generateLodIfNeeded(t,e,s),s}fetchMeshes(t,e){const s=this.getMesh(t,Nn.GEOMETRY);return this.generateMeshesIfNeeded(t,e,s),s}raycast(t,e){return this._vceRaycaster.raycast(t,e)}faceRaycast(){return[]}pointRaycast(t,e){return this._vcePointRaycaster.pointRaycast(t,e)}lineRaycast(t,e){return this._vceLineRaycaster.lineRaycast(t,e)}getObjectClass(){return this._objectClass}getRepresentation(){return this._representationClass}getLodClass(){return this.lodClass}newMeshes(t,e){this.meshes.circleExtrusions(t,td.temp.circleExtrusion);const s=td.temp.circleExtrusion;this._vceConstructor.construct(s,e),this.saveMesh(t,e,Nn.GEOMETRY)}generateMeshesIfNeeded(t,e,s){if(0===s.length)return;const i=Boolean(s.length),r=!s[0].positionBuffer;e&&r&&i&&this.newMeshes(t,s)}newCircleExtrusionTemplate(t){const e=[];this.meshes.circleExtrusions(t,td.temp.circleExtrusion);const s=td.temp.circleExtrusion,i=s.axesLength();for(let t=0;t<i;t++)this._vceConstructor.newTemplate(s,t,e);const r=this._lodConstructor.newTemplate();this.useMesh(t,e,Nn.GEOMETRY),this.useMesh(t,r,Nn.WIRES)}generateLodIfNeeded(t,e,s){!s.positionBuffer&&e&&(this.meshes.circleExtrusions(t,td.temp.circleExtrusion),this._lodConstructor.construct(td.temp.circleExtrusion,s),this.saveMesh(t,s,Nn.WIRES))}}class ad{constructor(t){ot(this,"size"),ot(this,"_data"),ot(this,"_highlightData"),this.size=t,this._data=new Uint8Array(t),this._highlightData=new Uint16Array(t),this._data.fill(1)}getHighlight(t){return this._highlightData[t]}setHighlight(t,e){Ao.checkMemory(e),this._highlightData[t]=e}clearHighlight(){this._highlightData.fill(0)}visible(t){return Ao.check(this._data,t,Pn.VISIBLE)}setVisible(t,e){Ao.apply(this._data,t,Pn.VISIBLE,e)}clearVisible(){this._data.fill(1)}}class ld{constructor(t,e){ot(this,"_rate",64),ot(this,"_updater"),ot(this,"_modelId"),ot(this,"_threshold",16),ot(this,"_connection"),ot(this,"_list",[]),ot(this,"refresh",(()=>{if(this._list.length){const t=this._list;this._connection.fetchMeshCompute(this._modelId,t),this._list=[]}})),this._modelId=t,this._connection=e,this._updater=Pa.newUpdater(this.refresh,this._rate)}get needsRefresh(){return this._list.length>this._threshold}dispose(){Pa.deleteUpdater(this._updater)}clean(){this._list=Pa.cleanRequests(this._list)}process(t){this._list.push(t),this.needsRefresh&&this.refresh()}}class cd{constructor(t,e,s,i){ot(this,"_meshes"),ot(this,"_model"),ot(this,"_boxes"),ot(this,"_tiles"),ot(this,"_items"),ot(this,"_edgeThreshold",8),ot(this,"_raycastMultiplier",32),ot(this,"_maxDuration",512),ot(this,"_precission",.001),ot(this,"_temp",{sample:new Or,representation:new Lr,tempPlane:new ft.Plane,ray:new ft.Ray,frustum:new ft.Frustum,m1:new ft.Matrix4,m2:new ft.Matrix4,m3:new ft.Matrix4,v1:new ft.Vector3,planes:[]}),this._model=t,this._boxes=e,this._tiles=s,this._items=i,this._meshes=t.meshes()}static cast(t,e,s,i,r){const n=e.id();return r===Mn.FACE?t.faceRaycast(n,s,i):r===Mn.LINE?t.lineRaycast(n,s,i):r===Mn.POINT?t.pointRaycast(n,s,i):void 0===r?t.raycast(n,s,i):void 0}raycast(t,e,s,i){const r={ray:t,frustum:e,planes:s,returnAll:i},n=this.castBox(e,s);return n.length?this.computeRaycastList(n,r):null}snapRaycast(t,e,s,i){const r=[],n={ray:t,frustum:e,planes:i},o=this.raycast(t,e,i);return o?(this.getSnaps(o,n,s,r),o.normal?this.filterOnFront(r):r):this.snapCastEdges(n,s)}rectangleRaycast(t,e,s){const i=this._boxes.lookup;if(!i)return[];const r=i.collideFrustum(e,t,s),n=this.filterVisible(r);return this.localIdsFromItemIds(n)}snapCastEdges(t,e){const s=[],i=e.includes(Mn.POINT),r=e.includes(Mn.LINE);return(i||r)&&this.computeEdgesCast(t,e,s),this.addDistanceToEdgeResult(s,t.ray),s}filterVisible(t){const e=[];for(const s of t){this._meshes.samples(s,this._temp.sample);const t=this._temp.sample.item();this._items.visible(t)&&e.push(s)}return e}computeSnaps(t,e,s,i){for(const r of t){if(this.isValidSnap(r)){const t={snap:r,...e},n=this.castSample(s,t);for(const t of n)i.push(t)}}}computeEdgesCast(t,e,s){const i=this.getRawEdges(t),r=performance.now();for(const n of i){this.fetchSampleData(n),this.computeSnaps(e,t,n,s);if(this.isTimeExceeded(r))break}}addDistanceToEdgeResult(t,e){for(const s of t){const t=s.point;s.raySquaredDistance=e.distanceSqToPoint(t)}}getRawEdges(t){const e=this.castBox(t.frustum,t.planes);return e.length<=this._edgeThreshold?e:this.sortBoxes(t.ray,e,this._edgeThreshold)}sortBoxes(t,e,s){const i=[],r=new ft.Vector3,n=t.origin;for(let s=0;s<e.length;s++){const o=e[s],a=this._boxes.get(o);t.intersectBox(a,r);const l=r.distanceToSquared(n);i.push(l)}const o=this.dataSort(e,i);return s&&o.length>s&&o.splice(s),o}castBox(t,e){const s=this._boxes.lookup;if(!s)return[];if(t instanceof ft.Ray){const i=s.collideRay(e,t);return this.filterVisible(i)}const i=s.collideFrustum(e,t);return this.filterVisible(i)}dataSort(t,e){const s=Array.from(t.keys()).sort(((t,s)=>e[t]-e[s])),i=[];for(const e of s){const s=t[e];i.push(s)}return i}localIdsFromItemIds(t){const e=new Set;for(const s of t){this._meshes.samples(s,this._temp.sample);const t=this._temp.sample.item(),i=this._meshes.meshesItems(t);if(null===i)continue;const r=this._model.localIds(i);null!==r&&e.add(r)}return Array.from(e)}getNearest(t){let e=t[0];for(let s=1;s<t.length;s++){const i=t[s];if(e.raySquaredDistance&&i.raySquaredDistance){const t=this.getNearScore(e);this.getNearScore(i)<t&&(e=i)}else i.cameraSquaredDistance<e.cameraSquaredDistance&&(e=i)}return e}getEdges(t,e,s){const i=this.snapCastEdges(t,e);if(i)for(const t of i)s.push(t)}getNearScore(t){const e=this._raycastMultiplier;return t.raySquaredDistance*e+t.cameraSquaredDistance}setupSampleCastData(t){Fo.get(this._temp.sample,this._meshes,this._temp.m1),this._temp.m2.copy(this._temp.m1).invert(),this._temp.ray.copy(t.ray).applyMatrix4(this._temp.m2),Gn.transform(t.frustum,this._temp.m2,this._temp.frustum)}addLocalId(t){if(!t)return;const e=this._meshes.meshesItems(t.itemId);null!==e&&(t.localId=this._model.localIds(e))}fetchSampleData(t){this._meshes.samples(t,this._temp.sample);const e=this._temp.sample.representation();this._meshes.representations(e,this._temp.representation)}computeRaycastList(t,e){const s=Array.from(new Set(t)),i=this.sortBoxes(e.ray,s),r=this.castBox(e.ray,e.planes),n=this.findAll(i,r,e);if(n.length){if(e.returnAll){for(const t of n)this.addLocalId(t);return n}const t=this.getNearest(n);return this.addLocalId(t),t}return null}formatRaycastResult(t,e,s){for(const i of t){if(i.point.applyMatrix4(this._temp.m1),i.normal&&i.normal.transformDirection(this._temp.m1),"facePoints"in i){const t=this._meshes.samples(e,this._temp.sample);Fo.get(t,this._meshes,this._temp.m3);for(let t=0;t<i.facePoints.length;t+=3){const e=i.facePoints[t],s=i.facePoints[t+1],r=i.facePoints[t+2];this._temp.v1.set(e,s,r),this._temp.v1.applyMatrix4(this._temp.m3),i.facePoints[t]=this._temp.v1.x,i.facePoints[t+1]=this._temp.v1.y,i.facePoints[t+2]=this._temp.v1.z}}i.sampleId=e,i.itemId=this._temp.sample.item();const t=s.ray.origin.distanceToSquared(i.point);i.cameraSquaredDistance=t,i.snappingClass||(i.snappingClass=s.snap),i.snappedEdgeP1&&i.snappedEdgeP1.applyMatrix4(this._temp.m1),i.snappedEdgeP2&&i.snappedEdgeP2.applyMatrix4(this._temp.m1)}}findAll(t,e,s){const i=[],r=performance.now();for(const n of t){if(this.fetchSampleData(n),!e.includes(n))continue;const t=this.castSample(n,s);for(const e of t)i.push(e);if(this.isTimeExceeded(r))break}return i}isTimeExceeded(t){return performance.now()-t>this._maxDuration}getFilteredSampleCast(t){const e=this._tiles.raycast(this._temp.representation,this._temp.ray,this._temp.frustum,t.snap);if(0===this._temp.planes.length)return e;const s=[];if(e)for(const t of e){const e=this._temp.planes,i=t.point;zn.containedInParallelPlanes(e,i)&&s.push(t)}return s}getSnaps(t,e,s,i){this.fetchSampleData(t.sampleId),t.normal&&(this.setCastSide(t,e.ray),this.setCastPlane(t)),this.getFaces(s,e,t,i),this.getEdges(e,s,i);for(const t of i)this.addLocalId(t)}filterOnFront(t){const e=[];for(const s of t){this._temp.tempPlane.distanceToPoint(s.point)>=0&&e.push(s)}return e}setCastSide(t,e){const s=t.point.clone().sub(e.origin);t.normal.dot(s)>0&&t.normal.negate()}getFaces(t,e,s,i){for(const r of t){const t={snap:r,...e},n=this.castSample(s.sampleId,t);for(const t of n)i.push(t)}}setCastPlane(t){const e=this._temp.tempPlane,s=t.point.clone(),i=t.normal.clone();i.multiplyScalar(this._precission),s.sub(i),e.setFromNormalAndCoplanarPoint(t.normal,s)}castSample(t,e){this.setupSampleCastData(e),this.setupPlanesForSampleCast(e);const s=this.getFilteredSampleCast(e);return s&&this.formatRaycastResult(s,t,e),s}isValidSnap(t){const e=t===Mn.LINE,s=t===Mn.POINT;return e||s}transform(t,e){const s=[];if(t)for(const i of t){const t=(new ft.Plane).copy(i);t.applyMatrix4(e),s.push(t)}return s}setupPlanesForSampleCast(t){if(this._temp.planes.length=0,t.planes&&t.planes.length>0){const e=this.transform(t.planes,this._temp.m2);for(const t of e)this._temp.planes.push(t)}}}const hd="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,dd=new Set,ud="object"==typeof process&&process?process:{},fd=(t,e,s,i)=>{"function"==typeof ud.emitWarning?ud.emitWarning(t,e,s,i):console.error(`[${s}] ${e}: ${t}`)};let pd=globalThis.AbortController,Id=globalThis.AbortSignal;if(void 0===pd){Id=class{constructor(){ot(this,"onabort"),ot(this,"_onabort",[]),ot(this,"reason"),ot(this,"aborted",!1)}addEventListener(t,e){this._onabort.push(e)}},pd=class{constructor(){ot(this,"signal",new Id),s()}abort(t){var e,s;if(!this.signal.aborted){this.signal.reason=t,this.signal.aborted=!0;for(const e of this.signal._onabort)e(t);null==(s=(e=this.signal).onabort)||s.call(e,t)}}};let e="1"!==(null==(t=ud.env)?void 0:t.LRU_CACHE_IGNORE_AC_WARNING);const s=()=>{e&&(e=!1,fd("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",s))}}const md=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),Ed=t=>md(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?_d:null:null;class _d extends Array{constructor(t){super(t),this.fill(0)}}const gd=class t{constructor(s,i){if(ot(this,"heap"),ot(this,"length"),!lt(t,e))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new i(s),this.length=0}static create(s){const i=Ed(s);if(!i)return[];ht(t,e,!0);const r=new t(s,i);return ht(t,e,!1),r}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}};e=new WeakMap,ct(gd,e,!1);let Cd=gd;const Td=class t{constructor(e){ct(this,F),ct(this,v),ct(this,V),ct(this,z),ct(this,H),ct(this,W),ct(this,j),ct(this,Z),ct(this,Q),ct(this,J),ct(this,et),ct(this,it),ct(this,s,void 0),ct(this,i,void 0),ct(this,r,void 0),ct(this,n,void 0),ct(this,o,void 0),ct(this,a,void 0),ct(this,l,void 0),ot(this,"ttl"),ot(this,"ttlResolution"),ot(this,"ttlAutopurge"),ot(this,"updateAgeOnGet"),ot(this,"updateAgeOnHas"),ot(this,"allowStale"),ot(this,"noDisposeOnSet"),ot(this,"noUpdateTTL"),ot(this,"maxEntrySize"),ot(this,"sizeCalculation"),ot(this,"noDeleteOnFetchRejection"),ot(this,"noDeleteOnStaleGet"),ot(this,"allowStaleOnFetchAbort"),ot(this,"allowStaleOnFetchRejection"),ot(this,"ignoreFetchAbort"),ct(this,c,void 0),ct(this,h,void 0),ct(this,d,void 0),ct(this,u,void 0),ct(this,f,void 0),ct(this,p,void 0),ct(this,I,void 0),ct(this,m,void 0),ct(this,E,void 0),ct(this,_,void 0),ct(this,g,void 0),ct(this,C,void 0),ct(this,T,void 0),ct(this,b,void 0),ct(this,R,void 0),ct(this,A,void 0),ct(this,y,void 0),ct(this,S,void 0),ct(this,L,(()=>{})),ct(this,O,(()=>{})),ct(this,x,(()=>{})),ct(this,N,(()=>!1)),ct(this,M,(t=>{})),ct(this,D,((t,e,s)=>{})),ct(this,U,((t,e,s,i)=>{if(s||i)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0})),ot(this,Y,"LRUCache");const{max:B=0,ttl:G,ttlResolution:k=1,ttlAutopurge:q,updateAgeOnGet:X,updateAgeOnHas:$,allowStale:K,dispose:tt,onInsert:st,disposeAfter:rt,noDisposeOnSet:nt,noUpdateTTL:at,maxSize:dt=0,maxEntrySize:ft=0,sizeCalculation:pt,fetchMethod:It,memoMethod:mt,noDeleteOnFetchRejection:Et,noDeleteOnStaleGet:_t,allowStaleOnFetchRejection:gt,allowStaleOnFetchAbort:Ct,ignoreFetchAbort:Tt}=e;if(0!==B&&!md(B))throw new TypeError("max option must be a nonnegative integer");const bt=B?Ed(B):Array;if(!bt)throw new Error("invalid max value: "+B);if(ht(this,s,B),ht(this,i,dt),this.maxEntrySize=ft||lt(this,i),this.sizeCalculation=pt,this.sizeCalculation){if(!lt(this,i)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==mt&&"function"!=typeof mt)throw new TypeError("memoMethod must be a function if defined");if(ht(this,l,mt),void 0!==It&&"function"!=typeof It)throw new TypeError("fetchMethod must be a function if specified");if(ht(this,a,It),ht(this,A,!!It),ht(this,d,new Map),ht(this,u,new Array(B).fill(void 0)),ht(this,f,new Array(B).fill(void 0)),ht(this,p,new bt(B)),ht(this,I,new bt(B)),ht(this,m,0),ht(this,E,0),ht(this,_,Cd.create(B)),ht(this,c,0),ht(this,h,0),"function"==typeof tt&&ht(this,r,tt),"function"==typeof st&&ht(this,n,st),"function"==typeof rt?(ht(this,o,rt),ht(this,g,[])):(ht(this,o,void 0),ht(this,g,void 0)),ht(this,R,!!lt(this,r)),ht(this,S,!!lt(this,n)),ht(this,y,!!lt(this,o)),this.noDisposeOnSet=!!nt,this.noUpdateTTL=!!at,this.noDeleteOnFetchRejection=!!Et,this.allowStaleOnFetchRejection=!!gt,this.allowStaleOnFetchAbort=!!Ct,this.ignoreFetchAbort=!!Tt,0!==this.maxEntrySize){if(0!==lt(this,i)&&!md(lt(this,i)))throw new TypeError("maxSize must be a positive integer if specified");if(!md(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");ut(this,v,P).call(this)}if(this.allowStale=!!K,this.noDeleteOnStaleGet=!!_t,this.updateAgeOnGet=!!X,this.updateAgeOnHas=!!$,this.ttlResolution=md(k)||0===k?k:1,this.ttlAutopurge=!!q,this.ttl=G||0,this.ttl){if(!md(this.ttl))throw new TypeError("ttl must be a positive integer if specified");ut(this,F,w).call(this)}if(0===lt(this,s)&&0===this.ttl&&0===lt(this,i))throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!lt(this,s)&&!lt(this,i)){const e="LRU_CACHE_UNBOUNDED";if((t=>!dd.has(t))(e)){dd.add(e);fd("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",e,t)}}}static unsafeExposeInternals(t){return{starts:lt(t,T),ttls:lt(t,b),sizes:lt(t,C),keyMap:lt(t,d),keyList:lt(t,u),valList:lt(t,f),next:lt(t,p),prev:lt(t,I),get head(){return lt(t,m)},get tail(){return lt(t,E)},free:lt(t,_),isBackgroundFetch:e=>{var s;return ut(s=t,Z,$).call(s,e)},backgroundFetch:(e,s,i,r)=>{var n;return ut(n=t,j,X).call(n,e,s,i,r)},moveToTail:e=>{var s;return ut(s=t,J,tt).call(s,e)},indexes:e=>{var s;return ut(s=t,V,B).call(s,e)},rindexes:e=>{var s;return ut(s=t,z,G).call(s,e)},isStale:e=>{var s;return lt(s=t,N).call(s,e)}}}get max(){return lt(this,s)}get maxSize(){return lt(this,i)}get calculatedSize(){return lt(this,h)}get size(){return lt(this,c)}get fetchMethod(){return lt(this,a)}get memoMethod(){return lt(this,l)}get dispose(){return lt(this,r)}get onInsert(){return lt(this,n)}get disposeAfter(){return lt(this,o)}getRemainingTTL(t){return lt(this,d).has(t)?1/0:0}*entries(){for(const t of ut(this,V,B).call(this))void 0===lt(this,f)[t]||void 0===lt(this,u)[t]||ut(this,Z,$).call(this,lt(this,f)[t])||(yield[lt(this,u)[t],lt(this,f)[t]])}*rentries(){for(const t of ut(this,z,G).call(this))void 0===lt(this,f)[t]||void 0===lt(this,u)[t]||ut(this,Z,$).call(this,lt(this,f)[t])||(yield[lt(this,u)[t],lt(this,f)[t]])}*keys(){for(const t of ut(this,V,B).call(this)){const e=lt(this,u)[t];void 0===e||ut(this,Z,$).call(this,lt(this,f)[t])||(yield e)}}*rkeys(){for(const t of ut(this,z,G).call(this)){const e=lt(this,u)[t];void 0===e||ut(this,Z,$).call(this,lt(this,f)[t])||(yield e)}}*values(){for(const t of ut(this,V,B).call(this)){void 0===lt(this,f)[t]||ut(this,Z,$).call(this,lt(this,f)[t])||(yield lt(this,f)[t])}}*rvalues(){for(const t of ut(this,z,G).call(this)){void 0===lt(this,f)[t]||ut(this,Z,$).call(this,lt(this,f)[t])||(yield lt(this,f)[t])}}[Symbol.iterator](){return this.entries()}find(t,e={}){for(const s of ut(this,V,B).call(this)){const i=lt(this,f)[s],r=ut(this,Z,$).call(this,i)?i.__staleWhileFetching:i;if(void 0!==r&&t(r,lt(this,u)[s],this))return this.get(lt(this,u)[s],e)}}forEach(t,e=this){for(const s of ut(this,V,B).call(this)){const i=lt(this,f)[s],r=ut(this,Z,$).call(this,i)?i.__staleWhileFetching:i;void 0!==r&&t.call(e,r,lt(this,u)[s],this)}}rforEach(t,e=this){for(const s of ut(this,z,G).call(this)){const i=lt(this,f)[s],r=ut(this,Z,$).call(this,i)?i.__staleWhileFetching:i;void 0!==r&&t.call(e,r,lt(this,u)[s],this)}}purgeStale(){let t=!1;for(const e of ut(this,z,G).call(this,{allowStale:!0}))lt(this,N).call(this,e)&&(ut(this,et,st).call(this,lt(this,u)[e],"expire"),t=!0);return t}info(t){const e=lt(this,d).get(t);if(void 0===e)return;const s=lt(this,f)[e],i=ut(this,Z,$).call(this,s)?s.__staleWhileFetching:s;if(void 0===i)return;const r={value:i};if(lt(this,b)&&lt(this,T)){const t=lt(this,b)[e],s=lt(this,T)[e];if(t&&s){const e=t-(hd.now()-s);r.ttl=e,r.start=Date.now()}}return lt(this,C)&&(r.size=lt(this,C)[e]),r}dump(){const t=[];for(const e of ut(this,V,B).call(this,{allowStale:!0})){const s=lt(this,u)[e],i=lt(this,f)[e],r=ut(this,Z,$).call(this,i)?i.__staleWhileFetching:i;if(void 0===r||void 0===s)continue;const n={value:r};if(lt(this,b)&&lt(this,T)){n.ttl=lt(this,b)[e];const t=hd.now()-lt(this,T)[e];n.start=Math.floor(Date.now()-t)}lt(this,C)&&(n.size=lt(this,C)[e]),t.unshift([s,n])}return t}load(t){this.clear();for(const[e,s]of t){if(s.start){const t=Date.now()-s.start;s.start=hd.now()-t}this.set(e,s.value,s)}}set(t,e,i={}){var a,l,h,m,C,T,L;if(void 0===e)return this.delete(t),this;const{ttl:N=this.ttl,start:v,noDisposeOnSet:P=this.noDisposeOnSet,sizeCalculation:V=this.sizeCalculation,status:B}=i;let{noUpdateTTL:z=this.noUpdateTTL}=i;const G=lt(this,U).call(this,t,e,i.size||0,V);if(this.maxEntrySize&&G>this.maxEntrySize)return B&&(B.set="miss",B.maxEntrySizeExceeded=!0),ut(this,et,st).call(this,t,"set"),this;let H=0===lt(this,c)?void 0:lt(this,d).get(t);if(void 0===H)H=0===lt(this,c)?lt(this,E):0!==lt(this,_).length?lt(this,_).pop():lt(this,c)===lt(this,s)?ut(this,W,q).call(this,!1):lt(this,c),lt(this,u)[H]=t,lt(this,f)[H]=e,lt(this,d).set(t,H),lt(this,p)[lt(this,E)]=H,lt(this,I)[H]=lt(this,E),ht(this,E,H),dt(this,c)._++,lt(this,D).call(this,H,G,B),B&&(B.set="add"),z=!1,lt(this,S)&&(null==(a=lt(this,n))||a.call(this,e,t,"add"));else{ut(this,J,tt).call(this,H);const s=lt(this,f)[H];if(e!==s){if(lt(this,A)&&ut(this,Z,$).call(this,s)){s.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:e}=s;void 0===e||P||(lt(this,R)&&(null==(l=lt(this,r))||l.call(this,e,t,"set")),lt(this,y)&&(null==(h=lt(this,g))||h.push([e,t,"set"])))}else P||(lt(this,R)&&(null==(m=lt(this,r))||m.call(this,s,t,"set")),lt(this,y)&&(null==(C=lt(this,g))||C.push([s,t,"set"])));if(lt(this,M).call(this,H),lt(this,D).call(this,H,G,B),lt(this,f)[H]=e,B){B.set="replace";const t=s&&ut(this,Z,$).call(this,s)?s.__staleWhileFetching:s;void 0!==t&&(B.oldValue=t)}}else B&&(B.set="update");lt(this,S)&&(null==(T=this.onInsert)||T.call(this,e,t,e===s?"update":"replace"))}if(0===N||lt(this,b)||ut(this,F,w).call(this),lt(this,b)&&(z||lt(this,x).call(this,H,N,v),B&&lt(this,O).call(this,B,H)),!P&&lt(this,y)&&lt(this,g)){const t=lt(this,g);let e;for(;e=null==t?void 0:t.shift();)null==(L=lt(this,o))||L.call(this,...e)}return this}pop(){var t;try{for(;lt(this,c);){const t=lt(this,f)[lt(this,m)];if(ut(this,W,q).call(this,!0),ut(this,Z,$).call(this,t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(lt(this,y)&&lt(this,g)){const e=lt(this,g);let s;for(;s=null==e?void 0:e.shift();)null==(t=lt(this,o))||t.call(this,...s)}}}has(t,e={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:i}=e,r=lt(this,d).get(t);if(void 0!==r){const t=lt(this,f)[r];if(ut(this,Z,$).call(this,t)&&void 0===t.__staleWhileFetching)return!1;if(!lt(this,N).call(this,r))return s&&lt(this,L).call(this,r),i&&(i.has="hit",lt(this,O).call(this,i,r)),!0;i&&(i.has="stale",lt(this,O).call(this,i,r))}else i&&(i.has="miss");return!1}peek(t,e={}){const{allowStale:s=this.allowStale}=e,i=lt(this,d).get(t);if(void 0===i||!s&&lt(this,N).call(this,i))return;const r=lt(this,f)[i];return ut(this,Z,$).call(this,r)?r.__staleWhileFetching:r}async fetch(t,e={}){const{allowStale:s=this.allowStale,updateAgeOnGet:i=this.updateAgeOnGet,noDeleteOnStaleGet:r=this.noDeleteOnStaleGet,ttl:n=this.ttl,noDisposeOnSet:o=this.noDisposeOnSet,size:a=0,sizeCalculation:l=this.sizeCalculation,noUpdateTTL:c=this.noUpdateTTL,noDeleteOnFetchRejection:h=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:u=this.allowStaleOnFetchRejection,ignoreFetchAbort:p=this.ignoreFetchAbort,allowStaleOnFetchAbort:I=this.allowStaleOnFetchAbort,context:m,forceRefresh:E=!1,status:_,signal:g}=e;if(!lt(this,A))return _&&(_.fetch="get"),this.get(t,{allowStale:s,updateAgeOnGet:i,noDeleteOnStaleGet:r,status:_});const C={allowStale:s,updateAgeOnGet:i,noDeleteOnStaleGet:r,ttl:n,noDisposeOnSet:o,size:a,sizeCalculation:l,noUpdateTTL:c,noDeleteOnFetchRejection:h,allowStaleOnFetchRejection:u,allowStaleOnFetchAbort:I,ignoreFetchAbort:p,status:_,signal:g};let T=lt(this,d).get(t);if(void 0===T){_&&(_.fetch="miss");const e=ut(this,j,X).call(this,t,T,C,m);return e.__returned=e}{const e=lt(this,f)[T];if(ut(this,Z,$).call(this,e)){const t=s&&void 0!==e.__staleWhileFetching;return _&&(_.fetch="inflight",t&&(_.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}const r=lt(this,N).call(this,T);if(!E&&!r)return _&&(_.fetch="hit"),ut(this,J,tt).call(this,T),i&&lt(this,L).call(this,T),_&&lt(this,O).call(this,_,T),e;const n=ut(this,j,X).call(this,t,T,C,m),o=void 0!==n.__staleWhileFetching&&s;return _&&(_.fetch=r?"stale":"refresh",o&&r&&(_.returnedStale=!0)),o?n.__staleWhileFetching:n.__returned=n}}async forceFetch(t,e={}){const s=await this.fetch(t,e);if(void 0===s)throw new Error("fetch() returned undefined");return s}memo(t,e={}){const s=lt(this,l);if(!s)throw new Error("no memoMethod provided to constructor");const{context:i,forceRefresh:r,...n}=e,o=this.get(t,n);if(!r&&void 0!==o)return o;const a=s(t,o,{options:n,context:i});return this.set(t,a,n),a}get(t,e={}){const{allowStale:s=this.allowStale,updateAgeOnGet:i=this.updateAgeOnGet,noDeleteOnStaleGet:r=this.noDeleteOnStaleGet,status:n}=e,o=lt(this,d).get(t);if(void 0!==o){const e=lt(this,f)[o],a=ut(this,Z,$).call(this,e);return n&&lt(this,O).call(this,n,o),lt(this,N).call(this,o)?(n&&(n.get="stale"),a?(n&&s&&void 0!==e.__staleWhileFetching&&(n.returnedStale=!0),s?e.__staleWhileFetching:void 0):(r||ut(this,et,st).call(this,t,"expire"),n&&s&&(n.returnedStale=!0),s?e:void 0)):(n&&(n.get="hit"),a?e.__staleWhileFetching:(ut(this,J,tt).call(this,o),i&&lt(this,L).call(this,o),e))}n&&(n.get="miss")}delete(t){return ut(this,et,st).call(this,t,"delete")}clear(){return ut(this,it,rt).call(this,"delete")}};Y=Symbol.toStringTag,s=new WeakMap,i=new WeakMap,r=new WeakMap,n=new WeakMap,o=new WeakMap,a=new WeakMap,l=new WeakMap,c=new WeakMap,h=new WeakMap,d=new WeakMap,u=new WeakMap,f=new WeakMap,p=new WeakMap,I=new WeakMap,m=new WeakMap,E=new WeakMap,_=new WeakMap,g=new WeakMap,C=new WeakMap,T=new WeakMap,b=new WeakMap,R=new WeakMap,A=new WeakMap,y=new WeakMap,S=new WeakMap,F=new WeakSet,w=function(){const t=new _d(lt(this,s)),e=new _d(lt(this,s));ht(this,b,t),ht(this,T,e),ht(this,x,((s,i,r=hd.now())=>{if(e[s]=0!==i?r:0,t[s]=i,0!==i&&this.ttlAutopurge){const t=setTimeout((()=>{lt(this,N).call(this,s)&&ut(this,et,st).call(this,lt(this,u)[s],"expire")}),i+1);t.unref&&t.unref()}})),ht(this,L,(s=>{e[s]=0!==t[s]?hd.now():0})),ht(this,O,((s,n)=>{if(t[n]){const o=t[n],a=e[n];if(!o||!a)return;s.ttl=o,s.start=a,s.now=i||r();const l=s.now-a;s.remainingTTL=o-l}}));let i=0;const r=()=>{const t=hd.now();if(this.ttlResolution>0){i=t;const e=setTimeout((()=>i=0),this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=s=>{const n=lt(this,d).get(s);if(void 0===n)return 0;const o=t[n],a=e[n];if(!o||!a)return 1/0;return o-((i||r())-a)},ht(this,N,(s=>{const n=e[s],o=t[s];return!!o&&!!n&&(i||r())-n>o}))},L=new WeakMap,O=new WeakMap,x=new WeakMap,N=new WeakMap,v=new WeakSet,P=function(){const t=new _d(lt(this,s));ht(this,h,0),ht(this,C,t),ht(this,M,(e=>{ht(this,h,lt(this,h)-t[e]),t[e]=0})),ht(this,U,((t,e,s,i)=>{if(ut(this,Z,$).call(this,e))return 0;if(!md(s)){if(!i)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof i)throw new TypeError("sizeCalculation must be a function");if(s=i(e,t),!md(s))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return s})),ht(this,D,((e,s,r)=>{if(t[e]=s,lt(this,i)){const s=lt(this,i)-t[e];for(;lt(this,h)>s;)ut(this,W,q).call(this,!0)}ht(this,h,lt(this,h)+t[e]),r&&(r.entrySize=s,r.totalCalculatedSize=lt(this,h))}))},M=new WeakMap,D=new WeakMap,U=new WeakMap,V=new WeakSet,B=function*({allowStale:t=this.allowStale}={}){if(lt(this,c))for(let e=lt(this,E);ut(this,H,k).call(this,e)&&(!t&&lt(this,N).call(this,e)||(yield e),e!==lt(this,m));)e=lt(this,I)[e]},z=new WeakSet,G=function*({allowStale:t=this.allowStale}={}){if(lt(this,c))for(let e=lt(this,m);ut(this,H,k).call(this,e)&&(!t&&lt(this,N).call(this,e)||(yield e),e!==lt(this,E));)e=lt(this,p)[e]},H=new WeakSet,k=function(t){return void 0!==t&&lt(this,d).get(lt(this,u)[t])===t},W=new WeakSet,q=function(t){var e,s;const i=lt(this,m),n=lt(this,u)[i],o=lt(this,f)[i];return lt(this,A)&&ut(this,Z,$).call(this,o)?o.__abortController.abort(new Error("evicted")):(lt(this,R)||lt(this,y))&&(lt(this,R)&&(null==(e=lt(this,r))||e.call(this,o,n,"evict")),lt(this,y)&&(null==(s=lt(this,g))||s.push([o,n,"evict"]))),lt(this,M).call(this,i),t&&(lt(this,u)[i]=void 0,lt(this,f)[i]=void 0,lt(this,_).push(i)),1===lt(this,c)?(ht(this,m,ht(this,E,0)),lt(this,_).length=0):ht(this,m,lt(this,p)[i]),lt(this,d).delete(n),dt(this,c)._--,i},j=new WeakSet,X=function(t,e,s,i){const r=void 0===e?void 0:lt(this,f)[e];if(ut(this,Z,$).call(this,r))return r;const n=new pd,{signal:o}=s;null==o||o.addEventListener("abort",(()=>n.abort(o.reason)),{signal:n.signal});const l={signal:n.signal,options:s,context:i},c=(i,r=!1)=>{const{aborted:o}=n.signal,a=s.ignoreFetchAbort&&void 0!==i;if(s.status&&(o&&!r?(s.status.fetchAborted=!0,s.status.fetchError=n.signal.reason,a&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),o&&!a&&!r)return h(n.signal.reason);const c=u;return lt(this,f)[e]===u&&(void 0===i?c.__staleWhileFetching?lt(this,f)[e]=c.__staleWhileFetching:ut(this,et,st).call(this,t,"fetch"):(s.status&&(s.status.fetchUpdated=!0),this.set(t,i,l.options))),i},h=i=>{const{aborted:r}=n.signal,o=r&&s.allowStaleOnFetchAbort,a=o||s.allowStaleOnFetchRejection,l=a||s.noDeleteOnFetchRejection,c=u;if(lt(this,f)[e]===u){!l||void 0===c.__staleWhileFetching?ut(this,et,st).call(this,t,"fetch"):o||(lt(this,f)[e]=c.__staleWhileFetching)}if(a)return s.status&&void 0!==c.__staleWhileFetching&&(s.status.returnedStale=!0),c.__staleWhileFetching;if(c.__returned===c)throw i};s.status&&(s.status.fetchDispatched=!0);const u=new Promise(((e,i)=>{var o;const h=null==(o=lt(this,a))?void 0:o.call(this,t,r,l);h&&h instanceof Promise&&h.then((t=>e(void 0===t?void 0:t)),i),n.signal.addEventListener("abort",(()=>{s.ignoreFetchAbort&&!s.allowStaleOnFetchAbort||(e(void 0),s.allowStaleOnFetchAbort&&(e=t=>c(t,!0)))}))})).then(c,(t=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=t),h(t)))),p=Object.assign(u,{__abortController:n,__staleWhileFetching:r,__returned:void 0});return void 0===e?(this.set(t,p,{...l.options,status:void 0}),e=lt(this,d).get(t)):lt(this,f)[e]=p,p},Z=new WeakSet,$=function(t){if(!lt(this,A))return!1;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof pd},Q=new WeakSet,K=function(t,e){lt(this,I)[e]=t,lt(this,p)[t]=e},J=new WeakSet,tt=function(t){t!==lt(this,E)&&(t===lt(this,m)?ht(this,m,lt(this,p)[t]):ut(this,Q,K).call(this,lt(this,I)[t],lt(this,p)[t]),ut(this,Q,K).call(this,lt(this,E),t),ht(this,E,t))},et=new WeakSet,st=function(t,e){var s,i,n,a;let l=!1;if(0!==lt(this,c)){const n=lt(this,d).get(t);if(void 0!==n)if(l=!0,1===lt(this,c))ut(this,it,rt).call(this,e);else{lt(this,M).call(this,n);const o=lt(this,f)[n];if(ut(this,Z,$).call(this,o)?o.__abortController.abort(new Error("deleted")):(lt(this,R)||lt(this,y))&&(lt(this,R)&&(null==(s=lt(this,r))||s.call(this,o,t,e)),lt(this,y)&&(null==(i=lt(this,g))||i.push([o,t,e]))),lt(this,d).delete(t),lt(this,u)[n]=void 0,lt(this,f)[n]=void 0,n===lt(this,E))ht(this,E,lt(this,I)[n]);else if(n===lt(this,m))ht(this,m,lt(this,p)[n]);else{const t=lt(this,I)[n];lt(this,p)[t]=lt(this,p)[n];const e=lt(this,p)[n];lt(this,I)[e]=lt(this,I)[n]}dt(this,c)._--,lt(this,_).push(n)}}if(lt(this,y)&&(null==(n=lt(this,g))?void 0:n.length)){const t=lt(this,g);let e;for(;e=null==t?void 0:t.shift();)null==(a=lt(this,o))||a.call(this,...e)}return l},it=new WeakSet,rt=function(t){var e,s,i;for(const i of ut(this,z,G).call(this,{allowStale:!0})){const n=lt(this,f)[i];if(ut(this,Z,$).call(this,n))n.__abortController.abort(new Error("deleted"));else{const o=lt(this,u)[i];lt(this,R)&&(null==(e=lt(this,r))||e.call(this,n,o,t)),lt(this,y)&&(null==(s=lt(this,g))||s.push([n,o,t]))}}if(lt(this,d).clear(),lt(this,f).fill(void 0),lt(this,u).fill(void 0),lt(this,b)&&lt(this,T)&&(lt(this,b).fill(0),lt(this,T).fill(0)),lt(this,C)&&lt(this,C).fill(0),ht(this,m,0),ht(this,E,0),lt(this,_).length=0,ht(this,h,0),ht(this,c,0),lt(this,y)&&lt(this,g)){const t=lt(this,g);let e;for(;e=null==t?void 0:t.shift();)null==(i=lt(this,o))||i.call(this,...e)}};let bd=Td;const Rd=class{static get(t){return this._meshes.get(t)}static lockIn(t){Object.seal(t)}static add(t,e){this._meshes.set(t,e)}static delete(t){for(const e of t)this._meshes.delete(e)}static setCapacity(t){t!==this._capacity&&(this._meshes.clear(),this._meshes=this.setupMeshes(t),this._capacity=t)}static setupMeshes(t){const e=Math.max(t??this.computeCapacity(),1),s=this.getSizeCalculationEvent();return new bd({maxSize:e,sizeCalculation:s})}static computeCapacity(){const t=globalThis.navigator&&"deviceMemory"in globalThis.navigator?globalThis.navigator.deviceMemory:null,e=null!==t?t:2,s=this.oneHundredMb*e;return Math.trunc(s)}static getDataSetMemory(t){let e=0;for(const s of t)e+=s.usedMemory;return Math.max(e,1)}static getSizeCalculationEvent(){return t=>Array.isArray(t)?this.getDataSetMemory(t):Math.max(t.usedMemory,1)}};ot(Rd,"oneHundredMb",1e8),ot(Rd,"_meshes",Rd.setupMeshes()),ot(Rd,"_capacity"),ot(Rd,"_memoryAttributes",["positionBuffer","indexBuffer","normalBuffer"]),ot(Rd,"updateMeshMemory",(t=>{t.usedMemory=0;for(const e of Rd._memoryAttributes)void 0!==t.usedMemory&&t[e]&&(t.usedMemory+=t[e].byteLength);Rd.lockIn(t)}));let Ad=Rd;const yd=class t{constructor(t){ot(this,"meshes"),ot(this,"tilesUpdated",!1),ot(this,"_sampleAmount"),ot(this,"_tileDimension"),ot(this,"_tileBySample"),ot(this,"_lodBySample"),ot(this,"_virtualMeshes",new Map),ot(this,"_meshConnection"),ot(this,"_samples"),ot(this,"_tileIdGenerator",new go),ot(this,"_tiles",new Map),ot(this,"_tilesChanged",new Set),ot(this,"_sizeByTile",new Map),ot(this,"_samplesDimensions"),ot(this,"_sampleLodClass"),ot(this,"_sampleLodState"),ot(this,"_sampleLodSize"),ot(this,"_boxes"),ot(this,"_items"),ot(this,"_materials"),ot(this,"_modelId"),ot(this,"_lastView",{rotation:new ft.Vector3,location:new ft.Vector3}),ot(this,"_params",{updateTime:16,updateSamples:64,updateviewOrientation:8*Math.PI/180,updateViewPosition:256,smallTileSize:.32,mediumTileSize:4,smallObjectSize:2,smallScreenSize:2,mediumScreenSize:4,largeScreenSize:16,tempTileDataSize:6,tileIdIncrement:1,tileSizeMultiplier:10,minTileDimension:32,tileDimensionFactor:8}),ot(this,"_temp",{sample:new Or,representation:new Lr,vector:new ft.Vector3,matrix:new ft.Matrix4,transform:new ft.Matrix4,boundingBox:new ft.Box3,sampleGeometry:{},box:new ft.Box3,raycastPoints:[],tileData:{positionCount:this._params.tempTileDataSize,objectClass:On.LINE,positionBuffer:new Float32Array(this._params.tempTileDataSize)},tileCenter:new ft.Vector3,tile:{objectClass:On.LINE,positionCount:6},viewDimension:0,pastFieldOfview:0}),ot(this,"_currentSample",0),ot(this,"_virtualPlanes",[]),ot(this,"_changedSamples",0),ot(this,"_virtualView"),ot(this,"_lodMode",Bn.DEFAULT),this._modelId=t.modelId,this._boxes=t.boxes,this._items=t.items,this._materials=t.materials,this._meshConnection=new ld(t.modelId,t.connection),this.meshes=t.model.meshes(),this._sampleAmount=this.meshes.samplesLength(),this._samples=new ad(this._sampleAmount),this._samplesDimensions=new Int32Array(this._sampleAmount),this._sampleLodClass=new Uint8Array(this._sampleAmount),this._sampleLodState=new Uint8Array(this._sampleAmount),this._sampleLodSize=new Float32Array(this._sampleAmount),this._tileDimension=this.computeTileSize(),this._tileBySample=new Array(this._sampleAmount),this._lodBySample=new Array(this._sampleAmount),this.init()}restart(){this.resetUpdateProcess(),this._meshConnection.clean()}fetchSample(t,e){this.fetchSampleAndRepresentation(t);const s=this.fetchCurrentMesh(),i=this.sampleTemplate(t);return i.geometries=this.sampleGeoms(i,e,s),i}fetchGeometry(t){this.meshes.representations(t,this._temp.representation);return this.fetchCurrentMesh().fetchMeshes(t,!0)}dispose(){this._meshConnection.dispose();for(const[,t]of this._virtualMeshes)t.dispose()}generate(){for(const[,t]of this._virtualMeshes)t.setupTemplates();for(let t=0;t<this._sampleAmount;t++)this.generateSampleInTiles(t);this.setupTileVisibilityAndHighlight()}setupView(t){this._virtualView=t,Ad.setCapacity(t.meshThreshold),this.restart(),this.updateOrientationIfNeeded(),this.updatePositionIfNeeded(),this.setupViewPlanes()}updateVirtualMeshes(t){if(t&&this._virtualView){for(const e of t)this.updateItem(e);this.restart()}}getSampleTransform(t){this.fetchSampleAndRepresentation(t);return this.sampleTemplate(t).transform}async update(t){this.updateTiles(t),this.notifyUpdateFinished();for(const t of this._tilesChanged){const e=this._tiles.get(t);this._meshConnection.process({tileRequestClass:xn.UPDATE,modelId:this._modelId,tileId:t,objectClass:e.objectClass,material:e.materialId,tileData:this.getTileData(e),currentLod:e.lod})}this._tilesChanged.clear()}raycast(t,e,s,i){this._temp.raycastPoints=[];const r=t.representationClass(),n=this._virtualMeshes.get(r);return this.manageRaycast(n,t,e,s,i),this._temp.raycastPoints}setLodMode(t){this._lodMode=t,this.restart()}init(){const t=new Qh(this._modelId,this.meshes),e=t.getRepresentation();this._virtualMeshes.set(e,t);const s=new od(this._modelId,this.meshes),i=s.getRepresentation();this._virtualMeshes.set(i,s),this.processSamplesDimension(),this.fetchSampleLodSize()}initSampleLod(t){this.fetchSampleAndRepresentation(t);const e=this.fetchCurrentMesh();this._sampleLodClass[t]=e.getLodClass(),this._sampleLodState[t]=Nn.INVISIBLE}fetchSampleAndRepresentation(t){this.meshes.samples(t,this._temp.sample),this.meshes.representations(this._temp.sample.representation(),this._temp.representation)}fetchCurrentMesh(){const t=this._temp.representation.representationClass();return this._virtualMeshes.get(t)}fetchCurrentMaterial(){const t=this._temp.sample.material();return this._materials[t]}fetchSampleLodSize(){for(let t=0;t<this._sampleAmount;t++)this.initSampleLod(t),Fo.getBox(this._temp.representation,this._temp.box),this._sampleLodSize[t]=wo.getWidth(this._temp.box)}setupTileVisibilityAndHighlight(){for(const[,t]of this._tiles)t.visibilities=new To(t.size,!1),t.highlights=new To(t.size,0)}addLodToTile(t,e,s){t.getLodClass()!==dh.AABB?t.getLodClass()===dh.CUSTOM&&this.addCustomLodToTile(t,e,s):this.addBoxLodToTile(e,s)}addBoxLodToTile(t,e){this._lodBySample[t]=this.lodTileAppendSample(t,e)}notifyUpdateFinished(){const t=!this.tilesUpdated;this._changedSamples>=this._sampleAmount&&t&&(this._meshConnection.process({tileRequestClass:xn.FINISH,modelId:this._modelId}),this.tilesUpdated=!0)}updatePositionIfNeeded(){const t=this._params.updateViewPosition,e=this._virtualView.cameraPosition;e.distanceToSquared(this._lastView.location)>t&&(this._currentSample=0,this._lastView.location.copy(e))}updateCurrentSample(){this._currentSample++,this._currentSample>=this._sampleAmount&&(this._currentSample=0),this._changedSamples++}processSamplesDimension(){for(let t=0;t<this._sampleAmount;t++)this._samplesDimensions[t]=t;this._samplesDimensions.sort(((t,e)=>this._boxes.dimensionOf(e)-this._boxes.dimensionOf(t)))}setupViewPlanes(){this._virtualPlanes=[];for(const t of this._virtualView.cameraFrustum.planes)this._virtualPlanes.push(t);if(this._virtualView.clippingPlanes)for(const t of this._virtualView.clippingPlanes)this._virtualPlanes.push(t)}updateOrientationIfNeeded(){const t=this.getCurrentViewOrientation(),e=this._params.updateviewOrientation;t.angleTo(this._lastView.rotation)>e&&(this._currentSample=0,this._lastView.rotation.copy(t))}getCurrentViewOrientation(){return this._virtualView.cameraFrustum.planes[4].normal}resetUpdateProcess(){this._changedSamples=0,this.tilesUpdated=!1}manageRaycast(t,e,s,i,r){const n=cd.cast(t,e,s,i,r);if(n)for(const e of n)e.representationClass=t.getObjectClass(),this._temp.raycastPoints.push(e)}setTileShellBuffer(t){void 0!==t.usedMemory&&t.objectClass===On.SHELL&&(t.ids=new Float32Array(t.positionCount/3),t.usedMemory+=t.ids.byteLength)}getTileWhenSamplePut(t,e,s){let i=this._tiles.get(t);if(void 0===i){const r=e.lod||Nn.GEOMETRY;i=this.newTile(e.objectClass,s,r),this._tiles.set(t,i)}return i}getPerspTrueDim(t,e){const s=Math.PI/180;return e*Math.tan(.5*t*s)}getTileHighlight(t,e){let s,i;const r=t.highlights;if(!r)return{highlightData:void 0,highlightIds:void 0};const n=r.size((t=>0!==t));if(n>0){i=new Uint16Array(n);const t=t=>0!==t,o=(t,e)=>i[t]=e;s=To.get(r,e,t,o)}return{highlightData:s,highlightIds:i}}setupTileSampleAttributes(t,e,s,i){const r=3*t.vertexLocation[e];for(let e=0;e<s.positionBuffer.length;e+=3)this._temp.vector.fromArray(s.positionBuffer,e),this._temp.vector.applyMatrix4(this._temp.matrix),this._temp.vector.toArray(t.positionBuffer,r+e);if(t.normalBuffer){const i=3*t.vertexLocation[e];for(let e=0;e<s.normalBuffer.length;e+=3)this._temp.vector.fromArray(s.normalBuffer,e),this._temp.vector.transformDirection(this._temp.matrix),this._temp.vector.multiplyScalar(hh),this._temp.vector.toArray(t.normalBuffer,i+e)}if(t.indexBuffer){const i=t.indexLocation[e],r=t.vertexLocation[e];for(let e=0;e<s.indexCount;e++){const n=s.indexBuffer[e]+r;t.indexBuffer[e+i]=n}}if(t.faceIdBuffer&&s.faceIdBuffer){const r=100*i.sample,n=t.vertexLocation[e],o=n+s.positionCount/3;for(let e=n;e<o;e++)t.faceIdBuffer[e]=s.faceIdBuffer[e-n]+r}if(s.objectClass===On.SHELL){const r=t.vertexLocation[e],n=r+s.positionCount/3;t.ids.fill(this.itemId(i.sample),r,n)}}getTileVisibility(t,e){if(!t.visibilities)throw new Error("Fragments: Malformed tile!");if(t.visibilities.fullOf(!1))return;return To.get(t.visibilities,e,(t=>t))}memoryOverflow(){return t._graphicMemoryConsumed>this._virtualView.graphicThreshold}updateMesh(t){let e=this.fetchLodLevel(t);const s=this._sampleLodState[t];e=this.hideHighlightedLods(e,t),e!==s?this.updateVisible(s,e,t):this.updateSampleIfSeen(e,t)}tileLoadSample(t,e,s){const i=t.sampleLocation.get(e.sample),r=this.getSampleGeometries(e,s);this.setupTileLocation(t,r,e),this.fetchSampleTransform(t,e),this.setupTileSampleAttributes(t,i,r,e)}updateSampleIfSeen(t,e){t!==Nn.INVISIBLE&&this.updateSample(e,t)}hideHighlightedLods(t,e){return t===Nn.WIRES&&this._samples.getHighlight(e)&&(t=Nn.INVISIBLE),t}updateVisible(t,e,s){t!==Nn.INVISIBLE&&this.makeSampleInvisible(s,t);const i=e!==Nn.INVISIBLE;i&&this.updateSample(s,e),this._samples.setVisible(s,i),this._sampleLodState[s]=e}makeInvisibleFromTile(t,e){const s=this._tiles.get(t);this.updateTileData(s,e,!1,0),this.deleteTileIfNeeded(s,t)}updateSample(t,e){const s=this.itemId(t),i=this._items.visible(s),r=this._items.getHighlight(s);this.hasChanged(t,e,i,r)&&this.setSample(t,i,r,e)}hasHighlightChanged(t,e){return e!==this._samples.getHighlight(t)}hasVisibleChanged(t,e){return e!==this._samples.visible(t)}newTile(t,e,s){const i={notVirtual:!1};return i.materialId=e,i.indexLocation=[],i.box=new ft.Box3,i.objectClass=t,i.lod=s,i.normalCount=0,i.indexCount=0,i.vertexLocation=[],i.size=0,i.geometriesLocation=[],i.positionCount=0,i.sampleLocation=new Map,i.faceIdBuffer=new Uint32Array(0),i}createLod(t){const e=Fo.boxSize(t),s=this._temp.tileData.positionBuffer;if(!s)throw new Error("Fragments: Malformed tiles!");return s[0]=e.start.x,s[1]=e.start.y,s[2]=e.start.z,s[3]=e.end.x,s[4]=e.end.y,s[5]=e.end.z,this._temp.tileData}sampleTemplate(t){const e=this._temp.sample,s=this._temp.representation;Fo.get(e,this.meshes,this._temp.transform),Fo.getBox(s,this._temp.boundingBox),this._temp.sampleGeometry.sample=t;const i=e.material();this._temp.sampleGeometry.material=this._materials[i],this._temp.sampleGeometry.transform=this._temp.transform,this._temp.sampleGeometry.aabb=this._temp.boundingBox,delete this._temp.sampleGeometry.geometries;const r=this._temp.sample.representation(),n=this.meshes.representationIds(r);return this._temp.sampleGeometry.representationId=n,this._temp.sampleGeometry}makeSampleInvisible(t,e){const s=this.getTileIds(t,e);if(!s)return;bo.forEach(s,(e=>this.makeInvisibleFromTile(e,t)))}setSample(t,e,s,i){this._samples.setVisible(t,e),this._samples.setHighlight(t,s);const r=this.getTileIds(t,i);void 0!==r&&bo.forEach(r,(e=>{this.updateTile(e,t,s,0===s)}))}getTileIds(t,e){return e===Nn.GEOMETRY?this._tileBySample[t]:this._lodBySample[t]}addBasicTileData(t,e,s){t.sampleLocation.set(e,t.size),t.size++,t.geometriesLocation.push(s),t.indexLocation.push(t.indexCount||0),t.vertexLocation.push((t.positionCount||0)/3)}buildNewVirtualTile(t,e){this.constructTile(t),this.loadTile(e,t),t.notVirtual=!0,delete t.indexBuffer,delete t.positionBuffer,delete t.normalBuffer,delete t.faceIdBuffer,delete t.ids}deleteTileIfNeeded(e,s){if(this.getShouldDeleteTile(e))return this.deleteGeometry(s),e.notVirtual=!1,void(t._graphicMemoryConsumed-=e.usedMemory);this._tilesChanged.add(s)}getShouldDeleteTile(t){if(!t.visibilities||!t.highlights)throw new Error("Fragments: Malformed tile!");const e=t.visibilities.fullOf(!1),s=t.highlights.fullOf(0),i=this.memoryOverflow();return e&&s&&i}checkTileMemoryOverflow(t,e){const s=this._tiles.get(t);return(s?s.positionCount:0)+e.positionCount>Ln}updateTileData(t,e,s,i){if(!t.visibilities||!t.highlights)throw new Error("Fragments: Malformed tile!");const r=t.sampleLocation.get(e);t.visibilities.update(r,s),t.highlights.update(r,i)}getKeepUpdating(t,e){const s=this._params.updateTime,i=this._params.updateSamples,r=t<this._sampleAmount,n=performance.now()-e;return r&&(n<s||t<i)}computeTileSize(){const t=this._boxes.fullBox.getSize(this._temp.vector),e=Math.max(t.x,t.y,t.z)/this._params.tileDimensionFactor,s=Math.ceil(e);return Math.max(this._params.minTileDimension,s)}newTileId(t,e,s){this.logBufferOverflowIfNeeded(s);const i=s.lod||Nn.GEOMETRY,r=this.generateTileCode(t,e,s,i),n=this._sizeByTile.get(r)||1;let o=r+n-1;return this.checkTileMemoryOverflow(o,s)&&(o+=this._params.tileIdIncrement,this._sizeByTile.set(r,n+1)),o}logBufferOverflowIfNeeded(t){t.positionCount/3>Ln&&console.log("Fragments: Buffer overflow")}fetchLodLevel(t){if(this._lodMode===Bn.ALL_VISIBLE)return Nn.GEOMETRY;const e=this._boxes.get(t);if(!Gn.collides(e,this._virtualPlanes))return Nn.INVISIBLE;this.meshes.samples(t,this._temp.sample);const s=this._temp.sample.item();if(!this._items.visible(s))return Nn.INVISIBLE;const i=this._virtualView.graphicQuality,r=this._boxes.dimensionOf(t),n=e.distanceToPoint(this._virtualView.cameraPosition),o=this.screenSize(r,n),a=r<this._params.smallObjectSize,l=!a,c=this._params.smallScreenSize*i,h=this._params.mediumScreenSize*i,d=this._params.largeScreenSize*i,u=o<h,f=a&&o<d,p=l&&u;if(a&&u||l&&o<c)return Nn.INVISIBLE;if(this._lodMode===Bn.ALL_GEOMETRY)return Nn.GEOMETRY;if(f||p)return Nn.WIRES;const I=this._sampleLodSize[t];return this.screenSize(I,n)<Math.max(h,this._params.mediumScreenSize)?Nn.WIRES:Nn.GEOMETRY}generateTileCode(t,e,s,i){this._tileIdGenerator.reset(),this.processTileDataId(s,e,i);const r=this.processTileSpatialId(t,i);return this.processTileDimensionId(r),this._tileIdGenerator.value}processTileDataId(t,e,s){this._tileIdGenerator.compute(void 0!==t.objectClass?t.objectClass:0),this._tileIdGenerator.compute(e),this._tileIdGenerator.compute(s)}deleteGeometry(t){this._meshConnection.process({tileRequestClass:xn.DELETE,modelId:this._modelId,tileId:t})}processTileSpatialId(t,e){const s=this._temp.tileCenter.x,i=this._temp.tileCenter.y,r=this._temp.tileCenter.z,n=this._boxes.get(t);n.getCenter(this._temp.tileCenter);const o=this.getTileDimension(e),a=s-s%o,l=i-i%o,c=r-r%o;return this._tileIdGenerator.compute(a),this._tileIdGenerator.compute(l),this._tileIdGenerator.compute(c),n}addCustomLodToTile(t,e,s){const i=this.meshData(t,!1,Nn.WIRES);this._sampleLodSize[e]=i.lodThickness||0,this._lodBySample[e]=this.putSampleInTiles(e,s,i)}getTileLocations(t){return t.indexCount?t.indexLocation:t.vertexLocation}getTileDimension(t){let e=this._tileDimension;return t===Nn.GEOMETRY&&(e*=this._params.tileSizeMultiplier),e}processTileDimensionId(t){const e=this.getTileDimensionClass(t);this._tileIdGenerator.compute(e)}tileAppend(t,e,s,i){this.addBasicTileData(t,s,i),this.tileAppendAttribute(t,e,"indexCount",!1),this.tileAppendAttribute(t,e,"positionCount",!1),this.tileAppendAttribute(t,e,"normalCount",!1),this.tileAppendAttribute(t,e,"materialId",!0)}putSampleInTiles(t,e,s){let i;return bo.forEach(s,((s,r)=>{const n=this.newTileId(t,e,s);i=this.getTileIdsWhenSamplePut(i,n);const o=this.getTileWhenSamplePut(n,s,e);this.tileAppend(o,s,t,r)})),i}hasLodChanged(t,e){return e!==this._sampleLodState[t]}getTileIdsWhenSamplePut(t,e){return void 0===t?t=e:"number"==typeof t?t!==e&&(t=[t,e]):t.includes(e)||t.push(e),t}updateTile(t,e,s,i){const r=this._tiles.get(t);this.updateTileData(r,e,i,s),r.notVirtual?this._tilesChanged.add(t):this.buildNewVirtualTile(r,t)}getLodTileWhenPutSample(t,e){let s=this._tiles.get(t);if(!s){const i=this._temp.tile.objectClass;s=this.newTile(i,e,Nn.WIRES),this._tiles.set(t,s)}return s}lodTileAppendSample(t,e){const s=Nn.WIRES,i=this._temp.tile,r=this.generateTileCode(t,e,i,s),n=this.getLodTileWhenPutSample(r,e);return this.tileAppend(n,i,t,0),r}addSampleToTile(t,e,s){const i=this.meshData(t,!1,Nn.GEOMETRY);this._tileBySample[e]=this.putSampleInTiles(e,s,i)}setTileBuffer(t,e,s){if(void 0===t.usedMemory)return;const i=t[`${e}Count`];if(i>0){const r=s?new Uint16Array(i):new Int16Array(i);t[`${e}Buffer`]=r,t.usedMemory+=r.byteLength}}updateTiles(t){const e=this._changedSamples<this._sampleAmount;if(!(void 0!==this._virtualView)||!e)return;let s=!0,i=0;for(;s;){const e=this._samplesDimensions[this._currentSample];this.updateMesh(e),this.updateCurrentSample(),i++,s=this.getKeepUpdating(i,t)}}sampleGeoms(t,e,s){return s.getLodClass()===dh.AABB&&e===Nn.WIRES?this.createLod(t.aabb):this.meshData(s,!0,e)}generateSampleInTiles(t){this.fetchSampleAndRepresentation(t);const e=this.fetchCurrentMaterial(),s=this.fetchCurrentMesh();this.addSampleToTile(s,t,e),this.addLodToTile(s,t,e)}buildSampleInTile(t,e,s,i,r){const n=t.geometriesLocation[e];if(this.tileLoadSample(t,s,n),i){const e=this._boxes.get(r);this._temp.vector.copy(t.location),this._temp.vector.negate(),e.translate(this._temp.vector),t.box.union(e)}}getSampleGeometries(t,e){return Array.isArray(t.geometries)?t.geometries[e]:t.geometries}constructTile(t){void 0===t.positionBuffer&&(t.positionBuffer=new Float32Array(t.positionCount),t.usedMemory=t.positionBuffer.byteLength,this.setTileBuffer(t,"index",!0),this.setTileBuffer(t,"normal",!1),this.setTileShellBuffer(t),t.faceIdBuffer=new Uint32Array(t.positionCount/3),t.usedMemory+=t.faceIdBuffer.byteLength);const e=!t.location;for(const[s,i]of t.sampleLocation){const r=this.fetchSample(s,t.lod);r&&r.geometries&&this.buildSampleInTile(t,i,r,e,s)}}fetchSampleTransform(t,e){this._temp.vector.copy(t.location),this._temp.vector.negate(),this._temp.matrix.identity(),this._temp.matrix.setPosition(this._temp.vector),this._temp.matrix.multiply(e.transform)}hasChanged(t,e,s,i){const r=this.hasLodChanged(t,e),n=this.hasVisibleChanged(t,s),o=this.hasHighlightChanged(t,i);return r||n||o}setupTileLocation(t,e,s){if(t.location)return;const i=new ft.Vector3;i.fromArray(e.positionBuffer),i.applyMatrix4(s.transform),t.location=i}getTileData(t){const e=this.getTileLocations(t),s=this.getTileVisibility(t,e),i=this.getTileHighlight(t,e),{highlightData:r,highlightIds:n}=i;return{visibilityData:s,highlightData:r,highlightIds:n}}updateMemoryOnTileLoad(e){t._graphicMemoryConsumed+=e.usedMemory}fetchTileMatrixOnLoad(t){t.location&&(this._temp.matrix.identity(),this._temp.matrix.setPosition(t.location))}updateItem(t){const e=this._boxes.sampleOf(t);if(e)for(const t of e)this.updateMesh(t)}screenSize(t,e){return t/this.getViewDimension(e)*this._virtualView.viewSize}getTileDimensionClass(t){const e=t.min.distanceToSquared(t.max),s=this._params.smallTileSize;return e>this._params.mediumTileSize?2:e>s?1:0}getViewDimension(t){if(this._virtualView.orthogonalDimension)return this._virtualView.orthogonalDimension;const e=this._virtualView.fov;return e!==this._temp.pastFieldOfview&&(this._temp.viewDimension=this.getPerspTrueDim(e,1),this._temp.pastFieldOfview=e),t*this._temp.viewDimension}loadTile(t,e){const s=this.getTileData(e);this.fetchTileMatrixOnLoad(e);const i=this.getFaceIds(e);this._meshConnection.process({tileRequestClass:xn.CREATE,modelId:this._modelId,objectClass:e.objectClass,tileId:t,itemId:void 0,tileData:s,indices:e.indexBuffer,positions:e.positionBuffer,normals:e.normalBuffer,faceIds:i,itemIds:e.ids,material:e.materialId,matrix:this._temp.matrix.clone(),aabb:e.box.clone(),currentLod:e.lod}),this.updateMemoryOnTileLoad(e)}getFaceIds(t){const e=new ft.Color,s=t.faceIdBuffer,i=new Float32Array(3*s.length);for(let t=0;t<s.length;t++){const r=s[t];e.set(0+r),i[3*t]=e.r,i[3*t+1]=e.g,i[3*t+2]=e.b}return i}meshData(t,e,s){const i=this._temp.representation.id(),r=t.getLodClass()===dh.CUSTOM,n=s===Nn.WIRES;if(r&&n){return t.fetchLod(i,e)}return t.fetchMeshes(i,e)}tileAppendAttribute(t,e,s,i){void 0!==e[s]&&(i?t[s]=e[s]:t[s]+=e[s])}itemId(t){return this.meshes.samples(t,this._temp.sample),this._temp.sample.item()}};ot(yd,"_graphicMemoryConsumed",0);let Sd=yd;class Fd{static isSame(t,e){const s=this.checkSameColor(t.color,e.color),i=this.checkSame(t.opacity,e.opacity,1),r=t.renderedFaces,n=e.renderedFaces,o=this.checkSame(r,n,zr.ONE);return s&&i&&o}static checkSame(t,e,s){return t===e||(t===s&&void 0===e||void 0===t&&e===s)}static checkSameColor(t,e){if(t===e)return!0;if(void 0===t||void 0===e)return!1;const{r:s,g:i,b:r}=t,{r:n,g:o,b:a}=e;return s===n&&i===o&&r===a}}class wd{constructor(t,e){ot(this,"_modelId"),ot(this,"_list",[]),ot(this,"_onTransfer"),this._modelId=t,this._onTransfer=e}update(t){const e=t.meshes();return this.getAll(e,[])}fetch(t){return this._list[t]}transfer(t){const e=this.deduplicateMaterials(t),{materialDefinitions:s,ids:i}=e;return this.transferMaterialData(s),i}getItemsMaterialDefinition(t,e,s){const i=[],r=t.meshes();if(!r)return[];const n=new Map;for(const[t,i]of e.entries()){const e=r.samples(i);if(!e)continue;const o=e.material();let a=n.get(o);a||(a=new Set,n.set(o,a)),a.add(s[t])}for(const[t,e]of n.entries()){const s=r.materials(t);if(!s)continue;const n=yo.parseMaterial(s);i.push({localIds:[...e],definition:n})}return i}checkMaterialExists(t,e){if(t.preserveOriginalMaterial)return!1;const s=this._list.length;for(let i=0;i<s;i++){const s=this._list[i];if(Fd.isSame(t,s))return e.push(i),!0}return!1}deduplicateMaterials(t){const e=[],s=[];for(const i of t){if(!this.checkMaterialExists(i,e)){this._list.push(i),s.push(i);const t=this._list.length-1;e.push(t)}}return{materialDefinitions:s,ids:e}}getAll(t,e){const s=t.materialsLength();for(let i=0;i<s;i++){const s=t.materials(i),r=yo.parseMaterial(s);r.localId=t.materialIds(i),e.push(r)}return this.transfer(e)}transferMaterialData(t){this._onTransfer({class:vn.CREATE_MATERIAL,modelId:this._modelId,materialDefinitions:t})}}class Ld{constructor(t,e,s){if(ot(this,"_model"),ot(this,"_boxes"),ot(this,"_localIdsToGeometryIds",new Map),ot(this,"_guidToLocalIdMap",new Map),ot(this,"_items",new Map),ot(this,"_itemDataCache",new Map),ot(this,"_itemDataConfig",{attributesDefault:!0,relationsDefault:{attributes:!1,relations:!1}}),ot(this,"_spatialStructure",null),ot(this,"_virtualModel"),ot(this,"_relations",new Map),this._virtualModel=t,this._model=t.data,this._boxes=e,this.preindexGeometryIds(),s&&s.extraRelations)for(const t of s.extraRelations){const{category:e,relation:s,inverseName:i}=t;this.addInverseRelation(e,s,i)}const i=this._model.localIdsArray();if(i){for(let t=0;t<this._model.localIdsLength();t++){const e=this._model.categories(t),s=i[t];let r=this._items.get(s);r||(r={category:null,guid:null,geometryIds:null,attrs:null},this._items.set(s,r)),r.category=e}for(let t=0;t<this._model.guidsItemsLength();t++){const e=this._model.guidsItems(t);if(null===e)continue;const s=this._model.guids(t);this._guidToLocalIdMap.set(s,e);let i=this._items.get(e);i||(i={category:null,guid:null,geometryIds:null,attrs:null},this._items.set(e,i)),i.guid=s}}}getAllLocalIds(){return this._model.localIdsArray()??[]}addInverseRelation(t,e,s){const i=this.getItemsOfCategories([new RegExp(`^${t}$`)])[t];for(const t of i){const i=this.getItemRelations(t);if(!i||!i[e])continue;const r=i[e];for(const e of r){let i=this._relations.get(e);i||(i={},this._relations.set(e,i));let r=i[s];r||(r=[],i[s]=r),r.push(t)}}}getItemsCount(){return this._model.localIdsLength()}getMaxLocalId(){return this._model.maxLocalId()}getMetadata(){const t=this._model.metadata();return t?JSON.parse(t):null}getItemIdsFromLocalIds(t){if(!t)return Array.from(this._model.meshes().meshesItemsArray());const e=[];for(const s of t){const t=this._localIdsToGeometryIds.get(s);if(t)for(const s of t)e.push(s)}return e}getLocalIdsFromItemIds(t){const e=[],s=this._localIdsToGeometryIds.entries();for(const[i,r]of s)for(const s of t)r.includes(s)&&e.push(i);return e}getBox(t,e){for(const s of t){const t=this._boxes.sampleOf(s);if(t)for(const s of t){const t=this._boxes.get(s);e.union(t)}}}getSpatialStructure(){if(this._spatialStructure)return this._spatialStructure;const t=this._model.spatialStructure();return t?(this._spatialStructure=this.getTreeItem(t),this._spatialStructure):{}}getItemsChildren(t){const e=new Set;for(const s of t){const t=this.convertToLocalId(s);null!==t&&this.traverseSpatialStructure(t,e)}return[...e]}getGuids(){const t=[];for(let e=0;e<this._model.guidsLength();e++){const s=this._model.guids(e);t.push(s)}return t}getLocalIds(){const t=this._model.localIdsArray();return t?Array.from(t):[]}getItemsCategories(t){var e;const s=[];for(const i of t){const t=this.convertToLocalId(i);if(null===t)continue;let r=(null==(e=this._items.get(t))?void 0:e.category)??null;if(null===r)for(let e=this._virtualModel.requests.length-1;e>=0;e--){const s=this._virtualModel.requests[e];s.type===kr.CREATE_ITEM&&s.localId===t&&(r=s.data.category)}s.push(r)}return s}getLocalIdsByGuids(t){const e=[];for(const s of t){const t=this._guidToLocalIdMap.get(s);e.push(void 0!==t?t:null)}return e}getGuidsByLocalIds(t){var e;const s=[];for(const i of t){const t=null==(e=this._items.get(i))?void 0:e.guid;s.push(void 0!==t?t:null)}return s}getAttributeNames(){const t=new Set;for(let e=0;e<this._model.uniqueAttributesLength();e++){const s=this._model.uniqueAttributes(e);if(!s)continue;const[i]=JSON.parse(s);t.add(i)}return[...t]}getAttributeValues(){const t=new Set;for(let e=0;e<this._model.uniqueAttributesLength();e++){const s=this._model.uniqueAttributes(e);if(!s)continue;const[,i]=JSON.parse(s);t.add(i)}return[...t]}getAttributesUniqueValues(t){var e,s,i;const r=new Map,n=t.every((t=>void 0!==t.categories)),o=t.map((t=>t.categories)).filter((t=>void 0!==t)).flat();for(let a=0;a<this._model.categoriesLength();a++){const l=this._model.localIds(a);if(null===l)continue;let c=!0;if(n){const t=this._model.categories(a);c=o.some((e=>null==e?void 0:e.test(t)))}if(!c)continue;const h=this._model.attributes(a);if(!h)continue;const d={};for(let t=0;t<h.dataLength();t++){const e=h.data(t);if(!e)continue;const[s,i,r]=JSON.parse(e);d[s]={value:i,type:r}}const u=Object.keys(d),f=this._model.categories(a);for(const{key:n,attributes:o,get:a,categories:c}of t){let t=!0;if(c&&(t=c.some((t=>t.test(f)))),!t)continue;let h=!0;if(o){const{aggregation:t,queries:s}=o,i=[];for(const{name:t,value:r,type:n,negate:o}of s){const s=u.find((e=>t.test(e)));if(!s||void 0===(null==(e=d[s])?void 0:e.value))break;let a=!1;const{value:l,type:c}=d[s];a=r instanceof RegExp?"string"==typeof l&&r.test(l):l===r,void 0!==n&&(a=a&&"string"==typeof c&&n.test(c)),o&&(a=!a),i.push(a)}h="exclusive"===t?i.every((t=>t)):i.some((t=>t))}if(h){const t=u.find((t=>a.test(t)));if(!t||void 0===(null==(s=d[t])?void 0:s.value))continue;const e=n??t,o=null==(i=d[t])?void 0:i.value;r.has(e)||r.set(e,new Map);const c=r.get(e);c.has(o)||c.set(o,new Set),c.get(o).add(l)}}}const a={};for(const[t,e]of r){a[t]=[];for(const[s,i]of e)a[t].push({value:s,localIds:Array.from(i)})}return a}getAttributeTypes(){const t=new Set;for(let e=0;e<this._model.uniqueAttributesLength();e++){const s=this._model.uniqueAttributes(e);if(!s)continue;const[,,i]=JSON.parse(s);t.add(i)}return[...t]}getRelationNames(){const t=new Set;for(let e=0;e<this._model.relationNamesLength();e++){const s=this._model.relationNames(e);s&&t.add(s)}return[...t]}getItemAttributes(t){var e;const s="number"==typeof t?t:this.getLocalIdsByGuids([t])[0];if(null===s)return null;const i=null==(e=this._model.localIdsArray())?void 0:e.indexOf(s);if(void 0===i||-1===i){const t={};for(let e=this._virtualModel.requests.length-1;e>=0;e--){const i=this._virtualModel.requests[e];if(i.type===kr.CREATE_ITEM&&i.localId===s){for(const e in i.data.data){const s=i.data.data[e];t[e]={value:s.value,type:s.type}}return t}}return null}const r=this._model.attributes(i);if(!r)return null;const n={};for(let t=this._virtualModel.requests.length-1;t>=0;t--){const e=this._virtualModel.requests[t];if((e.type===kr.UPDATE_ITEM||e.type===kr.CREATE_ITEM)&&e.localId===s){for(const t in e.data.data){const s=e.data.data[t];n[t]={value:s.value,type:s.type}}return n}}for(let t=0;t<r.dataLength();t++){const e=r.data(t);e&&this.parseAttribute(e,n)}return n}parseAttribute(t,e){const[s,i,r]=JSON.parse(t);e[s]={value:i,type:r}}getItemData(t,e={}){var s;const i=this._itemDataConfig.attributesDefault,r=this._itemDataConfig.attributes,n=this._itemDataConfig.relations??{};let{attributes:o,relations:a}=this._itemDataConfig.relationsDefault;const{parentName:l,rel:c}=e;if(l||c){const t=l&&l in n;if(c&&c in n){const t=n[c];t&&(o=t.attributes,a=t.relations)}else if(t){const t=n[l];t&&(o=t.attributes,a=t.relations)}}else o=!0,a=!0;if(!o&&!a)return{};if(this._itemDataCache.has(t))return this._itemDataCache.get(t);const h="number"==typeof t?t:this._guidToLocalIdMap.get(t)??null,d=new Set;for(const t of this._virtualModel.requests)t.type===kr.DELETE_ITEM&&d.add(t.localId);if(null===h||d.has(h))return{};const[u]=this.getItemsCategories([h]),f={_category:{value:u},_localId:{value:h},_guid:{value:"string"==typeof t?t:(null==(s=this._items.get(t))?void 0:s.guid)??null}};if(this._itemDataCache.set(t,f),o&&null!==h){const e=this.getItemAttributes(t);for(const[t,s]of Object.entries(e??{}))i?(null==r?void 0:r.includes(t))||(f[t]=s):(null==r?void 0:r.includes(t))&&(f[t]=s)}if(a){const e=this.getItemRelations(t);for(const[t,s]of Object.entries(e??{}))for(const e of s){if(d.has(e))continue;const s=this.getItemData(e,{parentName:c,rel:t});if(0===Object.keys(s).length)continue;const i=f[t];Array.isArray(i)?i.push(s):f[t]=[s]}}return f}getItemsData(t,e={}){this._itemDataCache.clear();const s=[],i=0!==t.length?t:this._model.localIdsArray();if(!i)return s;this._itemDataConfig={...this._itemDataConfig,...e};for(const t of i)s.push(this.getItemData(t));return this._itemDataCache.clear(),this._itemDataConfig={relationsDefault:{attributes:!1,relations:!1},attributesDefault:!0},s}getRawRelations(t){const e=new Set(t??this.getLocalIds()),s=new Map;for(const t of e){const e=this.getItemRelations(t);e&&s.set(t,{data:e})}return s}getItemRelations(t){var e;const s="number"==typeof t?t:this.getLocalIdsByGuids([t])[0];for(let t=this._virtualModel.requests.length-1;t>=0;t--){const e=this._virtualModel.requests[t];if((e.type===kr.UPDATE_RELATION||e.type===kr.CREATE_RELATION)&&e.localId===s)return e.data.data}if(null===s)return null;const i=this._relations.get(s)??{},r=null==(e=this._model.relationsItemsArray())?void 0:e.indexOf(s);if(void 0===r||-1===r)return Object.keys(i).length>0?i:null;const n=this._model.relations(r);if(!n)return Object.keys(i).length>0?i:null;for(let t=0;t<n.dataLength();t++){const e=n.data(t);if(!e)continue;const[s,...r]=JSON.parse(e);i[s]=r}return i}getCategories(){const t=new Set;for(let e=0;e<this._model.categoriesLength();e++){const s=this._model.categories(e);s&&t.add(s)}for(let e=0;e<this._virtualModel.requests.length;e++){const s=this._virtualModel.requests[e];s.type!==kr.CREATE_ITEM&&s.type!==kr.UPDATE_ITEM||s.data.category&&t.add(s.data.category)}return[...t]}getItemsOfCategories(t){const e={},s=new Set;for(const t of this._virtualModel.requests)t.type===kr.DELETE_ITEM&&s.add(t.localId);for(const i of this._virtualModel.requests)if(i.type===kr.CREATE_ITEM||i.type===kr.UPDATE_ITEM){if(s.has(i.localId))continue;for(const s of t)s.test(i.data.category)&&(e[i.data.category]||(e[i.data.category]=[]),e[i.data.category].push(i.localId))}for(let i=0;i<this._model.categoriesLength();i++){const r=this._model.categories(i);if(!r)continue;const n=this._model.localIds(i);if(!s.has(n))for(const s of t)if(s.test(r)){e[r]||(e[r]=[]),e[r].push(n);break}}return e}getItemsWithGeometry(){const t=this._model.meshes(new Dr),e=[];if(!t)return e;const s=t.meshesItemsArray();if(!s)return e;for(const t of s){const s=this._model.localIds(t);null!==s&&e.push(s)}return e}getItemsWithGeometryCategories(){const t=this.getItemsWithGeometry();return this.getItemsCategories(t)}checkAttribute(t,{name:e,value:s,type:i}){const{name:r,value:n,type:o}=t;let a=!1;return e.test(r)&&(a=void 0===s&&void 0===i,a||(void 0!==s&&(a=Array.isArray(s)?s.some((t=>"string"==typeof n&&t.test(n))):s instanceof RegExp?"string"==typeof n&&s.test(n):n===s),void 0!==i&&(a=a&&"string"==typeof o&&i.test(o)))),a}getItemsByAttribute({name:t,value:e,type:s,negate:i,itemIds:r}){const n=this._model.attributesLength(),o=[],a=new Set(r);for(let l=0;l<n;l++){const n=this._model.localIds(l);if(null===n)continue;if(a.delete(n),(null==r?void 0:r.length)&&!r.includes(n))continue;const c=this._model.attributes(l);if(!c)continue;const h=null==c?void 0:c.dataLength();let d=!1;for(let i=0;i<h;i++){const r=c.data(i);if(!r)continue;const[n,o,a]=JSON.parse(r);if(this.checkAttribute({name:n,value:o,type:a},{name:t,value:e,type:s})){d=!0;break}}(i?!d:d)&&o.push(n)}if(r)for(const r of a)for(let n=this._virtualModel.requests.length-1;n>=0;n--){const a=this._virtualModel.requests[n];if(a.type===kr.CREATE_ITEM){if(a.localId!==r)continue;const n={};for(const t in a.data.data){const e=a.data.data[t];n[t]={value:e.value,type:e.type}}let l=!1;for(const[i,{value:r,type:o}]of Object.entries(n)){if(this.checkAttribute({name:i,value:r,type:o},{name:t,value:e,type:s})){l=!0;break}}(i?!l:l)&&o.push(r)}}else for(let r=this._virtualModel.requests.length-1;r>=0;r--){const n=this._virtualModel.requests[r];if(n.type===kr.CREATE_ITEM&&void 0!==n.localId){const r={};for(const t in n.data.data){const e=n.data.data[t];r[t]={value:e.value,type:e.type}}let a=!1;for(const[i,{value:n,type:o}]of Object.entries(r)){if(this.checkAttribute({name:i,value:n,type:o},{name:t,value:e,type:s})){a=!0;break}}(i?!a:a)&&o.push(Number(n.localId))}}return o}getItemsByRelation({name:t,targetItemIds:e,sourceItemIds:s}){const i=[],r=s??this.getAllLocalIds();for(const s of r){const r=this.getItemRelations(s),n=null==r?void 0:r[t];if(n)if(e){for(const t of n)if(e.has(t)){i.push(s);break}}else i.push(s)}return i}getItemsByQuery(t,e){var s;const{categories:i,attributes:r,relation:n}=t;let o=null==e?void 0:e.localIds;if(o){if(i){const t=this.getItemsCategories(o);o=o.filter(((e,s)=>{const r=t[s];return r?i.some((t=>t.test(r))):null}))}}else o=(null==(s=null==i?void 0:i.filter(Boolean))?void 0:s.length)?Object.values(this.getItemsOfCategories(i)).flat():void 0;if(0===(null==o?void 0:o.length))return[];if(r){const t=r.aggregation??"exclusive",e=[];for(const t of r.queries)if(r&&Boolean(t.name)){const s=this.getItemsByAttribute({...t,itemIds:o});e.push(s)}const s=new Set;if("inclusive"===t)for(const t of e)for(const e of t)s.add(e);else{const t=new Map;for(const s of e)for(const e of s){const s=t.get(e);void 0===s?t.set(e,1):t.set(e,s+1)}for(const[i,r]of t)r===e.length&&s.add(i)}o=[...s]}if(0===(null==o?void 0:o.length))return[];if(n&&Boolean(n.name)){const{name:t,query:e}=n,s=e?new Set(this.getItemsByQuery(e)):void 0;o=this.getItemsByRelation({name:t,targetItemIds:s,sourceItemIds:o})}return Array.from(new Set(o))}getTreeItem(t){const e={category:t.category(),localId:t.localId()},s=[];for(let e=0;e<t.childrenLength();e++){const i=t.children(e);i&&s.push(this.getTreeItem(i))}return s.length>0&&(e.children=s),e}preindexGeometryIds(){const t=this._model.meshes(),e=t.meshesItemsLength();for(let s=0;s<e;s++){const e=t.meshesItems(s),i=this._model.localIds(e);null!==i&&(this._localIdsToGeometryIds.has(i)||this._localIdsToGeometryIds.set(i,[]),this._localIdsToGeometryIds.get(i).push(s))}}convertToLocalId(t){if("number"==typeof t)return t;const e=this._guidToLocalIdMap.get(t);return void 0===e?null:e}getChildrenLocalIds(t,e){if(null!==t.localId&&e.add(t.localId),t.children)for(const s of t.children)this.getChildrenLocalIds(s,e)}traverseSpatialStructure(t,e,s=this.getSpatialStructure()){if(s)if(s.localId===t&&s.children)for(const t of s.children)this.getChildrenLocalIds(t,e);else if(s.children)for(const i of s.children)this.traverseSpatialStructure(t,e,i)}}class Od{constructor(t){ot(this,"_fragments"),this._fragments=t}async getAlignments(){const t=[],e=new RegExp(Dn),s=this._fragments.getItemsOfCategories([e])[Dn];if(!s)return[];const i=this._fragments.getItemsData(s,{});for(const e of i){const s=JSON.parse(e.data.value);t.push(s)}return t}}class xd{constructor(){ot(this,"_templates",new Map)}add(t,e){this._templates.set(t,e)}get(t){const e=this._templates.get(t);return Array.isArray(e)?this.getTemplateSet(e):{...e}}getTemplateSet(t){const e=[];for(const s of t){const t={...s};e.push(t)}return e}}const Nd=class t{constructor(e,s){ot(this,"_dataBuffer"),ot(this,"_dataPosition"),this._dataBuffer=s||this.getDefaultData(),this._dataPosition=e||t._data.defaultPosition}set(e){let s=0;for(const i of t._data.points)for(const r of t._data.coords){const t=this.getPosition(r,i),n=e[s++];this.setValue(t,n)}}get(t,e){const s=this.getPosition(t,e);return this._dataBuffer[s]}clone(e){for(const s of t._data.points)for(const i of t._data.coords){const t=this.getPosition(i,s),r=e.get(i,s);this.setValue(t,r)}}combine(e,s){for(const i of t._data.points)for(const r of t._data.coords)this.save(r,i,e,s)}setValue(t,e){this._dataBuffer[t]=e}getDefaultData(){return new Float64Array(t._data.size)}getPosition(e,s){return t._data[s][e]+this._dataPosition}save(t,e,s,i){const r=this.getPosition(t,e),n=s.get(t,e),o=i.get(t,e),a=Math[e](n,o);this.setValue(r,a)}};ot(Nd,"_data",{size:6,defaultPosition:0,min:{x:0,y:2,z:4},max:{x:1,y:3,z:5},coords:["x","y","z"],points:["min","max"]});let vd=Nd;const Pd=class t{constructor(t,e){ot(this,"box"),ot(this,"data",0),this.box=new vd(t,e)}get size(){return this.data*t._data.factor}get isPoint(){return this.data>=t._data.threshold}transform(e,s,i){i||(e*=t._data.factor),this.data=e,this.box.clone(s)}};ot(Pd,"_data",{threshold:0,factor:-1});let Md=Pd;class Dd{constructor(t){ot(this,"_boxes"),ot(this,"_min",new ft.Vector3),ot(this,"_max",new ft.Vector3),this._boxes=t}inflate(t){const e=this._boxes.fullBox.min,s=this.getVector(t,e,"min"),i=this.getVector(t,e,"max");return new ft.Box3(s,i)}deflate(t,e){this.read(t);const s=[];s.push(this._min.x,this._min.y,this._min.z),s.push(this._max.x,this._max.y,this._max.z),e.set(s)}getVector(t,e,s){const i=t.get("x",s)+e.x,r=t.get("y",s)+e.y,n=t.get("z",s)+e.z;return new ft.Vector3(i,r,n)}read(t){const{min:e}=this._boxes.fullBox;this._min.subVectors(t.min,e),this._max.subVectors(t.max,e)}}class Ud{constructor(t,e){ot(this,"_data"),ot(this,"_compressor"),this._data=e,this._compressor=t}frustumCollide(t,e,s=!1){const i=this.getFrustumPlanes(e,t),r=this.getFrustumOnCollide(i),n=this.getFrustumOnIncludes(i),o=this.newDefaultCallback(!0);return this.collide(r,n,o,s)}rayCollide(t,e){const s=this.getRayOnCollide(e),i=this.newDefaultCallback(!1),r=this.getRayOnSeen(t);return this.collide(s,i,r)}addPoint(t,e,s,i){t?i&&e.push(this.getPointData(s)):e.push(this.getPointData(s))}getPointData(t){return this.getPoint(t).data}getBounds(t){const e=this.getPoint(t);return this._compressor.inflate(e.box)}isPoint(t){return this.getPoint(t).isPoint}newDefaultCallback(t){return e=>t}groupSize(t){return this.getPoint(t).size}getPoint(t){return this._data.points[t]}getRayOnSeen(t){let e=this.newDefaultCallback(!0);return(null==t?void 0:t.length)>0&&(e=e=>Gn.collides(e,t)),e}getRayOnCollide(t){return e=>t.intersectsBox(e)}collide(t,e,s,i=!1){const r=this._data.points.length,n=[];let o=0;const a=(t,e)=>{const r=o+this.groupSize(o);for(;o<r;o++){this.isPoint(o)&&s(t)&&(i?e&&this.savePoint(o,n):this.savePoint(o,n))}},l=()=>{const r=this.getBounds(o),l=e(r),c=this.isPoint(o),h=l||t(r);c&&h&&s(r)&&this.addPoint(i,n,o,l),h||c?(o++,l&&!c&&a(r,l)):o+=this.groupSize(o)};for(;o<r;)l();return n}getFrustumOnIncludes(t){return e=>Gn.isIncluded(e,t)}getFrustumOnCollide(t){return e=>Gn.collides(e,t)}getFrustumPlanes(t,e){const s=[];for(const e of t.planes)s.push(e);if(e)for(const t of e)s.push(t);return s}savePoint(t,e){const s=this.getPoint(t);e.push(s.data)}}class Vd{constructor(t){ot(this,"_boxes"),ot(this,"_total",new ft.Vector3),ot(this,"_change",new ft.Vector3),ot(this,"_average",new ft.Vector3),ot(this,"_tempCenterVector",new ft.Vector3),ot(this,"_tempVectors",{x:new ft.Vector3,y:new ft.Vector3,z:new ft.Vector3}),this._boxes=t}sort(t,e,s){this.average(this._average,t,e,s),this.getDataToTotal(e,s,t);let i=this.anySort(e,s,t);return i=this.adjust(s,e,i),Math.round(i)}anySort(t,e,s){return this._total.x>this._total.y?this._total.x>this._total.z?this.sortDim("x",this._average.x,t,e,s):this.sortDim("z",this._average.z,t,e,s):this._total.y>this._total.z?this.sortDim("y",this._average.y,t,e,s):this.sortDim("z",this._average.z,t,e,s)}getDataToTotal(t,e,s){this._total.set(0,0,0);for(let i=t;i<e;i++){this._boxes.get(s[i]).getCenter(this._change).sub(this._average);const t=this._change.multiply(this._change);this._total.add(t)}}sortDim(t,e,s,i,r){let n=s;for(let o=s;o<i;o++){this.getValue(r,o,t)>e&&(this.exchange(o,n,r),n++)}return n}exchange(t,e,s){const i=s[t];s[t]=s[e],s[e]=i}getValue(t,e,s){const i=this.getBox(t,e),r=this._tempVectors[s];return i.getCenter(r)[s]}average(t,e,s,i){const r=this.getBox(e,s);return r.getCenter(t),this.aggregate(s,i,e,r,t),t.divideScalar(i-s)}aggregate(t,e,s,i,r){for(let i=t+1;i<e;i++){const t=s[i],e=this._boxes.get(t).getCenter(this._tempCenterVector);r.add(e)}}adjust(t,e,s){const i=(e+t)/2,r=(t-e)/3;return(s<=e+r||s>=t-1-r)&&(s=i),s}getBox(t,e){const s=t[e];return this._boxes.get(s)}}class Bd{constructor(t,e,s){ot(this,"_data"),ot(this,"_compressor"),ot(this,"_boxes"),ot(this,"_sorter"),this._data=s,this._compressor=e,this._boxes=t,this._sorter=new Vd(t)}make(t,e,s=0,i=0,r=0,n=0){const o=s-i;return 1===o?this.makePoint(t,i,e,n):2===o?this.makeGroup3(n,t,i,e):this.makeGroup(r,t,i,s,n,e)}makeGroup3(t,e,s,i){const r=this.makeBox(t+1,e,s),n=this.makeBox(t+2,e,s+1);return i.combine(r,n),this.newGroup(t,3,i),3}makeGroup(t,e,s,i,r,n){const o=this._data.limits.primary[t],a=this._data.limits.secondary[t],l=this._sorter.sort(e,s,i),c=this.make(e,o,l,s,t+1,r+1),h=r+c+1,d=this.make(e,a,i,l,t+1,h);n.combine(o,a);const u=c+d+1;return this.newGroup(r,u,n),u}makeBox(t,e,s){const i=this._data.points[t].box,r=e[s],n=this._boxes.get(r);return this._compressor.deflate(n,i),this.set(t,r),i}makePoint(t,e,s,i){const r=this._boxes.get(t[e]);return this._compressor.deflate(r,s),this.newPoint(i,t[e],s),1}newGroup(t,e,s){this.get(t).transform(e,s,!1)}get(t){return this._data.points[t]}newPoint(t,e,s){this.get(t).transform(e,s,!0)}set(t,e){this.get(t).data=e}}const zd=class t{constructor(t){ot(this,"_compressor"),ot(this,"_collider"),ot(this,"_maker"),ot(this,"_data"),ot(this,"_boxes"),this._boxes=t,this._compressor=new Dd(t),this._data=this.getData(),this._collider=new Ud(this._compressor,this._data),this._maker=new Bd(this._boxes,this._compressor,this._data),this.initData()}collideFrustum(t,e,s=!1){return this._collider.frustumCollide(t,e,s)}collideRay(t,e){return this._collider.rayCollide(t,e)}setupLimits(){for(let e=0;e<t._limitThreshold;e++)this._data.limits.primary.push(new vd),this._data.limits.secondary.push(new vd)}getPointBuffer(){const t=this._boxes.getCount(),e=new Uint32Array(t);for(let t=0;t<e.length;t++)e[t]=t;return e}getPointsAmount(t){return 2*t.length-1}initData(){const e=this.getPointBuffer(),s=this.getPointsAmount(e),i=s*t._boxSize,r=new Float64Array(i);for(let e=0;e<s;e++){const s=e*t._boxSize,i=new Md(s,r);this._data.points.push(i)}this.setupLimits();const n=new vd;this._maker.make(e,n,e.length)}getData(){return{points:[],limits:{primary:[],secondary:[]}}}};ot(zd,"_boxSize",6),ot(zd,"_limitThreshold",32);let Gd=zd;class Hd{constructor(t){ot(this,"lookup",null),ot(this,"_boxSize",6),ot(this,"_pointSize",3),ot(this,"_temp"),ot(this,"_dimensionsOfSamples"),ot(this,"_samples",[]),ot(this,"_boxes"),ot(this,"_meshes"),ot(this,"_box"),this._temp={box:new ft.Box3,vector:new ft.Vector3,transform:new ft.Matrix4,sample:new Or,representation:new Lr},this._box=new ft.Box3;const e=t.meshes();if(!e)throw new Error("Fragments: Malformed fragments data!");this._meshes=e;const s=e.samplesLength();this._dimensionsOfSamples=new Float32Array(s);const i=s*this._boxSize;this._boxes=new Float64Array(i),this.lookup=this.newLookup()}get fullBox(){return this._box}set fullBox(t){this._box=t}sampleOf(t){return this._samples[t]}get(t){const e=this.getMinPosition(t),s=this.getMaxPosition(t);return this._temp.box.min.fromArray(this._boxes,e),this._temp.box.max.fromArray(this._boxes,s),this._temp.box}process(t){this.fetchSampleAndRepresentation(t),this.getBox(),this.addToFullBox();const e=this.getMinPosition(t),s=this.getMaxPosition(t);this._temp.box.min.toArray(this._boxes,e),this._temp.box.max.toArray(this._boxes,s)}getCount(){return this._boxes.length/this._boxSize}dimensionOf(t){const e=this._dimensionsOfSamples[t];if(!e)throw new Error("Fragments: Dimension not found!");return e}newLookup(){const t=this._meshes.samplesLength(),e=this._meshes.globalTransformsLength();if(0===t)return null;for(let e=0;e<t;e++){this.fetchSampleAndRepresentation(e),Fo.getBox(this._temp.representation,this._temp.box);const t=this._temp.box.getSize(this._temp.vector);this._dimensionsOfSamples[e]=t.length(),this.process(e)}this._samples=new Array(e);for(let e=0;e<t;e++)this.storeBox(e);if(!this.getCount())throw new Error("Fragments: Malformed boxes!");return new Gd(this)}getBox(){Fo.get(this._temp.sample,this._meshes,this._temp.transform),Fo.getBox(this._temp.representation,this._temp.box),this._temp.box.applyMatrix4(this._temp.transform)}fetchSampleAndRepresentation(t){this._meshes.samples(t,this._temp.sample);const e=this._temp.sample.representation();this._meshes.representations(e,this._temp.representation)}getMinPosition(t){return t*this._boxSize}storeBox(t){this.fetchSampleAndRepresentation(t);const e=this._temp.sample.item();void 0===this._samples[e]&&(this._samples[e]=[]),this._samples[e].push(t)}getMaxPosition(t){return t*this._boxSize+this._pointSize}addToFullBox(){this.fullBox.union(this._temp.box)}}class kd{raycast(t,e,s,i){if(t.view)return t.raycaster.raycast(e,s,t.view.clippingPlanes,i)}snapRaycast(t,e,s,i){return t.view?t.raycaster.snapRaycast(e,s,i,t.view.clippingPlanes):[]}rectangleRaycast(t,e,s){return t.view?t.raycaster.rectangleRaycast(e,t.view.clippingPlanes,s):[]}}class Yd{getPositions(t,e){const s=[],i=t.properties.getItemIdsFromLocalIds(e);for(const e of i){const i=t.tiles.meshes.globalTransforms(e);if(!i)continue;const r=i.position(),n=r.x(),o=r.y(),a=r.z();s.push({x:n,y:o,z:a})}return s}getCoordinates(t){const e=t.data.meshes().coordinates(),s=e.position(),i=e.xDirection(),r=e.yDirection();return[s.x(),s.y(),s.z(),i.x(),i.y(),i.z(),r.x(),r.y(),r.z()]}}class Wd{constructor(){ot(this,"_highlightProps",["color","opacity","transparent","renderedFaces"])}resetHighlight(t,e){const s=t.properties.getItemIdsFromLocalIds(e);this.resetHighlightForItems(s,t),t.tiles.restart()}getHighlight(t,e){const s=[],i=t.properties.getItemIdsFromLocalIds(e),r=this.getFetchEvent(t,s);return t.traverse(i,r),s}getHighlightItems(t){const e=[],s=t.itemConfig.size;for(let i=0;i<s;i++){if(!t.itemConfig.getHighlight(i))continue;const[s]=t.properties.getLocalIdsFromItemIds([i]);e.push(s)}return e}highlight(t,e,s){const i=t.properties.getItemIdsFromLocalIds(e),r=[],n=this.getCheckEvent(t,s,r);t.traverse(i,n);const o=t.materials.transfer(r),a=this.getCreateEvent(t,o);t.traverse(i,a),t.tiles.updateVirtualMeshes(i)}hasEffectiveProperties(t){const{preserveOriginalMaterial:e,...s}=t;return Object.keys(s).length>0}updateHighlightDefinition(t,e,s){const i=t.properties.getItemIdsFromLocalIds(e),r=[],n=[],o=[];for(const e of i){const i=t.itemConfig.getHighlight(e);if(i){const a=s(t.materials.fetch(i));if(this.hasEffectiveProperties(a)){const t={...a,preserveOriginalMaterial:!0};o.push(t),r.push(e)}else n.push(e)}}if(n.length>0)for(const e of n)t.itemConfig.setHighlight(e,0);if(r.length>0){const e=t.materials.transfer(o),s=this.getCreateEvent(t,e);t.traverse(r,s)}t.tiles.updateVirtualMeshes(i)}setColor(t,e,s){const i={color:s,preserveOriginalMaterial:!0};this.highlight(t,e,i)}resetColor(t,e){this.updateHighlightDefinition(t,e,(t=>{const{color:e,...s}=t;return s}))}setOpacity(t,e,s){const i={opacity:s,transparent:s<1,preserveOriginalMaterial:!0};this.highlight(t,e,i)}resetOpacity(t,e){this.updateHighlightDefinition(t,e,(t=>{const{opacity:e,transparent:s,...i}=t;return i}))}getFetchEvent(t,e){return s=>{const i=t.itemConfig.getHighlight(s);if(i){const s=t.materials.fetch(i);e.push(s)}else e.push(void 0)}}setHighlightProperty(t,e,s){void 0===t[s]&&void 0!==e[s]&&(t[s]=e[s])}getNewHighFromPast(t,e,s){const i=t.materials.fetch(e),r={...s};for(const t of this._highlightProps)this.setHighlightProperty(r,i,t);return r}getCheckEvent(t,e,s){return i=>{const r=t.itemConfig.getHighlight(i);if(void 0===r)s.push(e);else{const i=this.getNewHighFromPast(t,r,e);s.push(i)}}}getCreateEvent(t,e){return(s,i)=>{t.itemConfig.setHighlight(s,e[i])}}resetHighlightForItems(t,e){if(t)for(const s of t)e.itemConfig.setHighlight(s,0);else e.itemConfig.clearHighlight()}}class qd{constructor(){ot(this,"_hiddenForEdit",new Set)}resetVisible(t){t.itemConfig.clearVisible(),t.tiles.restart()}getVisible(t,e){const s=t.properties.getItemIdsFromLocalIds(e),i=[];for(const e of s){if(this._hiddenForEdit.has(e))continue;const s=t.itemConfig.visible(e);i.push(s)}return i}getItemsByVisibility(t,e){const s=this.getVisibleCondition(t,e),i=t.getItemsByConfig(s),r=t.properties.getLocalIdsFromItemIds(i);return this.filterHiddenForEdit(r)}toggleVisible(t,e){const s=t.properties.getItemIdsFromLocalIds(e),i=this.filterHiddenForEdit(s),r=this.getToggleEvent(t);t.traverse(i,r),t.tiles.updateVirtualMeshes(i)}setVisible(t,e,s){const i=t.properties.getItemIdsFromLocalIds(e),r=this.filterHiddenForEdit(i),n=this.getSetEvent(t,s);t.traverse(r,n),t.tiles.updateVirtualMeshes(r)}hideForEdit(t,e){this.setVisible(t,e,!1);for(const t of e)this._hiddenForEdit.add(t)}filterHiddenForEdit(t){if(!this._hiddenForEdit.size)return t;const e=[];for(const s of t)this._hiddenForEdit.has(s)||e.push(s);return e}getSetEvent(t,e){return s=>{t.itemConfig.setVisible(s,e)}}getVisibleCondition(t,e){return s=>t.itemConfig.visible(s)===e}getToggleEvent(t){return e=>{const s=t.itemConfig.visible(e);t.itemConfig.setVisible(e,!s)}}}class jd{getGeometriesLength(t){return t.data.meshes().globalTransformsLength()}getSampleGeometry(t,e,s){const i=t.boxes.sampleOf(e),r=[];if(!i)return r;const n=t.data.meshes();for(const e of i){const i=t.tiles.fetchSample(e,s),o=n.sampleIds(e),a=Array.isArray(i.geometries)?i.geometries:[i.geometries],l=n.samples(e),c=n.meshesItems(l.item()),h=t.data.localIds(c);for(const t of a){const e=s===Nn.GEOMETRY?t.positionBuffer:new Float32Array(t.positionBuffer);r.push({transform:i.transform.clone(),indices:t.indexBuffer,positions:e,normals:t.normalBuffer,sampleId:o,localId:h,representationId:i.representationId})}}return r}getVolume(t,e){let s=0;const i={x:0,y:0,z:0},r={x:0,y:0,z:0},n={x:0,y:0,z:0},o=this.getSampleGeometry(t,e,Nn.GEOMETRY);for(const{indices:t,positions:e}of o)if(t&&e)for(let o=0;o<t.length-2;o+=3){const a=3*t[o],l=3*t[o+1],c=3*t[o+2];i.x=e[a],i.y=e[a+1],i.z=e[a+2],r.x=e[l],r.y=e[l+1],r.z=e[l+2],n.x=e[c],n.y=e[c+1],n.z=e[c+2],s+=this.getSignedVolumeOfTriangle(i,r,n)}return Math.abs(s)}getSignedVolumeOfTriangle(t,e,s){return 1/6*(-(s.x*e.y*t.z)+e.x*s.y*t.z+s.x*t.y*e.z-t.x*s.y*e.z-e.x*t.y*s.z+t.x*e.y*s.z)}}class Xd{constructor(){ot(this,"_sectionGenerator",new Io)}async getSection(t,e,s){this._sectionGenerator.plane=e,performance.now();const i=new Map,r=[];for(const n of s){const s=t.boxes.sampleOf(n);if(s)for(const o of s){const s=t.boxes.get(o);if(!e.intersectsBox(s))continue;const a=t.tiles.meshes.meshesItems(n);if("IFCSPACE"===t.data.categories(a))continue;const l=t.tiles.meshes.samples(o);if(!l)continue;const c=l.representation();if(!i.has(c)){const e=[],s=t.tiles.fetchSample(o,Nn.GEOMETRY);bo.forEach(s.geometries,(t=>{if(!t.indexBuffer||!t.positionBuffer)return;const s=new ft.BufferGeometry;s.setIndex(Array.from(t.indexBuffer)),s.setAttribute("position",new ft.BufferAttribute(t.positionBuffer,3)),e.push(s)})),i.set(c,e)}const h=i.get(c);if(h)for(const e of h){const s=new ft.Mesh(e),i=t.tiles.getSampleTransform(o);s.applyMatrix4(i),s.updateWorldMatrix(!0,!0),r.push(s)}}}const n=new Float32Array(6e5),o=new ft.BufferAttribute(n,3,!1),{index:a,indexes:l}=this._sectionGenerator.createEdges({meshes:r,posAttr:o}),c=this._sectionGenerator.createFills(n,l);for(const[,t]of i)for(const e of t)e.dispose();return{buffer:n,index:a,fillsIndices:c}}}class Zd{constructor(t){ot(this,"_model"),ot(this,"sequenceSelectorFunction",{withVisiblity:t=>this._model.getItemsByVisibility(t),highlighted:()=>this._model.getHighlightItemIds(),children:t=>this._model.getItemsChildren(t),ofCategory:t=>{const e=this._model.getItemsOfCategories(t);return Object.values(e).flat()},withCondition:()=>[],withGeometry:()=>this._model.getItemsWithGeometry()}),ot(this,"sequenceResultFunction",{attributes:t=>t.map((t=>this._model.getItemAttributes(t))),mergedBoxes:t=>this._model.getBBoxes(t),category:t=>this._model.getItemsCategories(t),children:t=>this._model.getItemsChildren(t),data:(t,...e)=>this._model.getItemsData(t,e[0]),geometry:t=>this._model.getItemsGeometry(t),guid:t=>this._model.getGuidsByLocalIds(t),highlight:t=>this._model.getHighlight(t),relations:t=>t.map((t=>this._model.getItemRelations(t))),visibility:t=>this._model.getVisible(t)}),this._model=t}getSequenced(t,e,s){var i;const r=this.sequenceResultFunction[t];if(!r)return null;let n=[],o=0;for(const t of e){const e=this.sequenceSelectorFunction[t];if(!e)continue;const r=null==(i=null==s?void 0:s.selector)?void 0:i[t];n=e(0===o?r:n),o++}return r(n,null==s?void 0:s.result)}}class $d{traverse(t,e,s){e?this.traverseItems(e,s):this.traverseAllItems(t,s)}getItemsByConfig(t,e){const s=[],i=t.data.localIdsLength();for(let t=0;t<i;t++){e(t)&&s.push(t)}return s}traverseItems(t,e){const s=t.length;for(let i=0;i<s;i++)e(t[i],i)}traverseAllItems(t,e){const s=t.itemConfig.size;for(let t=0;t<s;t++)e(t,t)}}class Qd{constructor(t){ot(this,"_fragments"),this._fragments=t}async getGrids(){const t=[],e=new RegExp(Un),s=this._fragments.getItemsOfCategories([e])[Un];if(!s)return[];const i=this._fragments.getItemsData(s,{});for(const e of i){const s=JSON.parse(e.data.value);t.push(s)}return t}}class Kd{constructor(t,e,s,i){ot(this,"data"),ot(this,"view"),ot(this,"raycaster"),ot(this,"itemConfig"),ot(this,"properties"),ot(this,"materials"),ot(this,"tiles"),ot(this,"boxes"),ot(this,"requests",[]),ot(this,"_raycastHelper",new kd),ot(this,"_coordinatesHelper",new Yd),ot(this,"_highlightHelper",new Wd),ot(this,"_visibilityHelper",new qd),ot(this,"_geometryHelper",new jd),ot(this,"_sectionHelper",new Xd),ot(this,"_itemsHelper",new $d),ot(this,"_sequenceHelper",new Zd(this)),ot(this,"_config",{}),ot(this,"_modelId"),ot(this,"_alignments"),ot(this,"_grids"),ot(this,"_connection"),ot(this,"_reprIdMap",new Map),ot(this,"_nextId",0),ot(this,"_requestsForRedo",[]),ot(this,"_onTransferMaterial",((t,e)=>{if(this._connection)return this._connection.fetch(t,e)})),this._modelId=t,this._connection=s,this._config={...this._config,...i},this.data=this.setupModel(e),this.boxes=new Hd(this.data),this.materials=this.setupMaterials(t),this._alignments=new Od(this),this._grids=new Qd(this),this.itemConfig=this.setupItemsConfig(),this.tiles=this.setupTiles(),this.properties=this.setupProperties(),this.raycaster=this.setupRaycaster(),this.setupBVH(),this._nextId=this.getMaxLocalId()}getItemsByConfig(t){return this._itemsHelper.getItemsByConfig(this,t)}getItemsCategories(t){return this.properties.getItemsCategories(t)}getItemIdsByLocalIds(t){return this.properties.getItemIdsFromLocalIds(t)}getItemAttributes(t){return this.properties.getItemAttributes(t)}getAttributesUniqueValues(t){return this.properties.getAttributesUniqueValues(t)}getItemsData(t,e){return this.properties.getItemsData(t,e)}getItemsOfCategories(t){return this.properties.getItemsOfCategories(t)}getItemsWithGeometry(){return this.properties.getItemsWithGeometry()}getItemsWithGeometryCategories(){return this.properties.getItemsWithGeometryCategories()}getItemsByQuery(t,e){return this.properties.getItemsByQuery(t,e)}getItemRelations(t){return this.properties.getItemRelations(t)}getSpatialStructure(){const t=pn.applyChangesToSpecialData(this.requests,"SPATIAL_STRUCTURE");return t||this.properties.getSpatialStructure()}getMaxLocalId(){return this.properties.getMaxLocalId()}getCategories(){return this.properties.getCategories()}getMetadata(){const t=pn.applyChangesToSpecialData(this.requests,"METADATA");return t||this.properties.getMetadata()}getLocalIdsByGuids(t){return this.properties.getLocalIdsByGuids(t)}getGuidsByLocalIds(t){return this.properties.getGuidsByLocalIds(t)}getSequenced(t,e,s){return this._sequenceHelper.getSequenced(t,e,s)}highlight(t,e){this._highlightHelper.highlight(this,t,e)}setColor(t,e){this._highlightHelper.setColor(this,t,e)}resetColor(t){this._highlightHelper.resetColor(this,t)}setOpacity(t,e){this._highlightHelper.setOpacity(this,t,e)}resetOpacity(t){this._highlightHelper.resetOpacity(this,t)}getHighlight(t){return this._highlightHelper.getHighlight(this,t)}getHighlightItemIds(){return this._highlightHelper.getHighlightItems(this)}resetHighlight(t){this._highlightHelper.resetHighlight(this,t)}getCoordinates(){return this._coordinatesHelper.getCoordinates(this)}getPositions(t){return this._coordinatesHelper.getPositions(this,t)}getGeometriesLength(){return this._geometryHelper.getGeometriesLength(this)}getGuids(){return this.properties.getGuids()}getLocalIds(){return this.properties.getLocalIds()}getItemsGeometry(t,e=Nn.GEOMETRY){const s=this.properties.getItemIdsFromLocalIds(t),i=[];for(const t of s){const s=this._geometryHelper.getSampleGeometry(this,t,e);i.push(s)}return i}getGeometries(t){if(0===this._reprIdMap.size){const t=this.data.meshes();for(let e=0;e<t.representationsLength();e++){const s=t.representationIds(e);this._reprIdMap.set(s,e)}}const e=new Map;for(const s of t)this._reprIdMap.has(s)&&e.set(s,this._reprIdMap.get(s));const s=this.data.meshes(),i=Array.from(e.values()),r=[];for(const t of i){const e=this.tiles.fetchGeometry(t),i=Array.isArray(e)?e:[e];for(const e of i){const i=e.indexBuffer,n=e.positionBuffer,o=e.normalBuffer,a=s.representationIds(t);r.push({transform:new ft.Matrix4,indices:i,positions:n,normals:o,representationId:a})}}return r}getItemsVolume(t){const e=this.properties.getItemIdsFromLocalIds(t);let s=0;for(const t of e)s+=this._geometryHelper.getVolume(this,t);return s}getAttributeNames(){return this.properties.getAttributeNames()}getAttributeValues(){return this.properties.getAttributeValues()}getAttributeTypes(){return this.properties.getAttributeTypes()}getRelationNames(){return this.properties.getRelationNames()}getItemsMaterialDefinition(t){const e=this.properties.getItemIdsFromLocalIds(t);return this.materials.getItemsMaterialDefinition(this.data,e,t)}resetVisible(){this._visibilityHelper.resetVisible(this)}getItemsByVisibility(t){return this._visibilityHelper.getItemsByVisibility(this,t)}raycast(t,e,s){return this._raycastHelper.raycast(this,t,e,s)}snapRaycast(t,e,s){return this._raycastHelper.snapRaycast(this,t,e,s)}rectangleRaycast(t,e){return this._raycastHelper.rectangleRaycast(this,t,e)}async getSection(t,e){const s=this.properties.getItemIdsFromLocalIds(e);return this._sectionHelper.getSection(this,t,s)}async getAlignments(){return this._alignments.getAlignments()}async getGrids(){return this._grids.getGrids()}getBuffer(t){const e=this.data.bb.bytes().buffer;return t?e:Ir.deflate(e)}dispose(){this.tiles.dispose()}setVisible(t,e){this._visibilityHelper.setVisible(this,t,e)}toggleVisible(t){this._visibilityHelper.toggleVisible(this,t)}getVisible(t){return this._visibilityHelper.getVisible(this,t)}hideForEdit(t){this._visibilityHelper.hideForEdit(this,t)}getItemsChildren(t){return this.properties.getItemsChildren(t)}setupData(){this.tiles.generate()}refreshView(t){this.view=t,this.tiles.setupView(t)}getFullBBox(){return this.boxes.fullBox}getBBoxes(t){const e=new ft.Box3;return this.properties.getBox(t,e),e}traverse(t,e){this._itemsHelper.traverse(this,t,e)}update(t){return this.tiles.update(t),this.tiles.tilesUpdated}edit(t){const e=pn.solveIds(t,this._nextId);this._nextId+=e.length;for(const e of t)this.requests.push(e);const{model:s,items:i}=pn.edit(this.data,this.requests,{raw:!0,delta:!0});return this._visibilityHelper.hideForEdit(this,i),{deltaModelBuffer:s,ids:e}}reset(){this.requests=[],this._requestsForRedo=[],this._nextId=this.getMaxLocalId()}save(){this.requests.push({type:kr.UPDATE_MAX_LOCAL_ID,localId:this._nextId});const{model:t}=pn.edit(this.data,this.requests,{raw:!0,delta:!1});return t}undo(){if(0===this.requests.length)return;const t=this.requests.pop();t&&this._requestsForRedo.unshift(t)}redo(){if(0===this._requestsForRedo.length)return;const t=this._requestsForRedo.shift();t&&this.requests.push(t)}getRequests(){return{requests:this.requests,undoneRequests:this._requestsForRedo}}setRequests(t){t.requests&&(this.requests=t.requests),t.undoneRequests&&(this._requestsForRedo=t.undoneRequests)}selectRequest(t){const e=[];for(const t of this.requests)e.push(t);for(const t of this._requestsForRedo)e.push(t);this.requests=[],this._requestsForRedo=[];for(let s=0;s<e.length;s++)s<=t?this.requests.push(e[s]):this._requestsForRedo.push(e[s])}getMaterialsIds(){const t=pn.getMaterialsIds(this.data);return pn.applyChangesToIds(this.requests,t,"MATERIAL",!0)}getMaterials(t){const e=pn.getMaterials(this.data,t);return pn.applyChangesToRawData(this.requests,e,"MATERIAL"),e}getRepresentationsIds(){const t=pn.getRepresentationsIds(this.data);return pn.applyChangesToIds(this.requests,t,"REPRESENTATION",!0)}getRepresentations(t){const e=pn.getRepresentations(this.data,t);return pn.applyChangesToRawData(this.requests,e,"REPRESENTATION"),e}getLocalTransformsIds(){const t=pn.getLocalTransformsIds(this.data);return pn.applyChangesToIds(this.requests,t,"LOCAL_TRANSFORM",!0)}getLocalTransforms(t){const e=pn.getLocalTransforms(this.data,t);return pn.applyChangesToRawData(this.requests,e,"LOCAL_TRANSFORM"),e}getGlobalTransformsIds(){const t=pn.getGlobalTransformsIds(this.data);return pn.applyChangesToIds(this.requests,t,"GLOBAL_TRANSFORM",!0)}getGlobalTransforms(t){const e=pn.getGlobalTransforms(this.data,t);return pn.applyChangesToRawData(this.requests,e,"GLOBAL_TRANSFORM"),e}getSamplesIds(){const t=pn.getSamplesIds(this.data);return pn.applyChangesToIds(this.requests,t,"SAMPLE",!0)}getSamples(t){const e=pn.getSamples(this.data,t);return pn.applyChangesToRawData(this.requests,e,"SAMPLE"),e}getItemsIds(){const t=pn.getItemsIds(this.data);return pn.applyChangesToIds(this.requests,t,"ITEM",!0)}getItems(t){const e=this.properties.getItemIdsFromLocalIds(t),s=pn.getItems(this.data,e),i=t?new Set(t):void 0;return pn.applyChangesToRawData(this.requests,s,"ITEM",i),s}getRelations(t){const e=this.properties.getRawRelations(t);return pn.applyChangesToRawData(this.requests,e,"RELATION"),e}getGlobalTranformsIdsOfItems(t){return pn.getGlobalTranformsIdsOfItems(this.data,t)}getElementsData(t){const e=new Set(t);return pn.applyChangesToIds(this.requests,e,"ITEM",!1),pn.getElementsData(this,e)}setLodMode(t){this.tiles.setLodMode(t)}setupBVH(){ft.BufferGeometry.prototype.computeBoundsTree=ah,ft.BufferGeometry.prototype.disposeBoundsTree=lh,ft.Mesh.prototype.raycast=oh}setupProperties(){return new Ld(this,this.boxes,this._config.properties)}setupRaycaster(){return new cd(this.data,this.boxes,this.tiles,this.itemConfig)}setupMaterials(t){return new wd(t,this._onTransferMaterial)}setupTiles(){const t=this.materials.update(this.data);return new Sd({modelId:this._modelId,connection:this._connection,model:this.data,boxes:this.boxes,items:this.itemConfig,materials:t})}setupModel(t){const e=new Uint8Array(t),s=new Kt(e);return Br.getRootAsModel(s)}setupItemsConfig(){const t=this.data.localIdsLength();return new ad(t)}}class Jd{constructor(t,e,s=!1){ot(this,"_modelId"),ot(this,"_virtualModel"),this._modelId=t;let i=e;s||(i=Ir.inflate(e)),this._virtualModel=new Kd(t,i,void 0),this._virtualModel.setupData()}get modelId(){return this._modelId}dispose(){this._virtualModel.dispose(),this._virtualModel=null}getSpatialStructure(){return this._virtualModel.getSpatialStructure()}getLocalIdsByGuids(t){return this._virtualModel.getLocalIdsByGuids(t)}getCategories(){return this._virtualModel.getCategories()}getItemsWithGeometry(){return this._virtualModel.getItemsWithGeometry()}getMetadata(){return this._virtualModel.getMetadata()}getGuidsByLocalIds(t){return this._virtualModel.getGuidsByLocalIds(t)}getBuffer(t=!1){return this._virtualModel.getBuffer(t)}getItemsOfCategories(t){return this._virtualModel.getItemsOfCategories(t)}getMaxLocalId(){return this._virtualModel.getMaxLocalId()}getItemsChildren(t){this._virtualModel.getItemsChildren(t)}getItemsData(t,e){return this._virtualModel.getItemsData(t,e)}getPositions(t){return this._virtualModel.getPositions(t)}getCoordinates(){return this._virtualModel.getCoordinates()}getItemsGeometry(t,e){return this._virtualModel.getItemsGeometry(t,e)}getItemsByQuery(t,e){return this._virtualModel.getItemsByQuery(t,e)}async getSection(t,e){return this._virtualModel.getSection(t,e)}async getLocalIds(){return this._virtualModel.getLocalIds()}async getMaterialsIds(){return this._virtualModel.getMaterialsIds()}async getMaterials(t){return this._virtualModel.getMaterials(t)}async getRepresentationsIds(){return this._virtualModel.getRepresentationsIds()}async getRepresentations(t){return this._virtualModel.getRepresentations(t)}async getLocalTransformsIds(){return this._virtualModel.getLocalTransformsIds()}async getLocalTransforms(t){return this._virtualModel.getLocalTransforms(t)}async getGlobalTransformsIds(){return this._virtualModel.getGlobalTransformsIds()}async getGlobalTransforms(t){return this._virtualModel.getGlobalTransforms(t)}async getSamplesIds(){return this._virtualModel.getSamplesIds()}async getSamples(t){return this._virtualModel.getSamples(t)}async getItemsIds(){return this._virtualModel.getItemsIds()}async getItems(t){return this._virtualModel.getItems(t)}async getRelations(t){return this._virtualModel.getRelations(t)}async getGlobalTranformsIdsOfItems(t){return this._virtualModel.getGlobalTranformsIdsOfItems(t)}}class tu{constructor(t){ot(this,"onModelLoaded",new Ht),ot(this,"models"),ot(this,"settings",{autoCoordinate:!0,maxUpdateRate:100,graphicsQuality:0,forceUpdateRate:200,forceUpdateBuffer:200}),ot(this,"baseCoordinates",null),ot(this,"editor"),ot(this,"_connection"),ot(this,"_isDisposed",!1),ot(this,"_autoRedrawInterval",null),ot(this,"_lastUpdate",0);const e=this.newRequestEvent(),s=this.newUpdateEvent();this._connection=new Ua(e,t),this.editor=new Aa(this,this._connection),this.models=new Na(s),this.models.list.onItemDeleted.add((()=>{0===this.models.list.size&&(this.baseCoordinates=null)}))}async load(t,e){const s=new La(e.modelId,this.models,this._connection,this.editor);e.userData&&(s.object.userData=e.userData),s.frozen=!0,s.graphicsQuality=this.settings.graphicsQuality;try{if(this.models.list.set(s.modelId,s),await s._setup(t,e.raw,e.virtualModelConfig),this.settings.autoCoordinate){const t=await s.getCoordinates();if(null===this.baseCoordinates)this.baseCoordinates=t;else{const[e,i,r]=t,[n,o,a]=this.baseCoordinates,l=new ft.Vector3(n-e,o-i,a-r);s.object.position.add(l)}}}catch(t){throw this.models.list.delete(s.modelId),t}const{camera:i}=e;return i&&s.useCamera(i),s.frozen=!1,this.onModelLoaded.trigger(s),s}async dispose(){this._isDisposed=!0;const t=Array.from(this.models.list.values()),e=[];for(const s of t)e.push(s.dispose());await Promise.all(e),this.onModelLoaded.reset()}async disposeModel(t){const e=this.models.list.get(t);e&&await e.dispose()}async update(t=!1){if(this._isDisposed)return;const e=performance.now();if(e-this._lastUpdate<this.settings.maxUpdateRate)return;this._lastUpdate=e;const s=[];for(const t of this.models.list.values())s.push(t._refreshView());await Promise.all(s),t?await this.models.forceUpdateFinish(this.settings.forceUpdateRate,this.settings.forceUpdateBuffer):this.models.update()}async manageRequest(t){const e=this.models.list.get(t.modelId);e&&await e.handleRequest(t)}newUpdateEvent(){return()=>{this._autoRedrawInterval&&clearTimeout(this._autoRedrawInterval);const t=this.settings.maxUpdateRate+1;this._autoRedrawInterval=setTimeout((()=>{this.update()}),t)}}newRequestEvent(){return t=>{this.manageRequest(t)}}}class eu{constructor(t,e){ot(this,"_lengthUnitsFactor",1),ot(this,"_attributesOffsets",[]),ot(this,"_relationsMap",{}),ot(this,"_guids",[]),ot(this,"_guidsItems",[]),ot(this,"_uniqueAttributes",new Set),ot(this,"_uniqueRelNames",new Set),ot(this,"_maxLocalID",0),ot(this,"_ifcApi",null),ot(this,"wasm",{path:"/node_modules/web-ifc/",absolute:!1}),ot(this,"webIfcSettings",{}),ot(this,"expressIDs",[]),ot(this,"classes",[]),this._serializer=t,this._builder=e}async getIfcApi(){if(!this._ifcApi){const t=new Bt.IfcAPI;t.SetWasmPath(this.wasm.path,this.wasm.absolute),await t.Init(),t.SetLogLevel(Bt.LogLevel.LOG_LEVEL_OFF),this._ifcApi=t}return this._ifcApi}async getSchema(t=0){const e=(await this.getIfcApi()).GetModelSchema(t);if(!e)throw new Error("Fragments: IFC Schema not found");return e.startsWith("IFC2X3")?"IFC2X3":e.startsWith("IFC4")&&""===e.replace("IFC4","")?"IFC4":e.startsWith("IFC4X")?"IFC4X3":e}async process(t){var e,s,i;const r=await this.getIfcApi();if(this._maxLocalID=t.maxLocalID+1,t.readFromCallback)r.OpenModelFromCallback(t.readCallback,this.webIfcSettings);else{if(!t.bytes)throw new Error("Fragments: No data provided");await r.OpenModel(t.bytes,this.webIfcSettings)}this._serializer.replaceStoreyElevation&&await this.setLengthUnitsFactor();const n=r.GetAllTypesOfModel(0).map((t=>t.typeID)),o=await this.getSchema();if(!Bt[o])throw new Error("Fragments: Model schema not recognized.");const a=t.geometryProcessedLocalIDs;await this.processItems(a);const l=new Set(a);null==(e=t.progressCallback)||e.call(t,.6,{process:"attributes",state:"start",entitiesProcessed:a.length});const c=new Set([...this._serializer.classes.abstract,...this._serializer.classes.elements]),h=n.filter((t=>c.has(t))),d=.15/h.length;for(const[e,i]of h.entries()){const n=r.GetLineIDsWithType(0,i);if(0===n.size())continue;const o=[];for(let t=0;t<n.size();t++){const e=n.get(t);l.has(e)||o.push(e)}0!==o.length&&(await this.processItems(o),null==(s=t.progressCallback)||s.call(t,d*(e+1)+.6,{process:"attributes",state:e+1===h.length?"finish":"inProgress",class:Gt[i],entitiesProcessed:o.length}))}const u=t.alignments;u&&this.processCustomItems(u,Dn);const f=t.grids;f&&this.processCustomItems(f,Un);const p=new Set([...this._serializer.relations.keys()]),I=n.filter((t=>p.has(t))),m=.15/I.length;for(const[e,s]of I.entries()){const r=0===e?"start":e+1===I.length?"finish":"inProgress";await this.processRelations([s]),null==(i=t.progressCallback)||i.call(t,m*(e+1)+.75,{process:"relations",state:r,class:Gt[s]})}const{relIndicesVector:E,relsVector:_}=this.getRelationsVector(),{guidsVector:g,guidsItemsVector:C}=this.getGuidsVector(),T=await this.getMetadataOffset(),b=this.getAttributesVector(),R=this.getUniqueAttributesVector(),A=this.getRelNamesVector(),y=Br.createLocalIdsVector(this._builder,this.expressIDs),S=this.getCategoriesVector(),F=await this.getSpatialStructureOffset();return this.clean(),{relIndicesVector:E,relsVector:_,guidsVector:g,guidsItemsVector:C,metadataOffset:T,attributesVector:b,localIdsVector:y,categoriesVector:S,spatialStrutureOffset:F,uniqueAttributesVector:R,relNamesVector:A,newMaxLocalID:this._maxLocalID}}async processItems(t){const e=await this.getIfcApi();for(let s=0;s<t.length;s++){const i=t[s];try{const t=e.GetLine(0,i);if(!t)continue;const s=Gt[t.type];this.classes.push(s),this.expressIDs.push(i),await this.serializeAttributes(i,t)}catch(t){console.log(`Problem reading properties for ${i}. If many items are problematic, it may be a problem with the category you are trying to process. You can remove it and try again.`),console.log(t),await new Promise((t=>{setTimeout(t,100)}));continue}}}async processCustomItems(t,e){for(const s of t){const t=this._maxLocalID++,i=JSON.stringify(s),r="data",n="UNDEFINED",o=JSON.stringify([r,i,n]),a=this._builder.createSharedString(o);this._serializer.includeUniqueAttributes&&this._uniqueAttributes.add(o);const l=mr.createDataVector(this._builder,[a]),c=mr.createAttribute(this._builder,l);this.classes.push(e),this.expressIDs.push(t),this._attributesOffsets.push(c)}}addRelation(t,e,s){this._relationsMap[t]||(this._relationsMap[t]={}),this._relationsMap[t][e]||(this._relationsMap[t][e]=[]);for(const i of s)this._relationsMap[t][e].push(i);this._serializer.includeRelationNames&&this._uniqueRelNames.add(e)}async getAbsoluteElevation(t,e){const s=await this.getIfcApi(),i=s.GetLine(0,t);let r,n;(null==i?void 0:i.RelativePlacement)&&"value"in i.RelativePlacement&&"number"==typeof i.RelativePlacement.value&&(r=s.GetLine(0,i.RelativePlacement.value)),(null==r?void 0:r.Location)&&"value"in r.Location&&"number"==typeof r.Location.value&&(n=s.GetLine(0,r.Location.value)),(null==n?void 0:n.Coordinates)&&Array.isArray(n.Coordinates)&&"value"in n.Coordinates[2]&&"number"==typeof n.Coordinates[2].value&&(e.value+=n.Coordinates[2].value),(null==i?void 0:i.PlacementRelTo)&&"value"in i.PlacementRelTo&&"number"==typeof i.PlacementRelTo.value&&await this.getAbsoluteElevation(i.PlacementRelTo.value,e)}async setLengthUnitsFactor(){const t=await this.getIfcApi();this._lengthUnitsFactor=yn.getUnitsFactor(t)}async serializeAttributes(t,e){const s=[];let i=null;if(this._serializer.replaceSiteElevation&&e.type&&"number"==typeof e.type&&e.type===Bt.IFCSITE&&e.ObjectPlacement&&"value"in e.ObjectPlacement&&"number"==typeof e.ObjectPlacement.value){const t={value:0};await this.getAbsoluteElevation(e.ObjectPlacement.value,t),e.RefElevation=new Bt.IFC4X3.IfcLengthMeasure(t.value*this._lengthUnitsFactor)}if(this._serializer.replaceStoreyElevation&&e.type&&"number"==typeof e.type&&e.type===Bt.IFCBUILDINGSTOREY&&e.ObjectPlacement&&"value"in e.ObjectPlacement&&"number"==typeof e.ObjectPlacement.value){const t={value:0};await this.getAbsoluteElevation(e.ObjectPlacement.value,t),e.Elevation=new Bt.IFC4X3.IfcLengthMeasure(t.value*this._lengthUnitsFactor)}for(const[r,n]of Object.entries(e)){if("number"==typeof n||"boolean"==typeof n)continue;if(this._serializer.attributesToExclude.has(r)||null==n)continue;if(Array.isArray(n)){const e=n.filter((t=>5!==t.type));if(e.length>0){const t=[r,e.map((t=>t.value))],i="name"in e[0]&&e[0].name?e[0].name:e[0].constructor.name.toUpperCase();t.push("OBJECT"!==i?i:"UNDEFINED");const n=JSON.stringify(t),o=this._builder.createSharedString(n);s.push(o)}const i=n.filter((t=>5===t.type)).map((t=>t.value));this.addRelation(t,r,i);continue}const{value:e,type:o}=n;if(5===o){if("number"!=typeof e)continue;this.addRelation(t,r,[e])}else{if("GlobalId"===r&&"string"==typeof e){i=e;continue}const t=[r,e],o="name"in n&&n.name?n.name:n.constructor.name.toUpperCase();t.push("OBJECT"!==o?o:"UNDEFINED");const a=JSON.stringify(t),l=this._builder.createSharedString(a);s.push(l),this._serializer.includeUniqueAttributes&&this._uniqueAttributes.add(a)}}const r=mr.createDataVector(this._builder,s),n=mr.createAttribute(this._builder,r);this._attributesOffsets.push(n),i&&(this._guids.push(i),this._guidsItems.push(t))}getAttributesVector(){return Br.createAttributesVector(this._builder,this._attributesOffsets)}getUniqueAttributesVector(){const t=[];for(const e of this._uniqueAttributes){const s=this._builder.createSharedString(e);t.push(s)}return Br.createUniqueAttributesVector(this._builder,t)}getRelNamesVector(){const t=[];for(const e of this._uniqueRelNames){const s=this._builder.createSharedString(e);t.push(s)}return Br.createRelationNamesVector(this._builder,t)}getGuidsVector(){const t=[];for(const e of this._guids){const s=this._builder.createString(e);t.push(s)}return{guidsVector:Br.createGuidsVector(this._builder,t),guidsItemsVector:Br.createGuidsItemsVector(this._builder,this._guidsItems)}}async processRelations(t){const e=await this.getIfcApi();for(const s of t){const t=this._serializer.relations.get(s);if(!t)continue;const{forRelating:i,forRelated:r}=t,n=e.GetLineIDsWithType(0,s);if(0!==n.size())for(let t=0;t<n.size();t++){const s=n.get(t);try{const t=e.GetLine(0,s);if(!t)continue;const n=Object.keys(t),o=n.find((t=>t.startsWith("Relating"))),a=n.find((t=>t.startsWith("Related")));if(!o||!a)continue;const l=t[o].value,c=t[a];let h=[];h=Array.isArray(c)?c.map((({value:t})=>t)):[c.value],this.addRelation(l,i,h);for(const t of h)this.addRelation(t,r,[l])}catch(t){console.log(`Problem reading relations for ${s}`),console.log(t),await new Promise((t=>{setTimeout(t,100)}));continue}}}}getRelationsVector(t=!1){const e=[],s=[];for(const[i,r]of Object.entries(this._relationsMap)){if(t&&!this.expressIDs.includes(Number(i)))continue;const n=[];for(const[e,s]of Object.entries(r)){let i=s;if(t&&(i=s.filter((t=>this.expressIDs.includes(t))),0===i.length))continue;const r=JSON.stringify([e,...i]),o=this._builder.createSharedString(r);n.push(o)}if(t&&0===n.length)continue;s.push(Number(i));const o=Ur.createDataVector(this._builder,n),a=Ur.createRelation(this._builder,o);e.push(a)}const i=Br.createRelationsVector(this._builder,e);return{relIndicesVector:Br.createRelationsItemsVector(this._builder,s),relsVector:i}}getCategoriesVector(){const t=this.classes.map((t=>this._builder.createSharedString(t)));return Br.createCategoriesVector(this._builder,t)}async getMetadataOffset(){const t=await this.getIfcApi(),e=t.GetModelSchema(0),s=t.GetHeaderLine(0,Bt.FILE_NAME),i=t.GetHeaderLine(0,Bt.FILE_DESCRIPTION),r=[];this.getMetadataRecursively(s.arguments,r);const n=[];this.getMetadataRecursively(i.arguments,n);const o={schema:e,names:r,descriptions:n};return this._builder.createString(JSON.stringify(o))}getMetadataRecursively(t,e){for(const s of t)null!=s&&(Array.isArray(s)&&this.getMetadataRecursively(s,e),"value"in s&&"string"==typeof s.value&&e.push(s.value))}getEntityDecomposition(t,e){var s;const i=[];for(const r of e){const n=null==(s=this._relationsMap[t])?void 0:s[r];if(!n)continue;const o={};for(const t of n){const e=this.expressIDs.indexOf(t);if(-1===e)continue;const s=this.classes[e];s&&(o[s]||(o[s]=[]),o[s].push(t))}for(const t in o){const s=o[t].map((t=>this.getEntityDecomposition(t,e))),r=Vr.createChildrenVector(this._builder,s),n=this._builder.createSharedString(t);Vr.startSpatialStructure(this._builder),Vr.addCategory(this._builder,n),Vr.addChildren(this._builder,r);const a=Vr.endSpatialStructure(this._builder);i.push(a)}}const r=Vr.createChildrenVector(this._builder,i);Vr.startSpatialStructure(this._builder),Vr.addLocalId(this._builder,t),Vr.addChildren(this._builder,r);return Vr.endSpatialStructure(this._builder)}async getSpatialStructureOffset(){const t=await this.getIfcApi(),e=Bt.IFCPROJECT,s=[...t.GetLineIDsWithType(0,e)].map((t=>this.getEntityDecomposition(t,["IsDecomposedBy","ContainsElements"]))),i=this._builder.createSharedString("IFCPROJECT"),r=Vr.createChildrenVector(this._builder,s);Vr.startSpatialStructure(this._builder),Vr.addCategory(this._builder,i),Vr.addChildren(this._builder,r);return Vr.endSpatialStructure(this._builder)}clean(){var t;null==(t=this._ifcApi)||t.Dispose(),this._ifcApi=null,this._guids=[],this._guidsItems=[],this._attributesOffsets=[],this._relationsMap={},this._uniqueAttributes.clear(),this._uniqueRelNames.clear(),this.expressIDs=[],this.classes=[]}}class su{read(t){try{const e=t.GetAllAlignments(0),s=[];for(const t of e){const e={absolute:[],horizontal:[],vertical:[]};s.push(e);let i=0;for(let s=0;s<t.horizontal.length;s++){const r=t.curve3D[0].points,n=t.horizontal[s],o=[],a=[],l=this.getCurveType(n.data[1]),c=[],h=[];for(const t of n.points){const{x:e,y:s,z:n}=r[i++];c.push([e,s,n]),h.push([t.x,t.y])}for(const[t,e,s]of c)o.push(t,e,s);for(const[t,e]of h)a.push(t,0,-e);e.absolute.push({points:o,type:l}),e.horizontal.push({points:a,type:l})}for(let s=0;s<t.vertical.length;s++){const i=t.vertical[s],r=[],n=this.getCurveType(i.data[1]),o=[];for(const t of i.points)o.push([t.x,t.y]);for(const[t,e]of o)r.push(t,e,0);e.vertical.push({points:r,type:n})}}return s}catch(t){return console.error(t),[]}}getCurveType(t){if(t.includes("CIRCULARARC"))return Vn.ELLIPSE_ARC;if(t.includes("LINE")||t.includes("GRADIENT"))return Vn.LINES;if(t.includes("CLOTHOID"))return Vn.CLOTHOID;if(t.includes("PARABOLICARC"))return Vn.PARABOLA;throw new Error(`Fragments: Unknown curve type: ${t}`)}}class iu{read(t){try{const e=[],s=t.GetCoordinationMatrix(0),i=new ft.Matrix4;i.fromArray(s);const r=yn.getUnitsFactor(t),n=t.GetLineIDsWithType(0,Bt.IFCGRID),o=n.size();for(let s=0;s<o;s++){const o=n.get(s),a=t.GetLine(0,o),l=yn.getAbsolutePlacement(t,a,r);l.premultiply(i);const c={id:o,transform:l.elements,uAxes:[],vAxes:[],wAxes:[]};e.push(c),this.getGridAxes(a,t,r,"UAxes","uAxes",c),this.getGridAxes(a,t,r,"VAxes","vAxes",c),this.getGridAxes(a,t,r,"WAxes","wAxes",c)}return e}catch(t){return console.error(t),[]}}getGridAxes(t,e,s,i,r,n){if(t[i])for(const o of t[i]){const t=e.GetLine(0,o.value),i=t.AxisCurve.value,a=e.GetLine(0,i),l={tag:t.AxisTag.value,curve:[]};if(!a.Points)continue;const c=a.Points.value;if(!c)continue;const h=e.GetLine(0,c);if(h.CoordList)for(const t of h.CoordList)for(const e of t){const t=e.value*s;l.curve.push(t)}n[r].push(l)}}}class ru{constructor(t){ot(this,"_ifcAPI",null),ot(this,"wasm",{path:"../../../../node_modules/web-ifc/",absolute:!1}),ot(this,"webIfcSettings",{}),ot(this,"_tempObject1",new ft.Object3D),ot(this,"_tempObject2",new ft.Object3D),ot(this,"_tempMatrix1",new ft.Matrix4),ot(this,"_previousGeometries",new Map),ot(this,"_previousGeometriesIDs",new Map),ot(this,"_previousGeometriesScales",new Map),ot(this,"_previousLocalTransforms",new Map),ot(this,"_problematicGeometries",new Set),ot(this,"_problematicGeometriesHashes",new Set),ot(this,"_coordinatesInitialized",!1),ot(this,"_civilReader",new su),ot(this,"_gridReader",new iu),ot(this,"_nextId",0),ot(this,"_rawCategories",new Set([Bt.IFCEARTHWORKSFILL,Bt.IFCEARTHWORKSCUT])),ot(this,"scene",null),ot(this,"isolatedMeshes",null),ot(this,"onElementLoaded",(()=>{})),ot(this,"onGeometryLoaded",(()=>{})),ot(this,"onLocalTransformLoaded",(()=>{})),ot(this,"onNextIdFound",(()=>{})),ot(this,"onCoordinatesLoaded",(()=>{})),ot(this,"onAlignmentsLoaded",(()=>{})),ot(this,"onGridsLoaded",(()=>{})),this._serializer=t}async load(t){var e,s,i;null==(e=t.progressCallback)||e.call(t,0,{process:"conversion",state:"start"}),this._previousGeometriesIDs.clear(),this._ifcAPI=new Bt.IfcAPI,this._ifcAPI.SetWasmPath(this.wasm.path,this.wasm.absolute),await this._ifcAPI.Init();let r=0;if(t.readFromCallback&&t.readCallback)r=this._ifcAPI.OpenModelFromCallback(t.readCallback,this.webIfcSettings);else{if(!t.bytes)throw new Error("Fragments: No data provided");r=await this._ifcAPI.OpenModel(t.bytes,this.webIfcSettings)}this._ifcAPI.SetLogLevel(Bt.LogLevel.LOG_LEVEL_OFF),this._nextId=this._ifcAPI.GetMaxExpressID(r)+1,this.onLocalTransformLoaded({id:0,data:[0,0,0,1,0,0,0,1,0]});const n=new ft.Vector3;let o=0;const a=t=>{if(null===this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");if(!this._coordinatesInitialized){const t=this._ifcAPI.GetCoordinationMatrix(r);this._tempMatrix1.fromArray(t);const e=this.decompose(this._tempMatrix1);this.onCoordinatesLoaded(e),this._coordinatesInitialized=!0}const e=this._ifcAPI.GetLine(0,t.expressID),s={id:t.expressID,type:e.type,guid:e.GlobalId.value,geometries:[]},i=t.geometries.size(),a=t.geometries.get(0).flatTransformation,{transformWithoutScale:l}=this.removeScale(a),c=this._serializer.distanceThreshold;if(null!==c&&(n.set(0,0,0),n.applyMatrix4(l),n.x>c||n.y>c||n.z>c))return void console.log(`Fragments: Object ${s.id} is more than ${c} meters away from the origin and will be skipped.`);for(let e=0;e<i;e++)s.type===Bt.IFCREINFORCINGBAR?this.loadCircleExtrusionGeometry(r,s,t,e,l.elements):this.loadShellGeometry(r,s,t,e,l.elements,o);const{dxx:h,dxy:d,dxz:u,dyx:f,dyy:p,dyz:I,px:m,py:E,pz:_}=this.decompose(l);s.geometries.length>0&&this.onElementLoaded({element:s,position:[m,E,_],xDirection:[h,d,u],yDirection:[f,p,I]})};if(null==(s=this.isolatedMeshes)?void 0:s.size)this._ifcAPI.StreamMeshes(r,Array.from(this.isolatedMeshes),a);else{const e=this._ifcAPI.GetAllTypesOfModel(r).map((t=>t.typeID)).filter((t=>this._serializer.classes.elements.has(t)));e.includes(Bt.IFCANNOTATION)&&(e.splice(e.indexOf(Bt.IFCANNOTATION),1),e.push(Bt.IFCANNOTATION));const s=.5/e.length;for(const[n,l]of e.entries()){o=l;const c=0===n?"start":n+1===e.length?"finish":"inProgress",h=this._ifcAPI.GetLineIDsWithType(r,l),d=[];for(let t=0;t<h.size();t++)d.push(h.get(t));d.length>0&&(this._ifcAPI.StreamMeshes(r,d,a),null==(i=t.progressCallback)||i.call(t,s*(n+1),{process:"geometries",state:c,class:Gt[l],entitiesProcessed:d.length}))}}const l=this._civilReader.read(this._ifcAPI);this.onAlignmentsLoaded(l);const c=this._gridReader.read(this._ifcAPI);this.onGridsLoaded(c),this.onNextIdFound(this._nextId),this._ifcAPI.Dispose(),this._ifcAPI=null,this._ifcAPI=new Bt.IfcAPI,this._ifcAPI.SetWasmPath(this.wasm.path,this.wasm.absolute),await this._ifcAPI.Init(),this._previousGeometries.clear(),this._previousGeometriesIDs.clear(),this._previousGeometriesScales.clear(),this._nextId=0,this._previousLocalTransforms.clear(),this._problematicGeometries.clear(),this._problematicGeometriesHashes.clear()}loadCircleExtrusionGeometry(t,e,s,i,r){if(null===this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");const n=s.geometries.get(i),o=n.flatTransformation,{units:a}=this.removeScale(o),{x:l,y:c,z:h,w:d}=n.color,u={id:n.geometryExpressID,color:[l,c,h,d],localTransformID:null};e.geometries.push(u);const{transformWithoutScale:f}=this.removeScale(n.flatTransformation);if(this._previousGeometriesIDs.has(u.id))return this.getLocalTransform(r,f,u),void(u.id=this._previousGeometriesIDs.get(u.id));this.getLocalTransform(r,f,u);const p=this._ifcAPI.GetGeometry(t,u.id),I=p.GetSweptDiskSolid(),m=[],E=[],_=I.axis.size();for(let t=0;t<_;t++){const e=I.axis.get(t),s=[];for(let t=0;t<e.arcSegments.size();t++)s.push(e.arcSegments.get(t));m.push(s);const i=[];for(let t=0;t<e.points.size();t++){const s=e.points.get(t);i.push({x:s.x*a.x,y:s.y*a.y,z:s.z*a.z})}E.push(i)}const g=[],C=[],T=[],b=[];for(let t=0;t<E.length;t++){const e=E[t],s=m[t],i=e.length;for(let t=0;t<i-1;t++){let i=-1,r=-1;for(let e=0;e<s.length;e+=2)if(s[e]===t){i=t,r=s[e+1];break}if(-1===i){const s=[],i=e[t],r=e[t+1],n=i.x,o=i.y,a=i.z,l=r.x,c=r.y,h=r.z;g.push(T.length),s.push(n,o,a,l,c,h),T.push(s),C.push(br.WIRE)}else{const s=[],n=i,o=Math.round((i+r)/2),a=r,l=e[n],c=e[o],h=e[a],d=this.computeCircleCurveProperties(l,c,h),u=l.x-d.center.x,f=l.y-d.center.y,p=l.z-d.center.z;let I=Math.sqrt(u*u+f*f+p*p);0===I&&(I=1);const m=u/I,E=f/I,_=p/I,T=c.x-d.center.x,R=c.y-d.center.y,A=c.z-d.center.z;let y=Math.sqrt(T*T+R*R+A*A);0===y&&(y=1);const S=T/y,F=R/y,w=A/y;let L=this.crossProduct({x:m,y:E,z:_},{x:S,y:F,z:w});I=Math.sqrt(L.x*L.x+L.y*L.y+L.z*L.z),0===I&&(I=1),L={x:L.x/I,y:L.y/I,z:L.z/I},g.push(b.length),s.push(d.center.x,d.center.y,d.center.z,d.radius,d.angle,m,E,_,L.x,L.y,L.z),b.push(s),C.push(br.CIRCLE_CURVE),t=a-1}}}const R=this.getGeometryBuffers(t,n);if(null===R)return console.log(`Fragments: Zero length geometry: ${u.id}`),e.geometries.pop(),void this._problematicGeometries.add(u.id);const{position:A}=R;for(let t=0;t<A.length-2;t+=3)A[t]*=a.x,A[t+1]*=a.y,A[t+2]*=a.z;const y=An.getAABB(A),S=I.profileRadius*a.x;this._previousGeometriesIDs.set(u.id,u.id),this.onGeometryLoaded({id:u.id,geometry:{type:Gr.CIRCLE_EXTRUSION,indicesArray:g,typesArray:C,segments:T,circleCurveData:b,radius:S,bbox:y}}),p.delete()}loadShellGeometry(t,e,s,i,r,n){if(null===this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");const o=s.geometries.get(i),a=o.flatTransformation,{units:l}=this.removeScale(a);if(this._problematicGeometries.has(o.geometryExpressID))return void console.log(`Fragments: Problematic geometry: ${o.geometryExpressID}`);const{x:c,y:h,z:d}=o.color;let u=o.color.w;this._serializer.geometryProcessSettings.forceTransparentSpaces&&n===Bt.IFCSPACE&&1===u&&(u=.5);const f={id:o.geometryExpressID,color:[c,h,d,u],localTransformID:null};e.geometries.push(f);const{transformWithoutScale:p}=this.removeScale(o.flatTransformation);if(this._previousGeometriesIDs.has(f.id)){const t=this.getScaleHash(l);if(this._previousGeometriesScales.get(f.id)===t)return this.getLocalTransform(r,p,f),void(f.id=this._previousGeometriesIDs.get(f.id));const e=this._nextId++;this._previousGeometriesScales.set(e,t),f.id=e}const I=this.getGeometryBuffers(t,o);if(null===I)return console.log(`Fragments: Zero length geometry: ${f.id}`),e.geometries.pop(),void this._problematicGeometries.add(f.id);const{position:m,normals:E,index:_}=I;for(let t=0;t<m.length-2;t+=3)m[t]*=l.x,m[t+1]*=l.y,m[t+2]*=l.z;const g=m.length/3,C=_.length/3;let T=0,b=0;const R=new ft.Triangle,A=new ft.Vector3,y=new ft.Vector3,S=new ft.Vector3,F=this.getVolume(_,m),w=new ft.Vector3;for(let t=0;t<_.length-2;t+=3){const e=_[t],s=_[t+1],i=_[t+2];A.set(m[3*e],m[3*e+1],m[3*e+2]),y.set(m[3*s],m[3*s+1],m[3*s+2]),S.set(m[3*i],m[3*i+1],m[3*i+2]),w.add(A),w.add(y),w.add(S),R.set(A,y,S);const r=R.getArea();r>T&&(T=r),b+=r}w.divideScalar(_.length),A.set(m[0],m[1],m[2]),y.set(m[3],m[4],m[5]),S.set(m[6],m[7],m[8]);const L=1e4,O=An.round(b,L),x=An.round(T,L),N=An.round(F,L),v=An.round(A.x,L),P=An.round(A.y,L),M=An.round(A.z,L),D=`${g}-${C}-${O}-${x}-${N}-${An.round(w.x,L)}-${An.round(w.x,L)}-${An.round(w.x,L)}-${v}-${P}-${M}`;if(this._problematicGeometriesHashes.has(D))return console.log(`Fragments: Problematic geometry: ${f.id}`),e.geometries.pop(),this._problematicGeometries.add(f.id),void this._problematicGeometriesHashes.add(D);const U=!this._previousGeometries.has(D),V=f.id;if(U)this._previousGeometries.set(D,V),this._previousGeometriesIDs.set(V,V);else{const t=this._previousGeometries.get(D);if(void 0===t)throw new Error("Fragments: Previous geometry not found");this._previousGeometriesIDs.set(V,t),f.id=t}this.getLocalTransform(r,p,f);const B=this._rawCategories.has(e.type);if(U)try{const t=An.getShellData({position:m,normals:E,index:_,raw:B,settings:this._serializer.geometryProcessSettings,category:n});this.onGeometryLoaded({id:f.id,geometry:t})}catch(t){console.log(`Fragments: Problematic geometry: ${f.id}`),e.geometries.pop(),this._problematicGeometries.add(f.id),this._problematicGeometriesHashes.add(D)}}getScaleHash(t){return`${t.x}-${t.y}-${t.z}`}getLocalTransform(t,e,s){this._tempObject1.position.set(0,0,0),this._tempObject1.rotation.set(0,0,0),this._tempObject1.scale.set(1,1,1),this._tempObject1.updateMatrix(),this._tempMatrix1.fromArray(t),this._tempObject1.applyMatrix4(this._tempMatrix1),this._tempObject2.position.set(0,0,0),this._tempObject2.rotation.set(0,0,0),this._tempObject2.scale.set(1,1,1),this._tempObject2.updateMatrix(),this._tempObject2.applyMatrix4(e),this._tempObject1.attach(this._tempObject2);const{px:i,py:r,pz:n,dxx:o,dxy:a,dxz:l,dyx:c,dyy:h,dyz:d}=this.decompose(this._tempObject2.matrix);this._tempObject2.removeFromParent();if(!(0===i&&0===r&&0===n&&1===o&&0===a&&0===l&&0===c&&1===h&&0===d)){const t=`${i}-${r}-${n}-${o}-${a}-${l}-${c}-${h}-${d}`,e=this._previousLocalTransforms.get(t);if(e)s.localTransformID=e.id;else{const e={id:this._previousLocalTransforms.size+1,data:[i,r,n,o,a,l,c,h,d]};this._previousLocalTransforms.set(t,e),s.localTransformID=e.id,this.onLocalTransformLoaded(e)}}}removeScale(t){const e=(new ft.Matrix4).fromArray(t),s=new ft.Vector3,i=new ft.Quaternion,r=new ft.Vector3;e.decompose(s,i,r);const n=r,o=new ft.Matrix4;return o.compose(s,i,new ft.Vector3(1,1,1)),{units:n,transformWithoutScale:o}}decompose(t){const e=1e3,s=1e5;return{dxx:An.round(t.elements[0],e),dxy:An.round(t.elements[1],e),dxz:An.round(t.elements[2],e),dyx:An.round(t.elements[4],s),dyy:An.round(t.elements[5],s),dyz:An.round(t.elements[6],s),dzx:An.round(t.elements[8],s),dzy:An.round(t.elements[9],s),dzz:An.round(t.elements[10],s),px:An.round(t.elements[12],s),py:An.round(t.elements[13],s),pz:An.round(t.elements[14],s)}}getVolume(t,e){let s=0;const i=new ft.Vector3,r=new ft.Vector3,n=new ft.Vector3;for(let o=0;o<t.length-2;o+=3){const a=3*t[o],l=3*t[o+1],c=3*t[o+2];i.set(e[a],e[a+1],e[a+2]),r.set(e[l],e[l+1],e[l+2]),n.set(e[c],e[c+1],e[c+2]),s+=this.getSignedVolumeOfTriangle(i,r,n)}return Math.abs(s)}getSignedVolumeOfTriangle(t,e,s){return 1/6*(-(s.x*e.y*t.z)+e.x*s.y*t.z+s.x*t.y*e.z-t.x*s.y*e.z-e.x*t.y*s.z+t.x*e.y*s.z)}getGeometryBuffers(t,e){if(!this._ifcAPI)throw new Error("Fragments: IfcAPI not initialized");const s=this._ifcAPI.GetGeometry(t,e.geometryExpressID),i=this._ifcAPI.GetIndexArray(s.GetIndexData(),s.GetIndexDataSize()),r=this._ifcAPI.GetVertexArray(s.GetVertexData(),s.GetVertexDataSize());if(0===i.length||0===r.length)return s.delete(),null;const n=new Float32Array(r.length/2),o=new Float32Array(r.length/2);for(let t=0;t<r.length;t+=6)n[t/2]=r[t],n[t/2+1]=r[t+1],n[t/2+2]=r[t+2],o[t/2]=r[t+3],o[t/2+1]=r[t+4],o[t/2+2]=r[t+5];return s.delete(),{position:n,normals:o,index:i}}crossProduct(t,e){return{x:t.y*e.z-t.z*e.y,y:t.z*e.x-t.x*e.z,z:t.x*e.y-t.y*e.x}}computeCircleCurveProperties(t,e,s){function i(t,e){return{x:t.x-e.x,y:t.y-e.y,z:t.z-e.z}}function r(t){return Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z)}const n=i(e,t),o=i(s,e),a=this.crossProduct(n,o),l=function(t,e,s){const i=e.x-t.x,r=e.y-t.y,n=e.z-t.z,o=s.x-t.x,a=s.y-t.y,l=s.z-t.z,c=.5*(i**2+r**2+n**2),h=.5*(o**2+a**2+l**2),d=i*a-r*o,u=r*l-n*a,f=n*o-i*l,p=c*o-h*i,I=c*a-h*r,m=c*l-h*n,E=d**2+u**2+f**2;if(0===E)throw new Error("Fragments: Points are collinear, no unique circle exists.");return{x:t.x+(d*I-f*m)/E,y:t.y+(u*m-d*p)/E,z:t.z+(f*p-u*I)/E}}(t,e,s),c=i(t,l),h=i(s,l),d=r(i(l,t)),u=i(t,l),f=r(u);u.x/=f,u.y/=f,u.z/=f;return{center:l,radius:d,normal:a,initialTangent:u,angle:180*Math.acos((c.x*h.x+c.y*h.y+c.z*h.z)/(r(c)*r(h)))/Math.PI}}}class nu{constructor(t){ot(this,"wasm",{path:"../../../../node_modules/web-ifc/",absolute:!1}),ot(this,"webIfcSettings",{}),ot(this,"_serializer"),this._serializer=t}async process(t){const{builder:e}=t;let s=0;const i=[];let r={dxx:1,dxy:0,dxz:0,dyx:0,dyy:1,dyz:0,px:0,py:0,pz:0};const n=[],o=[],a=[],l=[],c=[],h=new Map,d=new Map,u=new Map,f=new ru(this._serializer);f.wasm=this.wasm,f.webIfcSettings=this.webIfcSettings,f.onGeometryLoaded=t=>{n.push(t)},f.onElementLoaded=t=>{l.push(t)},f.onLocalTransformLoaded=t=>{c.push(t)},f.onCoordinatesLoaded=t=>{r=t},f.onNextIdFound=t=>{s=t},f.onAlignmentsLoaded=t=>{for(const e of t)o.push(e)},f.onGridsLoaded=t=>{for(const e of t)a.push(e)},await f.load(t);const p=[];let I=0;Dr.startGlobalTransformsVector(e,l.length);const m=[],E=new Map,_=[];for(let t=0;t<l.length;t++){const r=l[l.length-1-t];p.push(I++);const{position:n,xDirection:o,yDirection:a}=r,[c,d,u]=n,[f,g,C]=o,[T,b,R]=a;i.push(l[t].element.id);const A=l.length-1-t,y=r.element.type,S=Gt[y];E.has(S)||E.set(S,E.size),m.unshift(s++),Mr.createTransform(e,c,d,u,f,g,C,T,b,R),E.get(S),_.unshift(r.element.id),h.set(r.element.id,A)}const g=e.endVector(),C=[];for(let t=0;t<n.length;t++){const s=n[t];if(s.geometry.type!==Gr.SHELL)continue;const{points:i,profiles:r,holes:o,profilesFaceIds:a}=s.geometry,l=i.length>An.ushortMaxValue,c=l?vr.BIG:vr.NONE;Pr.startPointsVector(e,i.length);for(let t=0;t<i.length;t++){const[s,r,n]=i[i.length-1-t];Er.createFloatVector(e,s,r,n)}const h=e.endVector(),d=[],u=[],f=[],p=[];for(const[,t]of r){if(l){const s=Ar.createIndicesVector(e,t),i=Ar.createBigShellProfile(e,s);f.push(i);continue}const s=Nr.createIndicesVector(e,t),i=Nr.createShellProfile(e,s);d.push(i)}const I=Pr.createBigProfilesVector(e,f),m=Pr.createProfilesVector(e,d);for(const[t,s]of o)if(l)for(const i of s){const s=Rr.createIndicesVector(e,i),r=Rr.createBigShellHole(e,s,t);p.push(r)}else for(const i of s){const s=xr.createIndicesVector(e,i),r=xr.createShellHole(e,s,t);u.push(r)}const E=Pr.createBigHolesVector(e,p),_=Pr.createHolesVector(e,u),g=Pr.createProfilesFaceIdsVector(e,a),T=Pr.createShell(e,m,_,h,I,E,c,g);C.push(T)}const T=Dr.createShellsVector(e,C),b=[];for(let t=0;t<n.length;t++){const s=n[t];if(s.geometry.type!==Gr.CIRCLE_EXTRUSION)continue;const i=[],{radius:r,indicesArray:o,typesArray:a,segments:l,circleCurveData:c}=s.geometry;Tr.startCircleCurvesVector(e,c.length);for(let t=0;t<c.length;t++){const[s,i,r,n,o,a,l,h,d,u,f]=c[t];_r.createCircleCurve(e,o/360*2*Math.PI,s,i,r,n,d,u,f,a,l,h)}const h=e.endVector();Tr.startWiresVector(e,l.length);for(let t=0;t<l.length;t++){const[s,i,r,n,o,a]=l[t];gr.createWire(e,s,i,r,n,o,a)}const d=e.endVector(),u=Tr.createOrderVector(e,o),f=Tr.createPartsVector(e,a);Tr.startWireSetsVector(e,0);const p=e.endVector();Tr.startAxis(e),Tr.addCircleCurves(e,h),Tr.addOrder(e,u),Tr.addWires(e,d),Tr.addWireSets(e,p),Tr.addParts(e,f);const I=Tr.endAxis(e);i.push(I);const m=Sr.createAxesVector(e,i),E=Sr.createRadiusVector(e,[r]);Sr.startCircleExtrusion(e),Sr.addAxes(e,m),Sr.addRadius(e,E);const _=Sr.endCircleExtrusion(e);b.push(_)}const R=Dr.createCircleExtrusionsVector(e,b),A=[];Dr.startRepresentationsVector(e,n.length);const y=new Map;for(let t=0;t<n.length;t++){const e=n.length-1-t,s=n[e].geometry.type;let i=y.get(s);void 0===i&&(i=-1),y.set(s,i+1)}const S=new ft.Vector3,F=new ft.Vector3;for(let t=0;t<n.length;t++){const i=n.length-1-t,r=n[i],{bbox:o}=r.geometry;d.set(r.id,i);const a=r.geometry.type,l=y.get(a);if(void 0===l)throw new Error("Fragments: Malformed geometry definition");y.set(a,l-1),S.set(o.min.x,o.min.y,o.min.z),F.set(o.max.x,o.max.y,o.max.z);S.distanceTo(F)>999999&&(console.log(`Infinity bounding box: ${r.id}`),o.min.x=0,o.min.y=0,o.min.z=0,o.max.x=.1,o.max.y=.1,o.max.z=.1),A.unshift(s++),Lr.createRepresentation(e,l,o.min.x,o.min.y,o.min.z,o.max.x,o.max.y,o.max.z,r.geometry.type)}const w=e.endVector();let L=0;for(const t of l)for(const e of t.element.geometries){const t=e.color.toString();if(!u.has(t)){const s=e.color.map((t=>255*t));u.set(t,{id:L++,color:s})}}Dr.startMaterialsVector(e,u.size);const O=[],x=Array.from(u.keys());for(let t=0;t<x.length;t++){const i=x[x.length-1-t],{color:r}=u.get(i),[n,o,a,l]=r;O.push(s++),wr.createMaterial(e,n,o,a,l,zr.ONE,0)}const N=e.endVector();let v=0;for(const t of l)v+=t.element.geometries.length;Dr.startSamplesVector(e,v);const P=[];for(let t=0;t<l.length;t++){const i=l[l.length-1-t],r=h.get(i.element.id),n=i.element.geometries;for(let t=0;t<n.length;t++){const i=n[n.length-t-1],o=d.get(i.id),a=u.get(i.color.toString()).id,l=i.localTransformID||0;P.push(s++),Or.createSample(e,r,a,o,l)}}const M=e.endVector();Dr.startLocalTransformsVector(e,c.length);const D=[];for(let t=0;t<c.length;t++){const i=c[c.length-1-t],[r,n,o,a,l,h,d,u,f]=i.data;D.push(s++),Mr.createTransform(e,r,n,o,a,l,h,d,u,f)}const U=e.endVector(),V=Dr.createMeshesItemsVector(e,p),B=Dr.createRepresentationIdsVector(e,A),z=Dr.createSampleIdsVector(e,P),G=Dr.createMaterialIdsVector(e,O),H=Dr.createLocalTransformIdsVector(e,D),k=Dr.createGlobalTransformIdsVector(e,m),Y=Mr.createTransform(e,r.px,r.py,r.pz,r.dxx,r.dxy,r.dxz,r.dyx,r.dyy,r.dyz);Dr.startMeshes(e),Dr.addCoordinates(e,Y),Dr.addGlobalTransforms(e,g),Dr.addShells(e,T),Dr.addRepresentations(e,w),Dr.addSamples(e,M),Dr.addLocalTransforms(e,U),Dr.addMaterials(e,N),Dr.addCircleExtrusions(e,R),Dr.addMeshesItems(e,V),Dr.addRepresentationIds(e,B),Dr.addSampleIds(e,z),Dr.addMaterialIds(e,G),Dr.addLocalTransformIds(e,H),Dr.addGlobalTransformIds(e,k);return{modelMesh:Dr.endMeshes(e),localIDs:i,maxLocalID:s,alignments:o,grids:a}}}const ou={base:new Set([Bt.IFCPROJECT,Bt.IFCSITE,Bt.IFCBUILDING,Bt.IFCBUILDINGSTOREY]),units:new Set([Bt.IFCUNITASSIGNMENT,Bt.IFCSIUNIT,Bt.IFCNAMEDUNIT,Bt.IFCDERIVEDUNIT,Bt.IFCMONETARYUNIT]),materials:new Set([Bt.IFCMATERIAL,Bt.IFCMATERIALLIST,Bt.IFCMATERIALCONSTITUENT,Bt.IFCMATERIALCONSTITUENTSET,Bt.IFCMATERIALLAYER,Bt.IFCMATERIALLAYERSET,Bt.IFCMATERIALLAYERSETUSAGE,Bt.IFCMATERIALPROFILE,Bt.IFCMATERIALPROFILESET,Bt.IFCMATERIALPROFILESETUSAGE]),properties:new Set([Bt.IFCPROPERTYSET,Bt.IFCPROPERTYSINGLEVALUE,Bt.IFCELEMENTQUANTITY,Bt.IFCQUANTITYAREA,Bt.IFCQUANTITYCOUNT,Bt.IFCQUANTITYLENGTH,Bt.IFCQUANTITYNUMBER,Bt.IFCQUANTITYTIME,Bt.IFCQUANTITYVOLUME,Bt.IFCQUANTITYWEIGHT]),types:new Set([Bt.IFCBEAMTYPE,Bt.IFCBEARINGTYPE,Bt.IFCBUILDINGELEMENTPROXYTYPE,Bt.IFCCHIMNEYTYPE,Bt.IFCCOLUMNTYPE,Bt.IFCCOURSETYPE,Bt.IFCCOVERINGTYPE,Bt.IFCCURTAINWALLTYPE,Bt.IFCDEEPFOUNDATIONTYPE,Bt.IFCDOORTYPE,Bt.IFCFOOTINGTYPE,Bt.IFCKERBTYPE,Bt.IFCMEMBERTYPE,Bt.IFCMOORINGDEVICETYPE,Bt.IFCNAVIGATIONELEMENTTYPE,Bt.IFCPAVEMENTTYPE,Bt.IFCPLATETYPE,Bt.IFCRAILTYPE,Bt.IFCRAILINGTYPE,Bt.IFCRAMPFLIGHTTYPE,Bt.IFCRAMPTYPE,Bt.IFCROOFTYPE,Bt.IFCSHADINGDEVICETYPE,Bt.IFCSLABTYPE,Bt.IFCSTAIRFLIGHTTYPE,Bt.IFCSTAIRTYPE,Bt.IFCTRACKELEMENTTYPE,Bt.IFCWALLTYPE,Bt.IFCWINDOWTYPE]),elements:new Set([Bt.IFCPROJECT,Bt.IFCSITE,Bt.IFCBUILDING,Bt.IFCBUILDINGSTOREY,Bt.IFCSPACE,Bt.IFCANNOTATION,Bt.IFCCONTROLLER,Bt.IFCBOILER,Bt.IFCLAMP,Bt.IFCPUMP,Bt.IFCAIRTERMINALBOX,Bt.IFCFLOWINSTRUMENT,Bt.IFCFURNISHINGELEMENT,Bt.IFCELECTRICGENERATOR,Bt.IFCAUDIOVISUALAPPLIANCE,Bt.IFCPIPEFITTING,Bt.IFCSTAIR,Bt.IFCDUCTFITTING,Bt.IFCMECHANICALFASTENER,Bt.IFCDOOR,Bt.IFCELECTRICMOTOR,Bt.IFCSYSTEMFURNITUREELEMENT,Bt.IFCEVAPORATOR,Bt.IFCWINDOWSTANDARDCASE,Bt.IFCLIGHTFIXTURE,Bt.IFCUNITARYCONTROLELEMENT,Bt.IFCCABLECARRIERFITTING,Bt.IFCCOIL,Bt.IFCFASTENER,Bt.IFCFLOWSTORAGEDEVICE,Bt.IFCPROTECTIVEDEVICE,Bt.IFCBEAM,Bt.IFCTANK,Bt.IFCFILTER,Bt.IFCCOLUMN,Bt.IFCELECTRICDISTRIBUTIONBOARD,Bt.IFCFOOTING,Bt.IFCCOLUMNSTANDARDCASE,Bt.IFCVOIDINGFEATURE,Bt.IFCREINFORCINGBAR,Bt.IFCFLOWSEGMENT,Bt.IFCELECTRICTIMECONTROL,Bt.IFCCABLEFITTING,Bt.IFCDISTRIBUTIONCHAMBERELEMENT,Bt.IFCDISTRIBUTIONCONTROLELEMENT,Bt.IFCMEMBER,Bt.IFCBUILDINGELEMENTPROXY,Bt.IFCPLATESTANDARDCASE,Bt.IFCSWITCHINGDEVICE,Bt.IFCSHADINGDEVICE,Bt.IFCDISCRETEACCESSORY,Bt.IFCDUCTSILENCER,Bt.IFCSTACKTERMINAL,Bt.IFCFIRESUPPRESSIONTERMINAL,Bt.IFCMEDICALDEVICE,Bt.IFCFURNITURE,Bt.IFCSLAB,Bt.IFCTRANSPORTELEMENT,Bt.IFCAIRTERMINAL,Bt.IFCENERGYCONVERSIONDEVICE,Bt.IFCCIVILELEMENT,Bt.IFCPILE,Bt.IFCELECTRICAPPLIANCE,Bt.IFCMEMBERSTANDARDCASE,Bt.IFCDISTRIBUTIONELEMENT,Bt.IFCCOVERING,Bt.IFCSPACEHEATER,Bt.IFCROOF,Bt.IFCAIRTOAIRHEATRECOVERY,Bt.IFCFLOWCONTROLLER,Bt.IFCHUMIDIFIER,Bt.IFCJUNCTIONBOX,Bt.IFCFLOWMETER,Bt.IFCFLOWTERMINAL,Bt.IFCRAILING,Bt.IFCCONDENSER,Bt.IFCPROTECTIVEDEVICETRIPPINGUNIT,Bt.IFCREINFORCINGMESH,Bt.IFCTENDONANCHOR,Bt.IFCVIBRATIONISOLATOR,Bt.IFCWALL,Bt.IFCMOTORCONNECTION,Bt.IFCVIRTUALELEMENT,Bt.IFCENGINE,Bt.IFCBEAMSTANDARDCASE,Bt.IFCBURNER,Bt.IFCBUILDINGELEMENTPART,Bt.IFCRAMP,Bt.IFCTUBEBUNDLE,Bt.IFCSLABSTANDARDCASE,Bt.IFCDISTRIBUTIONFLOWELEMENT,Bt.IFCSANITARYTERMINAL,Bt.IFCOPENINGSTANDARDCASE,Bt.IFCALARM,Bt.IFCSURFACEFEATURE,Bt.IFCSLABELEMENTEDCASE,Bt.IFCFLOWMOVINGDEVICE,Bt.IFCPLATE,Bt.IFCCOMMUNICATIONSAPPLIANCE,Bt.IFCDOORSTANDARDCASE,Bt.IFCRAMPFLIGHT,Bt.IFCCHIMNEY,Bt.IFCWINDOW,Bt.IFCELECTRICFLOWSTORAGEDEVICE,Bt.IFCHEATEXCHANGER,Bt.IFCFAN,Bt.IFCSOLARDEVICE,Bt.IFCGEOGRAPHICELEMENT,Bt.IFCCURTAINWALL,Bt.IFCFLOWTREATMENTDEVICE,Bt.IFCWALLSTANDARDCASE,Bt.IFCDUCTSEGMENT,Bt.IFCCOMPRESSOR,Bt.IFCPIPESEGMENT,Bt.IFCCOOLINGTOWER,Bt.IFCPROJECTIONELEMENT,Bt.IFCOUTLET,Bt.IFCEVAPORATIVECOOLER,Bt.IFCCABLECARRIERSEGMENT,Bt.IFCTENDON,Bt.IFCTRANSFORMER,Bt.IFCCHILLER,Bt.IFCDAMPER,Bt.IFCSENSOR,Bt.IFCELEMENTASSEMBLY,Bt.IFCCOOLEDBEAM,Bt.IFCWALLELEMENTEDCASE,Bt.IFCINTERCEPTOR,Bt.IFCVALVE,Bt.IFCCABLESEGMENT,Bt.IFCWASTETERMINAL,Bt.IFCSTAIRFLIGHT,Bt.IFCFLOWFITTING,Bt.IFCACTUATOR,Bt.IFCUNITARYEQUIPMENT,Bt.IFCGRID,Bt.IFCBUILTELEMENT,Bt.IFCCOURSE,Bt.IFCEARTHWORKSCUT,Bt.IFCEARTHWORKSFILL,Bt.IFCTRACKELEMENT,Bt.IFCRAIL,Bt.IFCSIGN,Bt.IFCPAVEMENT,Bt.IFCROAD,Bt.IFCBRIDGEPART])};class au{constructor(){ot(this,"_builder",null),ot(this,"wasm",{path:"/node_modules/web-ifc/",absolute:!1}),ot(this,"webIfcSettings",{COORDINATE_TO_ORIGIN:!0}),ot(this,"attributesToExclude",new Set(["Representation","ObjectPlacement","CompositionType","OwnerHistory"])),ot(this,"geometryProcessSettings",{threshold:3e3,precision:1e6,normalPrecision:1e7,planePrecision:1e3,faceThreshold:.6,forceTransparentSpaces:!0}),ot(this,"relations",new Map([[Bt.IFCRELDEFINESBYPROPERTIES,{forRelating:"DefinesOcurrence",forRelated:"IsDefinedBy"}],[Bt.IFCRELASSOCIATESMATERIAL,{forRelated:"HasAssociations",forRelating:"AssociatedTo"}],[Bt.IFCRELAGGREGATES,{forRelated:"Decomposes",forRelating:"IsDecomposedBy"}],[Bt.IFCRELCONTAINEDINSPATIALSTRUCTURE,{forRelated:"ContainedInStructure",forRelating:"ContainsElements"}]])),ot(this,"classes",{elements:new Wt([...ou.elements]),abstract:new Wt([...ou.base,...ou.materials,...ou.properties,...ou.units])}),ot(this,"includeUniqueAttributes",!1),ot(this,"includeRelationNames",!1),ot(this,"replaceStoreyElevation",!0),ot(this,"replaceSiteElevation",!0),ot(this,"distanceThreshold",1e5)}get builder(){if(!this._builder)throw new Error("Fragments: Builder not initialized");return this._builder}async process(t){var e;this._builder=new Jt(1024);const s=new nu(this);s.wasm=this.wasm,s.webIfcSettings=this.webIfcSettings;const i={...t,builder:this.builder},r=await s.process(i),{modelMesh:n,maxLocalID:o,localIDs:a,alignments:l,grids:c}=r,h=new eu(this,this.builder);h.wasm=this.wasm,h.webIfcSettings=this.webIfcSettings;const d={...t,geometryProcessedLocalIDs:a,alignments:l,grids:c,maxLocalID:o},u=await h.process(d),{relIndicesVector:f,relsVector:p,guidsVector:I,guidsItemsVector:m,metadataOffset:E,localIdsVector:_,spatialStrutureOffset:g,attributesVector:C,categoriesVector:T,uniqueAttributesVector:b,relNamesVector:R,newMaxLocalID:A}=u,y=t.id??pt.generateUUID(),S=this.builder.createString(y);Br.startModel(this.builder),Br.addMeshes(this.builder,n),Br.addMetadata(this.builder,E),Br.addAttributes(this.builder,C),Br.addUniqueAttributes(this.builder,b),Br.addRelationNames(this.builder,R),Br.addLocalIds(this.builder,_),Br.addCategories(this.builder,T),Br.addRelationsItems(this.builder,f),Br.addRelations(this.builder,p),Br.addGuidsItems(this.builder,m),Br.addGuids(this.builder,I),Br.addSpatialStructure(this.builder,g),Br.addGuid(this.builder,S),Br.addMaxLocalId(this.builder,A);const F=Br.endModel(this.builder);this.builder.finish(F);const w=this.builder.asUint8Array();this.clean();const L=t.raw?w:Ir.deflate(w);return null==(e=t.progressCallback)||e.call(t,1,{process:"conversion",state:"finish"}),L}addAllAttributes(){for(const t in Gt){const e=parseInt(t,10);Fn.has(e)||this.classes.abstract.add(e)}}addAllRelations(){this.relations=new Map(wn)}clean(){var t;null==(t=this._builder)||t.clear(),this._builder=null}}class lu{constructor(t){ot(this,"core"),this.core=t.CreateExtrusion()}get(t,e){const s=e.profilePoints??[0,0,0,1,0,0,1,1,0,0,1,0],i=e.profileHoles??[],r=e.direction??[0,0,1],n=e.cuttingPlaneNormal??[0,0,0],o=e.cuttingPlanePosition??[0,0,0],a=e.length??1,l=e.cap??!0,c=new t.wasmModule.DoubleVector;for(const t of s)c.push_back(t);for(const e of i){const s=new t.wasmModule.DoubleVector;for(const t of e)s.push_back(t);this.core.SetHoles(s)}const h=new t.wasmModule.DoubleVector;for(const t of r)h.push_back(t);const d=new t.wasmModule.DoubleVector;for(const t of n)d.push_back(t);const u=new t.wasmModule.DoubleVector;for(const t of o)u.push_back(t);this.core.SetValues(c,h,a,d,u,l);const f=this.core.GetBuffers();return this.core.ClearHoles(),f}}var cu=(t=>(t[t.H=0]="H",t[t.C=1]="C",t[t.Z=2]="Z",t[t.T=3]="T",t[t.L=4]="L",t))(cu||{});class hu{constructor(t){ot(this,"core"),this.core=t.CreateProfile()}get(t,e){const s=e.type??0,i=e.width??.2,r=e.depth??.2,n=e.thickness??.002,o=e.flangeThickness??.002,a=e.hasFillet??!1,l=e.filletRadius??.001,c=e.radius??.01,h=e.slope??.001,d=e.circleSegments??20,u=new t.wasmModule.DoubleVector,f=e.placement??(new ft.Matrix4).identity();for(const t of f.elements)u.push_back(t);const p=this.core;return p.SetValues(s,i,r,n,o,a,l,c,h,d,u),p.GetBuffers()}}ot(hu,"map",new Map([["H",0],["C",1],["Z",2],["T",3],["L",4]]));class du{constructor(t){ot(this,"core"),this.core=t.CreateBooleanOperator()}get(t,e){const s=e.target.geometry,i=[],r=s.attributes.position.array,n=s.index.array,o=new ft.Vector3;for(let t=0;t<n.length-2;t+=3){const s=n[t],a=n[t+1],l=n[t+2];o.set(r[3*s],r[3*s+1],r[3*s+2]),o.applyMatrix4(e.target.matrixWorld),i.push(o.x),i.push(o.y),i.push(o.z),o.set(r[3*a],r[3*a+1],r[3*a+2]),o.applyMatrix4(e.target.matrixWorld),i.push(o.x),i.push(o.y),i.push(o.z),o.set(r[3*l],r[3*l+1],r[3*l+2]),o.applyMatrix4(e.target.matrixWorld),i.push(o.x),i.push(o.y),i.push(o.z)}const a=[];for(const t of e.operands){const e=[],s=t.geometry.index.array,i=t.geometry.attributes.position.array;for(let r=0;r<s.length-2;r+=3){const s=n[r],a=n[r+1],l=n[r+2];o.set(i[3*s],i[3*s+1],i[3*s+2]),o.applyMatrix4(t.matrixWorld),e.push(o.x),e.push(o.y),e.push(o.z),o.set(i[3*a],i[3*a+1],i[3*a+2]),o.applyMatrix4(t.matrixWorld),e.push(o.x),e.push(o.y),e.push(o.z),o.set(i[3*l],i[3*l+1],i[3*l+2]),o.applyMatrix4(t.matrixWorld),e.push(o.x),e.push(o.y),e.push(o.z)}a.push(e)}this.core.clear();const l=new t.wasmModule.DoubleVector;for(const t of i)l.push_back(t);this.core.SetValues(l,e.type);for(const e of a){const s=new t.wasmModule.DoubleVector;for(const t of e)s.push_back(t);this.core.SetSecond(s)}return this.core.GetBuffers()}}class uu{constructor(t){ot(this,"core"),this.core=t.CreateArc()}get(t,e){const s=e.placement??new ft.Matrix3,i=new t.wasmModule.DoubleVector;s.elements.forEach((t=>{i.push_back(t)}));const r=e.radiusX??1,n=e.radiusY??1,o=e.numSegments??12,a=e.start??0,l=e.end??Math.PI,c=e.swap??!1,h=e.endingNormalToCenter??!1;return this.core.SetValues(r,n,o,i,a,l,c,h),this.core.GetBuffers()}}class fu{constructor(t){ot(this,"core"),this.core=t.CreateAABB()}get(t){const e=t.min??new ft.Vector3(0,0,0),s=t.max??new ft.Vector3(1,1,1),{x:i,y:r,z:n}=e,{x:o,y:a,z:l}=s;return this.core.SetValues(i,r,n,o,a,l),this.core.GetBuffers()}}class pu{constructor(t){ot(this,"core"),this.core=t.CreateCircularSweep()}get(t,e){const s=new t.wasmModule.DoubleVector,i=e.profilePoints??[];for(const t of i)s.push_back(t);const r=new t.wasmModule.DoubleVector,n=e.directrix??[];for(const t of n)r.push_back(t);const o=new t.wasmModule.DoubleVector,a=e.initNormal??[0,0,0];for(const t of a)o.push_back(t);const l=e.scale??1,c=e.closed??!1,h=e.radius??10,d=e.rotate??!1;return this.core.SetValues(l,c,s,h,r,o,d),this.core.GetBuffers()}}class Iu{constructor(t){ot(this,"core"),this.core=t.CreateCylindricalRevolution()}get(t,e){const s=new t.wasmModule.DoubleVector,i=e.transformation??(new ft.Matrix4).identity().elements;for(const t of i)s.push_back(t);const r=e.startAngle??0,n=e.endAngle??180,o=e.minZ??-10,a=e.maxZ??10,l=e.segmentCount??12,c=e.radius??4;return this.core.SetValues(s,r,n,o,a,l,c),this.core.GetBuffers()}}class mu{constructor(t){ot(this,"core"),this.core=t.CreateParabola()}get(t){const e=t.segmentCount??12,[s,i,r]=t.start??[0,0,0],n=t.horizontalLength??10,o=t.startHeight??2,a=t.startGradient??5,l=t.endGradient??0;return this.core.SetValues(e,s,i,r,n,o,a,l),this.core.GetBuffers()}}class Eu{constructor(t){ot(this,"core"),this.core=t.CreateRevolution()}get(t,e){const s=new t.wasmModule.DoubleVector,i=e.profile??[];for(const t of i)s.push_back(t);const r=new t.wasmModule.DoubleVector,n=e.transform??(new ft.Matrix4).identity().elements;for(const t of n)r.push_back(t);const o=e.start??0,a=e.end??180,l=e.segmentCount??12;return this.core.SetValues(s,r,o,a,l),this.core.GetBuffers()}}class _u{constructor(t){ot(this,"core"),this.core=t.CreateSweep()}get(t,e){const s=e.profilePoints??[],i=e.curvePoints??[],r=e.startNormal??[0,0,0],n=e.scale??1,o=e.close??!1,a=e.rotate90??!1,l=e.optimize??!1,c=new t.wasmModule.DoubleVector;for(const t of s)c.push_back(t);const h=new t.wasmModule.DoubleVector;for(const t of i)h.push_back(t);const d=new t.wasmModule.DoubleVector;for(const t of r)d.push_back(t);this.core.SetValues(n,o,c,h,d,a,l);return this.core.GetBuffers()}}class gu{constructor(t){ot(this,"core"),this.core=t.CreateExtrusion()}get(t,e){const s=e.start??[0,0,0],i=e.end??[1,0,0],r=e.elevation??0,n=e.offset??0,o=e.thickness??.1,a=e.direction??[0,1,0],l=e.cuttingPlaneNormal??[0,0,0],c=e.cuttingPlanePosition??[0,0,0],h=e.height??3,[d,,u]=s,[f,,p]=i,I=new ft.Vector3(f,r,p),m=new ft.Vector3(d,r,u),E=new ft.Vector3(f-d,r,p-u),_=new ft.Vector3(0,1,0),g=(new ft.Vector3).crossVectors(E,_).normalize(),C=g.clone().multiplyScalar(n);I.add(C),m.add(C);const T=g.clone().multiplyScalar(o/2),b=[m.clone().add(T),I.clone().add(T),I.clone().sub(T),m.clone().sub(T)];b.push(b[0]);const R=new t.wasmModule.DoubleVector;for(const t of b)R.push_back(t.x),R.push_back(t.y),R.push_back(t.z);const A=new t.wasmModule.DoubleVector;for(const t of a)A.push_back(t);const y=new t.wasmModule.DoubleVector;for(const t of l)y.push_back(t);const S=new t.wasmModule.DoubleVector;for(const t of c)S.push_back(t);this.core.SetValues(R,A,h,y,S,!0);const F=this.core.GetBuffers();return this.core.ClearHoles(),F}}class Cu{constructor(t){ot(this,"core"),this.core=t.CreateClothoid()}get(t){const e=t.startPoint??[0,0,0],s=t.startDirection??.5,i=t.segments??12,r=t.startRadius??5,n=t.endRadius??0,o=t.segmentLength??5,[a,l,c]=e;return this.core.SetValues(i,a,l,c,s,r,n,o),this.core.GetBuffers()}}class Tu{constructor(t){ot(this,"api"),ot(this,"_arc"),ot(this,"_parabola"),ot(this,"_extrusion"),ot(this,"_profile"),ot(this,"_booleanOperation"),ot(this,"_bbox"),ot(this,"_circularSweep"),ot(this,"_clothoid"),ot(this,"_cylindricalRevolve"),ot(this,"_revolve"),ot(this,"_sweep"),ot(this,"_wall"),this.api=t,this._extrusion=new lu(t),this._profile=new hu(t),this._booleanOperation=new du(t),this._arc=new uu(t),this._bbox=new fu(t),this._clothoid=new Cu(t),this._circularSweep=new pu(t),this._cylindricalRevolve=new Iu(t),this._revolve=new Eu(t),this._parabola=new mu(t),this._sweep=new _u(t),this._wall=new gu(t)}getExtrusion(t,e){const s=this._extrusion.get(this.api,e);this.applyMesh(t,s)}getSweep(t,e){const s=this._sweep.get(this.api,e);this.applyMesh(t,s)}getWall(t,e){const s=this._wall.get(this.api,e);this.applyMesh(t,s)}getProfile(t,e){const s=this._profile.get(this.api,e);this.applyCurve(t,s)}getBooleanOperation(t,e){const s=this._booleanOperation.get(this.api,e);this.applyMesh(t,s)}getBbox(t,e){const s=this._bbox.get(e);this.applyMesh(t,s)}getCircularSweep(t,e){const s=this._circularSweep.get(this.api,e);this.applyMesh(t,s)}getRevolve(t,e){const s=this._revolve.get(this.api,e);this.applyMesh(t,s)}getCylindricalRevolve(t,e){const s=this._cylindricalRevolve.get(this.api,e);this.applyMesh(t,s)}getArc(t,e){const s=this._arc.get(this.api,e);this.applyCurve(t,s)}getParabola(t,e){const s=this._parabola.get(e);this.applyCurve(t,s)}getClothoid(t,e){const s=this._clothoid.get(e);this.applyCurve(t,s)}getProfilePoints(t){const e=this._profile.get(this.api,t),s=e.fvertexData.size(),i=[];for(let t=0;t<s;t++){const s=e.fvertexData.get(t);i.push(s)}return i}transformPoints(t,e){const s=[],i=new ft.Vector3;for(let r=0;r<t.length;r+=3)i.set(t[r],t[r+1],t[r+2]),i.applyMatrix4(e),s.push(i.x,i.y,i.z);return s}applyMesh(t,e){const s=e.fvertexData.size(),i=new Float32Array(s);for(let t=0;t<s;t++)i[t]=e.fvertexData.get(t);t.setAttribute("position",new ft.BufferAttribute(i,3));const r=e.indexData.size(),n=[];for(let t=0;t<r;t++)n[t]=e.indexData.get(t);t.setIndex(n);const o=new Float32Array(s).fill(0);t.setAttribute("normal",new ft.BufferAttribute(o,3)),t.computeVertexNormals()}applyCurve(t,e){const s=e.fvertexData.size(),i=new Float32Array(s);for(let t=0;t<s;t++)i[t]=e.fvertexData.get(t);t.setAttribute("position",new ft.BufferAttribute(i,3));const r=[];for(let t=0;t<s/3-1;t++)r.push(t,t+1);t.setIndex(r)}}export{Dn as ALIGNMENT_CATEGORY,Vn as AlignmentCurveType,uu as Arc,kt as AsyncEvent,mr as Attribute,Tr as Axis,br as AxisPartClass,fu as Bbox,Rr as BigShellHole,Ar as BigShellProfile,du as BooleanOperation,yr as BoundingBox,_r as CircleCurve,Sr as CircleExtrusion,pu as CircularSweep,Cu as Clothoid,Nn as CurrentLod,Iu as CylindricalRevolve,Yt as DataMap,Wt as DataSet,Fr as DoubleVector,kr as EditRequestType,Yr as EditRequestTypeNames,pn as EditUtils,Aa as Editor,ya as Element,Ht as Event,lu as Extrusion,Er as FloatVector,yn as FragmentsIfcUtils,La as FragmentsModel,tu as FragmentsModels,Un as GRID_CATEGORY,Tu as GeometryEngine,An as GeomsFbUtils,au as IfcImporter,Pn as ItemConfigClass,Bn as LodMode,wr as Material,Dr as Meshes,Br as Model,vn as MultiThreadingRequestClass,On as ObjectClass,mu as Parabola,hu as Profile,cu as ProfileType,Ur as Relation,zr as RenderedFaces,Lr as Representation,Gr as RepresentationClass,Eu as Revolve,Or as Sample,Pr as Shell,xr as ShellHole,Nr as ShellProfile,vr as ShellType,Jd as SingleThreadedFragmentsModel,Mn as SnappingClass,Vr as SpatialStructure,Hr as Stroke,_u as Sweep,xn as TileRequestClass,Mr as Transform,gu as Wall,gr as Wire,Cr as WireSet,Fn as geometryTypes,zt as getObject,Gt as ifcCategoryMap,ou as ifcClasses,Sn as ifcGeometriesMap,wn as ifcRelationsMap,Ln as limitOf2Bytes};
